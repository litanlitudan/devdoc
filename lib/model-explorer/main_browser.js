"use strict";
(() => {
  // dist/custom_element/browser/main.js
  var gP = Object.defineProperty;
  var T4 = Object.defineProperties;
  var I4 = Object.getOwnPropertyDescriptors;
  var Kg = Object.getOwnPropertySymbols;
  var _P = Object.prototype.hasOwnProperty;
  var vP = Object.prototype.propertyIsEnumerable;
  var mP = (i59, t, e) => t in i59 ? gP(i59, t, { enumerable: true, configurable: true, writable: true, value: e }) : i59[t] = e;
  var le = (i59, t) => {
    for (var e in t ||= {}) _P.call(t, e) && mP(i59, e, t[e]);
    if (Kg) for (var e of Kg(t)) vP.call(t, e) && mP(i59, e, t[e]);
    return i59;
  };
  var xt = (i59, t) => T4(i59, I4(t));
  var Hw = (i59, t) => {
    var e = {};
    for (var n in i59) _P.call(i59, n) && t.indexOf(n) < 0 && (e[n] = i59[n]);
    if (i59 != null && Kg) for (var n of Kg(i59)) t.indexOf(n) < 0 && vP.call(i59, n) && (e[n] = i59[n]);
    return e;
  };
  var D4 = (i59, t) => {
    for (var e in t) gP(i59, e, { get: t[e], enumerable: true });
  };
  var $t = (i59, t, e) => new Promise((n, r) => {
    var o = (l) => {
      try {
        a(e.next(l));
      } catch (c) {
        r(c);
      }
    }, s = (l) => {
      try {
        a(e.throw(l));
      } catch (c) {
        r(c);
      }
    }, a = (l) => l.done ? n(l.value) : Promise.resolve(l.value).then(o, s);
    a((e = e.apply(i59, t)).next());
  });
  function bP(i59, t) {
    return Object.is(i59, t);
  }
  var Ii = null;
  var wp = false;
  var qw = 1;
  var lr = Symbol("SIGNAL");
  function Ht(i59) {
    let t = Ii;
    return Ii = i59, t;
  }
  function xP() {
    return Ii;
  }
  function P4() {
    return wp;
  }
  var Xl = { version: 0, lastCleanEpoch: 0, dirty: false, producerNode: void 0, producerLastReadVersion: void 0, producerIndexOfThis: void 0, nextProducerIndex: 0, liveConsumerNode: void 0, liveConsumerIndexOfThis: void 0, consumerAllowSignalWrites: false, consumerIsAlwaysLive: false, kind: "unknown", producerMustRecompute: () => false, producerRecomputeValue: () => {
  }, consumerMarkedDirty: () => {
  }, consumerOnSignalRead: () => {
  } };
  function e_(i59) {
    if (wp) throw new Error("");
    if (Ii === null) return;
    Ii.consumerOnSignalRead(i59);
    let t = Ii.nextProducerIndex++;
    if (n_(Ii), t < Ii.producerNode.length && Ii.producerNode[t] !== i59 && Cp(Ii)) {
      let e = Ii.producerNode[t];
      t_(e, Ii.producerIndexOfThis[t]);
    }
    Ii.producerNode[t] !== i59 && (Ii.producerNode[t] = i59, Ii.producerIndexOfThis[t] = Cp(Ii) ? EP(i59, Ii, t) : 0), Ii.producerLastReadVersion[t] = i59.version;
  }
  function R4() {
    qw++;
  }
  function wP(i59) {
    if (!(Cp(i59) && !i59.dirty) && !(!i59.dirty && i59.lastCleanEpoch === qw)) {
      if (!i59.producerMustRecompute(i59) && !Mp(i59)) {
        yP(i59);
        return;
      }
      i59.producerRecomputeValue(i59), yP(i59);
    }
  }
  function CP(i59) {
    if (i59.liveConsumerNode === void 0) return;
    let t = wp;
    wp = true;
    try {
      for (let e of i59.liveConsumerNode) e.dirty || MP(e);
    } finally {
      wp = t;
    }
  }
  function SP() {
    return Ii?.consumerAllowSignalWrites !== false;
  }
  function MP(i59) {
    i59.dirty = true, CP(i59), i59.consumerMarkedDirty?.(i59);
  }
  function yP(i59) {
    i59.dirty = false, i59.lastCleanEpoch = qw;
  }
  function Wd(i59) {
    return i59 && (i59.nextProducerIndex = 0), Ht(i59);
  }
  function Sp(i59, t) {
    if (Ht(t), !(!i59 || i59.producerNode === void 0 || i59.producerIndexOfThis === void 0 || i59.producerLastReadVersion === void 0)) {
      if (Cp(i59)) for (let e = i59.nextProducerIndex; e < i59.producerNode.length; e++) t_(i59.producerNode[e], i59.producerIndexOfThis[e]);
      for (; i59.producerNode.length > i59.nextProducerIndex; ) i59.producerNode.pop(), i59.producerLastReadVersion.pop(), i59.producerIndexOfThis.pop();
    }
  }
  function Mp(i59) {
    n_(i59);
    for (let t = 0; t < i59.producerNode.length; t++) {
      let e = i59.producerNode[t], n = i59.producerLastReadVersion[t];
      if (n !== e.version || (wP(e), n !== e.version)) return true;
    }
    return false;
  }
  function $d(i59) {
    if (n_(i59), Cp(i59)) for (let t = 0; t < i59.producerNode.length; t++) t_(i59.producerNode[t], i59.producerIndexOfThis[t]);
    i59.producerNode.length = i59.producerLastReadVersion.length = i59.producerIndexOfThis.length = 0, i59.liveConsumerNode && (i59.liveConsumerNode.length = i59.liveConsumerIndexOfThis.length = 0);
  }
  function EP(i59, t, e) {
    if (TP(i59), i59.liveConsumerNode.length === 0 && IP(i59)) for (let n = 0; n < i59.producerNode.length; n++) i59.producerIndexOfThis[n] = EP(i59.producerNode[n], i59, n);
    return i59.liveConsumerIndexOfThis.push(e), i59.liveConsumerNode.push(t) - 1;
  }
  function t_(i59, t) {
    if (TP(i59), i59.liveConsumerNode.length === 1 && IP(i59)) for (let n = 0; n < i59.producerNode.length; n++) t_(i59.producerNode[n], i59.producerIndexOfThis[n]);
    let e = i59.liveConsumerNode.length - 1;
    if (i59.liveConsumerNode[t] = i59.liveConsumerNode[e], i59.liveConsumerIndexOfThis[t] = i59.liveConsumerIndexOfThis[e], i59.liveConsumerNode.length--, i59.liveConsumerIndexOfThis.length--, t < i59.liveConsumerNode.length) {
      let n = i59.liveConsumerIndexOfThis[t], r = i59.liveConsumerNode[t];
      n_(r), r.producerIndexOfThis[n] = t;
    }
  }
  function Cp(i59) {
    return i59.consumerIsAlwaysLive || (i59?.liveConsumerNode?.length ?? 0) > 0;
  }
  function n_(i59) {
    i59.producerNode ??= [], i59.producerIndexOfThis ??= [], i59.producerLastReadVersion ??= [];
  }
  function TP(i59) {
    i59.liveConsumerNode ??= [], i59.liveConsumerIndexOfThis ??= [];
  }
  function IP(i59) {
    return i59.producerNode !== void 0;
  }
  function Yw(i59) {
    let t = Object.create(O4);
    t.computation = i59;
    let e = () => {
      if (wP(t), e_(t), t.value === Jg) throw t.error;
      return t.value;
    };
    return e[lr] = t, e;
  }
  var jw = Symbol("UNSET");
  var Ww = Symbol("COMPUTING");
  var Jg = Symbol("ERRORED");
  var O4 = xt(le({}, Xl), { value: jw, dirty: true, error: null, equal: bP, kind: "computed", producerMustRecompute(i59) {
    return i59.value === jw || i59.value === Ww;
  }, producerRecomputeValue(i59) {
    if (i59.value === Ww) throw new Error("Detected cycle in computations.");
    let t = i59.value;
    i59.value = Ww;
    let e = Wd(i59), n, r = false;
    try {
      n = i59.computation(), Ht(null), r = t !== jw && t !== Jg && n !== Jg && i59.equal(t, n);
    } catch (o) {
      n = Jg, i59.error = o;
    } finally {
      Sp(i59, e);
    }
    if (r) {
      i59.value = t;
      return;
    }
    i59.value = n, i59.version++;
  } });
  function A4() {
    throw new Error();
  }
  var DP = A4;
  function PP() {
    DP();
  }
  function RP(i59) {
    DP = i59;
  }
  var N4 = null;
  function OP(i59) {
    let t = Object.create(Xw);
    t.value = i59;
    let e = () => (e_(t), t.value);
    return e[lr] = t, e;
  }
  function i_(i59, t) {
    SP() || PP(), i59.equal(i59.value, t) || (i59.value = t, k4(i59));
  }
  function AP(i59, t) {
    SP() || PP(), i_(i59, t(i59.value));
  }
  var Xw = xt(le({}, Xl), { equal: bP, value: void 0, kind: "signal" });
  function k4(i59) {
    i59.version++, R4(), CP(i59), N4?.();
  }
  function NP(i59, t, e) {
    let n = Object.create(L4);
    e && (n.consumerAllowSignalWrites = true), n.fn = i59, n.schedule = t;
    let r = (l) => {
      n.cleanupFn = l;
    };
    function o(l) {
      return l.fn === null && l.schedule === null;
    }
    function s(l) {
      o(l) || ($d(l), l.cleanupFn(), l.fn = null, l.schedule = null, l.cleanupFn = $w);
    }
    let a = () => {
      if (n.fn === null) return;
      if (P4()) throw new Error("Schedulers cannot synchronously execute watches while scheduling.");
      if (n.dirty = false, n.hasRun && !Mp(n)) return;
      n.hasRun = true;
      let l = Wd(n);
      try {
        n.cleanupFn(), n.cleanupFn = $w, n.fn(r);
      } finally {
        Sp(n, l);
      }
    };
    return n.ref = { notify: () => MP(n), run: a, cleanup: () => n.cleanupFn(), destroy: () => s(n), [lr]: n }, n.ref;
  }
  var $w = () => {
  };
  var L4 = xt(le({}, Xl), { consumerIsAlwaysLive: true, consumerAllowSignalWrites: false, consumerMarkedDirty: (i59) => {
    i59.schedule !== null && i59.schedule(i59.ref);
  }, hasRun: false, cleanupFn: $w });
  function wt(i59) {
    return typeof i59 == "function";
  }
  function r_(i59) {
    let e = i59((n) => {
      Error.call(n), n.stack = new Error().stack;
    });
    return e.prototype = Object.create(Error.prototype), e.prototype.constructor = e, e;
  }
  var o_ = r_((i59) => function(e) {
    i59(this), this.message = e ? `${e.length} errors occurred during unsubscription:
${e.map((n, r) => `${r + 1}) ${n.toString()}`).join(`
  `)}` : "", this.name = "UnsubscriptionError", this.errors = e;
  });
  function Zl(i59, t) {
    if (i59) {
      let e = i59.indexOf(t);
      0 <= e && i59.splice(e, 1);
    }
  }
  var Rt = class i {
    constructor(t) {
      this.initialTeardown = t, this.closed = false, this._parentage = null, this._finalizers = null;
    }
    unsubscribe() {
      let t;
      if (!this.closed) {
        this.closed = true;
        let { _parentage: e } = this;
        if (e) if (this._parentage = null, Array.isArray(e)) for (let o of e) o.remove(this);
        else e.remove(this);
        let { initialTeardown: n } = this;
        if (wt(n)) try {
          n();
        } catch (o) {
          t = o instanceof o_ ? o.errors : [o];
        }
        let { _finalizers: r } = this;
        if (r) {
          this._finalizers = null;
          for (let o of r) try {
            kP(o);
          } catch (s) {
            t = t ?? [], s instanceof o_ ? t = [...t, ...s.errors] : t.push(s);
          }
        }
        if (t) throw new o_(t);
      }
    }
    add(t) {
      var e;
      if (t && t !== this) if (this.closed) kP(t);
      else {
        if (t instanceof i) {
          if (t.closed || t._hasParent(this)) return;
          t._addParent(this);
        }
        (this._finalizers = (e = this._finalizers) !== null && e !== void 0 ? e : []).push(t);
      }
    }
    _hasParent(t) {
      let { _parentage: e } = this;
      return e === t || Array.isArray(e) && e.includes(t);
    }
    _addParent(t) {
      let { _parentage: e } = this;
      this._parentage = Array.isArray(e) ? (e.push(t), e) : e ? [e, t] : t;
    }
    _removeParent(t) {
      let { _parentage: e } = this;
      e === t ? this._parentage = null : Array.isArray(e) && Zl(e, t);
    }
    remove(t) {
      let { _finalizers: e } = this;
      e && Zl(e, t), t instanceof i && t._removeParent(this);
    }
  };
  Rt.EMPTY = (() => {
    let i59 = new Rt();
    return i59.closed = true, i59;
  })();
  var Zw = Rt.EMPTY;
  function s_(i59) {
    return i59 instanceof Rt || i59 && "closed" in i59 && wt(i59.remove) && wt(i59.add) && wt(i59.unsubscribe);
  }
  function kP(i59) {
    wt(i59) ? i59() : i59.unsubscribe();
  }
  var jo = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: false, useDeprecatedNextContext: false };
  var qd = { setTimeout(i59, t, ...e) {
    let { delegate: n } = qd;
    return n?.setTimeout ? n.setTimeout(i59, t, ...e) : setTimeout(i59, t, ...e);
  }, clearTimeout(i59) {
    let { delegate: t } = qd;
    return (t?.clearTimeout || clearTimeout)(i59);
  }, delegate: void 0 };
  function a_(i59) {
    qd.setTimeout(() => {
      let { onUnhandledError: t } = jo;
      if (t) t(i59);
      else throw i59;
    });
  }
  function Ep() {
  }
  var LP = Qw("C", void 0, void 0);
  function FP(i59) {
    return Qw("E", void 0, i59);
  }
  function BP(i59) {
    return Qw("N", i59, void 0);
  }
  function Qw(i59, t, e) {
    return { kind: i59, value: t, error: e };
  }
  var Ql = null;
  function Yd(i59) {
    if (jo.useDeprecatedSynchronousErrorHandling) {
      let t = !Ql;
      if (t && (Ql = { errorThrown: false, error: null }), i59(), t) {
        let { errorThrown: e, error: n } = Ql;
        if (Ql = null, e) throw n;
      }
    } else i59();
  }
  function VP(i59) {
    jo.useDeprecatedSynchronousErrorHandling && Ql && (Ql.errorThrown = true, Ql.error = i59);
  }
  var Kl = class extends Rt {
    constructor(t) {
      super(), this.isStopped = false, t ? (this.destination = t, s_(t) && t.add(this)) : this.destination = V4;
    }
    static create(t, e, n) {
      return new Ks(t, e, n);
    }
    next(t) {
      this.isStopped ? Jw(BP(t), this) : this._next(t);
    }
    error(t) {
      this.isStopped ? Jw(FP(t), this) : (this.isStopped = true, this._error(t));
    }
    complete() {
      this.isStopped ? Jw(LP, this) : (this.isStopped = true, this._complete());
    }
    unsubscribe() {
      this.closed || (this.isStopped = true, super.unsubscribe(), this.destination = null);
    }
    _next(t) {
      this.destination.next(t);
    }
    _error(t) {
      try {
        this.destination.error(t);
      } finally {
        this.unsubscribe();
      }
    }
    _complete() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    }
  };
  var F4 = Function.prototype.bind;
  function Kw(i59, t) {
    return F4.call(i59, t);
  }
  var eC = class {
    constructor(t) {
      this.partialObserver = t;
    }
    next(t) {
      let { partialObserver: e } = this;
      if (e.next) try {
        e.next(t);
      } catch (n) {
        l_(n);
      }
    }
    error(t) {
      let { partialObserver: e } = this;
      if (e.error) try {
        e.error(t);
      } catch (n) {
        l_(n);
      }
      else l_(t);
    }
    complete() {
      let { partialObserver: t } = this;
      if (t.complete) try {
        t.complete();
      } catch (e) {
        l_(e);
      }
    }
  };
  var Ks = class extends Kl {
    constructor(t, e, n) {
      super();
      let r;
      if (wt(t) || !t) r = { next: t ?? void 0, error: e ?? void 0, complete: n ?? void 0 };
      else {
        let o;
        this && jo.useDeprecatedNextContext ? (o = Object.create(t), o.unsubscribe = () => this.unsubscribe(), r = { next: t.next && Kw(t.next, o), error: t.error && Kw(t.error, o), complete: t.complete && Kw(t.complete, o) }) : r = t;
      }
      this.destination = new eC(r);
    }
  };
  function l_(i59) {
    jo.useDeprecatedSynchronousErrorHandling ? VP(i59) : a_(i59);
  }
  function B4(i59) {
    throw i59;
  }
  function Jw(i59, t) {
    let { onStoppedNotification: e } = jo;
    e && qd.setTimeout(() => e(i59, t));
  }
  var V4 = { closed: true, next: Ep, error: B4, complete: Ep };
  var Xd = typeof Symbol == "function" && Symbol.observable || "@@observable";
  function Wo(i59) {
    return i59;
  }
  function zP(i59) {
    return i59.length === 0 ? Wo : i59.length === 1 ? i59[0] : function(e) {
      return i59.reduce((n, r) => r(n), e);
    };
  }
  var Et = (() => {
    class i59 {
      constructor(e) {
        e && (this._subscribe = e);
      }
      lift(e) {
        let n = new i59();
        return n.source = this, n.operator = e, n;
      }
      subscribe(e, n, r) {
        let o = U4(e) ? e : new Ks(e, n, r);
        return Yd(() => {
          let { operator: s, source: a } = this;
          o.add(s ? s.call(o, a) : a ? this._subscribe(o) : this._trySubscribe(o));
        }), o;
      }
      _trySubscribe(e) {
        try {
          return this._subscribe(e);
        } catch (n) {
          e.error(n);
        }
      }
      forEach(e, n) {
        return n = UP(n), new n((r, o) => {
          let s = new Ks({ next: (a) => {
            try {
              e(a);
            } catch (l) {
              o(l), s.unsubscribe();
            }
          }, error: o, complete: r });
          this.subscribe(s);
        });
      }
      _subscribe(e) {
        var n;
        return (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(e);
      }
      [Xd]() {
        return this;
      }
      pipe(...e) {
        return zP(e)(this);
      }
      toPromise(e) {
        return e = UP(e), new e((n, r) => {
          let o;
          this.subscribe((s) => o = s, (s) => r(s), () => n(o));
        });
      }
    }
    return i59.create = (t) => new i59(t), i59;
  })();
  function UP(i59) {
    var t;
    return (t = i59 ?? jo.Promise) !== null && t !== void 0 ? t : Promise;
  }
  function z4(i59) {
    return i59 && wt(i59.next) && wt(i59.error) && wt(i59.complete);
  }
  function U4(i59) {
    return i59 && i59 instanceof Kl || z4(i59) && s_(i59);
  }
  function tC(i59) {
    return wt(i59?.lift);
  }
  function jt(i59) {
    return (t) => {
      if (tC(t)) return t.lift(function(e) {
        try {
          return i59(e, this);
        } catch (n) {
          this.error(n);
        }
      });
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }
  function Ut(i59, t, e, n, r) {
    return new nC(i59, t, e, n, r);
  }
  var nC = class extends Kl {
    constructor(t, e, n, r, o, s) {
      super(t), this.onFinalize = o, this.shouldUnsubscribe = s, this._next = e ? function(a) {
        try {
          e(a);
        } catch (l) {
          t.error(l);
        }
      } : super._next, this._error = r ? function(a) {
        try {
          r(a);
        } catch (l) {
          t.error(l);
        } finally {
          this.unsubscribe();
        }
      } : super._error, this._complete = n ? function() {
        try {
          n();
        } catch (a) {
          t.error(a);
        } finally {
          this.unsubscribe();
        }
      } : super._complete;
    }
    unsubscribe() {
      var t;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        let { closed: e } = this;
        super.unsubscribe(), !e && ((t = this.onFinalize) === null || t === void 0 || t.call(this));
      }
    }
  };
  function GP() {
    return jt((i59, t) => {
      let e = null;
      i59._refCount++;
      let n = Ut(t, void 0, void 0, void 0, () => {
        if (!i59 || i59._refCount <= 0 || 0 < --i59._refCount) {
          e = null;
          return;
        }
        let r = i59._connection, o = e;
        e = null, r && (!o || r === o) && r.unsubscribe(), t.unsubscribe();
      });
      i59.subscribe(n), n.closed || (e = i59.connect());
    });
  }
  var Tp = class extends Et {
    constructor(t, e) {
      super(), this.source = t, this.subjectFactory = e, this._subject = null, this._refCount = 0, this._connection = null, tC(t) && (this.lift = t.lift);
    }
    _subscribe(t) {
      return this.getSubject().subscribe(t);
    }
    getSubject() {
      let t = this._subject;
      return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject;
    }
    _teardown() {
      this._refCount = 0;
      let { _connection: t } = this;
      this._subject = this._connection = null, t?.unsubscribe();
    }
    connect() {
      let t = this._connection;
      if (!t) {
        t = this._connection = new Rt();
        let e = this.getSubject();
        t.add(this.source.subscribe(Ut(e, void 0, () => {
          this._teardown(), e.complete();
        }, (n) => {
          this._teardown(), e.error(n);
        }, () => this._teardown()))), t.closed && (this._connection = null, t = Rt.EMPTY);
      }
      return t;
    }
    refCount() {
      return GP()(this);
    }
  };
  var Zd = { schedule(i59) {
    let t = requestAnimationFrame, e = cancelAnimationFrame, { delegate: n } = Zd;
    n && (t = n.requestAnimationFrame, e = n.cancelAnimationFrame);
    let r = t((o) => {
      e = void 0, i59(o);
    });
    return new Rt(() => e?.(r));
  }, requestAnimationFrame(...i59) {
    let { delegate: t } = Zd;
    return (t?.requestAnimationFrame || requestAnimationFrame)(...i59);
  }, cancelAnimationFrame(...i59) {
    let { delegate: t } = Zd;
    return (t?.cancelAnimationFrame || cancelAnimationFrame)(...i59);
  }, delegate: void 0 };
  var HP = r_((i59) => function() {
    i59(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed";
  });
  var we = (() => {
    class i59 extends Et {
      constructor() {
        super(), this.closed = false, this.currentObservers = null, this.observers = [], this.isStopped = false, this.hasError = false, this.thrownError = null;
      }
      lift(e) {
        let n = new c_(this, this);
        return n.operator = e, n;
      }
      _throwIfClosed() {
        if (this.closed) throw new HP();
      }
      next(e) {
        Yd(() => {
          if (this._throwIfClosed(), !this.isStopped) {
            this.currentObservers || (this.currentObservers = Array.from(this.observers));
            for (let n of this.currentObservers) n.next(e);
          }
        });
      }
      error(e) {
        Yd(() => {
          if (this._throwIfClosed(), !this.isStopped) {
            this.hasError = this.isStopped = true, this.thrownError = e;
            let { observers: n } = this;
            for (; n.length; ) n.shift().error(e);
          }
        });
      }
      complete() {
        Yd(() => {
          if (this._throwIfClosed(), !this.isStopped) {
            this.isStopped = true;
            let { observers: e } = this;
            for (; e.length; ) e.shift().complete();
          }
        });
      }
      unsubscribe() {
        this.isStopped = this.closed = true, this.observers = this.currentObservers = null;
      }
      get observed() {
        var e;
        return ((e = this.observers) === null || e === void 0 ? void 0 : e.length) > 0;
      }
      _trySubscribe(e) {
        return this._throwIfClosed(), super._trySubscribe(e);
      }
      _subscribe(e) {
        return this._throwIfClosed(), this._checkFinalizedStatuses(e), this._innerSubscribe(e);
      }
      _innerSubscribe(e) {
        let { hasError: n, isStopped: r, observers: o } = this;
        return n || r ? Zw : (this.currentObservers = null, o.push(e), new Rt(() => {
          this.currentObservers = null, Zl(o, e);
        }));
      }
      _checkFinalizedStatuses(e) {
        let { hasError: n, thrownError: r, isStopped: o } = this;
        n ? e.error(r) : o && e.complete();
      }
      asObservable() {
        let e = new Et();
        return e.source = this, e;
      }
    }
    return i59.create = (t, e) => new c_(t, e), i59;
  })();
  var c_ = class extends we {
    constructor(t, e) {
      super(), this.destination = t, this.source = e;
    }
    next(t) {
      var e, n;
      (n = (e = this.destination) === null || e === void 0 ? void 0 : e.next) === null || n === void 0 || n.call(e, t);
    }
    error(t) {
      var e, n;
      (n = (e = this.destination) === null || e === void 0 ? void 0 : e.error) === null || n === void 0 || n.call(e, t);
    }
    complete() {
      var t, e;
      (e = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null || e === void 0 || e.call(t);
    }
    _subscribe(t) {
      var e, n;
      return (n = (e = this.source) === null || e === void 0 ? void 0 : e.subscribe(t)) !== null && n !== void 0 ? n : Zw;
    }
  };
  var hi = class extends we {
    constructor(t) {
      super(), this._value = t;
    }
    get value() {
      return this.getValue();
    }
    _subscribe(t) {
      let e = super._subscribe(t);
      return !e.closed && t.next(this._value), e;
    }
    getValue() {
      let { hasError: t, thrownError: e, _value: n } = this;
      if (t) throw e;
      return this._throwIfClosed(), n;
    }
    next(t) {
      super.next(this._value = t);
    }
  };
  var Ip = { now() {
    return (Ip.delegate || Date).now();
  }, delegate: void 0 };
  var $o = class extends we {
    constructor(t = 1 / 0, e = 1 / 0, n = Ip) {
      super(), this._bufferSize = t, this._windowTime = e, this._timestampProvider = n, this._buffer = [], this._infiniteTimeWindow = true, this._infiniteTimeWindow = e === 1 / 0, this._bufferSize = Math.max(1, t), this._windowTime = Math.max(1, e);
    }
    next(t) {
      let { isStopped: e, _buffer: n, _infiniteTimeWindow: r, _timestampProvider: o, _windowTime: s } = this;
      e || (n.push(t), !r && n.push(o.now() + s)), this._trimBuffer(), super.next(t);
    }
    _subscribe(t) {
      this._throwIfClosed(), this._trimBuffer();
      let e = this._innerSubscribe(t), { _infiniteTimeWindow: n, _buffer: r } = this, o = r.slice();
      for (let s = 0; s < o.length && !t.closed; s += n ? 1 : 2) t.next(o[s]);
      return this._checkFinalizedStatuses(t), e;
    }
    _trimBuffer() {
      let { _bufferSize: t, _timestampProvider: e, _buffer: n, _infiniteTimeWindow: r } = this, o = (r ? 1 : 2) * t;
      if (t < 1 / 0 && o < n.length && n.splice(0, n.length - o), !r) {
        let s = e.now(), a = 0;
        for (let l = 1; l < n.length && n[l] <= s; l += 2) a = l;
        a && n.splice(0, a + 1);
      }
    }
  };
  var d_ = class extends Rt {
    constructor(t, e) {
      super();
    }
    schedule(t, e = 0) {
      return this;
    }
  };
  var Dp = { setInterval(i59, t, ...e) {
    let { delegate: n } = Dp;
    return n?.setInterval ? n.setInterval(i59, t, ...e) : setInterval(i59, t, ...e);
  }, clearInterval(i59) {
    let { delegate: t } = Dp;
    return (t?.clearInterval || clearInterval)(i59);
  }, delegate: void 0 };
  var Qd = class extends d_ {
    constructor(t, e) {
      super(t, e), this.scheduler = t, this.work = e, this.pending = false;
    }
    schedule(t, e = 0) {
      var n;
      if (this.closed) return this;
      this.state = t;
      let r = this.id, o = this.scheduler;
      return r != null && (this.id = this.recycleAsyncId(o, r, e)), this.pending = true, this.delay = e, this.id = (n = this.id) !== null && n !== void 0 ? n : this.requestAsyncId(o, this.id, e), this;
    }
    requestAsyncId(t, e, n = 0) {
      return Dp.setInterval(t.flush.bind(t, this), n);
    }
    recycleAsyncId(t, e, n = 0) {
      if (n != null && this.delay === n && this.pending === false) return e;
      e != null && Dp.clearInterval(e);
    }
    execute(t, e) {
      if (this.closed) return new Error("executing a cancelled action");
      this.pending = false;
      let n = this._execute(t, e);
      if (n) return n;
      this.pending === false && this.id != null && (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
    }
    _execute(t, e) {
      let n = false, r;
      try {
        this.work(t);
      } catch (o) {
        n = true, r = o || new Error("Scheduled action threw falsy error");
      }
      if (n) return this.unsubscribe(), r;
    }
    unsubscribe() {
      if (!this.closed) {
        let { id: t, scheduler: e } = this, { actions: n } = e;
        this.work = this.state = this.scheduler = null, this.pending = false, Zl(n, this), t != null && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null, super.unsubscribe();
      }
    }
  };
  var Kd = class i2 {
    constructor(t, e = i2.now) {
      this.schedulerActionCtor = t, this.now = e;
    }
    schedule(t, e = 0, n) {
      return new this.schedulerActionCtor(this, t).schedule(n, e);
    }
  };
  Kd.now = Ip.now;
  var Jd = class extends Kd {
    constructor(t, e = Kd.now) {
      super(t, e), this.actions = [], this._active = false;
    }
    flush(t) {
      let { actions: e } = this;
      if (this._active) {
        e.push(t);
        return;
      }
      let n;
      this._active = true;
      do
        if (n = t.execute(t.state, t.delay)) break;
      while (t = e.shift());
      if (this._active = false, n) {
        for (; t = e.shift(); ) t.unsubscribe();
        throw n;
      }
    }
  };
  var Jl = new Jd(Qd);
  var jP = Jl;
  var u_ = class extends Qd {
    constructor(t, e) {
      super(t, e), this.scheduler = t, this.work = e;
    }
    requestAsyncId(t, e, n = 0) {
      return n !== null && n > 0 ? super.requestAsyncId(t, e, n) : (t.actions.push(this), t._scheduled || (t._scheduled = Zd.requestAnimationFrame(() => t.flush(void 0))));
    }
    recycleAsyncId(t, e, n = 0) {
      var r;
      if (n != null ? n > 0 : this.delay > 0) return super.recycleAsyncId(t, e, n);
      let { actions: o } = t;
      e != null && ((r = o[o.length - 1]) === null || r === void 0 ? void 0 : r.id) !== e && (Zd.cancelAnimationFrame(e), t._scheduled = void 0);
    }
  };
  var h_ = class extends Jd {
    flush(t) {
      this._active = true;
      let e = this._scheduled;
      this._scheduled = void 0;
      let { actions: n } = this, r;
      t = t || n.shift();
      do
        if (r = t.execute(t.state, t.delay)) break;
      while ((t = n[0]) && t.id === e && n.shift());
      if (this._active = false, r) {
        for (; (t = n[0]) && t.id === e && n.shift(); ) t.unsubscribe();
        throw r;
      }
    }
  };
  var p_ = new h_(u_);
  var ec = new Et((i59) => i59.complete());
  function f_(i59) {
    return i59 && wt(i59.schedule);
  }
  function iC(i59) {
    return i59[i59.length - 1];
  }
  function m_(i59) {
    return wt(iC(i59)) ? i59.pop() : void 0;
  }
  function fs(i59) {
    return f_(iC(i59)) ? i59.pop() : void 0;
  }
  function WP(i59, t) {
    return typeof iC(i59) == "number" ? i59.pop() : t;
  }
  function qP(i59, t, e, n) {
    function r(o) {
      return o instanceof e ? o : new e(function(s) {
        s(o);
      });
    }
    return new (e || (e = Promise))(function(o, s) {
      function a(d) {
        try {
          c(n.next(d));
        } catch (u) {
          s(u);
        }
      }
      function l(d) {
        try {
          c(n.throw(d));
        } catch (u) {
          s(u);
        }
      }
      function c(d) {
        d.done ? o(d.value) : r(d.value).then(a, l);
      }
      c((n = n.apply(i59, t || [])).next());
    });
  }
  function $P(i59) {
    var t = typeof Symbol == "function" && Symbol.iterator, e = t && i59[t], n = 0;
    if (e) return e.call(i59);
    if (i59 && typeof i59.length == "number") return { next: function() {
      return i59 && n >= i59.length && (i59 = void 0), { value: i59 && i59[n++], done: !i59 };
    } };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function tc(i59) {
    return this instanceof tc ? (this.v = i59, this) : new tc(i59);
  }
  function YP(i59, t, e) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var n = e.apply(i59, t || []), r, o = [];
    return r = Object.create((typeof AsyncIterator == "function" ? AsyncIterator : Object).prototype), a("next"), a("throw"), a("return", s), r[Symbol.asyncIterator] = function() {
      return this;
    }, r;
    function s(p) {
      return function(f) {
        return Promise.resolve(f).then(p, u);
      };
    }
    function a(p, f) {
      n[p] && (r[p] = function(m) {
        return new Promise(function(v, _) {
          o.push([p, m, v, _]) > 1 || l(p, m);
        });
      }, f && (r[p] = f(r[p])));
    }
    function l(p, f) {
      try {
        c(n[p](f));
      } catch (m) {
        h(o[0][3], m);
      }
    }
    function c(p) {
      p.value instanceof tc ? Promise.resolve(p.value.v).then(d, u) : h(o[0][2], p);
    }
    function d(p) {
      l("next", p);
    }
    function u(p) {
      l("throw", p);
    }
    function h(p, f) {
      p(f), o.shift(), o.length && l(o[0][0], o[0][1]);
    }
  }
  function XP(i59) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var t = i59[Symbol.asyncIterator], e;
    return t ? t.call(i59) : (i59 = typeof $P == "function" ? $P(i59) : i59[Symbol.iterator](), e = {}, n("next"), n("throw"), n("return"), e[Symbol.asyncIterator] = function() {
      return this;
    }, e);
    function n(o) {
      e[o] = i59[o] && function(s) {
        return new Promise(function(a, l) {
          s = i59[o](s), r(a, l, s.done, s.value);
        });
      };
    }
    function r(o, s, a, l) {
      Promise.resolve(l).then(function(c) {
        o({ value: c, done: a });
      }, s);
    }
  }
  var eu = (i59) => i59 && typeof i59.length == "number" && typeof i59 != "function";
  function g_(i59) {
    return wt(i59?.then);
  }
  function __(i59) {
    return wt(i59[Xd]);
  }
  function v_(i59) {
    return Symbol.asyncIterator && wt(i59?.[Symbol.asyncIterator]);
  }
  function y_(i59) {
    return new TypeError(`You provided ${i59 !== null && typeof i59 == "object" ? "an invalid object" : `'${i59}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);
  }
  function G4() {
    return typeof Symbol != "function" || !Symbol.iterator ? "@@iterator" : Symbol.iterator;
  }
  var b_ = G4();
  function x_(i59) {
    return wt(i59?.[b_]);
  }
  function w_(i59) {
    return YP(this, arguments, function* () {
      let e = i59.getReader();
      try {
        for (; ; ) {
          let { value: n, done: r } = yield tc(e.read());
          if (r) return yield tc(void 0);
          yield yield tc(n);
        }
      } finally {
        e.releaseLock();
      }
    });
  }
  function C_(i59) {
    return wt(i59?.getReader);
  }
  function Cn(i59) {
    if (i59 instanceof Et) return i59;
    if (i59 != null) {
      if (__(i59)) return H4(i59);
      if (eu(i59)) return j4(i59);
      if (g_(i59)) return W4(i59);
      if (v_(i59)) return ZP(i59);
      if (x_(i59)) return $4(i59);
      if (C_(i59)) return q4(i59);
    }
    throw y_(i59);
  }
  function H4(i59) {
    return new Et((t) => {
      let e = i59[Xd]();
      if (wt(e.subscribe)) return e.subscribe(t);
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function j4(i59) {
    return new Et((t) => {
      for (let e = 0; e < i59.length && !t.closed; e++) t.next(i59[e]);
      t.complete();
    });
  }
  function W4(i59) {
    return new Et((t) => {
      i59.then((e) => {
        t.closed || (t.next(e), t.complete());
      }, (e) => t.error(e)).then(null, a_);
    });
  }
  function $4(i59) {
    return new Et((t) => {
      for (let e of i59) if (t.next(e), t.closed) return;
      t.complete();
    });
  }
  function ZP(i59) {
    return new Et((t) => {
      Y4(i59, t).catch((e) => t.error(e));
    });
  }
  function q4(i59) {
    return ZP(w_(i59));
  }
  function Y4(i59, t) {
    var e, n, r, o;
    return qP(this, void 0, void 0, function* () {
      try {
        for (e = XP(i59); n = yield e.next(), !n.done; ) {
          let s = n.value;
          if (t.next(s), t.closed) return;
        }
      } catch (s) {
        r = { error: s };
      } finally {
        try {
          n && !n.done && (o = e.return) && (yield o.call(e));
        } finally {
          if (r) throw r.error;
        }
      }
      t.complete();
    });
  }
  function zr(i59, t, e, n = 0, r = false) {
    let o = t.schedule(function() {
      e(), r ? i59.add(this.schedule(null, n)) : this.unsubscribe();
    }, n);
    if (i59.add(o), !r) return o;
  }
  function S_(i59, t = 0) {
    return jt((e, n) => {
      e.subscribe(Ut(n, (r) => zr(n, i59, () => n.next(r), t), () => zr(n, i59, () => n.complete(), t), (r) => zr(n, i59, () => n.error(r), t)));
    });
  }
  function M_(i59, t = 0) {
    return jt((e, n) => {
      n.add(i59.schedule(() => e.subscribe(n), t));
    });
  }
  function QP(i59, t) {
    return Cn(i59).pipe(M_(t), S_(t));
  }
  function KP(i59, t) {
    return Cn(i59).pipe(M_(t), S_(t));
  }
  function JP(i59, t) {
    return new Et((e) => {
      let n = 0;
      return t.schedule(function() {
        n === i59.length ? e.complete() : (e.next(i59[n++]), e.closed || this.schedule());
      });
    });
  }
  function eR(i59, t) {
    return new Et((e) => {
      let n;
      return zr(e, t, () => {
        n = i59[b_](), zr(e, t, () => {
          let r, o;
          try {
            ({ value: r, done: o } = n.next());
          } catch (s) {
            e.error(s);
            return;
          }
          o ? e.complete() : e.next(r);
        }, 0, true);
      }), () => wt(n?.return) && n.return();
    });
  }
  function E_(i59, t) {
    if (!i59) throw new Error("Iterable cannot be null");
    return new Et((e) => {
      zr(e, t, () => {
        let n = i59[Symbol.asyncIterator]();
        zr(e, t, () => {
          n.next().then((r) => {
            r.done ? e.complete() : e.next(r.value);
          });
        }, 0, true);
      });
    });
  }
  function tR(i59, t) {
    return E_(w_(i59), t);
  }
  function nR(i59, t) {
    if (i59 != null) {
      if (__(i59)) return QP(i59, t);
      if (eu(i59)) return JP(i59, t);
      if (g_(i59)) return KP(i59, t);
      if (v_(i59)) return E_(i59, t);
      if (x_(i59)) return eR(i59, t);
      if (C_(i59)) return tR(i59, t);
    }
    throw y_(i59);
  }
  function Zr(i59, t) {
    return t ? nR(i59, t) : Cn(i59);
  }
  function qt(...i59) {
    let t = fs(i59);
    return Zr(i59, t);
  }
  function rC(i59, t) {
    let e = wt(i59) ? i59 : () => i59, n = (r) => r.error(e());
    return new Et(t ? (r) => t.schedule(n, 0, r) : n);
  }
  function Js(i59) {
    return !!i59 && (i59 instanceof Et || wt(i59.lift) && wt(i59.subscribe));
  }
  function iR(i59) {
    return i59 instanceof Date && !isNaN(i59);
  }
  function kt(i59, t) {
    return jt((e, n) => {
      let r = 0;
      e.subscribe(Ut(n, (o) => {
        n.next(i59.call(t, o, r++));
      }));
    });
  }
  var { isArray: X4 } = Array;
  function Z4(i59, t) {
    return X4(t) ? i59(...t) : i59(t);
  }
  function tu(i59) {
    return kt((t) => Z4(i59, t));
  }
  var { isArray: Q4 } = Array;
  var { getPrototypeOf: K4, prototype: J4, keys: e5 } = Object;
  function T_(i59) {
    if (i59.length === 1) {
      let t = i59[0];
      if (Q4(t)) return { args: t, keys: null };
      if (t5(t)) {
        let e = e5(t);
        return { args: e.map((n) => t[n]), keys: e };
      }
    }
    return { args: i59, keys: null };
  }
  function t5(i59) {
    return i59 && typeof i59 == "object" && K4(i59) === J4;
  }
  function I_(i59, t) {
    return i59.reduce((e, n, r) => (e[n] = t[r], e), {});
  }
  function cr(...i59) {
    let t = fs(i59), e = m_(i59), { args: n, keys: r } = T_(i59);
    if (n.length === 0) return Zr([], t);
    let o = new Et(n5(n, t, r ? (s) => I_(r, s) : Wo));
    return e ? o.pipe(tu(e)) : o;
  }
  function n5(i59, t, e = Wo) {
    return (n) => {
      rR(t, () => {
        let { length: r } = i59, o = new Array(r), s = r, a = r;
        for (let l = 0; l < r; l++) rR(t, () => {
          let c = Zr(i59[l], t), d = false;
          c.subscribe(Ut(n, (u) => {
            o[l] = u, d || (d = true, a--), a || n.next(e(o.slice()));
          }, () => {
            --s || n.complete();
          }));
        }, n);
      }, n);
    };
  }
  function rR(i59, t, e) {
    i59 ? zr(e, i59, t) : t();
  }
  function oR(i59, t, e, n, r, o, s, a) {
    let l = [], c = 0, d = 0, u = false, h = () => {
      u && !l.length && !c && t.complete();
    }, p = (m) => c < n ? f(m) : l.push(m), f = (m) => {
      o && t.next(m), c++;
      let v = false;
      Cn(e(m, d++)).subscribe(Ut(t, (_) => {
        r?.(_), o ? p(_) : t.next(_);
      }, () => {
        v = true;
      }, void 0, () => {
        if (v) try {
          for (c--; l.length && c < n; ) {
            let _ = l.shift();
            s ? zr(t, s, () => f(_)) : f(_);
          }
          h();
        } catch (_) {
          t.error(_);
        }
      }));
    };
    return i59.subscribe(Ut(t, p, () => {
      u = true, h();
    })), () => {
      a?.();
    };
  }
  function $a(i59, t, e = 1 / 0) {
    return wt(t) ? $a((n, r) => kt((o, s) => t(n, o, r, s))(Cn(i59(n, r))), e) : (typeof t == "number" && (e = t), jt((n, r) => oR(n, r, i59, e)));
  }
  function D_(i59 = 1 / 0) {
    return $a(Wo, i59);
  }
  function sR() {
    return D_(1);
  }
  function ea(...i59) {
    return sR()(Zr(i59, fs(i59)));
  }
  function nc(i59) {
    return new Et((t) => {
      Cn(i59()).subscribe(t);
    });
  }
  function Pp(...i59) {
    let t = m_(i59), { args: e, keys: n } = T_(i59), r = new Et((o) => {
      let { length: s } = e;
      if (!s) {
        o.complete();
        return;
      }
      let a = new Array(s), l = s, c = s;
      for (let d = 0; d < s; d++) {
        let u = false;
        Cn(e[d]).subscribe(Ut(o, (h) => {
          u || (u = true, c--), a[d] = h;
        }, () => l--, void 0, () => {
          (!l || !u) && (c || o.next(n ? I_(n, a) : a), o.complete());
        }));
      }
    });
    return t ? r.pipe(tu(t)) : r;
  }
  var i5 = ["addListener", "removeListener"];
  var r5 = ["addEventListener", "removeEventListener"];
  var o5 = ["on", "off"];
  function zn(i59, t, e, n) {
    if (wt(e) && (n = e, e = void 0), n) return zn(i59, t, e).pipe(tu(n));
    let [r, o] = l5(i59) ? r5.map((s) => (a) => i59[s](t, a, e)) : s5(i59) ? i5.map(aR(i59, t)) : a5(i59) ? o5.map(aR(i59, t)) : [];
    if (!r && eu(i59)) return $a((s) => zn(s, t, e))(Cn(i59));
    if (!r) throw new TypeError("Invalid event target");
    return new Et((s) => {
      let a = (...l) => s.next(1 < l.length ? l : l[0]);
      return r(a), () => o(a);
    });
  }
  function aR(i59, t) {
    return (e) => (n) => i59[e](t, n);
  }
  function s5(i59) {
    return wt(i59.addListener) && wt(i59.removeListener);
  }
  function a5(i59) {
    return wt(i59.on) && wt(i59.off);
  }
  function l5(i59) {
    return wt(i59.addEventListener) && wt(i59.removeEventListener);
  }
  function P_(i59 = 0, t, e = jP) {
    let n = -1;
    return t != null && (f_(t) ? e = t : n = t), new Et((r) => {
      let o = iR(i59) ? +i59 - e.now() : i59;
      o < 0 && (o = 0);
      let s = 0;
      return e.schedule(function() {
        r.closed || (r.next(s++), 0 <= n ? this.schedule(void 0, n) : r.complete());
      }, o);
    });
  }
  function oC(i59 = 0, t = Jl) {
    return i59 < 0 && (i59 = 0), P_(i59, i59, t);
  }
  function Jn(...i59) {
    let t = fs(i59), e = WP(i59, 1 / 0), n = i59;
    return n.length ? n.length === 1 ? Cn(n[0]) : D_(e)(Zr(n, t)) : ec;
  }
  function En(i59, t) {
    return jt((e, n) => {
      let r = 0;
      e.subscribe(Ut(n, (o) => i59.call(t, o, r++) && n.next(o)));
    });
  }
  function Rp(i59) {
    return jt((t, e) => {
      let n = false, r = null, o = null, s = false, a = () => {
        if (o?.unsubscribe(), o = null, n) {
          n = false;
          let c = r;
          r = null, e.next(c);
        }
        s && e.complete();
      }, l = () => {
        o = null, s && e.complete();
      };
      t.subscribe(Ut(e, (c) => {
        n = true, r = c, o || Cn(i59(c)).subscribe(o = Ut(e, a, l));
      }, () => {
        s = true, (!n || !o || o.closed) && e.complete();
      }));
    });
  }
  function R_(i59, t = Jl) {
    return Rp(() => P_(i59, t));
  }
  function O_(i59) {
    return jt((t, e) => {
      let n = null, r = false, o;
      n = t.subscribe(Ut(e, void 0, void 0, (s) => {
        o = Cn(i59(s, O_(i59)(t))), n ? (n.unsubscribe(), n = null, o.subscribe(e)) : r = true;
      })), r && (n.unsubscribe(), n = null, o.subscribe(e));
    });
  }
  function lR(i59, t, e, n, r) {
    return (o, s) => {
      let a = e, l = t, c = 0;
      o.subscribe(Ut(s, (d) => {
        let u = c++;
        l = a ? i59(l, d, u) : (a = true, d), n && s.next(l);
      }, r && (() => {
        a && s.next(l), s.complete();
      })));
    };
  }
  function A_(i59, t) {
    return jt(lR(i59, t, arguments.length >= 2, false, true));
  }
  function nu(i59, t) {
    return wt(t) ? $a(i59, t, 1) : $a(i59, 1);
  }
  function vo(i59, t = Jl) {
    return jt((e, n) => {
      let r = null, o = null, s = null, a = () => {
        if (r) {
          r.unsubscribe(), r = null;
          let c = o;
          o = null, n.next(c);
        }
      };
      function l() {
        let c = s + i59, d = t.now();
        if (d < c) {
          r = this.schedule(void 0, c - d), n.add(r);
          return;
        }
        a();
      }
      e.subscribe(Ut(n, (c) => {
        o = c, s = t.now(), r || (r = t.schedule(l, i59), n.add(r));
      }, () => {
        a(), n.complete();
      }, void 0, () => {
        o = r = null;
      }));
    });
  }
  function On(i59) {
    return i59 <= 0 ? () => ec : jt((t, e) => {
      let n = 0;
      t.subscribe(Ut(e, (r) => {
        ++n <= i59 && (e.next(r), i59 <= n && e.complete());
      }));
    });
  }
  function qa(i59, t = Wo) {
    return i59 = i59 ?? c5, jt((e, n) => {
      let r, o = true;
      e.subscribe(Ut(n, (s) => {
        let a = t(s);
        (o || !i59(r, a)) && (o = false, r = a, n.next(s));
      }));
    });
  }
  function c5(i59, t) {
    return i59 === t;
  }
  function N_(i59) {
    return jt((t, e) => {
      try {
        t.subscribe(e);
      } finally {
        e.add(i59);
      }
    });
  }
  function k_() {
    return jt((i59, t) => {
      let e, n = false;
      i59.subscribe(Ut(t, (r) => {
        let o = e;
        e = r, n && t.next([o, r]), n = true;
      }));
    });
  }
  function Op(i59 = {}) {
    let { connector: t = () => new we(), resetOnError: e = true, resetOnComplete: n = true, resetOnRefCountZero: r = true } = i59;
    return (o) => {
      let s, a, l, c = 0, d = false, u = false, h = () => {
        a?.unsubscribe(), a = void 0;
      }, p = () => {
        h(), s = l = void 0, d = u = false;
      }, f = () => {
        let m = s;
        p(), m?.unsubscribe();
      };
      return jt((m, v) => {
        c++, !u && !d && h();
        let _ = l = l ?? t();
        v.add(() => {
          c--, c === 0 && !u && !d && (a = sC(f, r));
        }), _.subscribe(v), !s && c > 0 && (s = new Ks({ next: (g) => _.next(g), error: (g) => {
          u = true, h(), a = sC(p, e, g), _.error(g);
        }, complete: () => {
          d = true, h(), a = sC(p, n), _.complete();
        } }), Cn(m).subscribe(s));
      })(o);
    };
  }
  function sC(i59, t, ...e) {
    if (t === true) {
      i59();
      return;
    }
    if (t === false) return;
    let n = new Ks({ next: () => {
      n.unsubscribe(), i59();
    } });
    return Cn(t(...e)).subscribe(n);
  }
  function L_(i59, t, e) {
    let n, r = false;
    return i59 && typeof i59 == "object" ? { bufferSize: n = 1 / 0, windowTime: t = 1 / 0, refCount: r = false, scheduler: e } = i59 : n = i59 ?? 1 / 0, Op({ connector: () => new $o(n, t, e), resetOnError: true, resetOnComplete: false, resetOnRefCountZero: r });
  }
  function Ap(i59) {
    return En((t, e) => i59 <= e);
  }
  function ei(...i59) {
    let t = fs(i59);
    return jt((e, n) => {
      (t ? ea(i59, e, t) : ea(i59, e)).subscribe(n);
    });
  }
  function Ai(i59, t) {
    return jt((e, n) => {
      let r = null, o = 0, s = false, a = () => s && !r && n.complete();
      e.subscribe(Ut(n, (l) => {
        r?.unsubscribe();
        let c = 0, d = o++;
        Cn(i59(l, d)).subscribe(r = Ut(n, (u) => n.next(t ? t(l, u, d, c++) : u), () => {
          r = null, a();
        }));
      }, () => {
        s = true, a();
      }));
    });
  }
  function Je(i59) {
    return jt((t, e) => {
      Cn(i59).subscribe(Ut(e, () => e.complete(), Ep)), !e.closed && t.subscribe(e);
    });
  }
  function aC(i59, t = false) {
    return jt((e, n) => {
      let r = 0;
      e.subscribe(Ut(n, (o) => {
        let s = i59(o, r++);
        (s || t) && n.next(o), !s && n.complete();
      }));
    });
  }
  function Wi(i59, t, e) {
    let n = wt(i59) || t || e ? { next: i59, error: t, complete: e } : i59;
    return n ? jt((r, o) => {
      var s;
      (s = n.subscribe) === null || s === void 0 || s.call(n);
      let a = true;
      r.subscribe(Ut(o, (l) => {
        var c;
        (c = n.next) === null || c === void 0 || c.call(n, l), o.next(l);
      }, () => {
        var l;
        a = false, (l = n.complete) === null || l === void 0 || l.call(n), o.complete();
      }, (l) => {
        var c;
        a = false, (c = n.error) === null || c === void 0 || c.call(n, l), o.error(l);
      }, () => {
        var l, c;
        a && ((l = n.unsubscribe) === null || l === void 0 || l.call(n)), (c = n.finalize) === null || c === void 0 || c.call(n);
      }));
    }) : Wo;
  }
  var JR = "https://g.co/ng/security#xss";
  var ze = class extends Error {
    code;
    constructor(t, e) {
      super(bv(t, e)), this.code = t;
    }
  };
  function bv(i59, t) {
    return `${`NG0${Math.abs(i59)}`}${t ? ": " + t : ""}`;
  }
  var eO = Symbol("InputSignalNode#UNSET");
  var d5 = xt(le({}, Xw), { transformFn: void 0, applyValueToInputSignal(i59, t) {
    i_(i59, t);
  } });
  function tO(i59, t) {
    let e = Object.create(d5);
    e.value = i59, e.transformFn = t?.transform;
    function n() {
      if (e_(e), e.value === eO) throw new ze(-950, false);
      return e.value;
    }
    return n[lr] = e, n;
  }
  function Yp(i59) {
    return { toString: i59 }.toString();
  }
  var F_ = "__parameters__";
  function u5(i59) {
    return function(...e) {
      if (i59) {
        let n = i59(...e);
        for (let r in n) this[r] = n[r];
      }
    };
  }
  function nO(i59, t, e) {
    return Yp(() => {
      let n = u5(t);
      function r(...o) {
        if (this instanceof r) return n.apply(this, o), this;
        let s = new r(...o);
        return a.annotation = s, a;
        function a(l, c, d) {
          let u = l.hasOwnProperty(F_) ? l[F_] : Object.defineProperty(l, F_, { value: [] })[F_];
          for (; u.length <= d; ) u.push(null);
          return (u[d] = u[d] || []).push(s), l;
        }
      }
      return e && (r.prototype = Object.create(e.prototype)), r.prototype.ngMetadataName = i59, r.annotationCls = r, r;
    });
  }
  var bC = globalThis;
  function Un(i59) {
    for (let t in i59) if (i59[t] === Un) return t;
    throw Error("Could not find renamed property on target object.");
  }
  function h5(i59, t) {
    for (let e in t) t.hasOwnProperty(e) && !i59.hasOwnProperty(e) && (i59[e] = t[e]);
  }
  function Qr(i59) {
    if (typeof i59 == "string") return i59;
    if (Array.isArray(i59)) return "[" + i59.map(Qr).join(", ") + "]";
    if (i59 == null) return "" + i59;
    if (i59.overriddenName) return `${i59.overriddenName}`;
    if (i59.name) return `${i59.name}`;
    let t = i59.toString();
    if (t == null) return "" + t;
    let e = t.indexOf(`
`);
    return e === -1 ? t : t.substring(0, e);
  }
  function xC(i59, t) {
    return i59 == null || i59 === "" ? t === null ? "" : t : t == null || t === "" ? i59 : i59 + " " + t;
  }
  var p5 = Un({ __forward_ref__: Un });
  function Gr(i59) {
    return i59.__forward_ref__ = Gr, i59.toString = function() {
      return Qr(this());
    }, i59;
  }
  function $i(i59) {
    return iO(i59) ? i59() : i59;
  }
  function iO(i59) {
    return typeof i59 == "function" && i59.hasOwnProperty(p5) && i59.__forward_ref__ === Gr;
  }
  function de(i59) {
    return { token: i59.token, providedIn: i59.providedIn || null, factory: i59.factory, value: void 0 };
  }
  function at(i59) {
    return { providers: i59.providers || [], imports: i59.imports || [] };
  }
  function PS(i59) {
    return cR(i59, rO) || cR(i59, oO);
  }
  function cR(i59, t) {
    return i59.hasOwnProperty(t) ? i59[t] : null;
  }
  function f5(i59) {
    let t = i59 && (i59[rO] || i59[oO]);
    return t || null;
  }
  function dR(i59) {
    return i59 && (i59.hasOwnProperty(uR) || i59.hasOwnProperty(m5)) ? i59[uR] : null;
  }
  var rO = Un({ \u0275prov: Un });
  var uR = Un({ \u0275inj: Un });
  var oO = Un({ ngInjectableDef: Un });
  var m5 = Un({ ngInjectorDef: Un });
  var Ee = class {
    _desc;
    ngMetadataName = "InjectionToken";
    \u0275prov;
    constructor(t, e) {
      this._desc = t, this.\u0275prov = void 0, typeof e == "number" ? this.__NG_ELEMENT_ID__ = e : e !== void 0 && (this.\u0275prov = de({ token: this, providedIn: e.providedIn || "root", factory: e.factory }));
    }
    get multi() {
      return this;
    }
    toString() {
      return `InjectionToken ${this._desc}`;
    }
  };
  function sO(i59) {
    return i59 && !!i59.\u0275providers;
  }
  var g5 = Un({ \u0275cmp: Un });
  var _5 = Un({ \u0275dir: Un });
  var v5 = Un({ \u0275pipe: Un });
  var X_ = Un({ \u0275fac: Un });
  var Fp = Un({ __NG_ELEMENT_ID__: Un });
  var hR = Un({ __NG_ENV_ID__: Un });
  function ms(i59) {
    return typeof i59 == "string" ? i59 : i59 == null ? "" : String(i59);
  }
  function y5(i59) {
    return typeof i59 == "function" ? i59.name || i59.toString() : typeof i59 == "object" && i59 != null && typeof i59.type == "function" ? i59.type.name || i59.type.toString() : ms(i59);
  }
  function b5(i59, t) {
    let e = t ? `. Dependency path: ${t.join(" > ")} > ${i59}` : "";
    throw new ze(-200, i59);
  }
  function RS(i59, t) {
    throw new ze(-201, false);
  }
  var rn = function(i59) {
    return i59[i59.Default = 0] = "Default", i59[i59.Host = 1] = "Host", i59[i59.Self = 2] = "Self", i59[i59.SkipSelf = 4] = "SkipSelf", i59[i59.Optional = 8] = "Optional", i59;
  }(rn || {});
  var wC;
  function aO() {
    return wC;
  }
  function yo(i59) {
    let t = wC;
    return wC = i59, t;
  }
  function lO(i59, t, e) {
    let n = PS(i59);
    if (n && n.providedIn == "root") return n.value === void 0 ? n.value = n.factory() : n.value;
    if (e & rn.Optional) return null;
    if (t !== void 0) return t;
    RS(i59, "Injector");
  }
  var x5 = {};
  var Bp = x5;
  var CC = "__NG_DI_FLAG__";
  var Z_ = "ngTempTokenPath";
  var w5 = "ngTokenPath";
  var C5 = /\n/gm;
  var S5 = "\u0275";
  var pR = "__source";
  var au;
  function M5() {
    return au;
  }
  function Ya(i59) {
    let t = au;
    return au = i59, t;
  }
  function E5(i59, t = rn.Default) {
    if (au === void 0) throw new ze(-203, false);
    return au === null ? lO(i59, void 0, t) : au.get(i59, t & rn.Optional ? null : void 0, t);
  }
  function Ze(i59, t = rn.Default) {
    return (aO() || E5)($i(i59), t);
  }
  function M(i59, t = rn.Default) {
    return Ze(i59, xv(t));
  }
  function xv(i59) {
    return typeof i59 > "u" || typeof i59 == "number" ? i59 : 0 | (i59.optional && 8) | (i59.host && 1) | (i59.self && 2) | (i59.skipSelf && 4);
  }
  function SC(i59) {
    let t = [];
    for (let e = 0; e < i59.length; e++) {
      let n = $i(i59[e]);
      if (Array.isArray(n)) {
        if (n.length === 0) throw new ze(900, false);
        let r, o = rn.Default;
        for (let s = 0; s < n.length; s++) {
          let a = n[s], l = T5(a);
          typeof l == "number" ? l === -1 ? r = a.token : o |= l : r = a;
        }
        t.push(Ze(r, o));
      } else t.push(Ze(n));
    }
    return t;
  }
  function cO(i59, t) {
    return i59[CC] = t, i59.prototype[CC] = t, i59;
  }
  function T5(i59) {
    return i59[CC];
  }
  function I5(i59, t, e, n) {
    let r = i59[Z_];
    throw t[pR] && r.unshift(t[pR]), i59.message = D5(`
` + i59.message, r, e, n), i59[w5] = r, i59[Z_] = null, i59;
  }
  function D5(i59, t, e, n = null) {
    i59 = i59 && i59.charAt(0) === `
` && i59.charAt(1) == S5 ? i59.slice(2) : i59;
    let r = Qr(t);
    if (Array.isArray(t)) r = t.map(Qr).join(" -> ");
    else if (typeof t == "object") {
      let o = [];
      for (let s in t) if (t.hasOwnProperty(s)) {
        let a = t[s];
        o.push(s + ":" + (typeof a == "string" ? JSON.stringify(a) : Qr(a)));
      }
      r = `{${o.join(", ")}}`;
    }
    return `${e}${n ? "(" + n + ")" : ""}[${r}]: ${i59.replace(C5, `
  `)}`;
  }
  var wv = cO(nO("Optional"), 8);
  var dO = cO(nO("SkipSelf"), 4);
  function cu(i59, t) {
    let e = i59.hasOwnProperty(X_);
    return e ? i59[X_] : null;
  }
  function P5(i59, t, e) {
    if (i59.length !== t.length) return false;
    for (let n = 0; n < i59.length; n++) {
      let r = i59[n], o = t[n];
      if (e && (r = e(r), o = e(o)), o !== r) return false;
    }
    return true;
  }
  function R5(i59) {
    return i59.flat(Number.POSITIVE_INFINITY);
  }
  function OS(i59, t) {
    i59.forEach((e) => Array.isArray(e) ? OS(e, t) : t(e));
  }
  function uO(i59, t, e) {
    t >= i59.length ? i59.push(e) : i59.splice(t, 0, e);
  }
  function Q_(i59, t) {
    return t >= i59.length - 1 ? i59.pop() : i59.splice(t, 1)[0];
  }
  function O5(i59, t) {
    let e = [];
    for (let n = 0; n < i59; n++) e.push(t);
    return e;
  }
  function A5(i59, t, e, n) {
    let r = i59.length;
    if (r == t) i59.push(e, n);
    else if (r === 1) i59.push(n, i59[0]), i59[0] = e;
    else {
      for (r--, i59.push(i59[r - 1], i59[r]); r > t; ) {
        let o = r - 2;
        i59[r] = i59[o], r--;
      }
      i59[t] = e, i59[t + 1] = n;
    }
  }
  function Cv(i59, t, e) {
    let n = Xp(i59, t);
    return n >= 0 ? i59[n | 1] = e : (n = ~n, A5(i59, n, t, e)), n;
  }
  function lC(i59, t) {
    let e = Xp(i59, t);
    if (e >= 0) return i59[e | 1];
  }
  function Xp(i59, t) {
    return N5(i59, t, 1);
  }
  function N5(i59, t, e) {
    let n = 0, r = i59.length >> e;
    for (; r !== n; ) {
      let o = n + (r - n >> 1), s = i59[o << e];
      if (t === s) return o << e;
      s > t ? r = o : n = o + 1;
    }
    return ~(r << e);
  }
  var ta = {};
  var Er = [];
  var Vp = new Ee("");
  var hO = new Ee("", -1);
  var pO = new Ee("");
  var K_ = class {
    get(t, e = Bp) {
      if (e === Bp) {
        let n = new Error(`NullInjectorError: No provider for ${Qr(t)}!`);
        throw n.name = "NullInjectorError", n;
      }
      return e;
    }
  };
  function rc(i59) {
    return i59[g5] || null;
  }
  function AS(i59) {
    return i59[_5] || null;
  }
  function fO(i59) {
    return i59[v5] || null;
  }
  function k5(i59) {
    let t = rc(i59) || AS(i59) || fO(i59);
    return t !== null && t.standalone;
  }
  function L5(...i59) {
    return { \u0275providers: mO(true, i59), \u0275fromNgModule: true };
  }
  function mO(i59, ...t) {
    let e = [], n = /* @__PURE__ */ new Set(), r, o = (s) => {
      e.push(s);
    };
    return OS(t, (s) => {
      let a = s;
      MC(a, o, [], n) && (r ||= [], r.push(a));
    }), r !== void 0 && gO(r, o), e;
  }
  function gO(i59, t) {
    for (let e = 0; e < i59.length; e++) {
      let { ngModule: n, providers: r } = i59[e];
      NS(r, (o) => {
        t(o, n);
      });
    }
  }
  function MC(i59, t, e, n) {
    if (i59 = $i(i59), !i59) return false;
    let r = null, o = dR(i59), s = !o && rc(i59);
    if (!o && !s) {
      let l = i59.ngModule;
      if (o = dR(l), o) r = l;
      else return false;
    } else {
      if (s && !s.standalone) return false;
      r = i59;
    }
    let a = n.has(r);
    if (s) {
      if (a) return false;
      if (n.add(r), s.dependencies) {
        let l = typeof s.dependencies == "function" ? s.dependencies() : s.dependencies;
        for (let c of l) MC(c, t, e, n);
      }
    } else if (o) {
      if (o.imports != null && !a) {
        n.add(r);
        let c;
        try {
          OS(o.imports, (d) => {
            MC(d, t, e, n) && (c ||= [], c.push(d));
          });
        } finally {
        }
        c !== void 0 && gO(c, t);
      }
      if (!a) {
        let c = cu(r) || (() => new r());
        t({ provide: r, useFactory: c, deps: Er }, r), t({ provide: pO, useValue: r, multi: true }, r), t({ provide: Vp, useValue: () => Ze(r), multi: true }, r);
      }
      let l = o.providers;
      if (l != null && !a) {
        let c = i59;
        NS(l, (d) => {
          t(d, c);
        });
      }
    } else return false;
    return r !== i59 && i59.providers !== void 0;
  }
  function NS(i59, t) {
    for (let e of i59) sO(e) && (e = e.\u0275providers), Array.isArray(e) ? NS(e, t) : t(e);
  }
  var F5 = Un({ provide: String, useValue: Un });
  function _O(i59) {
    return i59 !== null && typeof i59 == "object" && F5 in i59;
  }
  function B5(i59) {
    return !!(i59 && i59.useExisting);
  }
  function V5(i59) {
    return !!(i59 && i59.useFactory);
  }
  function du(i59) {
    return typeof i59 == "function";
  }
  function z5(i59) {
    return !!i59.useClass;
  }
  var Sv = new Ee("");
  var G_ = {};
  var U5 = {};
  var cC;
  function Mv() {
    return cC === void 0 && (cC = new K_()), cC;
  }
  var Jr = class {
  };
  var zp = class extends Jr {
    parent;
    source;
    scopes;
    records = /* @__PURE__ */ new Map();
    _ngOnDestroyHooks = /* @__PURE__ */ new Set();
    _onDestroyHooks = [];
    get destroyed() {
      return this._destroyed;
    }
    _destroyed = false;
    injectorDefTypes;
    constructor(t, e, n, r) {
      super(), this.parent = e, this.source = n, this.scopes = r, TC(t, (s) => this.processProvider(s)), this.records.set(hO, iu(void 0, this)), r.has("environment") && this.records.set(Jr, iu(void 0, this));
      let o = this.records.get(Sv);
      o != null && typeof o.value == "string" && this.scopes.add(o.value), this.injectorDefTypes = new Set(this.get(pO, Er, rn.Self));
    }
    destroy() {
      kp(this), this._destroyed = true;
      let t = Ht(null);
      try {
        for (let n of this._ngOnDestroyHooks) n.ngOnDestroy();
        let e = this._onDestroyHooks;
        this._onDestroyHooks = [];
        for (let n of e) n();
      } finally {
        this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), Ht(t);
      }
    }
    onDestroy(t) {
      return kp(this), this._onDestroyHooks.push(t), () => this.removeOnDestroy(t);
    }
    runInContext(t) {
      kp(this);
      let e = Ya(this), n = yo(void 0), r;
      try {
        return t();
      } finally {
        Ya(e), yo(n);
      }
    }
    get(t, e = Bp, n = rn.Default) {
      if (kp(this), t.hasOwnProperty(hR)) return t[hR](this);
      n = xv(n);
      let r, o = Ya(this), s = yo(void 0);
      try {
        if (!(n & rn.SkipSelf)) {
          let l = this.records.get(t);
          if (l === void 0) {
            let c = $5(t) && PS(t);
            c && this.injectableDefInScope(c) ? l = iu(EC(t), G_) : l = null, this.records.set(t, l);
          }
          if (l != null) return this.hydrate(t, l);
        }
        let a = n & rn.Self ? Mv() : this.parent;
        return e = n & rn.Optional && e === Bp ? null : e, a.get(t, e);
      } catch (a) {
        if (a.name === "NullInjectorError") {
          if ((a[Z_] = a[Z_] || []).unshift(Qr(t)), o) throw a;
          return I5(a, t, "R3InjectorError", this.source);
        } else throw a;
      } finally {
        yo(s), Ya(o);
      }
    }
    resolveInjectorInitializers() {
      let t = Ht(null), e = Ya(this), n = yo(void 0), r;
      try {
        let o = this.get(Vp, Er, rn.Self);
        for (let s of o) s();
      } finally {
        Ya(e), yo(n), Ht(t);
      }
    }
    toString() {
      let t = [], e = this.records;
      for (let n of e.keys()) t.push(Qr(n));
      return `R3Injector[${t.join(", ")}]`;
    }
    processProvider(t) {
      t = $i(t);
      let e = du(t) ? t : $i(t && t.provide), n = H5(t);
      if (!du(t) && t.multi === true) {
        let r = this.records.get(e);
        r || (r = iu(void 0, G_, true), r.factory = () => SC(r.multi), this.records.set(e, r)), e = t, r.multi.push(t);
      }
      this.records.set(e, n);
    }
    hydrate(t, e) {
      let n = Ht(null);
      try {
        return e.value === G_ && (e.value = U5, e.value = e.factory()), typeof e.value == "object" && e.value && W5(e.value) && this._ngOnDestroyHooks.add(e.value), e.value;
      } finally {
        Ht(n);
      }
    }
    injectableDefInScope(t) {
      if (!t.providedIn) return false;
      let e = $i(t.providedIn);
      return typeof e == "string" ? e === "any" || this.scopes.has(e) : this.injectorDefTypes.has(e);
    }
    removeOnDestroy(t) {
      let e = this._onDestroyHooks.indexOf(t);
      e !== -1 && this._onDestroyHooks.splice(e, 1);
    }
  };
  function EC(i59) {
    let t = PS(i59), e = t !== null ? t.factory : cu(i59);
    if (e !== null) return e;
    if (i59 instanceof Ee) throw new ze(204, false);
    if (i59 instanceof Function) return G5(i59);
    throw new ze(204, false);
  }
  function G5(i59) {
    if (i59.length > 0) throw new ze(204, false);
    let e = f5(i59);
    return e !== null ? () => e.factory(i59) : () => new i59();
  }
  function H5(i59) {
    if (_O(i59)) return iu(void 0, i59.useValue);
    {
      let t = vO(i59);
      return iu(t, G_);
    }
  }
  function vO(i59, t, e) {
    let n;
    if (du(i59)) {
      let r = $i(i59);
      return cu(r) || EC(r);
    } else if (_O(i59)) n = () => $i(i59.useValue);
    else if (V5(i59)) n = () => i59.useFactory(...SC(i59.deps || []));
    else if (B5(i59)) n = () => Ze($i(i59.useExisting));
    else {
      let r = $i(i59 && (i59.useClass || i59.provide));
      if (j5(i59)) n = () => new r(...SC(i59.deps));
      else return cu(r) || EC(r);
    }
    return n;
  }
  function kp(i59) {
    if (i59.destroyed) throw new ze(205, false);
  }
  function iu(i59, t, e = false) {
    return { factory: i59, value: t, multi: e ? [] : void 0 };
  }
  function j5(i59) {
    return !!i59.deps;
  }
  function W5(i59) {
    return i59 !== null && typeof i59 == "object" && typeof i59.ngOnDestroy == "function";
  }
  function $5(i59) {
    return typeof i59 == "function" || typeof i59 == "object" && i59 instanceof Ee;
  }
  function TC(i59, t) {
    for (let e of i59) Array.isArray(e) ? TC(e, t) : e && sO(e) ? TC(e.\u0275providers, t) : t(e);
  }
  function kS(i59, t) {
    i59 instanceof zp && kp(i59);
    let e, n = Ya(i59), r = yo(void 0);
    try {
      return t();
    } finally {
      Ya(n), yo(r);
    }
  }
  function yO() {
    return aO() !== void 0 || M5() != null;
  }
  function pc(i59) {
    if (!yO()) throw new ze(-203, false);
  }
  function q5(i59) {
    return typeof i59 == "function";
  }
  var xs = 0;
  var Gt = 1;
  var Ot = 2;
  var ur = 3;
  var Xo = 4;
  var Hr = 5;
  var uu = 6;
  var J_ = 7;
  var qi = 8;
  var Up = 9;
  var na = 10;
  var ti = 11;
  var Gp = 12;
  var fR = 13;
  var _u = 14;
  var eo = 15;
  var oc = 16;
  var ru = 17;
  var ia = 18;
  var Ev = 19;
  var bO = 20;
  var Xa = 21;
  var H_ = 22;
  var sc = 23;
  var Kr = 24;
  var hr = 25;
  var LS = 1;
  var ac = 7;
  var ev = 8;
  var hu = 9;
  var dr = 10;
  function Za(i59) {
    return Array.isArray(i59) && typeof i59[LS] == "object";
  }
  function la(i59) {
    return Array.isArray(i59) && i59[LS] === true;
  }
  function FS(i59) {
    return (i59.flags & 4) !== 0;
  }
  function fc(i59) {
    return i59.componentOffset > -1;
  }
  function Tv(i59) {
    return (i59.flags & 1) === 1;
  }
  function _s(i59) {
    return !!i59.template;
  }
  function tv(i59) {
    return (i59[Ot] & 512) !== 0;
  }
  function Zp(i59) {
    return (i59[Ot] & 256) === 256;
  }
  var IC = class {
    previousValue;
    currentValue;
    firstChange;
    constructor(t, e, n) {
      this.previousValue = t, this.currentValue = e, this.firstChange = n;
    }
    isFirstChange() {
      return this.firstChange;
    }
  };
  function xO(i59, t, e, n) {
    t !== null ? t.applyValueToInputSignal(t, n) : i59[e] = n;
  }
  var yn = (() => {
    let i59 = () => wO;
    return i59.ngInherit = true, i59;
  })();
  function wO(i59) {
    return i59.type.prototype.ngOnChanges && (i59.setInput = X5), Y5;
  }
  function Y5() {
    let i59 = SO(this), t = i59?.current;
    if (t) {
      let e = i59.previous;
      if (e === ta) i59.previous = t;
      else for (let n in t) e[n] = t[n];
      i59.current = null, this.ngOnChanges(t);
    }
  }
  function X5(i59, t, e, n, r) {
    let o = this.declaredInputs[n], s = SO(i59) || Z5(i59, { previous: ta, current: null }), a = s.current || (s.current = {}), l = s.previous, c = l[o];
    a[o] = new IC(c && c.currentValue, e, l === ta), xO(i59, t, r, e);
  }
  var CO = "__ngSimpleChanges__";
  function SO(i59) {
    return i59[CO] || null;
  }
  function Z5(i59, t) {
    return i59[CO] = t;
  }
  var mR = null;
  var bo = function(i59, t, e) {
    mR?.(i59, t, e);
  };
  var MO = "svg";
  var Q5 = "math";
  function vs(i59) {
    for (; Array.isArray(i59); ) i59 = i59[xs];
    return i59;
  }
  function K5(i59) {
    for (; Array.isArray(i59); ) {
      if (typeof i59[LS] == "object") return i59;
      i59 = i59[xs];
    }
    return null;
  }
  function EO(i59, t) {
    return vs(t[i59]);
  }
  function Zo(i59, t) {
    return vs(t[i59.index]);
  }
  function BS(i59, t) {
    return i59.data[t];
  }
  function J5(i59, t) {
    return i59[t];
  }
  function ys(i59, t) {
    let e = t[i59];
    return Za(e) ? e : e[xs];
  }
  function ej(i59) {
    return (i59[Ot] & 4) === 4;
  }
  function VS(i59) {
    return (i59[Ot] & 128) === 128;
  }
  function tj(i59) {
    return la(i59[ur]);
  }
  function Qa(i59, t) {
    return t == null ? null : i59[t];
  }
  function TO(i59) {
    i59[ru] = 0;
  }
  function zS(i59) {
    i59[Ot] & 1024 || (i59[Ot] |= 1024, VS(i59) && Qp(i59));
  }
  function nj(i59, t) {
    for (; i59 > 0; ) t = t[_u], i59--;
    return t;
  }
  function Iv(i59) {
    return !!(i59[Ot] & 9216 || i59[Kr]?.dirty);
  }
  function DC(i59) {
    i59[na].changeDetectionScheduler?.notify(9), i59[Ot] & 64 && (i59[Ot] |= 1024), Iv(i59) && Qp(i59);
  }
  function Qp(i59) {
    i59[na].changeDetectionScheduler?.notify(0);
    let t = lc(i59);
    for (; t !== null && !(t[Ot] & 8192 || (t[Ot] |= 8192, !VS(t))); ) t = lc(t);
  }
  function IO(i59, t) {
    if (Zp(i59)) throw new ze(911, false);
    i59[Xa] === null && (i59[Xa] = []), i59[Xa].push(t);
  }
  function ij(i59, t) {
    if (i59[Xa] === null) return;
    let e = i59[Xa].indexOf(t);
    e !== -1 && i59[Xa].splice(e, 1);
  }
  function lc(i59) {
    let t = i59[ur];
    return la(t) ? t[ur] : t;
  }
  function DO(i59) {
    return i59[J_] ??= [];
  }
  function PO(i59) {
    return i59.cleanup ??= [];
  }
  function rj(i59, t, e, n) {
    let r = DO(t);
    r.push(e), i59.firstCreatePass && PO(i59).push(n, r.length - 1);
  }
  var Vt = { lFrame: FO(null), bindingsEnabled: true, skipHydrationRootTNode: null };
  var PC = false;
  function oj() {
    return Vt.lFrame.elementDepthCount;
  }
  function sj() {
    Vt.lFrame.elementDepthCount++;
  }
  function aj() {
    Vt.lFrame.elementDepthCount--;
  }
  function Dv() {
    return Vt.bindingsEnabled;
  }
  function RO() {
    return Vt.skipHydrationRootTNode !== null;
  }
  function lj(i59) {
    return Vt.skipHydrationRootTNode === i59;
  }
  function cj() {
    Vt.skipHydrationRootTNode = null;
  }
  function Ft() {
    return Vt.lFrame.lView;
  }
  function ii() {
    return Vt.lFrame.tView;
  }
  function q(i59) {
    return Vt.lFrame.contextLView = i59, i59[qi];
  }
  function Y(i59) {
    return Vt.lFrame.contextLView = null, i59;
  }
  function fr() {
    let i59 = OO();
    for (; i59 !== null && i59.type === 64; ) i59 = i59.parent;
    return i59;
  }
  function OO() {
    return Vt.lFrame.currentTNode;
  }
  function dj() {
    let i59 = Vt.lFrame, t = i59.currentTNode;
    return i59.isParent ? t : t.parent;
  }
  function mc(i59, t) {
    let e = Vt.lFrame;
    e.currentTNode = i59, e.isParent = t;
  }
  function US() {
    return Vt.lFrame.isParent;
  }
  function GS() {
    Vt.lFrame.isParent = false;
  }
  function uj() {
    return Vt.lFrame.contextLView;
  }
  function AO() {
    return PC;
  }
  function nv(i59) {
    let t = PC;
    return PC = i59, t;
  }
  function hj() {
    let i59 = Vt.lFrame, t = i59.bindingRootIndex;
    return t === -1 && (t = i59.bindingRootIndex = i59.tView.bindingStartIndex), t;
  }
  function NO() {
    return Vt.lFrame.bindingIndex;
  }
  function pj(i59) {
    return Vt.lFrame.bindingIndex = i59;
  }
  function gc() {
    return Vt.lFrame.bindingIndex++;
  }
  function Pv(i59) {
    let t = Vt.lFrame, e = t.bindingIndex;
    return t.bindingIndex = t.bindingIndex + i59, e;
  }
  function fj() {
    return Vt.lFrame.inI18n;
  }
  function mj(i59, t) {
    let e = Vt.lFrame;
    e.bindingIndex = e.bindingRootIndex = i59, RC(t);
  }
  function gj() {
    return Vt.lFrame.currentDirectiveIndex;
  }
  function RC(i59) {
    Vt.lFrame.currentDirectiveIndex = i59;
  }
  function HS(i59) {
    let t = Vt.lFrame.currentDirectiveIndex;
    return t === -1 ? null : i59[t];
  }
  function jS() {
    return Vt.lFrame.currentQueryIndex;
  }
  function Rv(i59) {
    Vt.lFrame.currentQueryIndex = i59;
  }
  function _j(i59) {
    let t = i59[Gt];
    return t.type === 2 ? t.declTNode : t.type === 1 ? i59[Hr] : null;
  }
  function kO(i59, t, e) {
    if (e & rn.SkipSelf) {
      let r = t, o = i59;
      for (; r = r.parent, r === null && !(e & rn.Host); ) if (r = _j(o), r === null || (o = o[_u], r.type & 10)) break;
      if (r === null) return false;
      t = r, i59 = o;
    }
    let n = Vt.lFrame = LO();
    return n.currentTNode = t, n.lView = i59, true;
  }
  function WS(i59) {
    let t = LO(), e = i59[Gt];
    Vt.lFrame = t, t.currentTNode = e.firstChild, t.lView = i59, t.tView = e, t.contextLView = i59, t.bindingIndex = e.bindingStartIndex, t.inI18n = false;
  }
  function LO() {
    let i59 = Vt.lFrame, t = i59 === null ? null : i59.child;
    return t === null ? FO(i59) : t;
  }
  function FO(i59) {
    let t = { currentTNode: null, isParent: true, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: i59, child: null, inI18n: false };
    return i59 !== null && (i59.child = t), t;
  }
  function BO() {
    let i59 = Vt.lFrame;
    return Vt.lFrame = i59.parent, i59.currentTNode = null, i59.lView = null, i59;
  }
  var VO = BO;
  function $S() {
    let i59 = BO();
    i59.isParent = true, i59.tView = null, i59.selectedIndex = -1, i59.contextLView = null, i59.elementDepthCount = 0, i59.currentDirectiveIndex = -1, i59.currentNamespace = null, i59.bindingRootIndex = -1, i59.bindingIndex = -1, i59.currentQueryIndex = 0;
  }
  function vj(i59) {
    return (Vt.lFrame.contextLView = nj(i59, Vt.lFrame.contextLView))[qi];
  }
  function ws() {
    return Vt.lFrame.selectedIndex;
  }
  function cc(i59) {
    Vt.lFrame.selectedIndex = i59;
  }
  function Ov() {
    let i59 = Vt.lFrame;
    return BS(i59.tView, i59.selectedIndex);
  }
  function to() {
    Vt.lFrame.currentNamespace = MO;
  }
  function Av() {
    yj();
  }
  function yj() {
    Vt.lFrame.currentNamespace = null;
  }
  function bj() {
    return Vt.lFrame.currentNamespace;
  }
  var zO = true;
  function Nv() {
    return zO;
  }
  function kv(i59) {
    zO = i59;
  }
  function xj(i59, t, e) {
    let { ngOnChanges: n, ngOnInit: r, ngDoCheck: o } = t.type.prototype;
    if (n) {
      let s = wO(t);
      (e.preOrderHooks ??= []).push(i59, s), (e.preOrderCheckHooks ??= []).push(i59, s);
    }
    r && (e.preOrderHooks ??= []).push(0 - i59, r), o && ((e.preOrderHooks ??= []).push(i59, o), (e.preOrderCheckHooks ??= []).push(i59, o));
  }
  function qS(i59, t) {
    for (let e = t.directiveStart, n = t.directiveEnd; e < n; e++) {
      let o = i59.data[e].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: l, ngAfterViewChecked: c, ngOnDestroy: d } = o;
      s && (i59.contentHooks ??= []).push(-e, s), a && ((i59.contentHooks ??= []).push(e, a), (i59.contentCheckHooks ??= []).push(e, a)), l && (i59.viewHooks ??= []).push(-e, l), c && ((i59.viewHooks ??= []).push(e, c), (i59.viewCheckHooks ??= []).push(e, c)), d != null && (i59.destroyHooks ??= []).push(e, d);
    }
  }
  function j_(i59, t, e) {
    UO(i59, t, 3, e);
  }
  function W_(i59, t, e, n) {
    (i59[Ot] & 3) === e && UO(i59, t, e, n);
  }
  function dC(i59, t) {
    let e = i59[Ot];
    (e & 3) === t && (e &= 16383, e += 1, i59[Ot] = e);
  }
  function UO(i59, t, e, n) {
    let r = n !== void 0 ? i59[ru] & 65535 : 0, o = n ?? -1, s = t.length - 1, a = 0;
    for (let l = r; l < s; l++) if (typeof t[l + 1] == "number") {
      if (a = t[l], n != null && a >= n) break;
    } else t[l] < 0 && (i59[ru] += 65536), (a < o || o == -1) && (wj(i59, e, t, l), i59[ru] = (i59[ru] & 4294901760) + l + 2), l++;
  }
  function gR(i59, t) {
    bo(4, i59, t);
    let e = Ht(null);
    try {
      t.call(i59);
    } finally {
      Ht(e), bo(5, i59, t);
    }
  }
  function wj(i59, t, e, n) {
    let r = e[n] < 0, o = e[n + 1], s = r ? -e[n] : e[n], a = i59[s];
    r ? i59[Ot] >> 14 < i59[ru] >> 16 && (i59[Ot] & 3) === t && (i59[Ot] += 16384, gR(a, o)) : gR(a, o);
  }
  var lu = -1;
  var dc = class {
    factory;
    injectImpl;
    resolving = false;
    canSeeViewProviders;
    multi;
    componentProviders;
    index;
    providerFactory;
    constructor(t, e, n) {
      this.factory = t, this.canSeeViewProviders = e, this.injectImpl = n;
    }
  };
  function Cj(i59) {
    return i59 instanceof dc;
  }
  function Sj(i59) {
    return (i59.flags & 8) !== 0;
  }
  function Mj(i59) {
    return (i59.flags & 16) !== 0;
  }
  function Ej(i59, t, e) {
    let n = 0;
    for (; n < e.length; ) {
      let r = e[n];
      if (typeof r == "number") {
        if (r !== 0) break;
        n++;
        let o = e[n++], s = e[n++], a = e[n++];
        i59.setAttribute(t, s, a, o);
      } else {
        let o = r, s = e[++n];
        Tj(o) ? i59.setProperty(t, o, s) : i59.setAttribute(t, o, s), n++;
      }
    }
    return n;
  }
  function GO(i59) {
    return i59 === 3 || i59 === 4 || i59 === 6;
  }
  function Tj(i59) {
    return i59.charCodeAt(0) === 64;
  }
  function pu(i59, t) {
    if (!(t === null || t.length === 0)) if (i59 === null || i59.length === 0) i59 = t.slice();
    else {
      let e = -1;
      for (let n = 0; n < t.length; n++) {
        let r = t[n];
        typeof r == "number" ? e = r : e === 0 || (e === -1 || e === 2 ? _R(i59, e, r, null, t[++n]) : _R(i59, e, r, null, null));
      }
    }
    return i59;
  }
  function _R(i59, t, e, n, r) {
    let o = 0, s = i59.length;
    if (t === -1) s = -1;
    else for (; o < i59.length; ) {
      let a = i59[o++];
      if (typeof a == "number") {
        if (a === t) {
          s = -1;
          break;
        } else if (a > t) {
          s = o - 1;
          break;
        }
      }
    }
    for (; o < i59.length; ) {
      let a = i59[o];
      if (typeof a == "number") break;
      if (a === e) {
        if (n === null) {
          r !== null && (i59[o + 1] = r);
          return;
        } else if (n === i59[o + 1]) {
          i59[o + 2] = r;
          return;
        }
      }
      o++, n !== null && o++, r !== null && o++;
    }
    s !== -1 && (i59.splice(s, 0, t), o = s + 1), i59.splice(o++, 0, e), n !== null && i59.splice(o++, 0, n), r !== null && i59.splice(o++, 0, r);
  }
  var uC = {};
  var OC = class {
    injector;
    parentInjector;
    constructor(t, e) {
      this.injector = t, this.parentInjector = e;
    }
    get(t, e, n) {
      n = xv(n);
      let r = this.injector.get(t, uC, n);
      return r !== uC || e === uC ? r : this.parentInjector.get(t, e, n);
    }
  };
  function HO(i59) {
    return i59 !== lu;
  }
  function iv(i59) {
    return i59 & 32767;
  }
  function Ij(i59) {
    return i59 >> 16;
  }
  function rv(i59, t) {
    let e = Ij(i59), n = t;
    for (; e > 0; ) n = n[_u], e--;
    return n;
  }
  var AC = true;
  function vR(i59) {
    let t = AC;
    return AC = i59, t;
  }
  var Dj = 256;
  var jO = Dj - 1;
  var WO = 5;
  var Pj = 0;
  var gs = {};
  function Rj(i59, t, e) {
    let n;
    typeof e == "string" ? n = e.charCodeAt(0) || 0 : e.hasOwnProperty(Fp) && (n = e[Fp]), n == null && (n = e[Fp] = Pj++);
    let r = n & jO, o = 1 << r;
    t.data[i59 + (r >> WO)] |= o;
  }
  function ov(i59, t) {
    let e = $O(i59, t);
    if (e !== -1) return e;
    let n = t[Gt];
    n.firstCreatePass && (i59.injectorIndex = t.length, hC(n.data, i59), hC(t, null), hC(n.blueprint, null));
    let r = YS(i59, t), o = i59.injectorIndex;
    if (HO(r)) {
      let s = iv(r), a = rv(r, t), l = a[Gt].data;
      for (let c = 0; c < 8; c++) t[o + c] = a[s + c] | l[s + c];
    }
    return t[o + 8] = r, o;
  }
  function hC(i59, t) {
    i59.push(0, 0, 0, 0, 0, 0, 0, 0, t);
  }
  function $O(i59, t) {
    return i59.injectorIndex === -1 || i59.parent && i59.parent.injectorIndex === i59.injectorIndex || t[i59.injectorIndex + 8] === null ? -1 : i59.injectorIndex;
  }
  function YS(i59, t) {
    if (i59.parent && i59.parent.injectorIndex !== -1) return i59.parent.injectorIndex;
    let e = 0, n = null, r = t;
    for (; r !== null; ) {
      if (n = QO(r), n === null) return lu;
      if (e++, r = r[_u], n.injectorIndex !== -1) return n.injectorIndex | e << 16;
    }
    return lu;
  }
  function NC(i59, t, e) {
    Rj(i59, t, e);
  }
  function Oj(i59, t) {
    if (t === "class") return i59.classes;
    if (t === "style") return i59.styles;
    let e = i59.attrs;
    if (e) {
      let n = e.length, r = 0;
      for (; r < n; ) {
        let o = e[r];
        if (GO(o)) break;
        if (o === 0) r = r + 2;
        else if (typeof o == "number") for (r++; r < n && typeof e[r] == "string"; ) r++;
        else {
          if (o === t) return e[r + 1];
          r = r + 2;
        }
      }
    }
    return null;
  }
  function qO(i59, t, e) {
    if (e & rn.Optional || i59 !== void 0) return i59;
    RS(t, "NodeInjector");
  }
  function YO(i59, t, e, n) {
    if (e & rn.Optional && n === void 0 && (n = null), !(e & (rn.Self | rn.Host))) {
      let r = i59[Up], o = yo(void 0);
      try {
        return r ? r.get(t, n, e & rn.Optional) : lO(t, n, e & rn.Optional);
      } finally {
        yo(o);
      }
    }
    return qO(n, t, e);
  }
  function XO(i59, t, e, n = rn.Default, r) {
    if (i59 !== null) {
      if (t[Ot] & 2048 && !(n & rn.Self)) {
        let s = Lj(i59, t, e, n, gs);
        if (s !== gs) return s;
      }
      let o = ZO(i59, t, e, n, gs);
      if (o !== gs) return o;
    }
    return YO(t, e, n, r);
  }
  function ZO(i59, t, e, n, r) {
    let o = Nj(e);
    if (typeof o == "function") {
      if (!kO(t, i59, n)) return n & rn.Host ? qO(r, e, n) : YO(t, e, n, r);
      try {
        let s;
        if (s = o(n), s == null && !(n & rn.Optional)) RS(e);
        else return s;
      } finally {
        VO();
      }
    } else if (typeof o == "number") {
      let s = null, a = $O(i59, t), l = lu, c = n & rn.Host ? t[eo][Hr] : null;
      for ((a === -1 || n & rn.SkipSelf) && (l = a === -1 ? YS(i59, t) : t[a + 8], l === lu || !bR(n, false) ? a = -1 : (s = t[Gt], a = iv(l), t = rv(l, t))); a !== -1; ) {
        let d = t[Gt];
        if (yR(o, a, d.data)) {
          let u = Aj(a, t, e, s, n, c);
          if (u !== gs) return u;
        }
        l = t[a + 8], l !== lu && bR(n, t[Gt].data[a + 8] === c) && yR(o, a, t) ? (s = d, a = iv(l), t = rv(l, t)) : a = -1;
      }
    }
    return r;
  }
  function Aj(i59, t, e, n, r, o) {
    let s = t[Gt], a = s.data[i59 + 8], l = n == null ? fc(a) && AC : n != s && (a.type & 3) !== 0, c = r & rn.Host && o === a, d = $_(a, s, e, l, c);
    return d !== null ? Hp(t, s, d, a) : gs;
  }
  function $_(i59, t, e, n, r) {
    let o = i59.providerIndexes, s = t.data, a = o & 1048575, l = i59.directiveStart, c = i59.directiveEnd, d = o >> 20, u = n ? a : a + d, h = r ? a + d : c;
    for (let p = u; p < h; p++) {
      let f = s[p];
      if (p < l && e === f || p >= l && f.type === e) return p;
    }
    if (r) {
      let p = s[l];
      if (p && _s(p) && p.type === e) return l;
    }
    return null;
  }
  function Hp(i59, t, e, n) {
    let r = i59[e], o = t.data;
    if (Cj(r)) {
      let s = r;
      s.resolving && b5(y5(o[e]));
      let a = vR(s.canSeeViewProviders);
      s.resolving = true;
      let l, c = s.injectImpl ? yo(s.injectImpl) : null, d = kO(i59, n, rn.Default);
      try {
        r = i59[e] = s.factory(void 0, o, i59, n), t.firstCreatePass && e >= n.directiveStart && xj(e, o[e], t);
      } finally {
        c !== null && yo(c), vR(a), s.resolving = false, VO();
      }
    }
    return r;
  }
  function Nj(i59) {
    if (typeof i59 == "string") return i59.charCodeAt(0) || 0;
    let t = i59.hasOwnProperty(Fp) ? i59[Fp] : void 0;
    return typeof t == "number" ? t >= 0 ? t & jO : kj : t;
  }
  function yR(i59, t, e) {
    let n = 1 << i59;
    return !!(e[t + (i59 >> WO)] & n);
  }
  function bR(i59, t) {
    return !(i59 & rn.Self) && !(i59 & rn.Host && t);
  }
  var ic = class {
    _tNode;
    _lView;
    constructor(t, e) {
      this._tNode = t, this._lView = e;
    }
    get(t, e, n) {
      return XO(this._tNode, this._lView, t, xv(n), e);
    }
  };
  function kj() {
    return new ic(fr(), Ft());
  }
  function ri(i59) {
    return Yp(() => {
      let t = i59.prototype.constructor, e = t[X_] || kC(t), n = Object.prototype, r = Object.getPrototypeOf(i59.prototype).constructor;
      for (; r && r !== n; ) {
        let o = r[X_] || kC(r);
        if (o && o !== e) return o;
        r = Object.getPrototypeOf(r);
      }
      return (o) => new o();
    });
  }
  function kC(i59) {
    return iO(i59) ? () => {
      let t = kC($i(i59));
      return t && t();
    } : cu(i59);
  }
  function Lj(i59, t, e, n, r) {
    let o = i59, s = t;
    for (; o !== null && s !== null && s[Ot] & 2048 && !tv(s); ) {
      let a = ZO(o, s, e, n | rn.Self, gs);
      if (a !== gs) return a;
      let l = o.parent;
      if (!l) {
        let c = s[bO];
        if (c) {
          let d = c.get(e, gs, n);
          if (d !== gs) return d;
        }
        l = QO(s), s = s[_u];
      }
      o = l;
    }
    return r;
  }
  function QO(i59) {
    let t = i59[Gt], e = t.type;
    return e === 2 ? t.declTNode : e === 1 ? i59[Hr] : null;
  }
  function KO(i59) {
    return Oj(fr(), i59);
  }
  function xR(i59, t = null, e = null, n) {
    let r = Fj(i59, t, e, n);
    return r.resolveInjectorInitializers(), r;
  }
  function Fj(i59, t = null, e = null, n, r = /* @__PURE__ */ new Set()) {
    let o = [e || Er, L5(i59)];
    return n = n || (typeof i59 == "object" ? void 0 : Qr(i59)), new zp(o, t || Mv(), n || null, r);
  }
  var mt = class i3 {
    static THROW_IF_NOT_FOUND = Bp;
    static NULL = new K_();
    static create(t, e) {
      if (Array.isArray(t)) return xR({ name: "" }, e, t, "");
      {
        let n = t.name ?? "";
        return xR({ name: n }, t.parent, t.providers, n);
      }
    }
    static \u0275prov = de({ token: i3, providedIn: "any", factory: () => Ze(hO) });
    static __NG_ELEMENT_ID__ = -1;
  };
  var Tr = class {
    attributeName;
    constructor(t) {
      this.attributeName = t;
    }
    __NG_ELEMENT_ID__ = () => KO(this.attributeName);
    toString() {
      return `HostAttributeToken ${this.attributeName}`;
    }
  };
  var Bj = new Ee("");
  Bj.__NG_ELEMENT_ID__ = (i59) => {
    let t = fr();
    if (t === null) throw new ze(204, false);
    if (t.type & 2) return t.value;
    if (i59 & rn.Optional) return null;
    throw new ze(204, false);
  };
  var JO = false;
  var pi = /* @__PURE__ */ (() => {
    class i59 {
      static __NG_ELEMENT_ID__ = Vj;
      static __NG_ENV_ID__ = (e) => e;
    }
    return i59;
  })();
  var sv = class extends pi {
    _lView;
    constructor(t) {
      super(), this._lView = t;
    }
    onDestroy(t) {
      return IO(this._lView, t), () => ij(this._lView, t);
    }
  };
  function Vj() {
    return new sv(Ft());
  }
  var ra = class {
  };
  var XS = new Ee("", { providedIn: "root", factory: () => false });
  var eA = new Ee("");
  var tA = new Ee("");
  var vu = (() => {
    class i59 {
      taskId = 0;
      pendingTasks = /* @__PURE__ */ new Set();
      get _hasPendingTasks() {
        return this.hasPendingTasks.value;
      }
      hasPendingTasks = new hi(false);
      add() {
        this._hasPendingTasks || this.hasPendingTasks.next(true);
        let e = this.taskId++;
        return this.pendingTasks.add(e), e;
      }
      has(e) {
        return this.pendingTasks.has(e);
      }
      remove(e) {
        this.pendingTasks.delete(e), this.pendingTasks.size === 0 && this._hasPendingTasks && this.hasPendingTasks.next(false);
      }
      ngOnDestroy() {
        this.pendingTasks.clear(), this._hasPendingTasks && this.hasPendingTasks.next(false);
      }
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => new i59() });
    }
    return i59;
  })();
  var LC = class extends we {
    __isAsync;
    destroyRef = void 0;
    pendingTasks = void 0;
    constructor(t = false) {
      super(), this.__isAsync = t, yO() && (this.destroyRef = M(pi, { optional: true }) ?? void 0, this.pendingTasks = M(vu, { optional: true }) ?? void 0);
    }
    emit(t) {
      let e = Ht(null);
      try {
        super.next(t);
      } finally {
        Ht(e);
      }
    }
    subscribe(t, e, n) {
      let r = t, o = e || (() => null), s = n;
      if (t && typeof t == "object") {
        let l = t;
        r = l.next?.bind(l), o = l.error?.bind(l), s = l.complete?.bind(l);
      }
      this.__isAsync && (o = this.wrapInTimeout(o), r && (r = this.wrapInTimeout(r)), s && (s = this.wrapInTimeout(s)));
      let a = super.subscribe({ next: r, error: o, complete: s });
      return t instanceof Rt && t.add(a), a;
    }
    wrapInTimeout(t) {
      return (e) => {
        let n = this.pendingTasks?.add();
        setTimeout(() => {
          t(e), n !== void 0 && this.pendingTasks?.remove(n);
        });
      };
    }
  };
  var Ue = LC;
  function jp(...i59) {
  }
  function nA(i59) {
    let t, e;
    function n() {
      i59 = jp;
      try {
        e !== void 0 && typeof cancelAnimationFrame == "function" && cancelAnimationFrame(e), t !== void 0 && clearTimeout(t);
      } catch {
      }
    }
    return t = setTimeout(() => {
      i59(), n();
    }), typeof requestAnimationFrame == "function" && (e = requestAnimationFrame(() => {
      i59(), n();
    })), () => n();
  }
  function wR(i59) {
    return queueMicrotask(() => i59()), () => {
      i59 = jp;
    };
  }
  var ZS = "isAngularZone";
  var av = ZS + "_ID";
  var zj = 0;
  var We = class i4 {
    hasPendingMacrotasks = false;
    hasPendingMicrotasks = false;
    isStable = true;
    onUnstable = new Ue(false);
    onMicrotaskEmpty = new Ue(false);
    onStable = new Ue(false);
    onError = new Ue(false);
    constructor(t) {
      let { enableLongStackTrace: e = false, shouldCoalesceEventChangeDetection: n = false, shouldCoalesceRunChangeDetection: r = false, scheduleInRootZone: o = JO } = t;
      if (typeof Zone > "u") throw new ze(908, false);
      Zone.assertZonePatched();
      let s = this;
      s._nesting = 0, s._outer = s._inner = Zone.current, Zone.TaskTrackingZoneSpec && (s._inner = s._inner.fork(new Zone.TaskTrackingZoneSpec())), e && Zone.longStackTraceZoneSpec && (s._inner = s._inner.fork(Zone.longStackTraceZoneSpec)), s.shouldCoalesceEventChangeDetection = !r && n, s.shouldCoalesceRunChangeDetection = r, s.callbackScheduled = false, s.scheduleInRootZone = o, Hj(s);
    }
    static isInAngularZone() {
      return typeof Zone < "u" && Zone.current.get(ZS) === true;
    }
    static assertInAngularZone() {
      if (!i4.isInAngularZone()) throw new ze(909, false);
    }
    static assertNotInAngularZone() {
      if (i4.isInAngularZone()) throw new ze(909, false);
    }
    run(t, e, n) {
      return this._inner.run(t, e, n);
    }
    runTask(t, e, n, r) {
      let o = this._inner, s = o.scheduleEventTask("NgZoneEvent: " + r, t, Uj, jp, jp);
      try {
        return o.runTask(s, e, n);
      } finally {
        o.cancelTask(s);
      }
    }
    runGuarded(t, e, n) {
      return this._inner.runGuarded(t, e, n);
    }
    runOutsideAngular(t) {
      return this._outer.run(t);
    }
  };
  var Uj = {};
  function QS(i59) {
    if (i59._nesting == 0 && !i59.hasPendingMicrotasks && !i59.isStable) try {
      i59._nesting++, i59.onMicrotaskEmpty.emit(null);
    } finally {
      if (i59._nesting--, !i59.hasPendingMicrotasks) try {
        i59.runOutsideAngular(() => i59.onStable.emit(null));
      } finally {
        i59.isStable = true;
      }
    }
  }
  function Gj(i59) {
    if (i59.isCheckStableRunning || i59.callbackScheduled) return;
    i59.callbackScheduled = true;
    function t() {
      nA(() => {
        i59.callbackScheduled = false, FC(i59), i59.isCheckStableRunning = true, QS(i59), i59.isCheckStableRunning = false;
      });
    }
    i59.scheduleInRootZone ? Zone.root.run(() => {
      t();
    }) : i59._outer.run(() => {
      t();
    }), FC(i59);
  }
  function Hj(i59) {
    let t = () => {
      Gj(i59);
    }, e = zj++;
    i59._inner = i59._inner.fork({ name: "angular", properties: { [ZS]: true, [av]: e, [av + e]: true }, onInvokeTask: (n, r, o, s, a, l) => {
      if (jj(l)) return n.invokeTask(o, s, a, l);
      try {
        return CR(i59), n.invokeTask(o, s, a, l);
      } finally {
        (i59.shouldCoalesceEventChangeDetection && s.type === "eventTask" || i59.shouldCoalesceRunChangeDetection) && t(), SR(i59);
      }
    }, onInvoke: (n, r, o, s, a, l, c) => {
      try {
        return CR(i59), n.invoke(o, s, a, l, c);
      } finally {
        i59.shouldCoalesceRunChangeDetection && !i59.callbackScheduled && !Wj(l) && t(), SR(i59);
      }
    }, onHasTask: (n, r, o, s) => {
      n.hasTask(o, s), r === o && (s.change == "microTask" ? (i59._hasPendingMicrotasks = s.microTask, FC(i59), QS(i59)) : s.change == "macroTask" && (i59.hasPendingMacrotasks = s.macroTask));
    }, onHandleError: (n, r, o, s) => (n.handleError(o, s), i59.runOutsideAngular(() => i59.onError.emit(s)), false) });
  }
  function FC(i59) {
    i59._hasPendingMicrotasks || (i59.shouldCoalesceEventChangeDetection || i59.shouldCoalesceRunChangeDetection) && i59.callbackScheduled === true ? i59.hasPendingMicrotasks = true : i59.hasPendingMicrotasks = false;
  }
  function CR(i59) {
    i59._nesting++, i59.isStable && (i59.isStable = false, i59.onUnstable.emit(null));
  }
  function SR(i59) {
    i59._nesting--, QS(i59);
  }
  var BC = class {
    hasPendingMicrotasks = false;
    hasPendingMacrotasks = false;
    isStable = true;
    onUnstable = new Ue();
    onMicrotaskEmpty = new Ue();
    onStable = new Ue();
    onError = new Ue();
    run(t, e, n) {
      return t.apply(e, n);
    }
    runGuarded(t, e, n) {
      return t.apply(e, n);
    }
    runOutsideAngular(t) {
      return t();
    }
    runTask(t, e, n, r) {
      return t.apply(e, n);
    }
  };
  function jj(i59) {
    return iA(i59, "__ignore_ng_zone__");
  }
  function Wj(i59) {
    return iA(i59, "__scheduler_tick__");
  }
  function iA(i59, t) {
    return !Array.isArray(i59) || i59.length !== 1 ? false : i59[0]?.data?.[t] === true;
  }
  var Ir = class {
    _console = console;
    handleError(t) {
      this._console.error("ERROR", t);
    }
  };
  var $j = new Ee("", { providedIn: "root", factory: () => {
    let i59 = M(We), t = M(Ir);
    return (e) => i59.runOutsideAngular(() => t.handleError(e));
  } });
  var VC = class {
    destroyed = false;
    listeners = null;
    errorHandler = M(Ir, { optional: true });
    destroyRef = M(pi);
    constructor() {
      this.destroyRef.onDestroy(() => {
        this.destroyed = true, this.listeners = null;
      });
    }
    subscribe(t) {
      if (this.destroyed) throw new ze(953, false);
      return (this.listeners ??= []).push(t), { unsubscribe: () => {
        let e = this.listeners?.indexOf(t);
        e !== void 0 && e !== -1 && this.listeners?.splice(e, 1);
      } };
    }
    emit(t) {
      if (this.destroyed) throw new ze(953, false);
      if (this.listeners === null) return;
      let e = Ht(null);
      try {
        for (let n of this.listeners) try {
          n(t);
        } catch (r) {
          this.errorHandler?.handleError(r);
        }
      } finally {
        Ht(e);
      }
    }
  };
  function _c(i59) {
    return new VC();
  }
  function MR(i59, t) {
    return tO(i59, t);
  }
  function qj(i59) {
    return tO(eO, i59);
  }
  var Kp = (MR.required = qj, MR);
  function Yj() {
    return yu(fr(), Ft());
  }
  function yu(i59, t) {
    return new He(Zo(i59, t));
  }
  var He = /* @__PURE__ */ (() => {
    class i59 {
      nativeElement;
      constructor(e) {
        this.nativeElement = e;
      }
      static __NG_ELEMENT_ID__ = Yj;
    }
    return i59;
  })();
  function rA(i59) {
    return i59 instanceof He ? i59.nativeElement : i59;
  }
  var ER = /* @__PURE__ */ new Set();
  function no(i59) {
    ER.has(i59) || (ER.add(i59), performance?.mark?.("mark_feature_usage", { detail: { feature: i59 } }));
  }
  function Jp(i59) {
    return typeof i59 == "function" && i59[lr] !== void 0;
  }
  function gt(i59, t) {
    no("NgSignals");
    let e = OP(i59), n = e[lr];
    return t?.equal && (n.equal = t.equal), e.set = (r) => i_(n, r), e.update = (r) => AP(n, r), e.asReadonly = Xj.bind(e), e;
  }
  function Xj() {
    let i59 = this[lr];
    if (i59.readonlyFn === void 0) {
      let t = () => this();
      t[lr] = i59, i59.readonlyFn = t;
    }
    return i59.readonlyFn;
  }
  function Zj() {
    return this._results[Symbol.iterator]();
  }
  var Ni = class {
    _emitDistinctChangesOnly;
    dirty = true;
    _onDirty = void 0;
    _results = [];
    _changesDetected = false;
    _changes = void 0;
    length = 0;
    first = void 0;
    last = void 0;
    get changes() {
      return this._changes ??= new we();
    }
    constructor(t = false) {
      this._emitDistinctChangesOnly = t;
    }
    get(t) {
      return this._results[t];
    }
    map(t) {
      return this._results.map(t);
    }
    filter(t) {
      return this._results.filter(t);
    }
    find(t) {
      return this._results.find(t);
    }
    reduce(t, e) {
      return this._results.reduce(t, e);
    }
    forEach(t) {
      this._results.forEach(t);
    }
    some(t) {
      return this._results.some(t);
    }
    toArray() {
      return this._results.slice();
    }
    toString() {
      return this._results.toString();
    }
    reset(t, e) {
      this.dirty = false;
      let n = R5(t);
      (this._changesDetected = !P5(this._results, n, e)) && (this._results = n, this.length = n.length, this.last = n[this.length - 1], this.first = n[0]);
    }
    notifyOnChanges() {
      this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.next(this);
    }
    onDirty(t) {
      this._onDirty = t;
    }
    setDirty() {
      this.dirty = true, this._onDirty?.();
    }
    destroy() {
      this._changes !== void 0 && (this._changes.complete(), this._changes.unsubscribe());
    }
    [Symbol.iterator] = Zj;
  };
  function oA(i59) {
    return (i59.flags & 128) === 128;
  }
  var sA = function(i59) {
    return i59[i59.OnPush = 0] = "OnPush", i59[i59.Default = 1] = "Default", i59;
  }(sA || {});
  var aA = /* @__PURE__ */ new Map();
  var Qj = 0;
  function Kj() {
    return Qj++;
  }
  function Jj(i59) {
    aA.set(i59[Ev], i59);
  }
  function zC(i59) {
    aA.delete(i59[Ev]);
  }
  var TR = "__ngContext__";
  function vc(i59, t) {
    Za(t) ? (i59[TR] = t[Ev], Jj(t)) : i59[TR] = t;
  }
  function lA(i59) {
    return dA(i59[Gp]);
  }
  function cA(i59) {
    return dA(i59[Xo]);
  }
  function dA(i59) {
    for (; i59 !== null && !la(i59); ) i59 = i59[Xo];
    return i59;
  }
  var UC;
  function uA(i59) {
    UC = i59;
  }
  function e8() {
    if (UC !== void 0) return UC;
    if (typeof document < "u") return document;
    throw new ze(210, false);
  }
  var bu = new Ee("", { providedIn: "root", factory: () => t8 });
  var t8 = "ng";
  var KS = new Ee("");
  var el = new Ee("", { providedIn: "platform", factory: () => "unknown" });
  var An = new Ee("");
  var ef = new Ee("", { providedIn: "root", factory: () => e8().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null });
  var n8 = "h";
  var i8 = "b";
  var hA = false;
  var r8 = new Ee("", { providedIn: "root", factory: () => hA });
  var JS = function(i59) {
    return i59[i59.CHANGE_DETECTION = 0] = "CHANGE_DETECTION", i59[i59.AFTER_NEXT_RENDER = 1] = "AFTER_NEXT_RENDER", i59;
  }(JS || {});
  var xu = new Ee("");
  var ou = function(i59) {
    return i59[i59.EarlyRead = 0] = "EarlyRead", i59[i59.Write = 1] = "Write", i59[i59.MixedReadWrite = 2] = "MixedReadWrite", i59[i59.Read = 3] = "Read", i59;
  }(ou || {});
  var pA = (() => {
    class i59 {
      impl = null;
      execute() {
        this.impl?.execute();
      }
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => new i59() });
    }
    return i59;
  })();
  var o8 = [ou.EarlyRead, ou.Write, ou.MixedReadWrite, ou.Read];
  var s8 = (() => {
    class i59 {
      ngZone = M(We);
      scheduler = M(ra);
      errorHandler = M(Ir, { optional: true });
      sequences = /* @__PURE__ */ new Set();
      deferredRegistrations = /* @__PURE__ */ new Set();
      executing = false;
      constructor() {
        M(xu, { optional: true });
      }
      execute() {
        this.executing = true;
        for (let e of o8) for (let n of this.sequences) if (!(n.erroredOrDestroyed || !n.hooks[e])) try {
          n.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => n.hooks[e](n.pipelinedValue), n.snapshot));
        } catch (r) {
          n.erroredOrDestroyed = true, this.errorHandler?.handleError(r);
        }
        this.executing = false;
        for (let e of this.sequences) e.afterRun(), e.once && (this.sequences.delete(e), e.destroy());
        for (let e of this.deferredRegistrations) this.sequences.add(e);
        this.deferredRegistrations.size > 0 && this.scheduler.notify(8), this.deferredRegistrations.clear();
      }
      register(e) {
        this.executing ? this.deferredRegistrations.add(e) : (this.sequences.add(e), this.scheduler.notify(7));
      }
      unregister(e) {
        this.executing && this.sequences.has(e) ? (e.erroredOrDestroyed = true, e.pipelinedValue = void 0, e.once = true) : (this.sequences.delete(e), this.deferredRegistrations.delete(e));
      }
      maybeTrace(e, n) {
        return n ? n.run(JS.AFTER_NEXT_RENDER, e) : e();
      }
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => new i59() });
    }
    return i59;
  })();
  var GC = class {
    impl;
    hooks;
    once;
    snapshot;
    erroredOrDestroyed = false;
    pipelinedValue = void 0;
    unregisterOnDestroy;
    constructor(t, e, n, r, o = null) {
      this.impl = t, this.hooks = e, this.once = n, this.snapshot = o, this.unregisterOnDestroy = r?.onDestroy(() => this.destroy());
    }
    afterRun() {
      this.erroredOrDestroyed = false, this.pipelinedValue = void 0, this.snapshot?.dispose(), this.snapshot = null;
    }
    destroy() {
      this.impl.unregister(this), this.unregisterOnDestroy?.();
    }
  };
  function tf(i59, t) {
    !t?.injector && pc(tf);
    let e = t?.injector ?? M(mt);
    return no("NgAfterRender"), fA(i59, e, t, false);
  }
  function Yi(i59, t) {
    !t?.injector && pc(Yi);
    let e = t?.injector ?? M(mt);
    return no("NgAfterNextRender"), fA(i59, e, t, true);
  }
  function a8(i59, t) {
    if (i59 instanceof Function) {
      let e = [void 0, void 0, void 0, void 0];
      return e[t] = i59, e;
    } else return [i59.earlyRead, i59.write, i59.mixedReadWrite, i59.read];
  }
  function fA(i59, t, e, n) {
    let r = t.get(pA);
    r.impl ??= t.get(s8);
    let o = t.get(xu, null, { optional: true }), s = e?.phase ?? ou.MixedReadWrite, a = e?.manualCleanup !== true ? t.get(pi) : null, l = new GC(r.impl, a8(i59, s), n, a, o?.snapshot(null));
    return r.impl.register(l), l;
  }
  var l8 = () => null;
  function mA(i59, t, e = false) {
    return l8(i59, t, e);
  }
  function gA(i59, t) {
    let e = i59.contentQueries;
    if (e !== null) {
      let n = Ht(null);
      try {
        for (let r = 0; r < e.length; r += 2) {
          let o = e[r], s = e[r + 1];
          if (s !== -1) {
            let a = i59.data[s];
            Rv(o), a.contentQueries(2, t[s], s);
          }
        }
      } finally {
        Ht(n);
      }
    }
  }
  function HC(i59, t, e) {
    Rv(0);
    let n = Ht(null);
    try {
      t(i59, e);
    } finally {
      Ht(n);
    }
  }
  function eM(i59, t, e) {
    if (FS(t)) {
      let n = Ht(null);
      try {
        let r = t.directiveStart, o = t.directiveEnd;
        for (let s = r; s < o; s++) {
          let a = i59.data[s];
          if (a.contentQueries) {
            let l = e[s];
            a.contentQueries(1, l, s);
          }
        }
      } finally {
        Ht(n);
      }
    }
  }
  var bs = function(i59) {
    return i59[i59.Emulated = 0] = "Emulated", i59[i59.None = 2] = "None", i59[i59.ShadowDom = 3] = "ShadowDom", i59;
  }(bs || {});
  var B_;
  function c8() {
    if (B_ === void 0 && (B_ = null, bC.trustedTypes)) try {
      B_ = bC.trustedTypes.createPolicy("angular", { createHTML: (i59) => i59, createScript: (i59) => i59, createScriptURL: (i59) => i59 });
    } catch {
    }
    return B_;
  }
  function Lv(i59) {
    return c8()?.createHTML(i59) || i59;
  }
  var oa = class {
    changingThisBreaksApplicationSecurity;
    constructor(t) {
      this.changingThisBreaksApplicationSecurity = t;
    }
    toString() {
      return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${JR})`;
    }
  };
  var jC = class extends oa {
    getTypeName() {
      return "HTML";
    }
  };
  var WC = class extends oa {
    getTypeName() {
      return "Style";
    }
  };
  var $C = class extends oa {
    getTypeName() {
      return "Script";
    }
  };
  var qC = class extends oa {
    getTypeName() {
      return "URL";
    }
  };
  var YC = class extends oa {
    getTypeName() {
      return "ResourceURL";
    }
  };
  function Cs(i59) {
    return i59 instanceof oa ? i59.changingThisBreaksApplicationSecurity : i59;
  }
  function yc(i59, t) {
    let e = d8(i59);
    if (e != null && e !== t) {
      if (e === "ResourceURL" && t === "URL") return true;
      throw new Error(`Required a safe ${t}, got a ${e} (see ${JR})`);
    }
    return e === t;
  }
  function d8(i59) {
    return i59 instanceof oa && i59.getTypeName() || null;
  }
  function _A(i59) {
    return new jC(i59);
  }
  function vA(i59) {
    return new WC(i59);
  }
  function yA(i59) {
    return new $C(i59);
  }
  function bA(i59) {
    return new qC(i59);
  }
  function xA(i59) {
    return new YC(i59);
  }
  function u8(i59) {
    let t = new ZC(i59);
    return h8() ? new XC(t) : t;
  }
  var XC = class {
    inertDocumentHelper;
    constructor(t) {
      this.inertDocumentHelper = t;
    }
    getInertBodyElement(t) {
      t = "<body><remove></remove>" + t;
      try {
        let e = new window.DOMParser().parseFromString(Lv(t), "text/html").body;
        return e === null ? this.inertDocumentHelper.getInertBodyElement(t) : (e.firstChild?.remove(), e);
      } catch {
        return null;
      }
    }
  };
  var ZC = class {
    defaultDoc;
    inertDocument;
    constructor(t) {
      this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert");
    }
    getInertBodyElement(t) {
      let e = this.inertDocument.createElement("template");
      return e.innerHTML = Lv(t), e;
    }
  };
  function h8() {
    try {
      return !!new window.DOMParser().parseFromString(Lv(""), "text/html");
    } catch {
      return false;
    }
  }
  var p8 = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;
  function Fv(i59) {
    return i59 = String(i59), i59.match(p8) ? i59 : "unsafe:" + i59;
  }
  function ca(i59) {
    let t = {};
    for (let e of i59.split(",")) t[e] = true;
    return t;
  }
  function nf(...i59) {
    let t = {};
    for (let e of i59) for (let n in e) e.hasOwnProperty(n) && (t[n] = true);
    return t;
  }
  var wA = ca("area,br,col,hr,img,wbr");
  var CA = ca("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");
  var SA = ca("rp,rt");
  var f8 = nf(SA, CA);
  var m8 = nf(CA, ca("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"));
  var g8 = nf(SA, ca("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"));
  var IR = nf(wA, m8, g8, f8);
  var MA = ca("background,cite,href,itemtype,longdesc,poster,src,xlink:href");
  var _8 = ca("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width");
  var v8 = ca("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext");
  var y8 = nf(MA, _8, v8);
  var b8 = ca("script,style,template");
  var QC = class {
    sanitizedSomething = false;
    buf = [];
    sanitizeChildren(t) {
      let e = t.firstChild, n = true, r = [];
      for (; e; ) {
        if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = true, n && e.firstChild) {
          r.push(e), e = C8(e);
          continue;
        }
        for (; e; ) {
          e.nodeType === Node.ELEMENT_NODE && this.endElement(e);
          let o = w8(e);
          if (o) {
            e = o;
            break;
          }
          e = r.pop();
        }
      }
      return this.buf.join("");
    }
    startElement(t) {
      let e = DR(t).toLowerCase();
      if (!IR.hasOwnProperty(e)) return this.sanitizedSomething = true, !b8.hasOwnProperty(e);
      this.buf.push("<"), this.buf.push(e);
      let n = t.attributes;
      for (let r = 0; r < n.length; r++) {
        let o = n.item(r), s = o.name, a = s.toLowerCase();
        if (!y8.hasOwnProperty(a)) {
          this.sanitizedSomething = true;
          continue;
        }
        let l = o.value;
        MA[a] && (l = Fv(l)), this.buf.push(" ", s, '="', PR(l), '"');
      }
      return this.buf.push(">"), true;
    }
    endElement(t) {
      let e = DR(t).toLowerCase();
      IR.hasOwnProperty(e) && !wA.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">"));
    }
    chars(t) {
      this.buf.push(PR(t));
    }
  };
  function x8(i59, t) {
    return (i59.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;
  }
  function w8(i59) {
    let t = i59.nextSibling;
    if (t && i59 !== t.previousSibling) throw EA(t);
    return t;
  }
  function C8(i59) {
    let t = i59.firstChild;
    if (t && x8(i59, t)) throw EA(t);
    return t;
  }
  function DR(i59) {
    let t = i59.nodeName;
    return typeof t == "string" ? t : "FORM";
  }
  function EA(i59) {
    return new Error(`Failed to sanitize html because the element is clobbered: ${i59.outerHTML}`);
  }
  var S8 = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var M8 = /([^\#-~ |!])/g;
  function PR(i59) {
    return i59.replace(/&/g, "&amp;").replace(S8, function(t) {
      let e = t.charCodeAt(0), n = t.charCodeAt(1);
      return "&#" + ((e - 55296) * 1024 + (n - 56320) + 65536) + ";";
    }).replace(M8, function(t) {
      return "&#" + t.charCodeAt(0) + ";";
    }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  var V_;
  function TA(i59, t) {
    let e = null;
    try {
      V_ = V_ || u8(i59);
      let n = t ? String(t) : "";
      e = V_.getInertBodyElement(n);
      let r = 5, o = n;
      do {
        if (r === 0) throw new Error("Failed to sanitize html because the input is unstable");
        r--, n = o, o = e.innerHTML, e = V_.getInertBodyElement(n);
      } while (n !== o);
      let a = new QC().sanitizeChildren(RR(e) || e);
      return Lv(a);
    } finally {
      if (e) {
        let n = RR(e) || e;
        for (; n.firstChild; ) n.firstChild.remove();
      }
    }
  }
  function RR(i59) {
    return "content" in i59 && E8(i59) ? i59.content : null;
  }
  function E8(i59) {
    return i59.nodeType === Node.ELEMENT_NODE && i59.nodeName === "TEMPLATE";
  }
  var Dr = function(i59) {
    return i59[i59.NONE = 0] = "NONE", i59[i59.HTML = 1] = "HTML", i59[i59.STYLE = 2] = "STYLE", i59[i59.SCRIPT = 3] = "SCRIPT", i59[i59.URL = 4] = "URL", i59[i59.RESOURCE_URL = 5] = "RESOURCE_URL", i59;
  }(Dr || {});
  function tM(i59) {
    let t = T8();
    return t ? t.sanitize(Dr.URL, i59) || "" : yc(i59, "URL") ? Cs(i59) : Fv(ms(i59));
  }
  function T8() {
    let i59 = Ft();
    return i59 && i59[na].sanitizer;
  }
  var I8 = /^>|^->|<!--|-->|--!>|<!-$/g;
  var D8 = /(<|>)/g;
  var P8 = "\u200B$1\u200B";
  function R8(i59) {
    return i59.replace(I8, (t) => t.replace(D8, P8));
  }
  function Bv(i59) {
    return i59.ownerDocument;
  }
  function O8(i59, t, e) {
    let n = i59.length;
    for (; ; ) {
      let r = i59.indexOf(t, e);
      if (r === -1) return r;
      if (r === 0 || i59.charCodeAt(r - 1) <= 32) {
        let o = t.length;
        if (r + o === n || i59.charCodeAt(r + o) <= 32) return r;
      }
      e = r + 1;
    }
  }
  var IA = "ng-template";
  function A8(i59, t, e, n) {
    let r = 0;
    if (n) {
      for (; r < t.length && typeof t[r] == "string"; r += 2) if (t[r] === "class" && O8(t[r + 1].toLowerCase(), e, 0) !== -1) return true;
    } else if (nM(i59)) return false;
    if (r = t.indexOf(1, r), r > -1) {
      let o;
      for (; ++r < t.length && typeof (o = t[r]) == "string"; ) if (o.toLowerCase() === e) return true;
    }
    return false;
  }
  function nM(i59) {
    return i59.type === 4 && i59.value !== IA;
  }
  function N8(i59, t, e) {
    let n = i59.type === 4 && !e ? IA : i59.value;
    return t === n;
  }
  function k8(i59, t, e) {
    let n = 4, r = i59.attrs, o = r !== null ? B8(r) : 0, s = false;
    for (let a = 0; a < t.length; a++) {
      let l = t[a];
      if (typeof l == "number") {
        if (!s && !qo(n) && !qo(l)) return false;
        if (s && qo(l)) continue;
        s = false, n = l | n & 1;
        continue;
      }
      if (!s) if (n & 4) {
        if (n = 2 | n & 1, l !== "" && !N8(i59, l, e) || l === "" && t.length === 1) {
          if (qo(n)) return false;
          s = true;
        }
      } else if (n & 8) {
        if (r === null || !A8(i59, r, l, e)) {
          if (qo(n)) return false;
          s = true;
        }
      } else {
        let c = t[++a], d = L8(l, r, nM(i59), e);
        if (d === -1) {
          if (qo(n)) return false;
          s = true;
          continue;
        }
        if (c !== "") {
          let u;
          if (d > o ? u = "" : u = r[d + 1].toLowerCase(), n & 2 && c !== u) {
            if (qo(n)) return false;
            s = true;
          }
        }
      }
    }
    return qo(n) || s;
  }
  function qo(i59) {
    return (i59 & 1) === 0;
  }
  function L8(i59, t, e, n) {
    if (t === null) return -1;
    let r = 0;
    if (n || !e) {
      let o = false;
      for (; r < t.length; ) {
        let s = t[r];
        if (s === i59) return r;
        if (s === 3 || s === 6) o = true;
        else if (s === 1 || s === 2) {
          let a = t[++r];
          for (; typeof a == "string"; ) a = t[++r];
          continue;
        } else {
          if (s === 4) break;
          if (s === 0) {
            r += 4;
            continue;
          }
        }
        r += o ? 1 : 2;
      }
      return -1;
    } else return V8(t, i59);
  }
  function DA(i59, t, e = false) {
    for (let n = 0; n < t.length; n++) if (k8(i59, t[n], e)) return true;
    return false;
  }
  function F8(i59) {
    let t = i59.attrs;
    if (t != null) {
      let e = t.indexOf(5);
      if (!(e & 1)) return t[e + 1];
    }
    return null;
  }
  function B8(i59) {
    for (let t = 0; t < i59.length; t++) {
      let e = i59[t];
      if (GO(e)) return t;
    }
    return i59.length;
  }
  function V8(i59, t) {
    let e = i59.indexOf(4);
    if (e > -1) for (e++; e < i59.length; ) {
      let n = i59[e];
      if (typeof n == "number") return -1;
      if (n === t) return e;
      e++;
    }
    return -1;
  }
  function z8(i59, t) {
    e: for (let e = 0; e < t.length; e++) {
      let n = t[e];
      if (i59.length === n.length) {
        for (let r = 0; r < i59.length; r++) if (i59[r] !== n[r]) continue e;
        return true;
      }
    }
    return false;
  }
  function OR(i59, t) {
    return i59 ? ":not(" + t.trim() + ")" : t;
  }
  function U8(i59) {
    let t = i59[0], e = 1, n = 2, r = "", o = false;
    for (; e < i59.length; ) {
      let s = i59[e];
      if (typeof s == "string") if (n & 2) {
        let a = i59[++e];
        r += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]";
      } else n & 8 ? r += "." + s : n & 4 && (r += " " + s);
      else r !== "" && !qo(s) && (t += OR(o, r), r = ""), n = s, o = o || !qo(n);
      e++;
    }
    return r !== "" && (t += OR(o, r)), t;
  }
  function G8(i59) {
    return i59.map(U8).join(",");
  }
  function H8(i59) {
    let t = [], e = [], n = 1, r = 2;
    for (; n < i59.length; ) {
      let o = i59[n];
      if (typeof o == "string") r === 2 ? o !== "" && t.push(o, i59[++n]) : r === 8 && e.push(o);
      else {
        if (!qo(r)) break;
        r = o;
      }
      n++;
    }
    return e.length && t.push(1, ...e), t;
  }
  var jr = {};
  function j8(i59, t) {
    return i59.createText(t);
  }
  function W8(i59, t, e) {
    i59.setValue(t, e);
  }
  function $8(i59, t) {
    return i59.createComment(R8(t));
  }
  function PA(i59, t, e) {
    return i59.createElement(t, e);
  }
  function lv(i59, t, e, n, r) {
    i59.insertBefore(t, e, n, r);
  }
  function RA(i59, t, e) {
    i59.appendChild(t, e);
  }
  function AR(i59, t, e, n, r) {
    n !== null ? lv(i59, t, e, n, r) : RA(i59, t, e);
  }
  function q8(i59, t, e) {
    i59.removeChild(null, t, e);
  }
  function Y8(i59, t, e) {
    i59.setAttribute(t, "style", e);
  }
  function X8(i59, t, e) {
    e === "" ? i59.removeAttribute(t, "class") : i59.setAttribute(t, "class", e);
  }
  function OA(i59, t, e) {
    let { mergedAttrs: n, classes: r, styles: o } = e;
    n !== null && Ej(i59, t, n), r !== null && X8(i59, t, r), o !== null && Y8(i59, t, o);
  }
  function C(i59 = 1) {
    AA(ii(), Ft(), ws() + i59, false);
  }
  function AA(i59, t, e, n) {
    if (!n) if ((t[Ot] & 3) === 3) {
      let o = i59.preOrderCheckHooks;
      o !== null && j_(t, o, e);
    } else {
      let o = i59.preOrderHooks;
      o !== null && W_(t, o, 0, e);
    }
    cc(e);
  }
  var Ka = function(i59) {
    return i59[i59.None = 0] = "None", i59[i59.SignalBased = 1] = "SignalBased", i59[i59.HasDecoratorInputTransform = 2] = "HasDecoratorInputTransform", i59;
  }(Ka || {});
  function NA(i59, t, e, n, r, o) {
    let s = Ht(null);
    try {
      let a = null;
      r & Ka.SignalBased && (a = t[n][lr]), a !== null && a.transformFn !== void 0 && (o = a.transformFn(o)), r & Ka.HasDecoratorInputTransform && (o = i59.inputTransforms[n].call(t, o)), i59.setInput !== null ? i59.setInput(t, a, o, e, n) : xO(t, a, n, o);
    } finally {
      Ht(s);
    }
  }
  function iM(i59, t, e, n, r, o, s, a, l, c, d) {
    let u = t.blueprint.slice();
    return u[xs] = r, u[Ot] = n | 4 | 128 | 8 | 64 | 1024, (c !== null || i59 && i59[Ot] & 2048) && (u[Ot] |= 2048), TO(u), u[ur] = u[_u] = i59, u[qi] = e, u[na] = s || i59 && i59[na], u[ti] = a || i59 && i59[ti], u[Up] = l || i59 && i59[Up] || null, u[Hr] = o, u[Ev] = Kj(), u[uu] = d, u[bO] = c, u[eo] = t.type == 2 ? i59[eo] : u, u;
  }
  function kA(i59, t, e, n, r) {
    let o = ws(), s = n & 2;
    try {
      cc(-1), s && t.length > hr && AA(i59, t, hr, false), bo(s ? 2 : 0, r), e(n, r);
    } finally {
      cc(o), bo(s ? 3 : 1, r);
    }
  }
  function rM(i59, t, e) {
    Dv() && (vc(Zo(e, t), t), LA(i59, t, e));
  }
  function LA(i59, t, e) {
    iW(i59, t, e), (e.flags & 64) === 64 && rW(i59, t, e);
  }
  function oM(i59, t, e = Zo) {
    let n = t.localNames;
    if (n !== null) {
      let r = t.index + 1;
      for (let o = 0; o < n.length; o += 2) {
        let s = n[o + 1], a = s === -1 ? e(t, i59) : i59[s];
        i59[r++] = a;
      }
    }
  }
  function Z8(i59) {
    let t = i59.tView;
    return t === null || t.incompleteFirstPass ? i59.tView = sM(1, null, i59.template, i59.decls, i59.vars, i59.directiveDefs, i59.pipeDefs, i59.viewQuery, i59.schemas, i59.consts, i59.id) : t;
  }
  function sM(i59, t, e, n, r, o, s, a, l, c, d) {
    let u = hr + n, h = u + r, p = Q8(u, h), f = typeof c == "function" ? c() : c;
    return p[Gt] = { type: i59, blueprint: p, template: e, queries: null, viewQuery: a, declTNode: t, data: p.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: true, firstUpdatePass: true, staticViewQueries: false, staticContentQueries: false, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: typeof o == "function" ? o() : o, pipeRegistry: typeof s == "function" ? s() : s, firstChild: null, schemas: l, consts: f, incompleteFirstPass: false, ssrId: d };
  }
  function Q8(i59, t) {
    let e = [];
    for (let n = 0; n < t; n++) e.push(n < i59 ? null : jr);
    return e;
  }
  function K8(i59, t, e, n) {
    let o = n.get(r8, hA) || e === bs.ShadowDom, s = i59.selectRootElement(t, o);
    return J8(s), s;
  }
  function J8(i59) {
    eW(i59);
  }
  var eW = () => null;
  function tW(i59) {
    return i59 === "class" ? "className" : i59 === "for" ? "htmlFor" : i59 === "formaction" ? "formAction" : i59 === "innerHtml" ? "innerHTML" : i59 === "readonly" ? "readOnly" : i59 === "tabindex" ? "tabIndex" : i59;
  }
  function aM(i59, t, e, n, r, o, s, a) {
    let l = Zo(t, e), c = t.inputs, d;
    !a && c != null && (d = c[n]) ? (dM(i59, e, d, n, r), fc(t) && nW(e, t.index)) : t.type & 3 ? (n = tW(n), r = s != null ? s(r, t.value || "", n) : r, o.setProperty(l, n, r)) : t.type & 12;
  }
  function nW(i59, t) {
    let e = ys(t, i59);
    e[Ot] & 16 || (e[Ot] |= 64);
  }
  function iW(i59, t, e) {
    let n = e.directiveStart, r = e.directiveEnd;
    fc(e) && sW(t, e, i59.data[n + e.componentOffset]), i59.firstCreatePass || ov(e, t);
    let o = e.initialInputs;
    for (let s = n; s < r; s++) {
      let a = i59.data[s], l = Hp(t, i59, s, e);
      if (vc(l, t), o !== null && cW(t, s - n, l, a, e, o), _s(a)) {
        let c = ys(e.index, t);
        c[qi] = Hp(t, i59, s, e);
      }
    }
  }
  function rW(i59, t, e) {
    let n = e.directiveStart, r = e.directiveEnd, o = e.index, s = gj();
    try {
      cc(o);
      for (let a = n; a < r; a++) {
        let l = i59.data[a], c = t[a];
        RC(a), (l.hostBindings !== null || l.hostVars !== 0 || l.hostAttrs !== null) && oW(l, c);
      }
    } finally {
      cc(-1), RC(s);
    }
  }
  function oW(i59, t) {
    i59.hostBindings !== null && i59.hostBindings(1, t);
  }
  function lM(i59, t) {
    let e = i59.directiveRegistry, n = null;
    if (e) for (let r = 0; r < e.length; r++) {
      let o = e[r];
      DA(t, o.selectors, false) && (n ??= [], _s(o) ? n.unshift(o) : n.push(o));
    }
    return n;
  }
  function FA(i59) {
    let t = 16;
    return i59.signals ? t = 4096 : i59.onPush && (t = 64), t;
  }
  function sW(i59, t, e) {
    let n = Zo(t, i59), r = Z8(e), o = i59[na].rendererFactory, s = cM(i59, iM(i59, r, null, FA(e), n, t, null, o.createRenderer(n, e), null, null, null));
    return i59[t.index] = s;
  }
  function aW(i59, t, e, n, r, o) {
    let s = Zo(i59, t);
    lW(t[ti], s, o, i59.value, e, n, r);
  }
  function lW(i59, t, e, n, r, o, s) {
    if (o == null) i59.removeAttribute(t, r, e);
    else {
      let a = s == null ? ms(o) : s(o, n || "", r);
      i59.setAttribute(t, r, a, e);
    }
  }
  function cW(i59, t, e, n, r, o) {
    let s = o[t];
    if (s !== null) for (let a = 0; a < s.length; ) {
      let l = s[a++], c = s[a++], d = s[a++], u = s[a++];
      NA(n, e, l, c, d, u);
    }
  }
  function BA(i59, t, e, n) {
    return [i59, true, 0, t, null, n, null, e, null, null];
  }
  function cM(i59, t) {
    return i59[Gp] ? i59[fR][Xo] = t : i59[Gp] = t, i59[fR] = t, t;
  }
  function VA(i59, t, e) {
    return (i59 === null || _s(i59)) && (e = K5(e[t.index])), e[ti];
  }
  function zA(i59, t) {
    let e = i59[Up], n = e ? e.get(Ir, null) : null;
    n && n.handleError(t);
  }
  function dM(i59, t, e, n, r) {
    for (let o = 0; o < e.length; ) {
      let s = e[o++], a = e[o++], l = e[o++], c = t[s], d = i59.data[s];
      NA(d, c, n, a, l, r);
    }
  }
  function dW(i59, t) {
    let e = ys(t, i59), n = e[Gt];
    uW(n, e);
    let r = e[xs];
    r !== null && e[uu] === null && (e[uu] = mA(r, e[Up])), uM(n, e, e[qi]);
  }
  function uW(i59, t) {
    for (let e = t.length; e < i59.blueprint.length; e++) t.push(i59.blueprint[e]);
  }
  function uM(i59, t, e) {
    WS(t);
    try {
      let n = i59.viewQuery;
      n !== null && HC(1, n, e);
      let r = i59.template;
      r !== null && kA(i59, t, r, 1, e), i59.firstCreatePass && (i59.firstCreatePass = false), t[ia]?.finishViewCreation(i59), i59.staticContentQueries && gA(i59, t), i59.staticViewQueries && HC(2, i59.viewQuery, e);
      let o = i59.components;
      o !== null && hW(t, o);
    } catch (n) {
      throw i59.firstCreatePass && (i59.incompleteFirstPass = true, i59.firstCreatePass = false), n;
    } finally {
      t[Ot] &= -5, $S();
    }
  }
  function hW(i59, t) {
    for (let e = 0; e < t.length; e++) dW(i59, t[e]);
  }
  var sa = function(i59) {
    return i59[i59.Important = 1] = "Important", i59[i59.DashCase = 2] = "DashCase", i59;
  }(sa || {});
  var pW;
  function hM(i59, t) {
    return pW(i59, t);
  }
  function pM(i59) {
    return (i59.flags & 32) === 32;
  }
  function su(i59, t, e, n, r) {
    if (n != null) {
      let o, s = false;
      la(n) ? o = n : Za(n) && (s = true, n = n[xs]);
      let a = vs(n);
      i59 === 0 && e !== null ? r == null ? RA(t, e, a) : lv(t, e, a, r || null, true) : i59 === 1 && e !== null ? lv(t, e, a, r || null, true) : i59 === 2 ? q8(t, a, s) : i59 === 3 && t.destroyNode(a), o != null && SW(t, i59, o, e, r);
    }
  }
  function fW(i59, t) {
    UA(i59, t), t[xs] = null, t[Hr] = null;
  }
  function mW(i59, t, e, n, r, o) {
    n[xs] = r, n[Hr] = t, Uv(i59, n, e, 1, r, o);
  }
  function UA(i59, t) {
    t[na].changeDetectionScheduler?.notify(10), Uv(i59, t, t[ti], 2, null, null);
  }
  function gW(i59) {
    let t = i59[Gp];
    if (!t) return pC(i59[Gt], i59);
    for (; t; ) {
      let e = null;
      if (Za(t)) e = t[Gp];
      else {
        let n = t[dr];
        n && (e = n);
      }
      if (!e) {
        for (; t && !t[Xo] && t !== i59; ) Za(t) && pC(t[Gt], t), t = t[ur];
        t === null && (t = i59), Za(t) && pC(t[Gt], t), e = t && t[Xo];
      }
      t = e;
    }
  }
  function _W(i59, t, e, n) {
    let r = dr + n, o = e.length;
    n > 0 && (e[r - 1][Xo] = t), n < o - dr ? (t[Xo] = e[r], uO(e, dr + n, t)) : (e.push(t), t[Xo] = null), t[ur] = e;
    let s = t[oc];
    s !== null && e !== s && GA(s, t);
    let a = t[ia];
    a !== null && a.insertView(i59), DC(t), t[Ot] |= 128;
  }
  function GA(i59, t) {
    let e = i59[hu], n = t[ur];
    if (Za(n)) i59[Ot] |= 2;
    else {
      let r = n[ur][eo];
      t[eo] !== r && (i59[Ot] |= 2);
    }
    e === null ? i59[hu] = [t] : e.push(t);
  }
  function fM(i59, t) {
    let e = i59[hu], n = e.indexOf(t);
    e.splice(n, 1);
  }
  function Wp(i59, t) {
    if (i59.length <= dr) return;
    let e = dr + t, n = i59[e];
    if (n) {
      let r = n[oc];
      r !== null && r !== i59 && fM(r, n), t > 0 && (i59[e - 1][Xo] = n[Xo]);
      let o = Q_(i59, dr + t);
      fW(n[Gt], n);
      let s = o[ia];
      s !== null && s.detachView(o[Gt]), n[ur] = null, n[Xo] = null, n[Ot] &= -129;
    }
    return n;
  }
  function Vv(i59, t) {
    if (Zp(t)) return;
    let e = t[ti];
    e.destroyNode && Uv(i59, t, e, 3, null, null), gW(t);
  }
  function pC(i59, t) {
    if (Zp(t)) return;
    let e = Ht(null);
    try {
      t[Ot] &= -129, t[Ot] |= 256, t[Kr] && $d(t[Kr]), yW(i59, t), vW(i59, t), t[Gt].type === 1 && t[ti].destroy();
      let n = t[oc];
      if (n !== null && la(t[ur])) {
        n !== t[ur] && fM(n, t);
        let r = t[ia];
        r !== null && r.detachView(i59);
      }
      zC(t);
    } finally {
      Ht(e);
    }
  }
  function vW(i59, t) {
    let e = i59.cleanup, n = t[J_];
    if (e !== null) for (let s = 0; s < e.length - 1; s += 2) if (typeof e[s] == "string") {
      let a = e[s + 3];
      a >= 0 ? n[a]() : n[-a].unsubscribe(), s += 2;
    } else {
      let a = n[e[s + 1]];
      e[s].call(a);
    }
    n !== null && (t[J_] = null);
    let r = t[Xa];
    if (r !== null) {
      t[Xa] = null;
      for (let s = 0; s < r.length; s++) {
        let a = r[s];
        a();
      }
    }
    let o = t[sc];
    if (o !== null) {
      t[sc] = null;
      for (let s of o) s.destroy();
    }
  }
  function yW(i59, t) {
    let e;
    if (i59 != null && (e = i59.destroyHooks) != null) for (let n = 0; n < e.length; n += 2) {
      let r = t[e[n]];
      if (!(r instanceof dc)) {
        let o = e[n + 1];
        if (Array.isArray(o)) for (let s = 0; s < o.length; s += 2) {
          let a = r[o[s]], l = o[s + 1];
          bo(4, a, l);
          try {
            l.call(a);
          } finally {
            bo(5, a, l);
          }
        }
        else {
          bo(4, r, o);
          try {
            o.call(r);
          } finally {
            bo(5, r, o);
          }
        }
      }
    }
  }
  function HA(i59, t, e) {
    return bW(i59, t.parent, e);
  }
  function bW(i59, t, e) {
    let n = t;
    for (; n !== null && n.type & 168; ) t = n, n = t.parent;
    if (n === null) return e[xs];
    if (fc(n)) {
      let { encapsulation: r } = i59.data[n.directiveStart + n.componentOffset];
      if (r === bs.None || r === bs.Emulated) return null;
    }
    return Zo(n, e);
  }
  function jA(i59, t, e) {
    return wW(i59, t, e);
  }
  function xW(i59, t, e) {
    return i59.type & 40 ? Zo(i59, e) : null;
  }
  var wW = xW;
  var NR;
  function zv(i59, t, e, n) {
    let r = HA(i59, n, t), o = t[ti], s = n.parent || t[Hr], a = jA(s, n, t);
    if (r != null) if (Array.isArray(e)) for (let l = 0; l < e.length; l++) AR(o, r, e[l], a, false);
    else AR(o, r, e, a, false);
    NR !== void 0 && NR(o, n, t, e, r);
  }
  function Lp(i59, t) {
    if (t !== null) {
      let e = t.type;
      if (e & 3) return Zo(t, i59);
      if (e & 4) return KC(-1, i59[t.index]);
      if (e & 8) {
        let n = t.child;
        if (n !== null) return Lp(i59, n);
        {
          let r = i59[t.index];
          return la(r) ? KC(-1, r) : vs(r);
        }
      } else {
        if (e & 128) return Lp(i59, t.next);
        if (e & 32) return hM(t, i59)() || vs(i59[t.index]);
        {
          let n = WA(i59, t);
          if (n !== null) {
            if (Array.isArray(n)) return n[0];
            let r = lc(i59[eo]);
            return Lp(r, n);
          } else return Lp(i59, t.next);
        }
      }
    }
    return null;
  }
  function WA(i59, t) {
    if (t !== null) {
      let n = i59[eo][Hr], r = t.projection;
      return n.projection[r];
    }
    return null;
  }
  function KC(i59, t) {
    let e = dr + i59 + 1;
    if (e < t.length) {
      let n = t[e], r = n[Gt].firstChild;
      if (r !== null) return Lp(n, r);
    }
    return t[ac];
  }
  function mM(i59, t, e, n, r, o, s) {
    for (; e != null; ) {
      if (e.type === 128) {
        e = e.next;
        continue;
      }
      let a = n[e.index], l = e.type;
      if (s && t === 0 && (a && vc(vs(a), n), e.flags |= 2), !pM(e)) if (l & 8) mM(i59, t, e.child, n, r, o, false), su(t, i59, r, a, o);
      else if (l & 32) {
        let c = hM(e, n), d;
        for (; d = c(); ) su(t, i59, r, d, o);
        su(t, i59, r, a, o);
      } else l & 16 ? $A(i59, t, n, e, r, o) : su(t, i59, r, a, o);
      e = s ? e.projectionNext : e.next;
    }
  }
  function Uv(i59, t, e, n, r, o) {
    mM(e, n, i59.firstChild, t, r, o, false);
  }
  function CW(i59, t, e) {
    let n = t[ti], r = HA(i59, e, t), o = e.parent || t[Hr], s = jA(o, e, t);
    $A(n, 0, t, e, r, s);
  }
  function $A(i59, t, e, n, r, o) {
    let s = e[eo], l = s[Hr].projection[n.projection];
    if (Array.isArray(l)) for (let c = 0; c < l.length; c++) {
      let d = l[c];
      su(t, i59, r, d, o);
    }
    else {
      let c = l, d = s[ur];
      oA(n) && (c.flags |= 128), mM(i59, t, c, d, r, o, true);
    }
  }
  function SW(i59, t, e, n, r) {
    let o = e[ac], s = vs(e);
    o !== s && su(t, i59, n, o, r);
    for (let a = dr; a < e.length; a++) {
      let l = e[a];
      Uv(l[Gt], l, i59, t, n, o);
    }
  }
  function MW(i59, t, e, n, r) {
    if (t) r ? i59.addClass(e, n) : i59.removeClass(e, n);
    else {
      let o = n.indexOf("-") === -1 ? void 0 : sa.DashCase;
      r == null ? i59.removeStyle(e, n, o) : (typeof r == "string" && r.endsWith("!important") && (r = r.slice(0, -10), o |= sa.Important), i59.setStyle(e, n, r, o));
    }
  }
  function rf(i59, t, e, n) {
    let r = Ht(null);
    try {
      let o = t.tView, a = i59[Ot] & 4096 ? 4096 : 16, l = iM(i59, o, e, a, null, t, null, null, n?.injector ?? null, n?.embeddedViewInjector ?? null, n?.dehydratedView ?? null), c = i59[t.index];
      l[oc] = c;
      let d = i59[ia];
      return d !== null && (l[ia] = d.createEmbeddedView(o)), uM(o, l, e), l;
    } finally {
      Ht(r);
    }
  }
  function qA(i59, t) {
    let e = dr + t;
    if (e < i59.length) return i59[e];
  }
  function fu(i59, t) {
    return !t || t.firstChild === null || oA(i59);
  }
  function of(i59, t, e, n = true) {
    let r = t[Gt];
    if (_W(r, t, i59, e), n) {
      let s = KC(e, i59), a = t[ti], l = a.parentNode(i59[ac]);
      l !== null && mW(r, i59[Hr], a, t, l, s);
    }
    let o = t[uu];
    o !== null && o.firstChild !== null && (o.firstChild = null);
  }
  function YA(i59, t) {
    let e = Wp(i59, t);
    return e !== void 0 && Vv(e[Gt], e), e;
  }
  function cv(i59, t, e, n, r = false) {
    for (; e !== null; ) {
      if (e.type === 128) {
        e = r ? e.projectionNext : e.next;
        continue;
      }
      let o = t[e.index];
      o !== null && n.push(vs(o)), la(o) && EW(o, n);
      let s = e.type;
      if (s & 8) cv(i59, t, e.child, n);
      else if (s & 32) {
        let a = hM(e, t), l;
        for (; l = a(); ) n.push(l);
      } else if (s & 16) {
        let a = WA(t, e);
        if (Array.isArray(a)) n.push(...a);
        else {
          let l = lc(t[eo]);
          cv(l[Gt], l, a, n, true);
        }
      }
      e = r ? e.projectionNext : e.next;
    }
    return n;
  }
  function EW(i59, t) {
    for (let e = dr; e < i59.length; e++) {
      let n = i59[e], r = n[Gt].firstChild;
      r !== null && cv(n[Gt], n, r, t);
    }
    i59[ac] !== i59[xs] && t.push(i59[ac]);
  }
  var XA = [];
  function TW(i59) {
    return i59[Kr] ?? IW(i59);
  }
  function IW(i59) {
    let t = XA.pop() ?? Object.create(PW);
    return t.lView = i59, t;
  }
  function DW(i59) {
    i59.lView[Kr] !== i59 && (i59.lView = null, XA.push(i59));
  }
  var PW = xt(le({}, Xl), { consumerIsAlwaysLive: true, kind: "template", consumerMarkedDirty: (i59) => {
    Qp(i59.lView);
  }, consumerOnSignalRead() {
    this.lView[Kr] = this;
  } });
  function RW(i59) {
    let t = i59[Kr] ?? Object.create(OW);
    return t.lView = i59, t;
  }
  var OW = xt(le({}, Xl), { consumerIsAlwaysLive: true, kind: "template", consumerMarkedDirty: (i59) => {
    let t = lc(i59.lView);
    for (; t && !ZA(t[Gt]); ) t = lc(t);
    t && zS(t);
  }, consumerOnSignalRead() {
    this.lView[Kr] = this;
  } });
  function ZA(i59) {
    return i59.type !== 2;
  }
  function QA(i59) {
    if (i59[sc] === null) return;
    let t = true;
    for (; t; ) {
      let e = false;
      for (let n of i59[sc]) n.dirty && (e = true, n.zone === null || Zone.current === n.zone ? n.run() : n.zone.run(() => n.run()));
      t = e && !!(i59[Ot] & 8192);
    }
  }
  var AW = 100;
  function KA(i59, t = true, e = 0) {
    let r = i59[na].rendererFactory, o = false;
    o || r.begin?.();
    try {
      NW(i59, e);
    } catch (s) {
      throw t && zA(i59, s), s;
    } finally {
      o || r.end?.();
    }
  }
  function NW(i59, t) {
    let e = AO();
    try {
      nv(true), JC(i59, t);
      let n = 0;
      for (; Iv(i59); ) {
        if (n === AW) throw new ze(103, false);
        n++, JC(i59, 1);
      }
    } finally {
      nv(e);
    }
  }
  function kW(i59, t, e, n) {
    if (Zp(t)) return;
    let r = t[Ot], o = false, s = false;
    WS(t);
    let a = true, l = null, c = null;
    o || (ZA(i59) ? (c = TW(t), l = Wd(c)) : xP() === null ? (a = false, c = RW(t), l = Wd(c)) : t[Kr] && ($d(t[Kr]), t[Kr] = null));
    try {
      TO(t), pj(i59.bindingStartIndex), e !== null && kA(i59, t, e, 2, n);
      let d = (r & 3) === 3;
      if (!o) if (d) {
        let p = i59.preOrderCheckHooks;
        p !== null && j_(t, p, null);
      } else {
        let p = i59.preOrderHooks;
        p !== null && W_(t, p, 0, null), dC(t, 0);
      }
      if (s || LW(t), QA(t), JA(t, 0), i59.contentQueries !== null && gA(i59, t), !o) if (d) {
        let p = i59.contentCheckHooks;
        p !== null && j_(t, p);
      } else {
        let p = i59.contentHooks;
        p !== null && W_(t, p, 1), dC(t, 1);
      }
      BW(i59, t);
      let u = i59.components;
      u !== null && tN(t, u, 0);
      let h = i59.viewQuery;
      if (h !== null && HC(2, h, n), !o) if (d) {
        let p = i59.viewCheckHooks;
        p !== null && j_(t, p);
      } else {
        let p = i59.viewHooks;
        p !== null && W_(t, p, 2), dC(t, 2);
      }
      if (i59.firstUpdatePass === true && (i59.firstUpdatePass = false), t[H_]) {
        for (let p of t[H_]) p();
        t[H_] = null;
      }
      o || (t[Ot] &= -73);
    } catch (d) {
      throw o || Qp(t), d;
    } finally {
      c !== null && (Sp(c, l), a && DW(c)), $S();
    }
  }
  function JA(i59, t) {
    for (let e = lA(i59); e !== null; e = cA(e)) for (let n = dr; n < e.length; n++) {
      let r = e[n];
      eN(r, t);
    }
  }
  function LW(i59) {
    for (let t = lA(i59); t !== null; t = cA(t)) {
      if (!(t[Ot] & 2)) continue;
      let e = t[hu];
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        zS(r);
      }
    }
  }
  function FW(i59, t, e) {
    let n = ys(t, i59);
    eN(n, e);
  }
  function eN(i59, t) {
    VS(i59) && JC(i59, t);
  }
  function JC(i59, t) {
    let n = i59[Gt], r = i59[Ot], o = i59[Kr], s = !!(t === 0 && r & 16);
    if (s ||= !!(r & 64 && t === 0), s ||= !!(r & 1024), s ||= !!(o?.dirty && Mp(o)), s ||= false, o && (o.dirty = false), i59[Ot] &= -9217, s) kW(n, i59, n.template, i59[qi]);
    else if (r & 8192) {
      QA(i59), JA(i59, 1);
      let a = n.components;
      a !== null && tN(i59, a, 1);
    }
  }
  function tN(i59, t, e) {
    for (let n = 0; n < t.length; n++) FW(i59, t[n], e);
  }
  function BW(i59, t) {
    let e = i59.hostBindingOpCodes;
    if (e !== null) try {
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        if (r < 0) cc(~r);
        else {
          let o = r, s = e[++n], a = e[++n];
          mj(s, o);
          let l = t[o];
          bo(24, l), a(2, l), bo(25, l);
        }
      }
    } finally {
      cc(-1);
    }
  }
  function gM(i59, t) {
    let e = AO() ? 64 : 1088;
    for (i59[na].changeDetectionScheduler?.notify(t); i59; ) {
      i59[Ot] |= e;
      let n = lc(i59);
      if (tv(i59) && !n) return i59;
      i59 = n;
    }
    return null;
  }
  var uc = class {
    _lView;
    _cdRefInjectingView;
    notifyErrorHandler;
    _appRef = null;
    _attachedToViewContainer = false;
    get rootNodes() {
      let t = this._lView, e = t[Gt];
      return cv(e, t, e.firstChild, []);
    }
    constructor(t, e, n = true) {
      this._lView = t, this._cdRefInjectingView = e, this.notifyErrorHandler = n;
    }
    get context() {
      return this._lView[qi];
    }
    get dirty() {
      return !!(this._lView[Ot] & 9280) || !!this._lView[Kr]?.dirty;
    }
    set context(t) {
      this._lView[qi] = t;
    }
    get destroyed() {
      return Zp(this._lView);
    }
    destroy() {
      if (this._appRef) this._appRef.detachView(this);
      else if (this._attachedToViewContainer) {
        let t = this._lView[ur];
        if (la(t)) {
          let e = t[ev], n = e ? e.indexOf(this) : -1;
          n > -1 && (Wp(t, n), Q_(e, n));
        }
        this._attachedToViewContainer = false;
      }
      Vv(this._lView[Gt], this._lView);
    }
    onDestroy(t) {
      IO(this._lView, t);
    }
    markForCheck() {
      gM(this._cdRefInjectingView || this._lView, 4);
    }
    markForRefresh() {
      zS(this._cdRefInjectingView || this._lView);
    }
    detach() {
      this._lView[Ot] &= -129;
    }
    reattach() {
      DC(this._lView), this._lView[Ot] |= 128;
    }
    detectChanges() {
      this._lView[Ot] |= 1024, KA(this._lView, this.notifyErrorHandler);
    }
    checkNoChanges() {
    }
    attachToViewContainerRef() {
      if (this._appRef) throw new ze(902, false);
      this._attachedToViewContainer = true;
    }
    detachFromAppRef() {
      this._appRef = null;
      let t = tv(this._lView), e = this._lView[oc];
      e !== null && !t && fM(e, this._lView), UA(this._lView[Gt], this._lView);
    }
    attachToAppRef(t) {
      if (this._attachedToViewContainer) throw new ze(902, false);
      this._appRef = t;
      let e = tv(this._lView), n = this._lView[oc];
      n !== null && !e && GA(n, this._lView), DC(this._lView);
    }
  };
  var ni = /* @__PURE__ */ (() => {
    class i59 {
      static __NG_ELEMENT_ID__ = UW;
    }
    return i59;
  })();
  var VW = ni;
  var zW = class extends VW {
    _declarationLView;
    _declarationTContainer;
    elementRef;
    constructor(t, e, n) {
      super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = n;
    }
    get ssrId() {
      return this._declarationTContainer.tView?.ssrId || null;
    }
    createEmbeddedView(t, e) {
      return this.createEmbeddedViewImpl(t, e);
    }
    createEmbeddedViewImpl(t, e, n) {
      let r = rf(this._declarationLView, this._declarationTContainer, t, { embeddedViewInjector: e, dehydratedView: n });
      return new uc(r);
    }
  };
  function UW() {
    return Gv(fr(), Ft());
  }
  function Gv(i59, t) {
    return i59.type & 4 ? new zW(t, i59, yu(i59, t)) : null;
  }
  function sf(i59, t, e, n, r) {
    let o = i59.data[t];
    if (o === null) o = GW(i59, t, e, n, r), fj() && (o.flags |= 32);
    else if (o.type & 64) {
      o.type = e, o.value = n, o.attrs = r;
      let s = dj();
      o.injectorIndex = s === null ? -1 : s.injectorIndex;
    }
    return mc(o, true), o;
  }
  function GW(i59, t, e, n, r) {
    let o = OO(), s = US(), a = s ? o : o && o.parent, l = i59.data[t] = jW(i59, a, e, t, n, r);
    return HW(i59, l, o, s), l;
  }
  function HW(i59, t, e, n) {
    i59.firstChild === null && (i59.firstChild = t), e !== null && (n ? e.child == null && t.parent !== null && (e.child = t) : e.next === null && (e.next = t, t.prev = e));
  }
  function jW(i59, t, e, n, r, o) {
    let s = t ? t.injectorIndex : -1, a = 0;
    return RO() && (a |= 128), { type: e, index: n, insertBeforeIndex: null, injectorIndex: s, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: a, providerIndexes: 0, value: r, attrs: o, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 };
  }
  var Mxe = new RegExp(`^(\\d+)*(${i8}|${n8})*(.*)`);
  var WW = () => null;
  function mu(i59, t) {
    return WW(i59, t);
  }
  var eS = class {
  };
  var dv = class {
  };
  var tS = class {
    resolveComponentFactory(t) {
      throw Error(`No component factory found for ${Qr(t)}.`);
    }
  };
  var Ja = class {
    static NULL = new tS();
  };
  var pr = class {
  };
  var Pr = /* @__PURE__ */ (() => {
    class i59 {
      destroyNode = null;
      static __NG_ELEMENT_ID__ = () => $W();
    }
    return i59;
  })();
  function $W() {
    let i59 = Ft(), t = fr(), e = ys(t.index, i59);
    return (Za(e) ? e : i59)[ti];
  }
  var qW = (() => {
    class i59 {
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => null });
    }
    return i59;
  })();
  function nS(i59, t, e) {
    let n = e ? i59.styles : null, r = e ? i59.classes : null, o = 0;
    if (t !== null) for (let s = 0; s < t.length; s++) {
      let a = t[s];
      if (typeof a == "number") o = a;
      else if (o == 1) r = xC(r, a);
      else if (o == 2) {
        let l = a, c = t[++s];
        n = xC(n, l + ": " + c + ";");
      }
    }
    e ? i59.styles = n : i59.stylesWithoutHost = n, e ? i59.classes = r : i59.classesWithoutHost = r;
  }
  function K(i59, t = rn.Default) {
    let e = Ft();
    if (e === null) return Ze(i59, t);
    let n = fr();
    return XO(n, e, $i(i59), t);
  }
  function nN(i59, t, e, n) {
    if (e === 0) return -1;
    let r = t.length;
    for (let o = 0; o < e; o++) t.push(n), i59.blueprint.push(n), i59.data.push(null);
    return r;
  }
  function _M(i59, t, e, n, r) {
    let o = n === null ? null : { "": -1 }, s = r(i59, e);
    if (s !== null) {
      let [a, l] = XW(i59, e, s);
      QW(i59, t, e, a, o, l);
    }
    o !== null && n !== null && YW(e, n, o);
  }
  function YW(i59, t, e) {
    let n = i59.localNames = [];
    for (let r = 0; r < t.length; r += 2) {
      let o = e[t[r + 1]];
      if (o == null) throw new ze(-301, false);
      n.push(t[r], o);
    }
  }
  function XW(i59, t, e) {
    let n = [], r = null;
    for (let o of e) o.findHostDirectiveDefs !== null && (r ??= /* @__PURE__ */ new Map(), o.findHostDirectiveDefs(o, n, r)), _s(o) && (n.push(o), ZW(i59, t, n.length - 1));
    return fc(t) ? n.push(...e.slice(1)) : n.push(...e), [n, r];
  }
  function ZW(i59, t, e) {
    t.componentOffset = e, (i59.components ??= []).push(t.index);
  }
  function QW(i59, t, e, n, r, o) {
    for (let c = 0; c < n.length; c++) NC(ov(e, t), i59, n[c].type);
    r6(e, i59.data.length, n.length);
    for (let c = 0; c < n.length; c++) {
      let d = n[c];
      d.providersResolver && d.providersResolver(d);
    }
    let s = false, a = false, l = nN(i59, t, n.length, null);
    for (let c = 0; c < n.length; c++) {
      let d = n[c];
      e.mergedAttrs = pu(e.mergedAttrs, d.hostAttrs), e6(i59, e, t, l, d), i6(l, d, r), d.contentQueries !== null && (e.flags |= 4), (d.hostBindings !== null || d.hostAttrs !== null || d.hostVars !== 0) && (e.flags |= 64);
      let u = d.type.prototype;
      !s && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((i59.preOrderHooks ??= []).push(e.index), s = true), !a && (u.ngOnChanges || u.ngDoCheck) && ((i59.preOrderCheckHooks ??= []).push(e.index), a = true), l++;
    }
    KW(i59, e, o);
  }
  function KW(i59, t, e) {
    let n = t.directiveStart, r = t.directiveEnd, o = i59.data, s = t.attrs, a = [], l = null, c = null;
    for (let d = n; d < r; d++) {
      let u = o[d], h = e ? e.get(u) : null, p = h ? h.inputs : null, f = h ? h.outputs : null;
      l = kR(0, u.inputs, d, l, p), c = kR(1, u.outputs, d, c, f);
      let m = l !== null && s !== null && !nM(t) ? JW(l, d, s) : null;
      a.push(m);
    }
    l !== null && (l.hasOwnProperty("class") && (t.flags |= 8), l.hasOwnProperty("style") && (t.flags |= 16)), t.initialInputs = a, t.inputs = l, t.outputs = c;
  }
  function kR(i59, t, e, n, r) {
    for (let o in t) {
      if (!t.hasOwnProperty(o)) continue;
      let s = t[o];
      if (s === void 0) continue;
      n ??= {};
      let a, l = Ka.None;
      Array.isArray(s) ? (a = s[0], l = s[1]) : a = s;
      let c = o;
      if (r !== null) {
        if (!r.hasOwnProperty(o)) continue;
        c = r[o];
      }
      i59 === 0 ? LR(n, e, c, a, l) : LR(n, e, c, a);
    }
    return n;
  }
  function LR(i59, t, e, n, r) {
    let o;
    i59.hasOwnProperty(e) ? (o = i59[e]).push(t, n) : o = i59[e] = [t, n], r !== void 0 && o.push(r);
  }
  function JW(i59, t, e) {
    let n = null, r = 0;
    for (; r < e.length; ) {
      let o = e[r];
      if (o === 0) {
        r += 4;
        continue;
      } else if (o === 5) {
        r += 2;
        continue;
      }
      if (typeof o == "number") break;
      if (i59.hasOwnProperty(o)) {
        n === null && (n = []);
        let s = i59[o];
        for (let a = 0; a < s.length; a += 3) if (s[a] === t) {
          n.push(o, s[a + 1], s[a + 2], e[r + 1]);
          break;
        }
      }
      r += 2;
    }
    return n;
  }
  function e6(i59, t, e, n, r) {
    i59.data[n] = r;
    let o = r.factory || (r.factory = cu(r.type, true)), s = new dc(o, _s(r), K);
    i59.blueprint[n] = s, e[n] = s, t6(i59, t, n, nN(i59, e, r.hostVars, jr), r);
  }
  function t6(i59, t, e, n, r) {
    let o = r.hostBindings;
    if (o) {
      let s = i59.hostBindingOpCodes;
      s === null && (s = i59.hostBindingOpCodes = []);
      let a = ~t.index;
      n6(s) != a && s.push(a), s.push(e, n, o);
    }
  }
  function n6(i59) {
    let t = i59.length;
    for (; t > 0; ) {
      let e = i59[--t];
      if (typeof e == "number" && e < 0) return e;
    }
    return 0;
  }
  function i6(i59, t, e) {
    if (e) {
      if (t.exportAs) for (let n = 0; n < t.exportAs.length; n++) e[t.exportAs[n]] = i59;
      _s(t) && (e[""] = i59);
    }
  }
  function r6(i59, t, e) {
    i59.flags |= 1, i59.directiveStart = t, i59.directiveEnd = t + e, i59.providerIndexes = t;
  }
  function iN(i59, t, e, n, r, o, s, a) {
    let l = t.consts, c = Qa(l, s), d = sf(t, i59, 2, n, c);
    return o && _M(t, e, d, Qa(l, a), r), d.mergedAttrs = pu(d.mergedAttrs, d.attrs), d.attrs !== null && nS(d, d.attrs, false), d.mergedAttrs !== null && nS(d, d.mergedAttrs, true), t.queries !== null && t.queries.elementStart(t, d), d;
  }
  function rN(i59, t) {
    qS(i59, t), FS(t) && i59.queries.elementEnd(t);
  }
  var iS = class extends Ja {
    ngModule;
    constructor(t) {
      super(), this.ngModule = t;
    }
    resolveComponentFactory(t) {
      let e = rc(t);
      return new $p(e, this.ngModule);
    }
  };
  function FR(i59, t) {
    let e = [];
    for (let n in i59) {
      if (!i59.hasOwnProperty(n)) continue;
      let r = i59[n];
      if (r === void 0) continue;
      let o = Array.isArray(r), s = o ? r[0] : r, a = o ? r[1] : Ka.None;
      t ? e.push({ propName: s, templateName: n, isSignal: (a & Ka.SignalBased) !== 0 }) : e.push({ propName: s, templateName: n });
    }
    return e;
  }
  function o6(i59, t, e) {
    let n = t instanceof Jr ? t : t?.injector;
    return n && i59.getStandaloneInjector !== null && (n = i59.getStandaloneInjector(n) || n), n ? new OC(e, n) : e;
  }
  function s6(i59) {
    let t = i59.get(pr, null);
    if (t === null) throw new ze(407, false);
    let e = i59.get(qW, null), n = i59.get(ra, null);
    return { rendererFactory: t, sanitizer: e, changeDetectionScheduler: n };
  }
  function a6(i59, t) {
    let e = (i59.selectors[0][0] || "div").toLowerCase();
    return PA(t, e, e === "svg" ? MO : e === "math" ? Q5 : null);
  }
  var $p = class extends dv {
    componentDef;
    ngModule;
    selector;
    componentType;
    ngContentSelectors;
    isBoundToModule;
    get inputs() {
      let t = this.componentDef, e = t.inputTransforms, n = FR(t.inputs, true);
      if (e !== null) for (let r of n) e.hasOwnProperty(r.propName) && (r.transform = e[r.propName]);
      return n;
    }
    get outputs() {
      return FR(this.componentDef.outputs, false);
    }
    constructor(t, e) {
      super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = G8(t.selectors), this.ngContentSelectors = t.ngContentSelectors ?? [], this.isBoundToModule = !!e;
    }
    create(t, e, n, r) {
      let o = Ht(null);
      try {
        let s = this.componentDef, a = n ? ["ng-version", "19.1.6"] : H8(this.componentDef.selectors[0]), l = sM(0, null, null, 1, 0, null, null, null, null, [a], null), c = o6(s, r || this.ngModule, t), d = s6(c), u = d.rendererFactory.createRenderer(null, s), h = n ? K8(u, n, s.encapsulation, c) : a6(s, u), p = iM(null, l, null, 512 | FA(s), null, null, d, u, c, null, mA(h, c, true));
        p[hr] = h, WS(p);
        let f = null;
        try {
          let m = iN(hr, l, p, "#host", () => [this.componentDef], true, 0);
          h && (OA(u, h, m), vc(h, p)), LA(l, p, m), eM(l, m, p), rN(l, m), e !== void 0 && l6(m, this.ngContentSelectors, e), f = ys(m.index, p), p[qi] = f[qi], uM(l, p, null);
        } catch (m) {
          throw f !== null && zC(f), zC(p), m;
        } finally {
          $S();
        }
        return new rS(this.componentType, p);
      } finally {
        Ht(o);
      }
    }
  };
  var rS = class extends eS {
    _rootLView;
    instance;
    hostView;
    changeDetectorRef;
    componentType;
    location;
    previousInputValues = null;
    _tNode;
    constructor(t, e) {
      super(), this._rootLView = e, this._tNode = BS(e[Gt], hr), this.location = yu(this._tNode, e), this.instance = ys(this._tNode.index, e)[qi], this.hostView = this.changeDetectorRef = new uc(e, void 0, false), this.componentType = t;
    }
    setInput(t, e) {
      let n = this._tNode.inputs, r;
      if (n !== null && (r = n[t])) {
        if (this.previousInputValues ??= /* @__PURE__ */ new Map(), this.previousInputValues.has(t) && Object.is(this.previousInputValues.get(t), e)) return;
        let o = this._rootLView;
        dM(o[Gt], o, r, t, e), this.previousInputValues.set(t, e);
        let s = ys(this._tNode.index, o);
        gM(s, 1);
      }
    }
    get injector() {
      return new ic(this._tNode, this._rootLView);
    }
    destroy() {
      this.hostView.destroy();
    }
    onDestroy(t) {
      this.hostView.onDestroy(t);
    }
  };
  function l6(i59, t, e) {
    let n = i59.projection = [];
    for (let r = 0; r < t.length; r++) {
      let o = e[r];
      n.push(o != null && o.length ? Array.from(o) : null);
    }
  }
  var un = /* @__PURE__ */ (() => {
    class i59 {
      static __NG_ELEMENT_ID__ = c6;
    }
    return i59;
  })();
  function c6() {
    let i59 = fr();
    return sN(i59, Ft());
  }
  var d6 = un;
  var oN = class extends d6 {
    _lContainer;
    _hostTNode;
    _hostLView;
    constructor(t, e, n) {
      super(), this._lContainer = t, this._hostTNode = e, this._hostLView = n;
    }
    get element() {
      return yu(this._hostTNode, this._hostLView);
    }
    get injector() {
      return new ic(this._hostTNode, this._hostLView);
    }
    get parentInjector() {
      let t = YS(this._hostTNode, this._hostLView);
      if (HO(t)) {
        let e = rv(t, this._hostLView), n = iv(t), r = e[Gt].data[n + 8];
        return new ic(r, e);
      } else return new ic(null, this._hostLView);
    }
    clear() {
      for (; this.length > 0; ) this.remove(this.length - 1);
    }
    get(t) {
      let e = BR(this._lContainer);
      return e !== null && e[t] || null;
    }
    get length() {
      return this._lContainer.length - dr;
    }
    createEmbeddedView(t, e, n) {
      let r, o;
      typeof n == "number" ? r = n : n != null && (r = n.index, o = n.injector);
      let s = mu(this._lContainer, t.ssrId), a = t.createEmbeddedViewImpl(e || {}, o, s);
      return this.insertImpl(a, r, fu(this._hostTNode, s)), a;
    }
    createComponent(t, e, n, r, o) {
      let s = t && !q5(t), a;
      if (s) a = e;
      else {
        let f = e || {};
        a = f.index, n = f.injector, r = f.projectableNodes, o = f.environmentInjector || f.ngModuleRef;
      }
      let l = s ? t : new $p(rc(t)), c = n || this.parentInjector;
      if (!o && l.ngModule == null) {
        let m = (s ? c : this.parentInjector).get(Jr, null);
        m && (o = m);
      }
      let d = rc(l.componentType ?? {}), u = mu(this._lContainer, d?.id ?? null), h = u?.firstChild ?? null, p = l.create(c, r, h, o);
      return this.insertImpl(p.hostView, a, fu(this._hostTNode, u)), p;
    }
    insert(t, e) {
      return this.insertImpl(t, e, true);
    }
    insertImpl(t, e, n) {
      let r = t._lView;
      if (tj(r)) {
        let a = this.indexOf(t);
        if (a !== -1) this.detach(a);
        else {
          let l = r[ur], c = new oN(l, l[Hr], l[ur]);
          c.detach(c.indexOf(t));
        }
      }
      let o = this._adjustIndex(e), s = this._lContainer;
      return of(s, r, o, n), t.attachToViewContainerRef(), uO(fC(s), o, t), t;
    }
    move(t, e) {
      return this.insert(t, e);
    }
    indexOf(t) {
      let e = BR(this._lContainer);
      return e !== null ? e.indexOf(t) : -1;
    }
    remove(t) {
      let e = this._adjustIndex(t, -1), n = Wp(this._lContainer, e);
      n && (Q_(fC(this._lContainer), e), Vv(n[Gt], n));
    }
    detach(t) {
      let e = this._adjustIndex(t, -1), n = Wp(this._lContainer, e);
      return n && Q_(fC(this._lContainer), e) != null ? new uc(n) : null;
    }
    _adjustIndex(t, e = 0) {
      return t ?? this.length + e;
    }
  };
  function BR(i59) {
    return i59[ev];
  }
  function fC(i59) {
    return i59[ev] || (i59[ev] = []);
  }
  function sN(i59, t) {
    let e, n = t[i59.index];
    return la(n) ? e = n : (e = BA(n, t, null, i59), t[i59.index] = e, cM(t, e)), h6(e, t, i59, n), new oN(e, i59, t);
  }
  function u6(i59, t) {
    let e = i59[ti], n = e.createComment(""), r = Zo(t, i59), o = e.parentNode(r);
    return lv(e, o, n, e.nextSibling(r), false), n;
  }
  var h6 = m6;
  var p6 = () => false;
  function f6(i59, t, e) {
    return p6(i59, t, e);
  }
  function m6(i59, t, e, n) {
    if (i59[ac]) return;
    let r;
    e.type & 8 ? r = vs(n) : r = u6(t, e), i59[ac] = r;
  }
  var oS = class i7 {
    queryList;
    matches = null;
    constructor(t) {
      this.queryList = t;
    }
    clone() {
      return new i7(this.queryList);
    }
    setDirty() {
      this.queryList.setDirty();
    }
  };
  var sS = class i9 {
    queries;
    constructor(t = []) {
      this.queries = t;
    }
    createEmbeddedView(t) {
      let e = t.queries;
      if (e !== null) {
        let n = t.contentQueries !== null ? t.contentQueries[0] : e.length, r = [];
        for (let o = 0; o < n; o++) {
          let s = e.getByIndex(o), a = this.queries[s.indexInDeclarationView];
          r.push(a.clone());
        }
        return new i9(r);
      }
      return null;
    }
    insertView(t) {
      this.dirtyQueriesWithMatches(t);
    }
    detachView(t) {
      this.dirtyQueriesWithMatches(t);
    }
    finishViewCreation(t) {
      this.dirtyQueriesWithMatches(t);
    }
    dirtyQueriesWithMatches(t) {
      for (let e = 0; e < this.queries.length; e++) yM(t, e).matches !== null && this.queries[e].setDirty();
    }
  };
  var uv = class {
    flags;
    read;
    predicate;
    constructor(t, e, n = null) {
      this.flags = e, this.read = n, typeof t == "string" ? this.predicate = b6(t) : this.predicate = t;
    }
  };
  var aS = class i10 {
    queries;
    constructor(t = []) {
      this.queries = t;
    }
    elementStart(t, e) {
      for (let n = 0; n < this.queries.length; n++) this.queries[n].elementStart(t, e);
    }
    elementEnd(t) {
      for (let e = 0; e < this.queries.length; e++) this.queries[e].elementEnd(t);
    }
    embeddedTView(t) {
      let e = null;
      for (let n = 0; n < this.length; n++) {
        let r = e !== null ? e.length : 0, o = this.getByIndex(n).embeddedTView(t, r);
        o && (o.indexInDeclarationView = n, e !== null ? e.push(o) : e = [o]);
      }
      return e !== null ? new i10(e) : null;
    }
    template(t, e) {
      for (let n = 0; n < this.queries.length; n++) this.queries[n].template(t, e);
    }
    getByIndex(t) {
      return this.queries[t];
    }
    get length() {
      return this.queries.length;
    }
    track(t) {
      this.queries.push(t);
    }
  };
  var lS = class i11 {
    metadata;
    matches = null;
    indexInDeclarationView = -1;
    crossesNgTemplate = false;
    _declarationNodeIndex;
    _appliesToNextNode = true;
    constructor(t, e = -1) {
      this.metadata = t, this._declarationNodeIndex = e;
    }
    elementStart(t, e) {
      this.isApplyingToNode(e) && this.matchTNode(t, e);
    }
    elementEnd(t) {
      this._declarationNodeIndex === t.index && (this._appliesToNextNode = false);
    }
    template(t, e) {
      this.elementStart(t, e);
    }
    embeddedTView(t, e) {
      return this.isApplyingToNode(t) ? (this.crossesNgTemplate = true, this.addMatch(-t.index, e), new i11(this.metadata)) : null;
    }
    isApplyingToNode(t) {
      if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {
        let e = this._declarationNodeIndex, n = t.parent;
        for (; n !== null && n.type & 8 && n.index !== e; ) n = n.parent;
        return e === (n !== null ? n.index : -1);
      }
      return this._appliesToNextNode;
    }
    matchTNode(t, e) {
      let n = this.metadata.predicate;
      if (Array.isArray(n)) for (let r = 0; r < n.length; r++) {
        let o = n[r];
        this.matchTNodeWithReadOption(t, e, g6(e, o)), this.matchTNodeWithReadOption(t, e, $_(e, t, o, false, false));
      }
      else n === ni ? e.type & 4 && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, $_(e, t, n, false, false));
    }
    matchTNodeWithReadOption(t, e, n) {
      if (n !== null) {
        let r = this.metadata.read;
        if (r !== null) if (r === He || r === un || r === ni && e.type & 4) this.addMatch(e.index, -2);
        else {
          let o = $_(e, t, r, false, false);
          o !== null && this.addMatch(e.index, o);
        }
        else this.addMatch(e.index, n);
      }
    }
    addMatch(t, e) {
      this.matches === null ? this.matches = [t, e] : this.matches.push(t, e);
    }
  };
  function g6(i59, t) {
    let e = i59.localNames;
    if (e !== null) {
      for (let n = 0; n < e.length; n += 2) if (e[n] === t) return e[n + 1];
    }
    return null;
  }
  function _6(i59, t) {
    return i59.type & 11 ? yu(i59, t) : i59.type & 4 ? Gv(i59, t) : null;
  }
  function v6(i59, t, e, n) {
    return e === -1 ? _6(t, i59) : e === -2 ? y6(i59, t, n) : Hp(i59, i59[Gt], e, t);
  }
  function y6(i59, t, e) {
    if (e === He) return yu(t, i59);
    if (e === ni) return Gv(t, i59);
    if (e === un) return sN(t, i59);
  }
  function aN(i59, t, e, n) {
    let r = t[ia].queries[n];
    if (r.matches === null) {
      let o = i59.data, s = e.matches, a = [];
      for (let l = 0; s !== null && l < s.length; l += 2) {
        let c = s[l];
        if (c < 0) a.push(null);
        else {
          let d = o[c];
          a.push(v6(t, d, s[l + 1], e.metadata.read));
        }
      }
      r.matches = a;
    }
    return r.matches;
  }
  function cS(i59, t, e, n) {
    let r = i59.queries.getByIndex(e), o = r.matches;
    if (o !== null) {
      let s = aN(i59, t, r, e);
      for (let a = 0; a < o.length; a += 2) {
        let l = o[a];
        if (l > 0) n.push(s[a / 2]);
        else {
          let c = o[a + 1], d = t[-l];
          for (let u = dr; u < d.length; u++) {
            let h = d[u];
            h[oc] === h[ur] && cS(h[Gt], h, c, n);
          }
          if (d[hu] !== null) {
            let u = d[hu];
            for (let h = 0; h < u.length; h++) {
              let p = u[h];
              cS(p[Gt], p, c, n);
            }
          }
        }
      }
    }
    return n;
  }
  function vM(i59, t) {
    return i59[ia].queries[t].queryList;
  }
  function lN(i59, t, e) {
    let n = new Ni((e & 4) === 4);
    return rj(i59, t, n, n.destroy), (t[ia] ??= new sS()).queries.push(new oS(n)) - 1;
  }
  function cN(i59, t, e) {
    let n = ii();
    return n.firstCreatePass && (uN(n, new uv(i59, t, e), -1), (t & 2) === 2 && (n.staticViewQueries = true)), lN(n, Ft(), t);
  }
  function dN(i59, t, e, n) {
    let r = ii();
    if (r.firstCreatePass) {
      let o = fr();
      uN(r, new uv(t, e, n), o.index), x6(r, i59), (e & 2) === 2 && (r.staticContentQueries = true);
    }
    return lN(r, Ft(), e);
  }
  function b6(i59) {
    return i59.split(",").map((t) => t.trim());
  }
  function uN(i59, t, e) {
    i59.queries === null && (i59.queries = new aS()), i59.queries.track(new lS(t, e));
  }
  function x6(i59, t) {
    let e = i59.contentQueries || (i59.contentQueries = []), n = e.length ? e[e.length - 1] : -1;
    t !== n && e.push(i59.queries.length - 1, t);
  }
  function yM(i59, t) {
    return i59.queries.getByIndex(t);
  }
  function hN(i59, t) {
    let e = i59[Gt], n = yM(e, t);
    return n.crossesNgTemplate ? cS(e, i59, t, []) : aN(e, i59, n, t);
  }
  function bM(i59, t, e) {
    let n, r = Yw(() => {
      n._dirtyCounter();
      let o = C6(n, i59);
      if (t && o === void 0) throw new ze(-951, false);
      return o;
    });
    return n = r[lr], n._dirtyCounter = gt(0), n._flatValue = void 0, r;
  }
  function pN(i59) {
    return bM(true, false, i59);
  }
  function fN(i59) {
    return bM(true, true, i59);
  }
  function w6(i59) {
    return bM(false, false, i59);
  }
  function mN(i59, t) {
    let e = i59[lr];
    e._lView = Ft(), e._queryIndex = t, e._queryList = vM(e._lView, t), e._queryList.onDirty(() => e._dirtyCounter.update((n) => n + 1));
  }
  function C6(i59, t) {
    let e = i59._lView, n = i59._queryIndex;
    if (e === void 0 || n === void 0 || e[Ot] & 4) return t ? void 0 : Er;
    let r = vM(e, n), o = hN(e, n);
    return r.reset(o, rA), t ? r.first : r._changesDetected || i59._flatValue === void 0 ? i59._flatValue = r.toArray() : i59._flatValue;
  }
  function VR(i59, t) {
    return pN(t);
  }
  function S6(i59, t) {
    return fN(t);
  }
  var gN = (VR.required = S6, VR);
  function _N(i59, t) {
    return w6(t);
  }
  function zR(i59, t) {
    return pN(t);
  }
  function M6(i59, t) {
    return fN(t);
  }
  var vN = (zR.required = M6, zR);
  var aa = class {
  };
  var hv = class extends aa {
    injector;
    componentFactoryResolver = new iS(this);
    instance = null;
    constructor(t) {
      super();
      let e = new zp([...t.providers, { provide: aa, useValue: this }, { provide: Ja, useValue: this.componentFactoryResolver }], t.parent || Mv(), t.debugName, /* @__PURE__ */ new Set(["environment"]));
      this.injector = e, t.runEnvironmentInitializers && e.resolveInjectorInitializers();
    }
    destroy() {
      this.injector.destroy();
    }
    onDestroy(t) {
      this.injector.onDestroy(t);
    }
  };
  function E6(i59, t, e = null) {
    return new hv({ providers: i59, parent: t, debugName: e, runEnvironmentInitializers: true }).injector;
  }
  var T6 = (() => {
    class i59 {
      _injector;
      cachedInjectors = /* @__PURE__ */ new Map();
      constructor(e) {
        this._injector = e;
      }
      getOrCreateStandaloneInjector(e) {
        if (!e.standalone) return null;
        if (!this.cachedInjectors.has(e)) {
          let n = mO(false, e.type), r = n.length > 0 ? E6([n], this._injector, `Standalone[${e.type.name}]`) : null;
          this.cachedInjectors.set(e, r);
        }
        return this.cachedInjectors.get(e);
      }
      ngOnDestroy() {
        try {
          for (let e of this.cachedInjectors.values()) e !== null && e.destroy();
        } finally {
          this.cachedInjectors.clear();
        }
      }
      static \u0275prov = de({ token: i59, providedIn: "environment", factory: () => new i59(Ze(Jr)) });
    }
    return i59;
  })();
  function xe(i59) {
    return Yp(() => {
      let t = yN(i59), e = xt(le({}, t), { decls: i59.decls, vars: i59.vars, template: i59.template, consts: i59.consts || null, ngContentSelectors: i59.ngContentSelectors, onPush: i59.changeDetection === sA.OnPush, directiveDefs: null, pipeDefs: null, dependencies: t.standalone && i59.dependencies || null, getStandaloneInjector: t.standalone ? (r) => r.get(T6).getOrCreateStandaloneInjector(e) : null, getExternalStyles: null, signals: i59.signals ?? false, data: i59.data || {}, encapsulation: i59.encapsulation || bs.Emulated, styles: i59.styles || Er, _: null, schemas: i59.schemas || null, tView: null, id: "" });
      t.standalone && no("NgStandalone"), bN(e);
      let n = i59.dependencies;
      return e.directiveDefs = GR(n, false), e.pipeDefs = GR(n, true), e.id = P6(e), e;
    });
  }
  function I6(i59) {
    return rc(i59) || AS(i59);
  }
  function D6(i59) {
    return i59 !== null;
  }
  function lt(i59) {
    return Yp(() => ({ type: i59.type, bootstrap: i59.bootstrap || Er, declarations: i59.declarations || Er, imports: i59.imports || Er, exports: i59.exports || Er, transitiveCompileScopes: null, schemas: i59.schemas || null, id: i59.id || null }));
  }
  function UR(i59, t) {
    if (i59 == null) return ta;
    let e = {};
    for (let n in i59) if (i59.hasOwnProperty(n)) {
      let r = i59[n], o, s, a = Ka.None;
      Array.isArray(r) ? (a = r[0], o = r[1], s = r[2] ?? o) : (o = r, s = r), t ? (e[o] = a !== Ka.None ? [n, a] : n, t[o] = s) : e[o] = n;
    }
    return e;
  }
  function qe(i59) {
    return Yp(() => {
      let t = yN(i59);
      return bN(t), t;
    });
  }
  function yN(i59) {
    let t = {};
    return { type: i59.type, providersResolver: null, factory: null, hostBindings: i59.hostBindings || null, hostVars: i59.hostVars || 0, hostAttrs: i59.hostAttrs || null, contentQueries: i59.contentQueries || null, declaredInputs: t, inputTransforms: null, inputConfig: i59.inputs || ta, exportAs: i59.exportAs || null, standalone: i59.standalone ?? true, signals: i59.signals === true, selectors: i59.selectors || Er, viewQuery: i59.viewQuery || null, features: i59.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: UR(i59.inputs, t), outputs: UR(i59.outputs), debugInfo: null };
  }
  function bN(i59) {
    i59.features?.forEach((t) => t(i59));
  }
  function GR(i59, t) {
    if (!i59) return null;
    let e = t ? fO : I6;
    return () => (typeof i59 == "function" ? i59() : i59).map((n) => e(n)).filter(D6);
  }
  function P6(i59) {
    let t = 0, e = typeof i59.consts == "function" ? "" : i59.consts, n = [i59.selectors, i59.ngContentSelectors, i59.hostVars, i59.hostAttrs, e, i59.vars, i59.decls, i59.encapsulation, i59.standalone, i59.signals, i59.exportAs, JSON.stringify(i59.inputs), JSON.stringify(i59.outputs), Object.getOwnPropertyNames(i59.type.prototype), !!i59.contentQueries, !!i59.viewQuery];
    for (let o of n.join("|")) t = Math.imul(31, t) + o.charCodeAt(0) << 0;
    return t += 2147483648, "c" + t;
  }
  function R6(i59) {
    return Object.getPrototypeOf(i59.prototype).constructor;
  }
  function Zt(i59) {
    let t = R6(i59.type), e = true, n = [i59];
    for (; t; ) {
      let r;
      if (_s(i59)) r = t.\u0275cmp || t.\u0275dir;
      else {
        if (t.\u0275cmp) throw new ze(903, false);
        r = t.\u0275dir;
      }
      if (r) {
        if (e) {
          n.push(r);
          let s = i59;
          s.inputs = z_(i59.inputs), s.inputTransforms = z_(i59.inputTransforms), s.declaredInputs = z_(i59.declaredInputs), s.outputs = z_(i59.outputs);
          let a = r.hostBindings;
          a && L6(i59, a);
          let l = r.viewQuery, c = r.contentQueries;
          if (l && N6(i59, l), c && k6(i59, c), O6(i59, r), h5(i59.outputs, r.outputs), _s(r) && r.data.animation) {
            let d = i59.data;
            d.animation = (d.animation || []).concat(r.data.animation);
          }
        }
        let o = r.features;
        if (o) for (let s = 0; s < o.length; s++) {
          let a = o[s];
          a && a.ngInherit && a(i59), a === Zt && (e = false);
        }
      }
      t = Object.getPrototypeOf(t);
    }
    A6(n);
  }
  function O6(i59, t) {
    for (let e in t.inputs) {
      if (!t.inputs.hasOwnProperty(e) || i59.inputs.hasOwnProperty(e)) continue;
      let n = t.inputs[e];
      if (n !== void 0 && (i59.inputs[e] = n, i59.declaredInputs[e] = t.declaredInputs[e], t.inputTransforms !== null)) {
        let r = Array.isArray(n) ? n[0] : n;
        if (!t.inputTransforms.hasOwnProperty(r)) continue;
        i59.inputTransforms ??= {}, i59.inputTransforms[r] = t.inputTransforms[r];
      }
    }
  }
  function A6(i59) {
    let t = 0, e = null;
    for (let n = i59.length - 1; n >= 0; n--) {
      let r = i59[n];
      r.hostVars = t += r.hostVars, r.hostAttrs = pu(r.hostAttrs, e = pu(e, r.hostAttrs));
    }
  }
  function z_(i59) {
    return i59 === ta ? {} : i59 === Er ? [] : i59;
  }
  function N6(i59, t) {
    let e = i59.viewQuery;
    e ? i59.viewQuery = (n, r) => {
      t(n, r), e(n, r);
    } : i59.viewQuery = t;
  }
  function k6(i59, t) {
    let e = i59.contentQueries;
    e ? i59.contentQueries = (n, r, o) => {
      t(n, r, o), e(n, r, o);
    } : i59.contentQueries = t;
  }
  function L6(i59, t) {
    let e = i59.hostBindings;
    e ? i59.hostBindings = (n, r) => {
      t(n, r), e(n, r);
    } : i59.hostBindings = t;
  }
  function xN(i59) {
    let t = (e) => {
      let n = Array.isArray(i59);
      e.hostDirectives === null ? (e.findHostDirectiveDefs = wN, e.hostDirectives = n ? i59.map(dS) : [i59]) : n ? e.hostDirectives.unshift(...i59.map(dS)) : e.hostDirectives.unshift(i59);
    };
    return t.ngInherit = true, t;
  }
  function wN(i59, t, e) {
    if (i59.hostDirectives !== null) for (let n of i59.hostDirectives) if (typeof n == "function") {
      let r = n();
      for (let o of r) HR(dS(o), t, e);
    } else HR(n, t, e);
  }
  function HR(i59, t, e) {
    let n = AS(i59.directive);
    F6(n.declaredInputs, i59.inputs), wN(n, t, e), e.set(n, i59), t.push(n);
  }
  function dS(i59) {
    return typeof i59 == "function" ? { directive: $i(i59), inputs: ta, outputs: ta } : { directive: $i(i59.directive), inputs: jR(i59.inputs), outputs: jR(i59.outputs) };
  }
  function jR(i59) {
    if (i59 === void 0 || i59.length === 0) return ta;
    let t = {};
    for (let e = 0; e < i59.length; e += 2) t[i59[e]] = i59[e + 1];
    return t;
  }
  function F6(i59, t) {
    for (let e in t) if (t.hasOwnProperty(e)) {
      let n = t[e], r = i59[e];
      i59[n] = r;
    }
  }
  function on(i59) {
    let t = i59.inputConfig, e = {};
    for (let n in t) if (t.hasOwnProperty(n)) {
      let r = t[n];
      Array.isArray(r) && r[3] && (e[n] = r[3]);
    }
    i59.inputTransforms = e;
  }
  function CN(i59) {
    return V6(i59) ? Array.isArray(i59) || !(i59 instanceof Map) && Symbol.iterator in i59 : false;
  }
  function B6(i59, t) {
    if (Array.isArray(i59)) for (let e = 0; e < i59.length; e++) t(i59[e]);
    else {
      let e = i59[Symbol.iterator](), n;
      for (; !(n = e.next()).done; ) t(n.value);
    }
  }
  function V6(i59) {
    return i59 !== null && (typeof i59 == "function" || typeof i59 == "object");
  }
  function z6(i59, t, e) {
    return i59[t] = e;
  }
  function xo(i59, t, e) {
    let n = i59[t];
    return Object.is(n, e) ? false : (i59[t] = e, true);
  }
  function uS(i59, t, e, n) {
    let r = xo(i59, t, e);
    return xo(i59, t + 1, n) || r;
  }
  function U6(i59, t, e, n, r, o) {
    let s = uS(i59, t, e, n);
    return uS(i59, t + 2, r, o) || s;
  }
  function G6(i59, t, e, n, r, o, s, a, l) {
    let c = t.consts, d = sf(t, i59, 4, s || null, a || null);
    Dv() && _M(t, e, d, Qa(c, l), lM), d.mergedAttrs = pu(d.mergedAttrs, d.attrs), qS(t, d);
    let u = d.tView = sM(2, d, n, r, o, t.directiveRegistry, t.pipeRegistry, null, t.schemas, c, null);
    return t.queries !== null && (t.queries.template(t, d), u.queries = t.queries.embeddedTView(d)), d;
  }
  function pv(i59, t, e, n, r, o, s, a, l, c) {
    let d = e + hr, u = t.firstCreatePass ? G6(d, t, i59, n, r, o, s, a, l) : t.data[d];
    mc(u, false);
    let h = H6(t, i59, u, e);
    Nv() && zv(t, i59, h, u), vc(h, i59);
    let p = BA(h, i59, h, u);
    return i59[d] = p, cM(i59, p), f6(p, u, i59), Tv(u) && rM(t, i59, u), l != null && oM(i59, u, c), u;
  }
  function X(i59, t, e, n, r, o, s, a) {
    let l = Ft(), c = ii(), d = Qa(c.consts, o);
    return pv(l, c, i59, t, e, n, r, d, s, a), X;
  }
  var H6 = j6;
  function j6(i59, t, e, n) {
    return kv(true), t[ti].createComment("");
  }
  var SN = new Ee("");
  function af(i59) {
    return !!i59 && typeof i59.then == "function";
  }
  function MN(i59) {
    return !!i59 && typeof i59.subscribe == "function";
  }
  var W6 = new Ee("");
  var EN = (() => {
    class i59 {
      resolve;
      reject;
      initialized = false;
      done = false;
      donePromise = new Promise((e, n) => {
        this.resolve = e, this.reject = n;
      });
      appInits = M(W6, { optional: true }) ?? [];
      injector = M(mt);
      constructor() {
      }
      runInitializers() {
        if (this.initialized) return;
        let e = [];
        for (let r of this.appInits) {
          let o = kS(this.injector, r);
          if (af(o)) e.push(o);
          else if (MN(o)) {
            let s = new Promise((a, l) => {
              o.subscribe({ complete: a, error: l });
            });
            e.push(s);
          }
        }
        let n = () => {
          this.done = true, this.resolve();
        };
        Promise.all(e).then(() => {
          n();
        }).catch((r) => {
          this.reject(r);
        }), e.length === 0 && n(), this.initialized = true;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var TN = (() => {
    class i59 {
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => new fv() });
    }
    return i59;
  })();
  var fv = class {
    queuedEffectCount = 0;
    queues = /* @__PURE__ */ new Map();
    schedule(t) {
      this.enqueue(t);
    }
    remove(t) {
      let e = t.zone, n = this.queues.get(e);
      n.has(t) && (n.delete(t), this.queuedEffectCount--);
    }
    enqueue(t) {
      let e = t.zone;
      this.queues.has(e) || this.queues.set(e, /* @__PURE__ */ new Set());
      let n = this.queues.get(e);
      n.has(t) || (this.queuedEffectCount++, n.add(t));
    }
    flush() {
      for (; this.queuedEffectCount > 0; ) for (let [t, e] of this.queues) t === null ? this.flushQueue(e) : t.run(() => this.flushQueue(e));
    }
    flushQueue(t) {
      for (let e of t) t.delete(e), this.queuedEffectCount--, e.run();
    }
  };
  var IN = new Ee("");
  function $6() {
    RP(() => {
      throw new ze(600, false);
    });
  }
  function q6(i59) {
    return i59.isBoundToModule;
  }
  var Y6 = 10;
  var Ur = (() => {
    class i59 {
      _runningTick = false;
      _destroyed = false;
      _destroyListeners = [];
      _views = [];
      internalErrorHandler = M($j);
      afterRenderManager = M(pA);
      zonelessEnabled = M(XS);
      rootEffectScheduler = M(TN);
      dirtyFlags = 0;
      deferredDirtyFlags = 0;
      tracingSnapshot = null;
      externalTestViews = /* @__PURE__ */ new Set();
      afterTick = new we();
      get allViews() {
        return [...this.externalTestViews.keys(), ...this._views];
      }
      get destroyed() {
        return this._destroyed;
      }
      componentTypes = [];
      components = [];
      isStable = M(vu).hasPendingTasks.pipe(kt((e) => !e));
      constructor() {
        M(xu, { optional: true });
      }
      whenStable() {
        let e;
        return new Promise((n) => {
          e = this.isStable.subscribe({ next: (r) => {
            r && n();
          } });
        }).finally(() => {
          e.unsubscribe();
        });
      }
      _injector = M(Jr);
      _rendererFactory = null;
      get injector() {
        return this._injector;
      }
      bootstrap(e, n) {
        let r = e instanceof dv;
        if (!this._injector.get(EN).done) {
          let h = !r && k5(e), p = false;
          throw new ze(405, p);
        }
        let s;
        r ? s = e : s = this._injector.get(Ja).resolveComponentFactory(e), this.componentTypes.push(s.componentType);
        let a = q6(s) ? void 0 : this._injector.get(aa), l = n || s.selector, c = s.create(mt.NULL, [], l, a), d = c.location.nativeElement, u = c.injector.get(SN, null);
        return u?.registerApplication(d), c.onDestroy(() => {
          this.detachView(c.hostView), q_(this.components, c), u?.unregisterApplication(d);
        }), this._loadComponent(c), c;
      }
      tick() {
        this.zonelessEnabled || (this.dirtyFlags |= 1), this._tick();
      }
      _tick = () => {
        if (this.tracingSnapshot !== null) {
          let n = this.tracingSnapshot;
          this.tracingSnapshot = null, n.run(JS.CHANGE_DETECTION, this._tick), n.dispose();
          return;
        }
        if (this._runningTick) throw new ze(101, false);
        let e = Ht(null);
        try {
          this._runningTick = true, this.synchronize();
        } catch (n) {
          this.internalErrorHandler(n);
        } finally {
          this._runningTick = false, Ht(e), this.afterTick.next();
        }
      };
      synchronize() {
        this._rendererFactory === null && !this._injector.destroyed && (this._rendererFactory = this._injector.get(pr, null, { optional: true })), this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0;
        let e = 0;
        for (; this.dirtyFlags !== 0 && e++ < Y6; ) this.synchronizeOnce();
      }
      synchronizeOnce() {
        if (this.dirtyFlags |= this.deferredDirtyFlags, this.deferredDirtyFlags = 0, this.dirtyFlags & 16 && (this.dirtyFlags &= -17, this.rootEffectScheduler.flush()), this.dirtyFlags & 7) {
          let e = !!(this.dirtyFlags & 1);
          this.dirtyFlags &= -8, this.dirtyFlags |= 8;
          for (let { _lView: n, notifyErrorHandler: r } of this.allViews) X6(n, r, e, this.zonelessEnabled);
          if (this.dirtyFlags &= -5, this.syncDirtyFlagsWithViews(), this.dirtyFlags & 23) return;
        } else this._rendererFactory?.begin?.(), this._rendererFactory?.end?.();
        this.dirtyFlags & 8 && (this.dirtyFlags &= -9, this.afterRenderManager.execute()), this.syncDirtyFlagsWithViews();
      }
      syncDirtyFlagsWithViews() {
        if (this.allViews.some(({ _lView: e }) => Iv(e))) {
          this.dirtyFlags |= 2;
          return;
        } else this.dirtyFlags &= -8;
      }
      attachView(e) {
        let n = e;
        this._views.push(n), n.attachToAppRef(this);
      }
      detachView(e) {
        let n = e;
        q_(this._views, n), n.detachFromAppRef();
      }
      _loadComponent(e) {
        this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(IN, []).forEach((r) => r(e));
      }
      ngOnDestroy() {
        if (!this._destroyed) try {
          this._destroyListeners.forEach((e) => e()), this._views.slice().forEach((e) => e.destroy());
        } finally {
          this._destroyed = true, this._views = [], this._destroyListeners = [];
        }
      }
      onDestroy(e) {
        return this._destroyListeners.push(e), () => q_(this._destroyListeners, e);
      }
      destroy() {
        if (this._destroyed) throw new ze(406, false);
        let e = this._injector;
        e.destroy && !e.destroyed && e.destroy();
      }
      get viewCount() {
        return this._views.length;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function q_(i59, t) {
    let e = i59.indexOf(t);
    e > -1 && i59.splice(e, 1);
  }
  function X6(i59, t, e, n) {
    if (!e && !Iv(i59)) return;
    KA(i59, t, e && !n ? 0 : 1);
  }
  function Ke(i59, t, e, n) {
    let r = Ft(), o = gc();
    if (xo(r, o, t)) {
      let s = ii(), a = Ov();
      aW(a, r, i59, t, e, n);
    }
    return Ke;
  }
  function DN(i59, t, e, n) {
    return xo(i59, gc(), e) ? t + ms(e) + n : jr;
  }
  function Z6(i59, t, e, n, r, o) {
    let s = NO(), a = uS(i59, s, e, r);
    return Pv(2), a ? t + ms(e) + n + ms(r) + o : jr;
  }
  function Q6(i59, t, e, n, r, o, s, a, l, c) {
    let d = NO(), u = U6(i59, d, e, r, s, l);
    return Pv(4), u ? t + ms(e) + n + ms(r) + o + ms(s) + a + ms(l) + c : jr;
  }
  function U_(i59, t) {
    return i59 << 17 | t << 2;
  }
  function hc(i59) {
    return i59 >> 17 & 32767;
  }
  function K6(i59) {
    return (i59 & 2) == 2;
  }
  function J6(i59, t) {
    return i59 & 131071 | t << 17;
  }
  function hS(i59) {
    return i59 | 2;
  }
  function gu(i59) {
    return (i59 & 131068) >> 2;
  }
  function mC(i59, t) {
    return i59 & -131069 | t << 2;
  }
  function e$(i59) {
    return (i59 & 1) === 1;
  }
  function pS(i59) {
    return i59 | 1;
  }
  function t$(i59, t, e, n, r, o) {
    let s = o ? t.classBindings : t.styleBindings, a = hc(s), l = gu(s);
    i59[n] = e;
    let c = false, d;
    if (Array.isArray(e)) {
      let u = e;
      d = u[1], (d === null || Xp(u, d) > 0) && (c = true);
    } else d = e;
    if (r) if (l !== 0) {
      let h = hc(i59[a + 1]);
      i59[n + 1] = U_(h, a), h !== 0 && (i59[h + 1] = mC(i59[h + 1], n)), i59[a + 1] = J6(i59[a + 1], n);
    } else i59[n + 1] = U_(a, 0), a !== 0 && (i59[a + 1] = mC(i59[a + 1], n)), a = n;
    else i59[n + 1] = U_(l, 0), a === 0 ? a = n : i59[l + 1] = mC(i59[l + 1], n), l = n;
    c && (i59[n + 1] = hS(i59[n + 1])), WR(i59, d, n, true), WR(i59, d, n, false), n$(t, d, i59, n, o), s = U_(a, l), o ? t.classBindings = s : t.styleBindings = s;
  }
  function n$(i59, t, e, n, r) {
    let o = r ? i59.residualClasses : i59.residualStyles;
    o != null && typeof t == "string" && Xp(o, t) >= 0 && (e[n + 1] = pS(e[n + 1]));
  }
  function WR(i59, t, e, n) {
    let r = i59[e + 1], o = t === null, s = n ? hc(r) : gu(r), a = false;
    for (; s !== 0 && (a === false || o); ) {
      let l = i59[s], c = i59[s + 1];
      i$(l, t) && (a = true, i59[s + 1] = n ? pS(c) : hS(c)), s = n ? hc(c) : gu(c);
    }
    a && (i59[e + 1] = n ? hS(r) : pS(r));
  }
  function i$(i59, t) {
    return i59 === null || t == null || (Array.isArray(i59) ? i59[1] : i59) === t ? true : Array.isArray(i59) && typeof t == "string" ? Xp(i59, t) >= 0 : false;
  }
  var Yo = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
  function r$(i59) {
    return i59.substring(Yo.key, Yo.keyEnd);
  }
  function o$(i59) {
    return s$(i59), PN(i59, RN(i59, 0, Yo.textEnd));
  }
  function PN(i59, t) {
    let e = Yo.textEnd;
    return e === t ? -1 : (t = Yo.keyEnd = a$(i59, Yo.key = t, e), RN(i59, t, e));
  }
  function s$(i59) {
    Yo.key = 0, Yo.keyEnd = 0, Yo.value = 0, Yo.valueEnd = 0, Yo.textEnd = i59.length;
  }
  function RN(i59, t, e) {
    for (; t < e && i59.charCodeAt(t) <= 32; ) t++;
    return t;
  }
  function a$(i59, t, e) {
    for (; t < e && i59.charCodeAt(t) > 32; ) t++;
    return t;
  }
  function U(i59, t, e) {
    let n = Ft(), r = gc();
    if (xo(n, r, t)) {
      let o = ii(), s = Ov();
      aM(o, s, n, i59, t, n[ti], e, false);
    }
    return U;
  }
  function fS(i59, t, e, n, r) {
    let o = t.inputs, s = r ? "class" : "style";
    dM(i59, e, o[s], s, n);
  }
  function sn(i59, t, e) {
    return AN(i59, t, e, false), sn;
  }
  function ye(i59, t) {
    return AN(i59, t, null, true), ye;
  }
  function io(i59) {
    NN(p$, ON, i59, true);
  }
  function ON(i59, t) {
    for (let e = o$(t); e >= 0; e = PN(t, e)) Cv(i59, r$(t), true);
  }
  function AN(i59, t, e, n) {
    let r = Ft(), o = ii(), s = Pv(2);
    if (o.firstUpdatePass && LN(o, i59, s, n), t !== jr && xo(r, s, t)) {
      let a = o.data[ws()];
      FN(o, a, r, r[ti], i59, r[s + 1] = m$(t, e), n, s);
    }
  }
  function NN(i59, t, e, n) {
    let r = ii(), o = Pv(2);
    r.firstUpdatePass && LN(r, null, o, n);
    let s = Ft();
    if (e !== jr && xo(s, o, e)) {
      let a = r.data[ws()];
      if (BN(a, n) && !kN(r, o)) {
        let l = n ? a.classesWithoutHost : a.stylesWithoutHost;
        l !== null && (e = xC(l, e || "")), fS(r, a, s, e, n);
      } else f$(r, a, s, s[ti], s[o + 1], s[o + 1] = h$(i59, t, e), n, o);
    }
  }
  function kN(i59, t) {
    return t >= i59.expandoStartIndex;
  }
  function LN(i59, t, e, n) {
    let r = i59.data;
    if (r[e + 1] === null) {
      let o = r[ws()], s = kN(i59, e);
      BN(o, n) && t === null && !s && (t = false), t = l$(r, o, t, n), t$(r, o, t, e, s, n);
    }
  }
  function l$(i59, t, e, n) {
    let r = HS(i59), o = n ? t.residualClasses : t.residualStyles;
    if (r === null) (n ? t.classBindings : t.styleBindings) === 0 && (e = gC(null, i59, t, e, n), e = qp(e, t.attrs, n), o = null);
    else {
      let s = t.directiveStylingLast;
      if (s === -1 || i59[s] !== r) if (e = gC(r, i59, t, e, n), o === null) {
        let l = c$(i59, t, n);
        l !== void 0 && Array.isArray(l) && (l = gC(null, i59, t, l[1], n), l = qp(l, t.attrs, n), d$(i59, t, n, l));
      } else o = u$(i59, t, n);
    }
    return o !== void 0 && (n ? t.residualClasses = o : t.residualStyles = o), e;
  }
  function c$(i59, t, e) {
    let n = e ? t.classBindings : t.styleBindings;
    if (gu(n) !== 0) return i59[hc(n)];
  }
  function d$(i59, t, e, n) {
    let r = e ? t.classBindings : t.styleBindings;
    i59[hc(r)] = n;
  }
  function u$(i59, t, e) {
    let n, r = t.directiveEnd;
    for (let o = 1 + t.directiveStylingLast; o < r; o++) {
      let s = i59[o].hostAttrs;
      n = qp(n, s, e);
    }
    return qp(n, t.attrs, e);
  }
  function gC(i59, t, e, n, r) {
    let o = null, s = e.directiveEnd, a = e.directiveStylingLast;
    for (a === -1 ? a = e.directiveStart : a++; a < s && (o = t[a], n = qp(n, o.hostAttrs, r), o !== i59); ) a++;
    return i59 !== null && (e.directiveStylingLast = a), n;
  }
  function qp(i59, t, e) {
    let n = e ? 1 : 2, r = -1;
    if (t !== null) for (let o = 0; o < t.length; o++) {
      let s = t[o];
      typeof s == "number" ? r = s : r === n && (Array.isArray(i59) || (i59 = i59 === void 0 ? [] : ["", i59]), Cv(i59, s, e ? true : t[++o]));
    }
    return i59 === void 0 ? null : i59;
  }
  function h$(i59, t, e) {
    if (e == null || e === "") return Er;
    let n = [], r = Cs(e);
    if (Array.isArray(r)) for (let o = 0; o < r.length; o++) i59(n, r[o], true);
    else if (typeof r == "object") for (let o in r) r.hasOwnProperty(o) && i59(n, o, r[o]);
    else typeof r == "string" && t(n, r);
    return n;
  }
  function p$(i59, t, e) {
    let n = String(t);
    n !== "" && !n.includes(" ") && Cv(i59, n, e);
  }
  function f$(i59, t, e, n, r, o, s, a) {
    r === jr && (r = Er);
    let l = 0, c = 0, d = 0 < r.length ? r[0] : null, u = 0 < o.length ? o[0] : null;
    for (; d !== null || u !== null; ) {
      let h = l < r.length ? r[l + 1] : void 0, p = c < o.length ? o[c + 1] : void 0, f = null, m;
      d === u ? (l += 2, c += 2, h !== p && (f = u, m = p)) : u === null || d !== null && d < u ? (l += 2, f = d) : (c += 2, f = u, m = p), f !== null && FN(i59, t, e, n, f, m, s, a), d = l < r.length ? r[l] : null, u = c < o.length ? o[c] : null;
    }
  }
  function FN(i59, t, e, n, r, o, s, a) {
    if (!(t.type & 3)) return;
    let l = i59.data, c = l[a + 1], d = e$(c) ? $R(l, t, e, r, gu(c), s) : void 0;
    if (!mv(d)) {
      mv(o) || K6(c) && (o = $R(l, null, e, r, a, s));
      let u = EO(ws(), e);
      MW(n, s, u, r, o);
    }
  }
  function $R(i59, t, e, n, r, o) {
    let s = t === null, a;
    for (; r > 0; ) {
      let l = i59[r], c = Array.isArray(l), d = c ? l[1] : l, u = d === null, h = e[r + 1];
      h === jr && (h = u ? Er : void 0);
      let p = u ? lC(h, n) : d === n ? h : void 0;
      if (c && !mv(p) && (p = lC(l, n)), mv(p) && (a = p, s)) return a;
      let f = i59[r + 1];
      r = s ? hc(f) : gu(f);
    }
    if (t !== null) {
      let l = o ? t.residualClasses : t.residualStyles;
      l != null && (a = lC(l, n));
    }
    return a;
  }
  function mv(i59) {
    return i59 !== void 0;
  }
  function m$(i59, t) {
    return i59 == null || i59 === "" || (typeof t == "string" ? i59 = i59 + t : typeof i59 == "object" && (i59 = Qr(Cs(i59)))), i59;
  }
  function BN(i59, t) {
    return (i59.flags & (t ? 8 : 16)) !== 0;
  }
  function VN(i59, t, e) {
    let n = Ft(), r = DN(n, i59, t, e);
    NN(Cv, ON, r, true);
  }
  var mS = class {
    destroy(t) {
    }
    updateValue(t, e) {
    }
    swap(t, e) {
      let n = Math.min(t, e), r = Math.max(t, e), o = this.detach(r);
      if (r - n > 1) {
        let s = this.detach(n);
        this.attach(n, o), this.attach(r, s);
      } else this.attach(n, o);
    }
    move(t, e) {
      this.attach(e, this.detach(t));
    }
  };
  function _C(i59, t, e, n, r) {
    return i59 === e && Object.is(t, n) ? 1 : Object.is(r(i59, t), r(e, n)) ? -1 : 0;
  }
  function g$(i59, t, e) {
    let n, r, o = 0, s = i59.length - 1, a = void 0;
    if (Array.isArray(t)) {
      let l = t.length - 1;
      for (; o <= s && o <= l; ) {
        let c = i59.at(o), d = t[o], u = _C(o, c, o, d, e);
        if (u !== 0) {
          u < 0 && i59.updateValue(o, d), o++;
          continue;
        }
        let h = i59.at(s), p = t[l], f = _C(s, h, l, p, e);
        if (f !== 0) {
          f < 0 && i59.updateValue(s, p), s--, l--;
          continue;
        }
        let m = e(o, c), v = e(s, h), _ = e(o, d);
        if (Object.is(_, v)) {
          let g = e(l, p);
          Object.is(g, m) ? (i59.swap(o, s), i59.updateValue(s, p), l--, s--) : i59.move(s, o), i59.updateValue(o, d), o++;
          continue;
        }
        if (n ??= new gv(), r ??= YR(i59, o, s, e), gS(i59, n, o, _)) i59.updateValue(o, d), o++, s++;
        else if (r.has(_)) n.set(m, i59.detach(o)), s--;
        else {
          let g = i59.create(o, t[o]);
          i59.attach(o, g), o++, s++;
        }
      }
      for (; o <= l; ) qR(i59, n, e, o, t[o]), o++;
    } else if (t != null) {
      let l = t[Symbol.iterator](), c = l.next();
      for (; !c.done && o <= s; ) {
        let d = i59.at(o), u = c.value, h = _C(o, d, o, u, e);
        if (h !== 0) h < 0 && i59.updateValue(o, u), o++, c = l.next();
        else {
          n ??= new gv(), r ??= YR(i59, o, s, e);
          let p = e(o, u);
          if (gS(i59, n, o, p)) i59.updateValue(o, u), o++, s++, c = l.next();
          else if (!r.has(p)) i59.attach(o, i59.create(o, u)), o++, s++, c = l.next();
          else {
            let f = e(o, d);
            n.set(f, i59.detach(o)), s--;
          }
        }
      }
      for (; !c.done; ) qR(i59, n, e, i59.length, c.value), c = l.next();
    }
    for (; o <= s; ) i59.destroy(i59.detach(s--));
    n?.forEach((l) => {
      i59.destroy(l);
    });
  }
  function gS(i59, t, e, n) {
    return t !== void 0 && t.has(n) ? (i59.attach(e, t.get(n)), t.delete(n), true) : false;
  }
  function qR(i59, t, e, n, r) {
    if (gS(i59, t, n, e(n, r))) i59.updateValue(n, r);
    else {
      let o = i59.create(n, r);
      i59.attach(n, o);
    }
  }
  function YR(i59, t, e, n) {
    let r = /* @__PURE__ */ new Set();
    for (let o = t; o <= e; o++) r.add(n(o, i59.at(o)));
    return r;
  }
  var gv = class {
    kvMap = /* @__PURE__ */ new Map();
    _vMap = void 0;
    has(t) {
      return this.kvMap.has(t);
    }
    delete(t) {
      if (!this.has(t)) return false;
      let e = this.kvMap.get(t);
      return this._vMap !== void 0 && this._vMap.has(e) ? (this.kvMap.set(t, this._vMap.get(e)), this._vMap.delete(e)) : this.kvMap.delete(t), true;
    }
    get(t) {
      return this.kvMap.get(t);
    }
    set(t, e) {
      if (this.kvMap.has(t)) {
        let n = this.kvMap.get(t);
        this._vMap === void 0 && (this._vMap = /* @__PURE__ */ new Map());
        let r = this._vMap;
        for (; r.has(n); ) n = r.get(n);
        r.set(n, e);
      } else this.kvMap.set(t, e);
    }
    forEach(t) {
      for (let [e, n] of this.kvMap) if (t(n, e), this._vMap !== void 0) {
        let r = this._vMap;
        for (; r.has(n); ) n = r.get(n), t(n, e);
      }
    }
  };
  function he(i59, t) {
    no("NgControlFlow");
    let e = Ft(), n = gc(), r = e[n] !== jr ? e[n] : -1, o = r !== -1 ? _v(e, hr + r) : void 0, s = 0;
    if (xo(e, n, i59)) {
      let a = Ht(null);
      try {
        if (o !== void 0 && YA(o, s), i59 !== -1) {
          let l = hr + i59, c = _v(e, l), d = bS(e[Gt], l), u = mu(c, d.tView.ssrId), h = rf(e, d, t, { dehydratedView: u });
          of(c, h, s, fu(d, u));
        }
      } finally {
        Ht(a);
      }
    } else if (o !== void 0) {
      let a = qA(o, s);
      a !== void 0 && (a[qi] = t);
    }
  }
  var _S = class {
    lContainer;
    $implicit;
    $index;
    constructor(t, e, n) {
      this.lContainer = t, this.$implicit = e, this.$index = n;
    }
    get $count() {
      return this.lContainer.length - dr;
    }
  };
  function lf(i59) {
    return i59;
  }
  function mr(i59, t) {
    return t;
  }
  var vS = class {
    hasEmptyBlock;
    trackByFn;
    liveCollection;
    constructor(t, e, n) {
      this.hasEmptyBlock = t, this.trackByFn = e, this.liveCollection = n;
    }
  };
  function Qt(i59, t, e, n, r, o, s, a, l, c, d, u, h) {
    no("NgControlFlow");
    let p = Ft(), f = ii(), m = l !== void 0, v = Ft(), _ = a ? s.bind(v[eo][qi]) : s, g = new vS(m, _);
    v[hr + i59] = g, pv(p, f, i59 + 1, t, e, n, r, Qa(f.consts, o)), m && pv(p, f, i59 + 2, l, c, d, u, Qa(f.consts, h));
  }
  var yS = class extends mS {
    lContainer;
    hostLView;
    templateTNode;
    operationsCounter = void 0;
    needsIndexUpdate = false;
    constructor(t, e, n) {
      super(), this.lContainer = t, this.hostLView = e, this.templateTNode = n;
    }
    get length() {
      return this.lContainer.length - dr;
    }
    at(t) {
      return this.getLView(t)[qi].$implicit;
    }
    attach(t, e) {
      let n = e[uu];
      this.needsIndexUpdate ||= t !== this.length, of(this.lContainer, e, t, fu(this.templateTNode, n));
    }
    detach(t) {
      return this.needsIndexUpdate ||= t !== this.length - 1, _$(this.lContainer, t);
    }
    create(t, e) {
      let n = mu(this.lContainer, this.templateTNode.tView.ssrId), r = rf(this.hostLView, this.templateTNode, new _S(this.lContainer, e, t), { dehydratedView: n });
      return this.operationsCounter?.recordCreate(), r;
    }
    destroy(t) {
      Vv(t[Gt], t), this.operationsCounter?.recordDestroy();
    }
    updateValue(t, e) {
      this.getLView(t)[qi].$implicit = e;
    }
    reset() {
      this.needsIndexUpdate = false, this.operationsCounter?.reset();
    }
    updateIndexes() {
      if (this.needsIndexUpdate) for (let t = 0; t < this.length; t++) this.getLView(t)[qi].$index = t;
    }
    getLView(t) {
      return v$(this.lContainer, t);
    }
  };
  function Kt(i59) {
    let t = Ht(null), e = ws();
    try {
      let n = Ft(), r = n[Gt], o = n[e], s = e + 1, a = _v(n, s);
      if (o.liveCollection === void 0) {
        let c = bS(r, s);
        o.liveCollection = new yS(a, n, c);
      } else o.liveCollection.reset();
      let l = o.liveCollection;
      if (g$(l, i59, o.trackByFn), l.updateIndexes(), o.hasEmptyBlock) {
        let c = gc(), d = l.length === 0;
        if (xo(n, c, d)) {
          let u = e + 2, h = _v(n, u);
          if (d) {
            let p = bS(r, u), f = mu(h, p.tView.ssrId), m = rf(n, p, void 0, { dehydratedView: f });
            of(h, m, 0, fu(p, f));
          } else YA(h, 0);
        }
      }
    } finally {
      Ht(t);
    }
  }
  function _v(i59, t) {
    return i59[t];
  }
  function _$(i59, t) {
    return Wp(i59, t);
  }
  function v$(i59, t) {
    return qA(i59, t);
  }
  function bS(i59, t) {
    return BS(i59, t);
  }
  function b(i59, t, e, n) {
    let r = Ft(), o = ii(), s = hr + i59, a = r[ti], l = o.firstCreatePass ? iN(s, o, r, t, lM, Dv(), e, n) : o.data[s], c = y$(o, r, l, a, t, i59);
    r[s] = c;
    let d = Tv(l);
    return mc(l, true), OA(a, c, l), !pM(l) && Nv() && zv(o, r, c, l), oj() === 0 && vc(c, r), sj(), d && (rM(o, r, l), eM(o, l, r)), n !== null && oM(r, l), b;
  }
  function x() {
    let i59 = fr();
    US() ? GS() : (i59 = i59.parent, mc(i59, false));
    let t = i59;
    lj(t) && cj(), aj();
    let e = ii();
    return e.firstCreatePass && rN(e, t), t.classesWithoutHost != null && Sj(t) && fS(e, t, Ft(), t.classesWithoutHost, true), t.stylesWithoutHost != null && Mj(t) && fS(e, t, Ft(), t.stylesWithoutHost, false), x;
  }
  function ae(i59, t, e, n) {
    return b(i59, t, e, n), x(), ae;
  }
  var y$ = (i59, t, e, n, r, o) => (kv(true), PA(n, r, bj()));
  function b$(i59, t, e, n, r) {
    let o = t.consts, s = Qa(o, n), a = sf(t, i59, 8, "ng-container", s);
    s !== null && nS(a, s, true);
    let l = Qa(o, r);
    return Dv() && _M(t, e, a, l, lM), a.mergedAttrs = pu(a.mergedAttrs, a.attrs), t.queries !== null && t.queries.elementStart(t, a), a;
  }
  function bc(i59, t, e) {
    let n = Ft(), r = ii(), o = i59 + hr, s = r.firstCreatePass ? b$(o, r, n, t, e) : r.data[o];
    mc(s, true);
    let a = x$(r, n, s, i59);
    return n[o] = a, Nv() && zv(r, n, a, s), vc(a, n), Tv(s) && (rM(r, n, s), eM(r, s, n)), e != null && oM(n, s), bc;
  }
  function xc() {
    let i59 = fr(), t = ii();
    return US() ? GS() : (i59 = i59.parent, mc(i59, false)), t.firstCreatePass && (qS(t, i59), FS(i59) && t.queries.elementEnd(i59)), xc;
  }
  function fi(i59, t, e) {
    return bc(i59, t, e), xc(), fi;
  }
  var x$ = (i59, t, e, n) => (kv(true), $8(t[ti], ""));
  function pe() {
    return Ft();
  }
  function gr(i59, t, e) {
    let n = Ft(), r = gc();
    if (xo(n, r, t)) {
      let o = ii(), s = Ov();
      aM(o, s, n, i59, t, n[ti], e, true);
    }
    return gr;
  }
  function cf(i59, t, e) {
    let n = Ft(), r = gc();
    if (xo(n, r, t)) {
      let o = ii(), s = Ov(), a = HS(o.data), l = VA(a, s, n);
      aM(o, s, n, i59, t, l, e, true);
    }
    return cf;
  }
  var vv = "en-US";
  var w$ = vv;
  function C$(i59) {
    typeof i59 == "string" && (w$ = i59.toLowerCase().replace(/_/g, "-"));
  }
  var S$ = (i59, t, e) => {
  };
  function Z(i59, t, e, n) {
    let r = Ft(), o = ii(), s = fr();
    return zN(o, r, r[ti], s, i59, t, n), Z;
  }
  function xM(i59, t) {
    let e = fr(), n = Ft(), r = ii(), o = HS(r.data), s = VA(o, e, n);
    return zN(r, n, s, e, i59, t), xM;
  }
  function M$(i59, t, e, n) {
    let r = i59.cleanup;
    if (r != null) for (let o = 0; o < r.length - 1; o += 2) {
      let s = r[o];
      if (s === e && r[o + 1] === n) {
        let a = t[J_], l = r[o + 2];
        return a.length > l ? a[l] : null;
      }
      typeof s == "string" && (o += 2);
    }
    return null;
  }
  function zN(i59, t, e, n, r, o, s) {
    let a = Tv(n), c = i59.firstCreatePass && PO(i59), d = t[qi], u = DO(t), h = true;
    if (n.type & 3 || s) {
      let m = Zo(n, t), v = s ? s(m) : m, _ = u.length, g = s ? (w) => s(vs(w[n.index])) : n.index, y = null;
      if (!s && a && (y = M$(i59, t, r, n.index)), y !== null) {
        let w = y.__ngLastListenerFn__ || y;
        w.__ngNextListenerFn__ = o, y.__ngLastListenerFn__ = o, h = false;
      } else {
        o = ZR(n, t, d, o), S$(m, r, o);
        let w = e.listen(v, r, o);
        u.push(o, w), c && c.push(r, g, _, _ + 1);
      }
    } else o = ZR(n, t, d, o);
    let p = n.outputs, f;
    if (h && p !== null && (f = p[r])) {
      let m = f.length;
      if (m) for (let v = 0; v < m; v += 2) {
        let _ = f[v], g = f[v + 1], E = t[_][g].subscribe(o), P = u.length;
        u.push(o, E), c && c.push(r, n.index, P, -(P + 1));
      }
    }
  }
  function XR(i59, t, e, n) {
    let r = Ht(null);
    try {
      return bo(6, t, e), e(n) !== false;
    } catch (o) {
      return zA(i59, o), false;
    } finally {
      bo(7, t, e), Ht(r);
    }
  }
  function ZR(i59, t, e, n) {
    return function r(o) {
      if (o === Function) return n;
      let s = fc(i59) ? ys(i59.index, t) : t;
      gM(s, 5);
      let a = XR(t, e, n, o), l = r.__ngNextListenerFn__;
      for (; l; ) a = XR(t, e, l, o) && a, l = l.__ngNextListenerFn__;
      return a;
    };
  }
  function T(i59 = 1) {
    return vj(i59);
  }
  function E$(i59, t) {
    let e = null, n = F8(i59);
    for (let r = 0; r < t.length; r++) {
      let o = t[r];
      if (o === "*") {
        e = r;
        continue;
      }
      if (n === null ? DA(i59, o, true) : z8(n, o)) return r;
    }
    return e;
  }
  function Tn(i59) {
    let t = Ft()[eo][Hr];
    if (!t.projection) {
      let e = i59 ? i59.length : 1, n = t.projection = O5(e, null), r = n.slice(), o = t.child;
      for (; o !== null; ) {
        if (o.type !== 128) {
          let s = i59 ? E$(o, i59) : 0;
          s !== null && (r[s] ? r[s].projectionNext = o : n[s] = o, r[s] = o);
        }
        o = o.next;
      }
    }
  }
  function zt(i59, t = 0, e, n, r, o) {
    let s = Ft(), a = ii(), l = n ? i59 + 1 : null;
    l !== null && pv(s, a, l, n, r, o, null, e);
    let c = sf(a, hr + i59, 16, null, e || null);
    c.projection === null && (c.projection = t), GS();
    let u = !s[uu] || RO();
    s[eo][Hr].projection[c.projection] === null && l !== null ? T$(s, a, l) : u && !pM(c) && CW(a, s, c);
  }
  function T$(i59, t, e) {
    let n = hr + e, r = t.data[n], o = i59[n], s = mu(o, r.tView.ssrId), a = rf(i59, r, void 0, { dehydratedView: s });
    of(o, a, 0, fu(r, s));
  }
  function Xi(i59, t, e, n) {
    dN(i59, t, e, n);
  }
  function Fe(i59, t, e) {
    cN(i59, t, e);
  }
  function Ie(i59) {
    let t = Ft(), e = ii(), n = jS();
    Rv(n + 1);
    let r = yM(e, n);
    if (i59.dirty && ej(t) === ((r.metadata.flags & 2) === 2)) {
      if (r.matches === null) i59.reset([]);
      else {
        let o = hN(t, n);
        i59.reset(o, rA), i59.notifyOnChanges();
      }
      return true;
    }
    return false;
  }
  function De() {
    return vM(Ft(), jS());
  }
  function UN(i59, t, e, n, r) {
    mN(t, dN(i59, e, n, r));
  }
  function Hv(i59, t, e, n) {
    mN(i59, cN(t, e, n));
  }
  function wu(i59 = 1) {
    Rv(jS() + i59);
  }
  function Ce(i59) {
    let t = uj();
    return J5(t, hr + i59);
  }
  function D(i59, t = "") {
    let e = Ft(), n = ii(), r = i59 + hr, o = n.firstCreatePass ? sf(n, r, 1, t, null) : n.data[r], s = I$(n, e, o, t, i59);
    e[r] = s, Nv() && zv(n, e, s, o), mc(o, false);
  }
  var I$ = (i59, t, e, n, r) => (kv(true), j8(t[ti], n));
  function Qe(i59) {
    return Oe("", i59, ""), Qe;
  }
  function Oe(i59, t, e) {
    let n = Ft(), r = DN(n, i59, t, e);
    return r !== jr && CM(n, ws(), r), Oe;
  }
  function wM(i59, t, e, n, r) {
    let o = Ft(), s = Z6(o, i59, t, e, n, r);
    return s !== jr && CM(o, ws(), s), wM;
  }
  function wc(i59, t, e, n, r, o, s, a, l) {
    let c = Ft(), d = Q6(c, i59, t, e, n, r, o, s, a, l);
    return d !== jr && CM(c, ws(), d), wc;
  }
  function CM(i59, t, e) {
    let n = EO(t, i59);
    W8(i59[ti], n, e);
  }
  function D$(i59, t, e) {
    let n = ii();
    if (n.firstCreatePass) {
      let r = _s(i59);
      xS(e, n.data, n.blueprint, r, true), xS(t, n.data, n.blueprint, r, false);
    }
  }
  function xS(i59, t, e, n, r) {
    if (i59 = $i(i59), Array.isArray(i59)) for (let o = 0; o < i59.length; o++) xS(i59[o], t, e, n, r);
    else {
      let o = ii(), s = Ft(), a = fr(), l = du(i59) ? i59 : $i(i59.provide), c = vO(i59), d = a.providerIndexes & 1048575, u = a.directiveStart, h = a.providerIndexes >> 20;
      if (du(i59) || !i59.multi) {
        let p = new dc(c, r, K), f = yC(l, t, r ? d : d + h, u);
        f === -1 ? (NC(ov(a, s), o, l), vC(o, i59, t.length), t.push(l), a.directiveStart++, a.directiveEnd++, r && (a.providerIndexes += 1048576), e.push(p), s.push(p)) : (e[f] = p, s[f] = p);
      } else {
        let p = yC(l, t, d + h, u), f = yC(l, t, d, d + h), m = p >= 0 && e[p], v = f >= 0 && e[f];
        if (r && !v || !r && !m) {
          NC(ov(a, s), o, l);
          let _ = O$(r ? R$ : P$, e.length, r, n, c);
          !r && v && (e[f].providerFactory = _), vC(o, i59, t.length, 0), t.push(l), a.directiveStart++, a.directiveEnd++, r && (a.providerIndexes += 1048576), e.push(_), s.push(_);
        } else {
          let _ = GN(e[r ? f : p], c, !r && n);
          vC(o, i59, p > -1 ? p : f, _);
        }
        !r && n && v && e[f].componentProviders++;
      }
    }
  }
  function vC(i59, t, e, n) {
    let r = du(t), o = z5(t);
    if (r || o) {
      let l = (o ? $i(t.useClass) : t).prototype.ngOnDestroy;
      if (l) {
        let c = i59.destroyHooks || (i59.destroyHooks = []);
        if (!r && t.multi) {
          let d = c.indexOf(e);
          d === -1 ? c.push(e, [n, l]) : c[d + 1].push(n, l);
        } else c.push(e, l);
      }
    }
  }
  function GN(i59, t, e) {
    return e && i59.componentProviders++, i59.multi.push(t) - 1;
  }
  function yC(i59, t, e, n) {
    for (let r = e; r < n; r++) if (t[r] === i59) return r;
    return -1;
  }
  function P$(i59, t, e, n) {
    return wS(this.multi, []);
  }
  function R$(i59, t, e, n) {
    let r = this.multi, o;
    if (this.providerFactory) {
      let s = this.providerFactory.componentProviders, a = Hp(e, e[Gt], this.providerFactory.index, n);
      o = a.slice(0, s), wS(r, o);
      for (let l = s; l < a.length; l++) o.push(a[l]);
    } else o = [], wS(r, o);
    return o;
  }
  function wS(i59, t) {
    for (let e = 0; e < i59.length; e++) {
      let n = i59[e];
      t.push(n());
    }
    return t;
  }
  function O$(i59, t, e, n, r) {
    let o = new dc(i59, e, K);
    return o.multi = [], o.index = t, o.componentProviders = 0, GN(o, r, n && !e), o;
  }
  function Bt(i59, t = []) {
    return (e) => {
      e.providersResolver = (n, r) => D$(n, r ? r(i59) : i59, t);
    };
  }
  function wo(i59, t, e, n) {
    return N$(Ft(), hj(), i59, t, e, n);
  }
  function A$(i59, t) {
    let e = i59[t];
    return e === jr ? void 0 : e;
  }
  function N$(i59, t, e, n, r, o) {
    let s = t + e;
    return xo(i59, s, r) ? z6(i59, s + 1, o ? n.call(o, r) : n(r)) : A$(i59, s + 1);
  }
  function Tt(i59, t) {
    return Gv(i59, t);
  }
  var k$ = (() => {
    class i59 {
      zone = M(We);
      changeDetectionScheduler = M(ra);
      applicationRef = M(Ur);
      _onMicrotaskEmptySubscription;
      initialize() {
        this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => {
          this.changeDetectionScheduler.runningTick || this.zone.run(() => {
            this.applicationRef.tick();
          });
        } }));
      }
      ngOnDestroy() {
        this._onMicrotaskEmptySubscription?.unsubscribe();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function L$({ ngZoneFactory: i59, ignoreChangesOutsideZone: t, scheduleInRootZone: e }) {
    return i59 ??= () => new We(xt(le({}, F$()), { scheduleInRootZone: e })), [{ provide: We, useFactory: i59 }, { provide: Vp, multi: true, useFactory: () => {
      let n = M(k$, { optional: true });
      return () => n.initialize();
    } }, { provide: Vp, multi: true, useFactory: () => {
      let n = M(B$);
      return () => {
        n.initialize();
      };
    } }, t === true ? { provide: eA, useValue: true } : [], { provide: tA, useValue: e ?? JO }];
  }
  function F$(i59) {
    return { enableLongStackTrace: false, shouldCoalesceEventChangeDetection: i59?.eventCoalescing ?? false, shouldCoalesceRunChangeDetection: i59?.runCoalescing ?? false };
  }
  var B$ = (() => {
    class i59 {
      subscription = new Rt();
      initialized = false;
      zone = M(We);
      pendingTasks = M(vu);
      initialize() {
        if (this.initialized) return;
        this.initialized = true;
        let e = null;
        !this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (e = this.pendingTasks.add()), this.zone.runOutsideAngular(() => {
          this.subscription.add(this.zone.onStable.subscribe(() => {
            We.assertNotInAngularZone(), queueMicrotask(() => {
              e !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks && (this.pendingTasks.remove(e), e = null);
            });
          }));
        }), this.subscription.add(this.zone.onUnstable.subscribe(() => {
          We.assertInAngularZone(), e ??= this.pendingTasks.add();
        }));
      }
      ngOnDestroy() {
        this.subscription.unsubscribe();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var V$ = (() => {
    class i59 {
      appRef = M(Ur);
      taskService = M(vu);
      ngZone = M(We);
      zonelessEnabled = M(XS);
      tracing = M(xu, { optional: true });
      disableScheduling = M(eA, { optional: true }) ?? false;
      zoneIsDefined = typeof Zone < "u" && !!Zone.root.run;
      schedulerTickApplyArgs = [{ data: { __scheduler_tick__: true } }];
      subscriptions = new Rt();
      angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(av) : null;
      scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (M(tA, { optional: true }) ?? false);
      cancelScheduledCallback = null;
      useMicrotaskScheduler = false;
      runningTick = false;
      pendingRenderTaskId = null;
      constructor() {
        this.subscriptions.add(this.appRef.afterTick.subscribe(() => {
          this.runningTick || this.cleanup();
        })), this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {
          this.runningTick || this.cleanup();
        })), this.disableScheduling ||= !this.zonelessEnabled && (this.ngZone instanceof BC || !this.zoneIsDefined);
      }
      notify(e) {
        if (!this.zonelessEnabled && e === 5) return;
        let n = false;
        switch (e) {
          case 0: {
            this.appRef.dirtyFlags |= 2;
            break;
          }
          case 3:
          case 2:
          case 4:
          case 5:
          case 1: {
            this.appRef.dirtyFlags |= 4;
            break;
          }
          case 8: {
            this.appRef.deferredDirtyFlags |= 8;
            break;
          }
          case 6: {
            this.appRef.dirtyFlags |= 2, n = true;
            break;
          }
          case 13: {
            this.appRef.dirtyFlags |= 16, n = true;
            break;
          }
          case 14: {
            this.appRef.dirtyFlags |= 2, n = true;
            break;
          }
          case 12: {
            n = true;
            break;
          }
          case 10:
          case 9:
          case 7:
          case 11:
          default:
            this.appRef.dirtyFlags |= 8;
        }
        if (this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null, !this.shouldScheduleTick(n)) return;
        let r = this.useMicrotaskScheduler ? wR : nA;
        this.pendingRenderTaskId = this.taskService.add(), this.scheduleInRootZone ? this.cancelScheduledCallback = Zone.root.run(() => r(() => this.tick())) : this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => r(() => this.tick()));
      }
      shouldScheduleTick(e) {
        return !(this.disableScheduling && !e || this.appRef.destroyed || this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick || !this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(av + this.angularZoneId));
      }
      tick() {
        if (this.runningTick || this.appRef.destroyed) return;
        if (this.appRef.dirtyFlags === 0) {
          this.cleanup();
          return;
        }
        !this.zonelessEnabled && this.appRef.dirtyFlags & 7 && (this.appRef.dirtyFlags |= 1);
        let e = this.taskService.add();
        try {
          this.ngZone.run(() => {
            this.runningTick = true, this.appRef._tick();
          }, void 0, this.schedulerTickApplyArgs);
        } catch (n) {
          throw this.taskService.remove(e), n;
        } finally {
          this.cleanup();
        }
        this.useMicrotaskScheduler = true, wR(() => {
          this.useMicrotaskScheduler = false, this.taskService.remove(e);
        });
      }
      ngOnDestroy() {
        this.subscriptions.unsubscribe(), this.cleanup();
      }
      cleanup() {
        if (this.runningTick = false, this.cancelScheduledCallback?.(), this.cancelScheduledCallback = null, this.pendingRenderTaskId !== null) {
          let e = this.pendingRenderTaskId;
          this.pendingRenderTaskId = null, this.taskService.remove(e);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function z$() {
    return typeof $localize < "u" && $localize.locale || vv;
  }
  var jv = new Ee("", { providedIn: "root", factory: () => M(jv, rn.Optional | rn.SkipSelf) || z$() });
  var CS = new Ee("");
  var U$ = new Ee("");
  function Np(i59) {
    return !i59.moduleRef;
  }
  function G$(i59) {
    let t = Np(i59) ? i59.r3Injector : i59.moduleRef.injector, e = t.get(We);
    return e.run(() => {
      Np(i59) ? i59.r3Injector.resolveInjectorInitializers() : i59.moduleRef.resolveInjectorInitializers();
      let n = t.get(Ir, null), r;
      if (e.runOutsideAngular(() => {
        r = e.onError.subscribe({ next: (o) => {
          n.handleError(o);
        } });
      }), Np(i59)) {
        let o = () => t.destroy(), s = i59.platformInjector.get(CS);
        s.add(o), t.onDestroy(() => {
          r.unsubscribe(), s.delete(o);
        });
      } else {
        let o = () => i59.moduleRef.destroy(), s = i59.platformInjector.get(CS);
        s.add(o), i59.moduleRef.onDestroy(() => {
          q_(i59.allPlatformModules, i59.moduleRef), r.unsubscribe(), s.delete(o);
        });
      }
      return j$(n, e, () => {
        let o = t.get(EN);
        return o.runInitializers(), o.donePromise.then(() => {
          let s = t.get(jv, vv);
          if (C$(s || vv), !t.get(U$, true)) return Np(i59) ? t.get(Ur) : (i59.allPlatformModules.push(i59.moduleRef), i59.moduleRef);
          if (Np(i59)) {
            let l = t.get(Ur);
            return i59.rootComponent !== void 0 && l.bootstrap(i59.rootComponent), l;
          } else return H$(i59.moduleRef, i59.allPlatformModules), i59.moduleRef;
        });
      });
    });
  }
  function H$(i59, t) {
    let e = i59.injector.get(Ur);
    if (i59._bootstrapComponents.length > 0) i59._bootstrapComponents.forEach((n) => e.bootstrap(n));
    else if (i59.instance.ngDoBootstrap) i59.instance.ngDoBootstrap(e);
    else throw new ze(-403, false);
    t.push(i59);
  }
  function j$(i59, t, e) {
    try {
      let n = e();
      return af(n) ? n.catch((r) => {
        throw t.runOutsideAngular(() => i59.handleError(r)), r;
      }) : n;
    } catch (n) {
      throw t.runOutsideAngular(() => i59.handleError(n)), n;
    }
  }
  var Y_ = null;
  function W$(i59 = [], t) {
    return mt.create({ name: t, providers: [{ provide: Sv, useValue: "platform" }, { provide: CS, useValue: /* @__PURE__ */ new Set([() => Y_ = null]) }, ...i59] });
  }
  function $$(i59 = []) {
    if (Y_) return Y_;
    let t = W$(i59);
    return Y_ = t, $6(), q$(t), t;
  }
  function q$(i59) {
    let t = i59.get(KS, null);
    kS(i59, () => {
      t?.forEach((e) => e());
    });
  }
  var Ge = /* @__PURE__ */ (() => {
    class i59 {
      static __NG_ELEMENT_ID__ = Y$;
    }
    return i59;
  })();
  function Y$(i59) {
    return X$(fr(), Ft(), (i59 & 16) === 16);
  }
  function X$(i59, t, e) {
    if (fc(i59) && !e) {
      let n = ys(i59.index, t);
      return new uc(n, n);
    } else if (i59.type & 175) {
      let n = t[eo];
      return new uc(n, t);
    }
    return null;
  }
  var SS = class {
    constructor() {
    }
    supports(t) {
      return CN(t);
    }
    create(t) {
      return new MS(t);
    }
  };
  var Z$ = (i59, t) => t;
  var MS = class {
    length = 0;
    collection;
    _linkedRecords = null;
    _unlinkedRecords = null;
    _previousItHead = null;
    _itHead = null;
    _itTail = null;
    _additionsHead = null;
    _additionsTail = null;
    _movesHead = null;
    _movesTail = null;
    _removalsHead = null;
    _removalsTail = null;
    _identityChangesHead = null;
    _identityChangesTail = null;
    _trackByFn;
    constructor(t) {
      this._trackByFn = t || Z$;
    }
    forEachItem(t) {
      let e;
      for (e = this._itHead; e !== null; e = e._next) t(e);
    }
    forEachOperation(t) {
      let e = this._itHead, n = this._removalsHead, r = 0, o = null;
      for (; e || n; ) {
        let s = !n || e && e.currentIndex < QR(n, r, o) ? e : n, a = QR(s, r, o), l = s.currentIndex;
        if (s === n) r--, n = n._nextRemoved;
        else if (e = e._next, s.previousIndex == null) r++;
        else {
          o || (o = []);
          let c = a - r, d = l - r;
          if (c != d) {
            for (let h = 0; h < c; h++) {
              let p = h < o.length ? o[h] : o[h] = 0, f = p + h;
              d <= f && f < c && (o[h] = p + 1);
            }
            let u = s.previousIndex;
            o[u] = d - c;
          }
        }
        a !== l && t(s, a, l);
      }
    }
    forEachPreviousItem(t) {
      let e;
      for (e = this._previousItHead; e !== null; e = e._nextPrevious) t(e);
    }
    forEachAddedItem(t) {
      let e;
      for (e = this._additionsHead; e !== null; e = e._nextAdded) t(e);
    }
    forEachMovedItem(t) {
      let e;
      for (e = this._movesHead; e !== null; e = e._nextMoved) t(e);
    }
    forEachRemovedItem(t) {
      let e;
      for (e = this._removalsHead; e !== null; e = e._nextRemoved) t(e);
    }
    forEachIdentityChange(t) {
      let e;
      for (e = this._identityChangesHead; e !== null; e = e._nextIdentityChange) t(e);
    }
    diff(t) {
      if (t == null && (t = []), !CN(t)) throw new ze(900, false);
      return this.check(t) ? this : null;
    }
    onDestroy() {
    }
    check(t) {
      this._reset();
      let e = this._itHead, n = false, r, o, s;
      if (Array.isArray(t)) {
        this.length = t.length;
        for (let a = 0; a < this.length; a++) o = t[a], s = this._trackByFn(a, o), e === null || !Object.is(e.trackById, s) ? (e = this._mismatch(e, o, s, a), n = true) : (n && (e = this._verifyReinsertion(e, o, s, a)), Object.is(e.item, o) || this._addIdentityChange(e, o)), e = e._next;
      } else r = 0, B6(t, (a) => {
        s = this._trackByFn(r, a), e === null || !Object.is(e.trackById, s) ? (e = this._mismatch(e, a, s, r), n = true) : (n && (e = this._verifyReinsertion(e, a, s, r)), Object.is(e.item, a) || this._addIdentityChange(e, a)), e = e._next, r++;
      }), this.length = r;
      return this._truncate(e), this.collection = t, this.isDirty;
    }
    get isDirty() {
      return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
    }
    _reset() {
      if (this.isDirty) {
        let t;
        for (t = this._previousItHead = this._itHead; t !== null; t = t._next) t._nextPrevious = t._next;
        for (t = this._additionsHead; t !== null; t = t._nextAdded) t.previousIndex = t.currentIndex;
        for (this._additionsHead = this._additionsTail = null, t = this._movesHead; t !== null; t = t._nextMoved) t.previousIndex = t.currentIndex;
        this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null;
      }
    }
    _mismatch(t, e, n, r) {
      let o;
      return t === null ? o = this._itTail : (o = t._prev, this._remove(t)), t = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(n, null), t !== null ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, o, r)) : (t = this._linkedRecords === null ? null : this._linkedRecords.get(n, r), t !== null ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, o, r)) : t = this._addAfter(new ES(e, n), o, r)), t;
    }
    _verifyReinsertion(t, e, n, r) {
      let o = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(n, null);
      return o !== null ? t = this._reinsertAfter(o, t._prev, r) : t.currentIndex != r && (t.currentIndex = r, this._addToMoves(t, r)), t;
    }
    _truncate(t) {
      for (; t !== null; ) {
        let e = t._next;
        this._addToRemovals(this._unlink(t)), t = e;
      }
      this._unlinkedRecords !== null && this._unlinkedRecords.clear(), this._additionsTail !== null && (this._additionsTail._nextAdded = null), this._movesTail !== null && (this._movesTail._nextMoved = null), this._itTail !== null && (this._itTail._next = null), this._removalsTail !== null && (this._removalsTail._nextRemoved = null), this._identityChangesTail !== null && (this._identityChangesTail._nextIdentityChange = null);
    }
    _reinsertAfter(t, e, n) {
      this._unlinkedRecords !== null && this._unlinkedRecords.remove(t);
      let r = t._prevRemoved, o = t._nextRemoved;
      return r === null ? this._removalsHead = o : r._nextRemoved = o, o === null ? this._removalsTail = r : o._prevRemoved = r, this._insertAfter(t, e, n), this._addToMoves(t, n), t;
    }
    _moveAfter(t, e, n) {
      return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t;
    }
    _addAfter(t, e, n) {
      return this._insertAfter(t, e, n), this._additionsTail === null ? this._additionsTail = this._additionsHead = t : this._additionsTail = this._additionsTail._nextAdded = t, t;
    }
    _insertAfter(t, e, n) {
      let r = e === null ? this._itHead : e._next;
      return t._next = r, t._prev = e, r === null ? this._itTail = t : r._prev = t, e === null ? this._itHead = t : e._next = t, this._linkedRecords === null && (this._linkedRecords = new yv()), this._linkedRecords.put(t), t.currentIndex = n, t;
    }
    _remove(t) {
      return this._addToRemovals(this._unlink(t));
    }
    _unlink(t) {
      this._linkedRecords !== null && this._linkedRecords.remove(t);
      let e = t._prev, n = t._next;
      return e === null ? this._itHead = n : e._next = n, n === null ? this._itTail = e : n._prev = e, t;
    }
    _addToMoves(t, e) {
      return t.previousIndex === e || (this._movesTail === null ? this._movesTail = this._movesHead = t : this._movesTail = this._movesTail._nextMoved = t), t;
    }
    _addToRemovals(t) {
      return this._unlinkedRecords === null && (this._unlinkedRecords = new yv()), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, this._removalsTail === null ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t;
    }
    _addIdentityChange(t, e) {
      return t.item = e, this._identityChangesTail === null ? this._identityChangesTail = this._identityChangesHead = t : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = t, t;
    }
  };
  var ES = class {
    item;
    trackById;
    currentIndex = null;
    previousIndex = null;
    _nextPrevious = null;
    _prev = null;
    _next = null;
    _prevDup = null;
    _nextDup = null;
    _prevRemoved = null;
    _nextRemoved = null;
    _nextAdded = null;
    _nextMoved = null;
    _nextIdentityChange = null;
    constructor(t, e) {
      this.item = t, this.trackById = e;
    }
  };
  var TS = class {
    _head = null;
    _tail = null;
    add(t) {
      this._head === null ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t);
    }
    get(t, e) {
      let n;
      for (n = this._head; n !== null; n = n._nextDup) if ((e === null || e <= n.currentIndex) && Object.is(n.trackById, t)) return n;
      return null;
    }
    remove(t) {
      let e = t._prevDup, n = t._nextDup;
      return e === null ? this._head = n : e._nextDup = n, n === null ? this._tail = e : n._prevDup = e, this._head === null;
    }
  };
  var yv = class {
    map = /* @__PURE__ */ new Map();
    put(t) {
      let e = t.trackById, n = this.map.get(e);
      n || (n = new TS(), this.map.set(e, n)), n.add(t);
    }
    get(t, e) {
      let n = t, r = this.map.get(n);
      return r ? r.get(t, e) : null;
    }
    remove(t) {
      let e = t.trackById;
      return this.map.get(e).remove(t) && this.map.delete(e), t;
    }
    get isEmpty() {
      return this.map.size === 0;
    }
    clear() {
      this.map.clear();
    }
  };
  function QR(i59, t, e) {
    let n = i59.previousIndex;
    if (n === null) return n;
    let r = 0;
    return e && n < e.length && (r = e[n]), n + t + r;
  }
  function KR() {
    return new Cu([new SS()]);
  }
  var Cu = (() => {
    class i59 {
      factories;
      static \u0275prov = de({ token: i59, providedIn: "root", factory: KR });
      constructor(e) {
        this.factories = e;
      }
      static create(e, n) {
        if (n != null) {
          let r = n.factories.slice();
          e = e.concat(r);
        }
        return new i59(e);
      }
      static extend(e) {
        return { provide: i59, useFactory: (n) => i59.create(e, n || KR()), deps: [[i59, new dO(), new wv()]] };
      }
      find(e) {
        let n = this.factories.find((r) => r.supports(e));
        if (n != null) return n;
        throw new ze(901, false);
      }
    }
    return i59;
  })();
  function HN(i59) {
    try {
      let { rootComponent: t, appProviders: e, platformProviders: n } = i59, r = $$(n), o = [L$({}), { provide: ra, useExisting: V$ }, ...e || []], s = new hv({ providers: o, parent: r, debugName: "", runEnvironmentInitializers: false });
      return G$({ r3Injector: s.injector, platformInjector: r, rootComponent: t });
    } catch (t) {
      return Promise.reject(t);
    }
  }
  function tt(i59) {
    return typeof i59 == "boolean" ? i59 : i59 != null && i59 !== "false";
  }
  function Gn(i59, t = NaN) {
    return !isNaN(parseFloat(i59)) && !isNaN(Number(i59)) ? Number(i59) : t;
  }
  function It(i59, t) {
    no("NgSignals");
    let e = Yw(i59);
    return t?.equal && (e[lr].equal = t.equal), e;
  }
  function Rr(i59) {
    let t = Ht(null);
    try {
      return i59();
    } finally {
      Ht(t);
    }
  }
  var jN = /* @__PURE__ */ (() => {
    class i59 {
      view;
      node;
      constructor(e, n) {
        this.view = e, this.node = n;
      }
      static __NG_ELEMENT_ID__ = Q$;
    }
    return i59;
  })();
  function Q$() {
    return new jN(Ft(), fr());
  }
  var K$ = false;
  var J$ = (() => {
    class i59 extends fv {
      pendingTasks = M(vu);
      taskId = null;
      schedule(e) {
        super.schedule(e), this.taskId === null && (this.taskId = this.pendingTasks.add(), queueMicrotask(() => this.flush()));
      }
      flush() {
        try {
          super.flush();
        } finally {
          this.taskId !== null && (this.pendingTasks.remove(this.taskId), this.taskId = null);
        }
      }
      static \u0275prov = de({ token: i59, providedIn: "root", factory: () => new i59() });
    }
    return i59;
  })();
  var IS = class {
    scheduler;
    effectFn;
    zone;
    injector;
    unregisterOnDestroy;
    watcher;
    constructor(t, e, n, r, o, s) {
      this.scheduler = t, this.effectFn = e, this.zone = n, this.injector = o, this.watcher = NP((a) => this.runEffect(a), () => this.schedule(), s), this.unregisterOnDestroy = r?.onDestroy(() => this.destroy());
    }
    runEffect(t) {
      try {
        this.effectFn(t);
      } catch (e) {
        this.injector.get(Ir, null, { optional: true })?.handleError(e);
      }
    }
    run() {
      this.watcher.run();
    }
    schedule() {
      this.scheduler.schedule(this);
    }
    destroy() {
      this.watcher.destroy(), this.unregisterOnDestroy?.();
    }
  };
  function e9() {
  }
  function WN(i59, t) {
    no("NgSignals"), !t?.injector && pc(e9);
    let e = t?.injector ?? M(mt), n = t?.manualCleanup !== true ? e.get(pi) : null, r = new IS(e.get(J$), i59, typeof Zone > "u" ? null : Zone.current, n, e, t?.allowSignalWrites ?? false), o = e.get(Ge, null, { optional: true });
    return !o || !(o._lView[Ot] & 8) ? r.watcher.notify() : (o._lView[H_] ??= []).push(r.watcher.notify), r;
  }
  var t9 = K$;
  var DS = class {
    [lr];
    constructor(t) {
      this[lr] = t;
    }
    destroy() {
      this[lr].destroy();
    }
  };
  function ht(i59, t) {
    if (t9) return WN(i59, t);
    no("NgSignals"), !t?.injector && pc(ht);
    let e = t?.injector ?? M(mt), n = t?.manualCleanup !== true ? e.get(pi) : null, r, o = e.get(jN, null, { optional: true }), s = e.get(ra);
    return o !== null && !t?.forceRoot ? (r = r9(o.view, s, i59), n instanceof sv && n._lView === o.view && (n = null)) : r = o9(i59, e.get(TN), s), r.injector = e, n !== null && (r.onDestroyFn = n.onDestroy(() => r.destroy())), new DS(r);
  }
  var $N = xt(le({}, Xl), { consumerIsAlwaysLive: true, consumerAllowSignalWrites: true, dirty: true, hasRun: false, cleanupFns: void 0, zone: null, kind: "effect", onDestroyFn: jp, run() {
    if (this.dirty = false, this.hasRun && !Mp(this)) return;
    this.hasRun = true;
    let i59 = (n) => (this.cleanupFns ??= []).push(n), t = Wd(this), e = nv(false);
    try {
      this.maybeCleanup(), this.fn(i59);
    } finally {
      nv(e), Sp(this, t);
    }
  }, maybeCleanup() {
    if (this.cleanupFns?.length) try {
      for (; this.cleanupFns.length; ) this.cleanupFns.pop()();
    } finally {
      this.cleanupFns = [];
    }
  } });
  var n9 = xt(le({}, $N), { consumerMarkedDirty() {
    this.scheduler.schedule(this), this.notifier.notify(13);
  }, destroy() {
    $d(this), this.onDestroyFn(), this.maybeCleanup(), this.scheduler.remove(this);
  } });
  var i92 = xt(le({}, $N), { consumerMarkedDirty() {
    this.view[Ot] |= 8192, Qp(this.view), this.notifier.notify(14);
  }, destroy() {
    $d(this), this.onDestroyFn(), this.maybeCleanup(), this.view[sc]?.delete(this);
  } });
  function r9(i59, t, e) {
    let n = Object.create(i92);
    return n.view = i59, n.zone = typeof Zone < "u" ? Zone.current : null, n.notifier = t, n.fn = e, i59[sc] ??= /* @__PURE__ */ new Set(), i59[sc].add(n), n.consumerMarkedDirty(n), n;
  }
  function o9(i59, t, e) {
    let n = Object.create(n9);
    return n.fn = i59, n.scheduler = t, n.notifier = e, n.zone = typeof Zone < "u" ? Zone.current : null, n.scheduler.schedule(n), n.notifier.notify(13), n;
  }
  function Wv(i59, t) {
    let e = rc(i59), n = t.elementInjector || Mv();
    return new $p(e).create(n, t.projectableNodes, t.hostElement, t.environmentInjector);
  }
  var s9 = { schedule(i59, t) {
    let e = setTimeout(i59, t);
    return () => clearTimeout(e);
  } };
  function a9(i59) {
    return i59.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
  }
  function l9(i59) {
    return !!i59 && i59.nodeType === Node.ELEMENT_NODE;
  }
  var SM;
  function c9(i59, t) {
    if (!SM) {
      let e = Element.prototype;
      SM = e.matches || e.matchesSelector || e.mozMatchesSelector || e.msMatchesSelector || e.oMatchesSelector || e.webkitMatchesSelector;
    }
    return i59.nodeType === Node.ELEMENT_NODE ? SM.call(i59, t) : false;
  }
  function d9(i59) {
    let t = {};
    return i59.forEach(({ propName: e, templateName: n, transform: r }) => {
      t[a9(n)] = [e, r];
    }), t;
  }
  function u9(i59, t) {
    return t.get(Ja).resolveComponentFactory(i59).inputs;
  }
  function h9(i59, t) {
    let e = i59.childNodes, n = t.map(() => []), r = -1;
    t.some((o, s) => o === "*" ? (r = s, true) : false);
    for (let o = 0, s = e.length; o < s; ++o) {
      let a = e[o], l = p9(a, t, r);
      l !== -1 && n[l].push(a);
    }
    return n;
  }
  function p9(i59, t, e) {
    let n = e;
    return l9(i59) && t.some((r, o) => r !== "*" && c9(i59, r) ? (n = o, true) : false), n;
  }
  var f9 = 10;
  var MM = class {
    componentFactory;
    inputMap = /* @__PURE__ */ new Map();
    constructor(t, e) {
      this.componentFactory = e.get(Ja).resolveComponentFactory(t);
      for (let n of this.componentFactory.inputs) this.inputMap.set(n.propName, n.templateName);
    }
    create(t) {
      return new EM(this.componentFactory, t, this.inputMap);
    }
  };
  var EM = class {
    componentFactory;
    injector;
    inputMap;
    eventEmitters = new $o(1);
    events = this.eventEmitters.pipe(Ai((t) => Jn(...t)));
    componentRef = null;
    scheduledDestroyFn = null;
    initialInputValues = /* @__PURE__ */ new Map();
    ngZone;
    elementZone;
    appRef;
    cdScheduler;
    constructor(t, e, n) {
      this.componentFactory = t, this.injector = e, this.inputMap = n, this.ngZone = this.injector.get(We), this.appRef = this.injector.get(Ur), this.cdScheduler = e.get(ra), this.elementZone = typeof Zone > "u" ? null : this.ngZone.run(() => Zone.current);
    }
    connect(t) {
      this.runInZone(() => {
        if (this.scheduledDestroyFn !== null) {
          this.scheduledDestroyFn(), this.scheduledDestroyFn = null;
          return;
        }
        this.componentRef === null && this.initializeComponent(t);
      });
    }
    disconnect() {
      this.runInZone(() => {
        this.componentRef === null || this.scheduledDestroyFn !== null || (this.scheduledDestroyFn = s9.schedule(() => {
          this.componentRef !== null && (this.componentRef.destroy(), this.componentRef = null);
        }, f9));
      });
    }
    getInputValue(t) {
      return this.runInZone(() => this.componentRef === null ? this.initialInputValues.get(t) : this.componentRef.instance[t]);
    }
    setInputValue(t, e) {
      if (this.componentRef === null) {
        this.initialInputValues.set(t, e);
        return;
      }
      this.runInZone(() => {
        this.componentRef.setInput(this.inputMap.get(t) ?? t, e), this.componentRef.hostView.dirty && (this.componentRef.changeDetectorRef.markForRefresh(), this.cdScheduler.notify(6));
      });
    }
    initializeComponent(t) {
      let e = mt.create({ providers: [], parent: this.injector }), n = h9(t, this.componentFactory.ngContentSelectors);
      this.componentRef = this.componentFactory.create(e, n, t), this.initializeInputs(), this.initializeOutputs(this.componentRef), this.appRef.attachView(this.componentRef.hostView), this.componentRef.hostView.detectChanges();
    }
    initializeInputs() {
      for (let [t, e] of this.initialInputValues) this.setInputValue(t, e);
      this.initialInputValues.clear();
    }
    initializeOutputs(t) {
      let e = this.componentFactory.outputs.map(({ propName: n, templateName: r }) => {
        let o = t.instance[n];
        return new Et((s) => {
          let a = o.subscribe((l) => s.next({ name: r, value: l }));
          return () => a.unsubscribe();
        });
      });
      this.eventEmitters.next(e);
    }
    runInZone(t) {
      return this.elementZone && Zone.current !== this.elementZone ? this.ngZone.run(t) : t();
    }
  };
  var TM = class extends HTMLElement {
    ngElementEventsSubscription = null;
  };
  function qN(i59, t) {
    let e = u9(i59, t.injector), n = t.strategyFactory || new MM(i59, t.injector), r = d9(e);
    class o extends TM {
      injector;
      static observedAttributes = Object.keys(r);
      get ngElementStrategy() {
        if (!this._ngElementStrategy) {
          let a = this._ngElementStrategy = n.create(this.injector || t.injector);
          e.forEach(({ propName: l, transform: c }) => {
            if (!this.hasOwnProperty(l)) return;
            let d = this[l];
            delete this[l], a.setInputValue(l, d, c);
          });
        }
        return this._ngElementStrategy;
      }
      _ngElementStrategy;
      constructor(a) {
        super(), this.injector = a;
      }
      attributeChangedCallback(a, l, c, d) {
        let [u, h] = r[a];
        this.ngElementStrategy.setInputValue(u, c, h);
      }
      connectedCallback() {
        let a = false;
        this.ngElementStrategy.events && (this.subscribeToEvents(), a = true), this.ngElementStrategy.connect(this), a || this.subscribeToEvents();
      }
      disconnectedCallback() {
        this._ngElementStrategy && this._ngElementStrategy.disconnect(), this.ngElementEventsSubscription && (this.ngElementEventsSubscription.unsubscribe(), this.ngElementEventsSubscription = null);
      }
      subscribeToEvents() {
        this.ngElementEventsSubscription = this.ngElementStrategy.events.subscribe((a) => {
          let l = new CustomEvent(a.name, { detail: a.value });
          this.dispatchEvent(l);
        });
      }
    }
    return e.forEach(({ propName: s, transform: a }) => {
      Object.defineProperty(o.prototype, s, { get() {
        return this.ngElementStrategy.getInputValue(s);
      }, set(l) {
        this.ngElementStrategy.setInputValue(s, l, a);
      }, configurable: true, enumerable: true });
    }), o;
  }
  var JN = null;
  function da() {
    return JN;
  }
  function ek(i59) {
    JN ??= i59;
  }
  var qv = class {
  };
  var yt = new Ee("");
  var tk = (() => {
    class i59 {
      historyGo(e) {
        throw new Error("");
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: () => M(m9), providedIn: "platform" });
    }
    return i59;
  })();
  var m9 = (() => {
    class i59 extends tk {
      _location;
      _history;
      _doc = M(yt);
      constructor() {
        super(), this._location = window.location, this._history = window.history;
      }
      getBaseHrefFromDOM() {
        return da().getBaseHref(this._doc);
      }
      onPopState(e) {
        let n = da().getGlobalEventTarget(this._doc, "window");
        return n.addEventListener("popstate", e, false), () => n.removeEventListener("popstate", e);
      }
      onHashChange(e) {
        let n = da().getGlobalEventTarget(this._doc, "window");
        return n.addEventListener("hashchange", e, false), () => n.removeEventListener("hashchange", e);
      }
      get href() {
        return this._location.href;
      }
      get protocol() {
        return this._location.protocol;
      }
      get hostname() {
        return this._location.hostname;
      }
      get port() {
        return this._location.port;
      }
      get pathname() {
        return this._location.pathname;
      }
      get search() {
        return this._location.search;
      }
      get hash() {
        return this._location.hash;
      }
      set pathname(e) {
        this._location.pathname = e;
      }
      pushState(e, n, r) {
        this._history.pushState(e, n, r);
      }
      replaceState(e, n, r) {
        this._history.replaceState(e, n, r);
      }
      forward() {
        this._history.forward();
      }
      back() {
        this._history.back();
      }
      historyGo(e = 0) {
        this._history.go(e);
      }
      getState() {
        return this._history.state;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: () => new i59(), providedIn: "platform" });
    }
    return i59;
  })();
  function nk(i59, t) {
    return i59 ? t ? i59.endsWith("/") ? t.startsWith("/") ? i59 + t.slice(1) : i59 + t : t.startsWith("/") ? i59 + t : `${i59}/${t}` : i59 : t;
  }
  function YN(i59) {
    let t = i59.match(/#|\?|$/), e = t && t.index || i59.length, n = e - (i59[e - 1] === "/" ? 1 : 0);
    return i59.slice(0, n) + i59.slice(e);
  }
  function Cc(i59) {
    return i59 && i59[0] !== "?" ? "?" + i59 : i59;
  }
  var RM = (() => {
    class i59 {
      historyGo(e) {
        throw new Error("");
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: () => M(_9), providedIn: "root" });
    }
    return i59;
  })();
  var g9 = new Ee("");
  var _9 = (() => {
    class i59 extends RM {
      _platformLocation;
      _baseHref;
      _removeListenerFns = [];
      constructor(e, n) {
        super(), this._platformLocation = e, this._baseHref = n ?? this._platformLocation.getBaseHrefFromDOM() ?? M(yt).location?.origin ?? "";
      }
      ngOnDestroy() {
        for (; this._removeListenerFns.length; ) this._removeListenerFns.pop()();
      }
      onPopState(e) {
        this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e));
      }
      getBaseHref() {
        return this._baseHref;
      }
      prepareExternalUrl(e) {
        return nk(this._baseHref, e);
      }
      path(e = false) {
        let n = this._platformLocation.pathname + Cc(this._platformLocation.search), r = this._platformLocation.hash;
        return r && e ? `${n}${r}` : n;
      }
      pushState(e, n, r, o) {
        let s = this.prepareExternalUrl(r + Cc(o));
        this._platformLocation.pushState(e, n, s);
      }
      replaceState(e, n, r, o) {
        let s = this.prepareExternalUrl(r + Cc(o));
        this._platformLocation.replaceState(e, n, s);
      }
      forward() {
        this._platformLocation.forward();
      }
      back() {
        this._platformLocation.back();
      }
      getState() {
        return this._platformLocation.getState();
      }
      historyGo(e = 0) {
        this._platformLocation.historyGo?.(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(tk), Ze(g9, 8));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var OM = (() => {
    class i59 {
      _subject = new we();
      _basePath;
      _locationStrategy;
      _urlChangeListeners = [];
      _urlChangeSubscription = null;
      constructor(e) {
        this._locationStrategy = e;
        let n = this._locationStrategy.getBaseHref();
        this._basePath = b9(YN(XN(n))), this._locationStrategy.onPopState((r) => {
          this._subject.next({ url: this.path(true), pop: true, state: r.state, type: r.type });
        });
      }
      ngOnDestroy() {
        this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [];
      }
      path(e = false) {
        return this.normalize(this._locationStrategy.path(e));
      }
      getState() {
        return this._locationStrategy.getState();
      }
      isCurrentPathEqualTo(e, n = "") {
        return this.path() == this.normalize(e + Cc(n));
      }
      normalize(e) {
        return i59.stripTrailingSlash(y9(this._basePath, XN(e)));
      }
      prepareExternalUrl(e) {
        return e && e[0] !== "/" && (e = "/" + e), this._locationStrategy.prepareExternalUrl(e);
      }
      go(e, n = "", r = null) {
        this._locationStrategy.pushState(r, "", e, n), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Cc(n)), r);
      }
      replaceState(e, n = "", r = null) {
        this._locationStrategy.replaceState(r, "", e, n), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + Cc(n)), r);
      }
      forward() {
        this._locationStrategy.forward();
      }
      back() {
        this._locationStrategy.back();
      }
      historyGo(e = 0) {
        this._locationStrategy.historyGo?.(e);
      }
      onUrlChange(e) {
        return this._urlChangeListeners.push(e), this._urlChangeSubscription ??= this.subscribe((n) => {
          this._notifyUrlChangeListeners(n.url, n.state);
        }), () => {
          let n = this._urlChangeListeners.indexOf(e);
          this._urlChangeListeners.splice(n, 1), this._urlChangeListeners.length === 0 && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null);
        };
      }
      _notifyUrlChangeListeners(e = "", n) {
        this._urlChangeListeners.forEach((r) => r(e, n));
      }
      subscribe(e, n, r) {
        return this._subject.subscribe({ next: e, error: n ?? void 0, complete: r ?? void 0 });
      }
      static normalizeQueryParams = Cc;
      static joinWithSlash = nk;
      static stripTrailingSlash = YN;
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(RM));
      };
      static \u0275prov = de({ token: i59, factory: () => v9(), providedIn: "root" });
    }
    return i59;
  })();
  function v9() {
    return new OM(Ze(RM));
  }
  function y9(i59, t) {
    if (!i59 || !t.startsWith(i59)) return t;
    let e = t.substring(i59.length);
    return e === "" || ["/", ";", "?", "#"].includes(e[0]) ? e : t;
  }
  function XN(i59) {
    return i59.replace(/\/index.html$/, "");
  }
  function b9(i59) {
    if (new RegExp("^(https?:)?//").test(i59)) {
      let [, e] = i59.split(/\/\/[^\/]+/);
      return e;
    }
    return i59;
  }
  function ik(i59, t) {
    t = encodeURIComponent(t);
    for (let e of i59.split(";")) {
      let n = e.indexOf("="), [r, o] = n == -1 ? [e, ""] : [e.slice(0, n), e.slice(n + 1)];
      if (r.trim() === t) return decodeURIComponent(o);
    }
    return null;
  }
  var IM = /\s+/;
  var ZN = [];
  var Xv = (() => {
    class i59 {
      _ngEl;
      _renderer;
      initialClasses = ZN;
      rawClass;
      stateMap = /* @__PURE__ */ new Map();
      constructor(e, n) {
        this._ngEl = e, this._renderer = n;
      }
      set klass(e) {
        this.initialClasses = e != null ? e.trim().split(IM) : ZN;
      }
      set ngClass(e) {
        this.rawClass = typeof e == "string" ? e.trim().split(IM) : e;
      }
      ngDoCheck() {
        for (let n of this.initialClasses) this._updateState(n, true);
        let e = this.rawClass;
        if (Array.isArray(e) || e instanceof Set) for (let n of e) this._updateState(n, true);
        else if (e != null) for (let n of Object.keys(e)) this._updateState(n, !!e[n]);
        this._applyStateDiff();
      }
      _updateState(e, n) {
        let r = this.stateMap.get(e);
        r !== void 0 ? (r.enabled !== n && (r.changed = true, r.enabled = n), r.touched = true) : this.stateMap.set(e, { enabled: n, changed: true, touched: true });
      }
      _applyStateDiff() {
        for (let e of this.stateMap) {
          let n = e[0], r = e[1];
          r.changed ? (this._toggleClass(n, r.enabled), r.changed = false) : r.touched || (r.enabled && this._toggleClass(n, false), this.stateMap.delete(n)), r.touched = false;
        }
      }
      _toggleClass(e, n) {
        e = e.trim(), e.length > 0 && e.split(IM).forEach((r) => {
          n ? this._renderer.addClass(this._ngEl.nativeElement, r) : this._renderer.removeClass(this._ngEl.nativeElement, r);
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(He), K(Pr));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "ngClass", ""]], inputs: { klass: [0, "class", "klass"], ngClass: "ngClass" } });
    }
    return i59;
  })();
  var DM = class {
    $implicit;
    ngForOf;
    index;
    count;
    constructor(t, e, n, r) {
      this.$implicit = t, this.ngForOf = e, this.index = n, this.count = r;
    }
    get first() {
      return this.index === 0;
    }
    get last() {
      return this.index === this.count - 1;
    }
    get even() {
      return this.index % 2 === 0;
    }
    get odd() {
      return !this.even;
    }
  };
  var Wr = (() => {
    class i59 {
      _viewContainer;
      _template;
      _differs;
      set ngForOf(e) {
        this._ngForOf = e, this._ngForOfDirty = true;
      }
      set ngForTrackBy(e) {
        this._trackByFn = e;
      }
      get ngForTrackBy() {
        return this._trackByFn;
      }
      _ngForOf = null;
      _ngForOfDirty = true;
      _differ = null;
      _trackByFn;
      constructor(e, n, r) {
        this._viewContainer = e, this._template = n, this._differs = r;
      }
      set ngForTemplate(e) {
        e && (this._template = e);
      }
      ngDoCheck() {
        if (this._ngForOfDirty) {
          this._ngForOfDirty = false;
          let e = this._ngForOf;
          !this._differ && e && (this._differ = this._differs.find(e).create(this.ngForTrackBy));
        }
        if (this._differ) {
          let e = this._differ.diff(this._ngForOf);
          e && this._applyChanges(e);
        }
      }
      _applyChanges(e) {
        let n = this._viewContainer;
        e.forEachOperation((r, o, s) => {
          if (r.previousIndex == null) n.createEmbeddedView(this._template, new DM(r.item, this._ngForOf, -1, -1), s === null ? void 0 : s);
          else if (s == null) n.remove(o === null ? void 0 : o);
          else if (o !== null) {
            let a = n.get(o);
            n.move(a, s), QN(a, r);
          }
        });
        for (let r = 0, o = n.length; r < o; r++) {
          let a = n.get(r).context;
          a.index = r, a.count = o, a.ngForOf = this._ngForOf;
        }
        e.forEachIdentityChange((r) => {
          let o = n.get(r.currentIndex);
          QN(o, r);
        });
      }
      static ngTemplateContextGuard(e, n) {
        return true;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(un), K(ni), K(Cu));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } });
    }
    return i59;
  })();
  function QN(i59, t) {
    i59.context.$implicit = t.item;
  }
  var In = (() => {
    class i59 {
      _viewContainer;
      _context = new PM();
      _thenTemplateRef = null;
      _elseTemplateRef = null;
      _thenViewRef = null;
      _elseViewRef = null;
      constructor(e, n) {
        this._viewContainer = e, this._thenTemplateRef = n;
      }
      set ngIf(e) {
        this._context.$implicit = this._context.ngIf = e, this._updateView();
      }
      set ngIfThen(e) {
        KN("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView();
      }
      set ngIfElse(e) {
        KN("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView();
      }
      _updateView() {
        this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)));
      }
      static ngIfUseIfTypeGuard;
      static ngTemplateGuard_ngIf;
      static ngTemplateContextGuard(e, n) {
        return true;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(un), K(ni));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } });
    }
    return i59;
  })();
  var PM = class {
    $implicit = null;
    ngIf = null;
  };
  function KN(i59, t) {
    if (!!!(!t || t.createEmbeddedView)) throw new Error(`${i59} must be a TemplateRef, but received '${Qr(t)}'.`);
  }
  var Ss = (() => {
    class i59 {
      _viewContainerRef;
      _viewRef = null;
      ngTemplateOutletContext = null;
      ngTemplateOutlet = null;
      ngTemplateOutletInjector = null;
      constructor(e) {
        this._viewContainerRef = e;
      }
      ngOnChanges(e) {
        if (this._shouldRecreateView(e)) {
          let n = this._viewContainerRef;
          if (this._viewRef && n.remove(n.indexOf(this._viewRef)), !this.ngTemplateOutlet) {
            this._viewRef = null;
            return;
          }
          let r = this._createContextForwardProxy();
          this._viewRef = n.createEmbeddedView(this.ngTemplateOutlet, r, { injector: this.ngTemplateOutletInjector ?? void 0 });
        }
      }
      _shouldRecreateView(e) {
        return !!e.ngTemplateOutlet || !!e.ngTemplateOutletInjector;
      }
      _createContextForwardProxy() {
        return new Proxy({}, { set: (e, n, r) => this.ngTemplateOutletContext ? Reflect.set(this.ngTemplateOutletContext, n, r) : false, get: (e, n, r) => {
          if (this.ngTemplateOutletContext) return Reflect.get(this.ngTemplateOutletContext, n, r);
        } });
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(un));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, features: [yn] });
    }
    return i59;
  })();
  var et = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  var AM = "browser";
  var x9 = "server";
  function rk(i59) {
    return i59 === AM;
  }
  function NM(i59) {
    return i59 === x9;
  }
  var Yv = class {
  };
  var LM = class {
  };
  var Su = class i12 {
    headers;
    normalizedNames = /* @__PURE__ */ new Map();
    lazyInit;
    lazyUpdate = null;
    constructor(t) {
      t ? typeof t == "string" ? this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map(), t.split(`
`).forEach((e) => {
          let n = e.indexOf(":");
          if (n > 0) {
            let r = e.slice(0, n), o = e.slice(n + 1).trim();
            this.addHeaderEntry(r, o);
          }
        });
      } : typeof Headers < "u" && t instanceof Headers ? (this.headers = /* @__PURE__ */ new Map(), t.forEach((e, n) => {
        this.addHeaderEntry(n, e);
      })) : this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map(), Object.entries(t).forEach(([e, n]) => {
          this.setHeaderEntries(e, n);
        });
      } : this.headers = /* @__PURE__ */ new Map();
    }
    has(t) {
      return this.init(), this.headers.has(t.toLowerCase());
    }
    get(t) {
      this.init();
      let e = this.headers.get(t.toLowerCase());
      return e && e.length > 0 ? e[0] : null;
    }
    keys() {
      return this.init(), Array.from(this.normalizedNames.values());
    }
    getAll(t) {
      return this.init(), this.headers.get(t.toLowerCase()) || null;
    }
    append(t, e) {
      return this.clone({ name: t, value: e, op: "a" });
    }
    set(t, e) {
      return this.clone({ name: t, value: e, op: "s" });
    }
    delete(t, e) {
      return this.clone({ name: t, value: e, op: "d" });
    }
    maybeSetNormalizedName(t, e) {
      this.normalizedNames.has(e) || this.normalizedNames.set(e, t);
    }
    init() {
      this.lazyInit && (this.lazyInit instanceof i12 ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach((t) => this.applyUpdate(t)), this.lazyUpdate = null));
    }
    copyFrom(t) {
      t.init(), Array.from(t.headers.keys()).forEach((e) => {
        this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e));
      });
    }
    clone(t) {
      let e = new i12();
      return e.lazyInit = this.lazyInit && this.lazyInit instanceof i12 ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e;
    }
    applyUpdate(t) {
      let e = t.name.toLowerCase();
      switch (t.op) {
        case "a":
        case "s":
          let n = t.value;
          if (typeof n == "string" && (n = [n]), n.length === 0) return;
          this.maybeSetNormalizedName(t.name, e);
          let r = (t.op === "a" ? this.headers.get(e) : void 0) || [];
          r.push(...n), this.headers.set(e, r);
          break;
        case "d":
          let o = t.value;
          if (!o) this.headers.delete(e), this.normalizedNames.delete(e);
          else {
            let s = this.headers.get(e);
            if (!s) return;
            s = s.filter((a) => o.indexOf(a) === -1), s.length === 0 ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, s);
          }
          break;
      }
    }
    addHeaderEntry(t, e) {
      let n = t.toLowerCase();
      this.maybeSetNormalizedName(t, n), this.headers.has(n) ? this.headers.get(n).push(e) : this.headers.set(n, [e]);
    }
    setHeaderEntries(t, e) {
      let n = (Array.isArray(e) ? e : [e]).map((o) => o.toString()), r = t.toLowerCase();
      this.headers.set(r, n), this.maybeSetNormalizedName(t, r);
    }
    forEach(t) {
      this.init(), Array.from(this.normalizedNames.keys()).forEach((e) => t(this.normalizedNames.get(e), this.headers.get(e)));
    }
  };
  var FM = class {
    encodeKey(t) {
      return ok(t);
    }
    encodeValue(t) {
      return ok(t);
    }
    decodeKey(t) {
      return decodeURIComponent(t);
    }
    decodeValue(t) {
      return decodeURIComponent(t);
    }
  };
  function C9(i59, t) {
    let e = /* @__PURE__ */ new Map();
    return i59.length > 0 && i59.replace(/^\?/, "").split("&").forEach((r) => {
      let o = r.indexOf("="), [s, a] = o == -1 ? [t.decodeKey(r), ""] : [t.decodeKey(r.slice(0, o)), t.decodeValue(r.slice(o + 1))], l = e.get(s) || [];
      l.push(a), e.set(s, l);
    }), e;
  }
  var S9 = /%(\d[a-f0-9])/gi;
  var M9 = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" };
  function ok(i59) {
    return encodeURIComponent(i59).replace(S9, (t, e) => M9[e] ?? t);
  }
  function Zv(i59) {
    return `${i59}`;
  }
  var tl = class i13 {
    map;
    encoder;
    updates = null;
    cloneFrom = null;
    constructor(t = {}) {
      if (this.encoder = t.encoder || new FM(), t.fromString) {
        if (t.fromObject) throw new ze(2805, false);
        this.map = C9(t.fromString, this.encoder);
      } else t.fromObject ? (this.map = /* @__PURE__ */ new Map(), Object.keys(t.fromObject).forEach((e) => {
        let n = t.fromObject[e], r = Array.isArray(n) ? n.map(Zv) : [Zv(n)];
        this.map.set(e, r);
      })) : this.map = null;
    }
    has(t) {
      return this.init(), this.map.has(t);
    }
    get(t) {
      this.init();
      let e = this.map.get(t);
      return e ? e[0] : null;
    }
    getAll(t) {
      return this.init(), this.map.get(t) || null;
    }
    keys() {
      return this.init(), Array.from(this.map.keys());
    }
    append(t, e) {
      return this.clone({ param: t, value: e, op: "a" });
    }
    appendAll(t) {
      let e = [];
      return Object.keys(t).forEach((n) => {
        let r = t[n];
        Array.isArray(r) ? r.forEach((o) => {
          e.push({ param: n, value: o, op: "a" });
        }) : e.push({ param: n, value: r, op: "a" });
      }), this.clone(e);
    }
    set(t, e) {
      return this.clone({ param: t, value: e, op: "s" });
    }
    delete(t, e) {
      return this.clone({ param: t, value: e, op: "d" });
    }
    toString() {
      return this.init(), this.keys().map((t) => {
        let e = this.encoder.encodeKey(t);
        return this.map.get(t).map((n) => e + "=" + this.encoder.encodeValue(n)).join("&");
      }).filter((t) => t !== "").join("&");
    }
    clone(t) {
      let e = new i13({ encoder: this.encoder });
      return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e;
    }
    init() {
      this.map === null && (this.map = /* @__PURE__ */ new Map()), this.cloneFrom !== null && (this.cloneFrom.init(), this.cloneFrom.keys().forEach((t) => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach((t) => {
        switch (t.op) {
          case "a":
          case "s":
            let e = (t.op === "a" ? this.map.get(t.param) : void 0) || [];
            e.push(Zv(t.value)), this.map.set(t.param, e);
            break;
          case "d":
            if (t.value !== void 0) {
              let n = this.map.get(t.param) || [], r = n.indexOf(Zv(t.value));
              r !== -1 && n.splice(r, 1), n.length > 0 ? this.map.set(t.param, n) : this.map.delete(t.param);
            } else {
              this.map.delete(t.param);
              break;
            }
        }
      }), this.cloneFrom = this.updates = null);
    }
  };
  var BM = class {
    map = /* @__PURE__ */ new Map();
    set(t, e) {
      return this.map.set(t, e), this;
    }
    get(t) {
      return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t);
    }
    delete(t) {
      return this.map.delete(t), this;
    }
    has(t) {
      return this.map.has(t);
    }
    keys() {
      return this.map.keys();
    }
  };
  function E9(i59) {
    switch (i59) {
      case "DELETE":
      case "GET":
      case "HEAD":
      case "OPTIONS":
      case "JSONP":
        return false;
      default:
        return true;
    }
  }
  function sk(i59) {
    return typeof ArrayBuffer < "u" && i59 instanceof ArrayBuffer;
  }
  function ak(i59) {
    return typeof Blob < "u" && i59 instanceof Blob;
  }
  function lk(i59) {
    return typeof FormData < "u" && i59 instanceof FormData;
  }
  function T9(i59) {
    return typeof URLSearchParams < "u" && i59 instanceof URLSearchParams;
  }
  var I9 = "X-Request-URL";
  var ck = "text/plain";
  var dk = "application/json";
  var fwe = `${dk}, ${ck}, */*`;
  var df = class i14 {
    url;
    body = null;
    headers;
    context;
    reportProgress = false;
    withCredentials = false;
    responseType = "json";
    method;
    params;
    urlWithParams;
    transferCache;
    constructor(t, e, n, r) {
      this.url = e, this.method = t.toUpperCase();
      let o;
      if (E9(this.method) || r ? (this.body = n !== void 0 ? n : null, o = r) : o = n, o && (this.reportProgress = !!o.reportProgress, this.withCredentials = !!o.withCredentials, o.responseType && (this.responseType = o.responseType), o.headers && (this.headers = o.headers), o.context && (this.context = o.context), o.params && (this.params = o.params), this.transferCache = o.transferCache), this.headers ??= new Su(), this.context ??= new BM(), !this.params) this.params = new tl(), this.urlWithParams = e;
      else {
        let s = this.params.toString();
        if (s.length === 0) this.urlWithParams = e;
        else {
          let a = e.indexOf("?"), l = a === -1 ? "?" : a < e.length - 1 ? "&" : "";
          this.urlWithParams = e + l + s;
        }
      }
    }
    serializeBody() {
      return this.body === null ? null : typeof this.body == "string" || sk(this.body) || ak(this.body) || lk(this.body) || T9(this.body) ? this.body : this.body instanceof tl ? this.body.toString() : typeof this.body == "object" || typeof this.body == "boolean" || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString();
    }
    detectContentTypeHeader() {
      return this.body === null || lk(this.body) ? null : ak(this.body) ? this.body.type || null : sk(this.body) ? null : typeof this.body == "string" ? ck : this.body instanceof tl ? "application/x-www-form-urlencoded;charset=UTF-8" : typeof this.body == "object" || typeof this.body == "number" || typeof this.body == "boolean" ? dk : null;
    }
    clone(t = {}) {
      let e = t.method || this.method, n = t.url || this.url, r = t.responseType || this.responseType, o = t.transferCache ?? this.transferCache, s = t.body !== void 0 ? t.body : this.body, a = t.withCredentials ?? this.withCredentials, l = t.reportProgress ?? this.reportProgress, c = t.headers || this.headers, d = t.params || this.params, u = t.context ?? this.context;
      return t.setHeaders !== void 0 && (c = Object.keys(t.setHeaders).reduce((h, p) => h.set(p, t.setHeaders[p]), c)), t.setParams && (d = Object.keys(t.setParams).reduce((h, p) => h.set(p, t.setParams[p]), d)), new i14(e, n, s, { params: d, headers: c, context: u, reportProgress: l, responseType: r, withCredentials: a, transferCache: o });
    }
  };
  var uk = function(i59) {
    return i59[i59.Sent = 0] = "Sent", i59[i59.UploadProgress = 1] = "UploadProgress", i59[i59.ResponseHeader = 2] = "ResponseHeader", i59[i59.DownloadProgress = 3] = "DownloadProgress", i59[i59.Response = 4] = "Response", i59[i59.User = 5] = "User", i59;
  }(uk || {});
  var VM = class {
    headers;
    status;
    statusText;
    url;
    ok;
    type;
    constructor(t, e = 200, n = "OK") {
      this.headers = t.headers || new Su(), this.status = t.status !== void 0 ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300;
    }
  };
  var zM = class i15 extends VM {
    body;
    constructor(t = {}) {
      super(t), this.body = t.body !== void 0 ? t.body : null;
    }
    type = uk.Response;
    clone(t = {}) {
      return new i15({ body: t.body !== void 0 ? t.body : this.body, headers: t.headers || this.headers, status: t.status !== void 0 ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 });
    }
  };
  function kM(i59, t) {
    return { body: t, headers: i59.headers, context: i59.context, observe: i59.observe, params: i59.params, reportProgress: i59.reportProgress, responseType: i59.responseType, withCredentials: i59.withCredentials, transferCache: i59.transferCache };
  }
  var hk = (() => {
    class i59 {
      handler;
      constructor(e) {
        this.handler = e;
      }
      request(e, n, r = {}) {
        let o;
        if (e instanceof df) o = e;
        else {
          let l;
          r.headers instanceof Su ? l = r.headers : l = new Su(r.headers);
          let c;
          r.params && (r.params instanceof tl ? c = r.params : c = new tl({ fromObject: r.params })), o = new df(e, n, r.body !== void 0 ? r.body : null, { headers: l, context: r.context, params: c, reportProgress: r.reportProgress, responseType: r.responseType || "json", withCredentials: r.withCredentials, transferCache: r.transferCache });
        }
        let s = qt(o).pipe(nu((l) => this.handler.handle(l)));
        if (e instanceof df || r.observe === "events") return s;
        let a = s.pipe(En((l) => l instanceof zM));
        switch (r.observe || "body") {
          case "body":
            switch (o.responseType) {
              case "arraybuffer":
                return a.pipe(kt((l) => {
                  if (l.body !== null && !(l.body instanceof ArrayBuffer)) throw new ze(2806, false);
                  return l.body;
                }));
              case "blob":
                return a.pipe(kt((l) => {
                  if (l.body !== null && !(l.body instanceof Blob)) throw new ze(2807, false);
                  return l.body;
                }));
              case "text":
                return a.pipe(kt((l) => {
                  if (l.body !== null && typeof l.body != "string") throw new ze(2808, false);
                  return l.body;
                }));
              case "json":
              default:
                return a.pipe(kt((l) => l.body));
            }
          case "response":
            return a;
          default:
            throw new ze(2809, false);
        }
      }
      delete(e, n = {}) {
        return this.request("DELETE", e, n);
      }
      get(e, n = {}) {
        return this.request("GET", e, n);
      }
      head(e, n = {}) {
        return this.request("HEAD", e, n);
      }
      jsonp(e, n) {
        return this.request("JSONP", e, { params: new tl().append(n, "JSONP_CALLBACK"), observe: "body", responseType: "json" });
      }
      options(e, n = {}) {
        return this.request("OPTIONS", e, n);
      }
      patch(e, n, r = {}) {
        return this.request("PATCH", e, kM(r, n));
      }
      post(e, n, r = {}) {
        return this.request("POST", e, kM(r, n));
      }
      put(e, n, r = {}) {
        return this.request("PUT", e, kM(r, n));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(LM));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var mwe = RegExp(`^${I9}:`, "m");
  var GM = class extends qv {
    supportsDOMEvents = true;
  };
  var HM = class i16 extends GM {
    static makeCurrent() {
      ek(new i16());
    }
    onAndCancel(t, e, n, r) {
      return t.addEventListener(e, n, r), () => {
        t.removeEventListener(e, n, r);
      };
    }
    dispatchEvent(t, e) {
      t.dispatchEvent(e);
    }
    remove(t) {
      t.remove();
    }
    createElement(t, e) {
      return e = e || this.getDefaultDocument(), e.createElement(t);
    }
    createHtmlDocument() {
      return document.implementation.createHTMLDocument("fakeTitle");
    }
    getDefaultDocument() {
      return document;
    }
    isElementNode(t) {
      return t.nodeType === Node.ELEMENT_NODE;
    }
    isShadowRoot(t) {
      return t instanceof DocumentFragment;
    }
    getGlobalEventTarget(t, e) {
      return e === "window" ? window : e === "document" ? t : e === "body" ? t.body : null;
    }
    getBaseHref(t) {
      let e = P9();
      return e == null ? null : R9(e);
    }
    resetBaseElement() {
      uf = null;
    }
    getUserAgent() {
      return window.navigator.userAgent;
    }
    getCookie(t) {
      return ik(document.cookie, t);
    }
  };
  var uf = null;
  function P9() {
    return uf = uf || document.querySelector("base"), uf ? uf.getAttribute("href") : null;
  }
  function R9(i59) {
    return new URL(i59, document.baseURI).pathname;
  }
  var O9 = (() => {
    class i59 {
      build() {
        return new XMLHttpRequest();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var jM = new Ee("");
  var _k = (() => {
    class i59 {
      _zone;
      _plugins;
      _eventNameToPlugin = /* @__PURE__ */ new Map();
      constructor(e, n) {
        this._zone = n, e.forEach((r) => {
          r.manager = this;
        }), this._plugins = e.slice().reverse();
      }
      addEventListener(e, n, r, o) {
        return this._findPluginFor(n).addEventListener(e, n, r, o);
      }
      getZone() {
        return this._zone;
      }
      _findPluginFor(e) {
        let n = this._eventNameToPlugin.get(e);
        if (n) return n;
        if (n = this._plugins.find((o) => o.supports(e)), !n) throw new ze(5101, false);
        return this._eventNameToPlugin.set(e, n), n;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(jM), Ze(We));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Kv = class {
    _doc;
    constructor(t) {
      this._doc = t;
    }
    manager;
  };
  var Qv = "ng-app-id";
  function pk(i59) {
    for (let t of i59) t.remove();
  }
  function fk(i59, t) {
    let e = t.createElement("style");
    return e.textContent = i59, e;
  }
  function A9(i59, t, e, n) {
    let r = i59.head?.querySelectorAll(`style[${Qv}="${t}"],link[${Qv}="${t}"]`);
    if (r) for (let o of r) o.removeAttribute(Qv), o instanceof HTMLLinkElement ? n.set(o.href.slice(o.href.lastIndexOf("/") + 1), { usage: 0, elements: [o] }) : o.textContent && e.set(o.textContent, { usage: 0, elements: [o] });
  }
  function WM(i59, t) {
    let e = t.createElement("link");
    return e.setAttribute("rel", "stylesheet"), e.setAttribute("href", i59), e;
  }
  var vk = (() => {
    class i59 {
      doc;
      appId;
      nonce;
      inline = /* @__PURE__ */ new Map();
      external = /* @__PURE__ */ new Map();
      hosts = /* @__PURE__ */ new Set();
      isServer;
      constructor(e, n, r, o = {}) {
        this.doc = e, this.appId = n, this.nonce = r, this.isServer = NM(o), A9(e, n, this.inline, this.external), this.hosts.add(e.head);
      }
      addStyles(e, n) {
        for (let r of e) this.addUsage(r, this.inline, fk);
        n?.forEach((r) => this.addUsage(r, this.external, WM));
      }
      removeStyles(e, n) {
        for (let r of e) this.removeUsage(r, this.inline);
        n?.forEach((r) => this.removeUsage(r, this.external));
      }
      addUsage(e, n, r) {
        let o = n.get(e);
        o ? o.usage++ : n.set(e, { usage: 1, elements: [...this.hosts].map((s) => this.addElement(s, r(e, this.doc))) });
      }
      removeUsage(e, n) {
        let r = n.get(e);
        r && (r.usage--, r.usage <= 0 && (pk(r.elements), n.delete(e)));
      }
      ngOnDestroy() {
        for (let [, { elements: e }] of [...this.inline, ...this.external]) pk(e);
        this.hosts.clear();
      }
      addHost(e) {
        this.hosts.add(e);
        for (let [n, { elements: r }] of this.inline) r.push(this.addElement(e, fk(n, this.doc)));
        for (let [n, { elements: r }] of this.external) r.push(this.addElement(e, WM(n, this.doc)));
      }
      removeHost(e) {
        this.hosts.delete(e);
      }
      addElement(e, n) {
        return this.nonce && n.setAttribute("nonce", this.nonce), this.isServer && n.setAttribute(Qv, this.appId), e.appendChild(n);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(yt), Ze(bu), Ze(ef, 8), Ze(el));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var UM = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/Math/MathML" };
  var qM = /%COMP%/g;
  var yk = "%COMP%";
  var N9 = `_nghost-${yk}`;
  var k9 = `_ngcontent-${yk}`;
  var L9 = true;
  var F9 = new Ee("", { providedIn: "root", factory: () => L9 });
  function B9(i59) {
    return k9.replace(qM, i59);
  }
  function V9(i59) {
    return N9.replace(qM, i59);
  }
  function bk(i59, t) {
    return t.map((e) => e.replace(qM, i59));
  }
  var Jv = (() => {
    class i59 {
      eventManager;
      sharedStylesHost;
      appId;
      removeStylesOnCompDestroy;
      doc;
      platformId;
      ngZone;
      nonce;
      tracingService;
      rendererByCompId = /* @__PURE__ */ new Map();
      defaultRenderer;
      platformIsServer;
      constructor(e, n, r, o, s, a, l, c = null, d = null) {
        this.eventManager = e, this.sharedStylesHost = n, this.appId = r, this.removeStylesOnCompDestroy = o, this.doc = s, this.platformId = a, this.ngZone = l, this.nonce = c, this.tracingService = d, this.platformIsServer = NM(a), this.defaultRenderer = new hf(e, s, l, this.platformIsServer, this.tracingService);
      }
      createRenderer(e, n) {
        if (!e || !n) return this.defaultRenderer;
        this.platformIsServer && n.encapsulation === bs.ShadowDom && (n = xt(le({}, n), { encapsulation: bs.Emulated }));
        let r = this.getOrCreateRenderer(e, n);
        return r instanceof ey ? r.applyToHost(e) : r instanceof pf && r.applyStyles(), r;
      }
      getOrCreateRenderer(e, n) {
        let r = this.rendererByCompId, o = r.get(n.id);
        if (!o) {
          let s = this.doc, a = this.ngZone, l = this.eventManager, c = this.sharedStylesHost, d = this.removeStylesOnCompDestroy, u = this.platformIsServer, h = this.tracingService;
          switch (n.encapsulation) {
            case bs.Emulated:
              o = new ey(l, c, n, this.appId, d, s, a, u, h);
              break;
            case bs.ShadowDom:
              return new $M(l, c, e, n, s, a, this.nonce, u, h);
            default:
              o = new pf(l, c, n, d, s, a, u, h);
              break;
          }
          r.set(n.id, o);
        }
        return o;
      }
      ngOnDestroy() {
        this.rendererByCompId.clear();
      }
      componentReplaced(e) {
        this.rendererByCompId.delete(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(_k), Ze(vk), Ze(bu), Ze(F9), Ze(yt), Ze(el), Ze(We), Ze(ef), Ze(xu, 8));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var hf = class {
    eventManager;
    doc;
    ngZone;
    platformIsServer;
    tracingService;
    data = /* @__PURE__ */ Object.create(null);
    throwOnSyntheticProps = true;
    constructor(t, e, n, r, o) {
      this.eventManager = t, this.doc = e, this.ngZone = n, this.platformIsServer = r, this.tracingService = o;
    }
    destroy() {
    }
    destroyNode = null;
    createElement(t, e) {
      return e ? this.doc.createElementNS(UM[e] || e, t) : this.doc.createElement(t);
    }
    createComment(t) {
      return this.doc.createComment(t);
    }
    createText(t) {
      return this.doc.createTextNode(t);
    }
    appendChild(t, e) {
      (mk(t) ? t.content : t).appendChild(e);
    }
    insertBefore(t, e, n) {
      t && (mk(t) ? t.content : t).insertBefore(e, n);
    }
    removeChild(t, e) {
      e.remove();
    }
    selectRootElement(t, e) {
      let n = typeof t == "string" ? this.doc.querySelector(t) : t;
      if (!n) throw new ze(-5104, false);
      return e || (n.textContent = ""), n;
    }
    parentNode(t) {
      return t.parentNode;
    }
    nextSibling(t) {
      return t.nextSibling;
    }
    setAttribute(t, e, n, r) {
      if (r) {
        e = r + ":" + e;
        let o = UM[r];
        o ? t.setAttributeNS(o, e, n) : t.setAttribute(e, n);
      } else t.setAttribute(e, n);
    }
    removeAttribute(t, e, n) {
      if (n) {
        let r = UM[n];
        r ? t.removeAttributeNS(r, e) : t.removeAttribute(`${n}:${e}`);
      } else t.removeAttribute(e);
    }
    addClass(t, e) {
      t.classList.add(e);
    }
    removeClass(t, e) {
      t.classList.remove(e);
    }
    setStyle(t, e, n, r) {
      r & (sa.DashCase | sa.Important) ? t.style.setProperty(e, n, r & sa.Important ? "important" : "") : t.style[e] = n;
    }
    removeStyle(t, e, n) {
      n & sa.DashCase ? t.style.removeProperty(e) : t.style[e] = "";
    }
    setProperty(t, e, n) {
      t != null && (t[e] = n);
    }
    setValue(t, e) {
      t.nodeValue = e;
    }
    listen(t, e, n, r) {
      if (typeof t == "string" && (t = da().getGlobalEventTarget(this.doc, t), !t)) throw new Error(`Unsupported event target ${t} for event ${e}`);
      let o = this.decoratePreventDefault(n);
      return this.tracingService !== null && this.tracingService.wrapEventListener && (o = this.tracingService.wrapEventListener(t, e, o)), this.eventManager.addEventListener(t, e, o, r);
    }
    decoratePreventDefault(t) {
      return (e) => {
        if (e === "__ngUnwrap__") return t;
        (this.platformIsServer ? this.ngZone.runGuarded(() => t(e)) : t(e)) === false && e.preventDefault();
      };
    }
  };
  function mk(i59) {
    return i59.tagName === "TEMPLATE" && i59.content !== void 0;
  }
  var $M = class extends hf {
    sharedStylesHost;
    hostEl;
    shadowRoot;
    constructor(t, e, n, r, o, s, a, l, c) {
      super(t, o, s, l, c), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot);
      let d = r.styles;
      d = bk(r.id, d);
      for (let h of d) {
        let p = document.createElement("style");
        a && p.setAttribute("nonce", a), p.textContent = h, this.shadowRoot.appendChild(p);
      }
      let u = r.getExternalStyles?.();
      if (u) for (let h of u) {
        let p = WM(h, o);
        a && p.setAttribute("nonce", a), this.shadowRoot.appendChild(p);
      }
    }
    nodeOrShadowRoot(t) {
      return t === this.hostEl ? this.shadowRoot : t;
    }
    appendChild(t, e) {
      return super.appendChild(this.nodeOrShadowRoot(t), e);
    }
    insertBefore(t, e, n) {
      return super.insertBefore(this.nodeOrShadowRoot(t), e, n);
    }
    removeChild(t, e) {
      return super.removeChild(null, e);
    }
    parentNode(t) {
      return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t)));
    }
    destroy() {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
  };
  var pf = class extends hf {
    sharedStylesHost;
    removeStylesOnCompDestroy;
    styles;
    styleUrls;
    constructor(t, e, n, r, o, s, a, l, c) {
      super(t, o, s, a, l), this.sharedStylesHost = e, this.removeStylesOnCompDestroy = r;
      let d = n.styles;
      this.styles = c ? bk(c, d) : d, this.styleUrls = n.getExternalStyles?.(c);
    }
    applyStyles() {
      this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
    }
    destroy() {
      this.removeStylesOnCompDestroy && this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
    }
  };
  var ey = class extends pf {
    contentAttr;
    hostAttr;
    constructor(t, e, n, r, o, s, a, l, c) {
      let d = r + "-" + n.id;
      super(t, e, n, o, s, a, l, c, d), this.contentAttr = B9(d), this.hostAttr = V9(d);
    }
    applyToHost(t) {
      this.applyStyles(), this.setAttribute(t, this.hostAttr, "");
    }
    createElement(t, e) {
      let n = super.createElement(t, e);
      return super.setAttribute(n, this.contentAttr, ""), n;
    }
  };
  var z9 = (() => {
    class i59 extends Kv {
      constructor(e) {
        super(e);
      }
      supports(e) {
        return true;
      }
      addEventListener(e, n, r, o) {
        return e.addEventListener(n, r, o), () => this.removeEventListener(e, n, r, o);
      }
      removeEventListener(e, n, r, o) {
        return e.removeEventListener(n, r, o);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(yt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var gk = ["alt", "control", "meta", "shift"];
  var U9 = { "\b": "Backspace", "	": "Tab", "\x7F": "Delete", "\x1B": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" };
  var G9 = { alt: (i59) => i59.altKey, control: (i59) => i59.ctrlKey, meta: (i59) => i59.metaKey, shift: (i59) => i59.shiftKey };
  var H9 = (() => {
    class i59 extends Kv {
      constructor(e) {
        super(e);
      }
      supports(e) {
        return i59.parseEventName(e) != null;
      }
      addEventListener(e, n, r, o) {
        let s = i59.parseEventName(n), a = i59.eventCallback(s.fullKey, r, this.manager.getZone());
        return this.manager.getZone().runOutsideAngular(() => da().onAndCancel(e, s.domEventName, a, o));
      }
      static parseEventName(e) {
        let n = e.toLowerCase().split("."), r = n.shift();
        if (n.length === 0 || !(r === "keydown" || r === "keyup")) return null;
        let o = i59._normalizeKey(n.pop()), s = "", a = n.indexOf("code");
        if (a > -1 && (n.splice(a, 1), s = "code."), gk.forEach((c) => {
          let d = n.indexOf(c);
          d > -1 && (n.splice(d, 1), s += c + ".");
        }), s += o, n.length != 0 || o.length === 0) return null;
        let l = {};
        return l.domEventName = r, l.fullKey = s, l;
      }
      static matchEventFullKeyCode(e, n) {
        let r = U9[e.key] || e.key, o = "";
        return n.indexOf("code.") > -1 && (r = e.code, o = "code."), r == null || !r ? false : (r = r.toLowerCase(), r === " " ? r = "space" : r === "." && (r = "dot"), gk.forEach((s) => {
          if (s !== r) {
            let a = G9[s];
            a(e) && (o += s + ".");
          }
        }), o += r, o === n);
      }
      static eventCallback(e, n, r) {
        return (o) => {
          i59.matchEventFullKeyCode(o, e) && r.runGuarded(() => n(o));
        };
      }
      static _normalizeKey(e) {
        return e === "esc" ? "escape" : e;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(yt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  function xk(i59) {
    return HN(j9(i59));
  }
  function j9(i59) {
    return { appProviders: [...X9, ...i59?.providers ?? []], platformProviders: Y9 };
  }
  function W9() {
    HM.makeCurrent();
  }
  function $9() {
    return new Ir();
  }
  function q9() {
    return uA(document), document;
  }
  var Y9 = [{ provide: el, useValue: AM }, { provide: KS, useValue: W9, multi: true }, { provide: yt, useFactory: q9, deps: [] }];
  var X9 = [{ provide: Sv, useValue: "root" }, { provide: Ir, useFactory: $9, deps: [] }, { provide: jM, useClass: z9, multi: true, deps: [yt] }, { provide: jM, useClass: H9, multi: true, deps: [yt] }, Jv, vk, _k, { provide: pr, useExisting: Jv }, { provide: Yv, useClass: O9, deps: [] }, []];
  var YM = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: function(n) {
        let r = null;
        return n ? r = new (n || i59)() : r = Ze(Z9), r;
      }, providedIn: "root" });
    }
    return i59;
  })();
  var Z9 = (() => {
    class i59 extends YM {
      _doc;
      constructor(e) {
        super(), this._doc = e;
      }
      sanitize(e, n) {
        if (n == null) return null;
        switch (e) {
          case Dr.NONE:
            return n;
          case Dr.HTML:
            return yc(n, "HTML") ? Cs(n) : TA(this._doc, String(n)).toString();
          case Dr.STYLE:
            return yc(n, "Style") ? Cs(n) : n;
          case Dr.SCRIPT:
            if (yc(n, "Script")) return Cs(n);
            throw new ze(5200, false);
          case Dr.URL:
            return yc(n, "URL") ? Cs(n) : Fv(String(n));
          case Dr.RESOURCE_URL:
            if (yc(n, "ResourceURL")) return Cs(n);
            throw new ze(5201, false);
          default:
            throw new ze(5202, false);
        }
      }
      bypassSecurityTrustHtml(e) {
        return _A(e);
      }
      bypassSecurityTrustStyle(e) {
        return vA(e);
      }
      bypassSecurityTrustScript(e) {
        return yA(e);
      }
      bypassSecurityTrustUrl(e) {
        return bA(e);
      }
      bypassSecurityTrustResourceUrl(e) {
        return xA(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(yt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Ms = globalThis;
  function Co(i59) {
    return (Ms.__Zone_symbol_prefix || "__zone_symbol__") + i59;
  }
  function K9() {
    let i59 = Ms.performance;
    function t(k) {
      i59 && i59.mark && i59.mark(k);
    }
    function e(k, z) {
      i59 && i59.measure && i59.measure(k, z);
    }
    t("Zone");
    let n = (() => {
      class k {
        static {
          this.__symbol__ = Co;
        }
        static assertZonePatched() {
          if (Ms.Promise !== H.ZoneAwarePromise) throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)");
        }
        static get root() {
          let R = k.current;
          for (; R.parent; ) R = R.parent;
          return R;
        }
        static get current() {
          return I.zone;
        }
        static get currentTask() {
          return F;
        }
        static __load_patch(R, V, ie = false) {
          if (H.hasOwnProperty(R)) {
            let re = Ms[Co("forceDuplicateZoneCheck")] === true;
            if (!ie && re) throw Error("Already loaded patch: " + R);
          } else if (!Ms["__Zone_disable_" + R]) {
            let re = "Zone:" + R;
            t(re), H[R] = V(Ms, k, O), e(re, re);
          }
        }
        get parent() {
          return this._parent;
        }
        get name() {
          return this._name;
        }
        constructor(R, V) {
          this._parent = R, this._name = V ? V.name || "unnamed" : "<root>", this._properties = V && V.properties || {}, this._zoneDelegate = new o(this, this._parent && this._parent._zoneDelegate, V);
        }
        get(R) {
          let V = this.getZoneWith(R);
          if (V) return V._properties[R];
        }
        getZoneWith(R) {
          let V = this;
          for (; V; ) {
            if (V._properties.hasOwnProperty(R)) return V;
            V = V._parent;
          }
          return null;
        }
        fork(R) {
          if (!R) throw new Error("ZoneSpec required!");
          return this._zoneDelegate.fork(this, R);
        }
        wrap(R, V) {
          if (typeof R != "function") throw new Error("Expecting function got: " + R);
          let ie = this._zoneDelegate.intercept(this, R, V), re = this;
          return function() {
            return re.runGuarded(ie, this, arguments, V);
          };
        }
        run(R, V, ie, re) {
          I = { parent: I, zone: this };
          try {
            return this._zoneDelegate.invoke(this, R, V, ie, re);
          } finally {
            I = I.parent;
          }
        }
        runGuarded(R, V = null, ie, re) {
          I = { parent: I, zone: this };
          try {
            try {
              return this._zoneDelegate.invoke(this, R, V, ie, re);
            } catch (Re) {
              if (this._zoneDelegate.handleError(this, Re)) throw Re;
            }
          } finally {
            I = I.parent;
          }
        }
        runTask(R, V, ie) {
          if (R.zone != this) throw new Error("A task can only be run in the zone of creation! (Creation: " + (R.zone || v).name + "; Execution: " + this.name + ")");
          let re = R, { type: Re, data: { isPeriodic: ne = false, isRefreshable: oe = false } = {} } = R;
          if (R.state === _ && (Re === W || Re === A)) return;
          let Be = R.state != w;
          Be && re._transitionTo(w, y);
          let me = F;
          F = re, I = { parent: I, zone: this };
          try {
            Re == A && R.data && !ne && !oe && (R.cancelFn = void 0);
            try {
              return this._zoneDelegate.invokeTask(this, re, V, ie);
            } catch (Ve) {
              if (this._zoneDelegate.handleError(this, Ve)) throw Ve;
            }
          } finally {
            let Ve = R.state;
            if (Ve !== _ && Ve !== P) if (Re == W || ne || oe && Ve === g) Be && re._transitionTo(y, w, g);
            else {
              let ue = re._zoneDelegates;
              this._updateTaskCount(re, -1), Be && re._transitionTo(_, w, _), oe && (re._zoneDelegates = ue);
            }
            I = I.parent, F = me;
          }
        }
        scheduleTask(R) {
          if (R.zone && R.zone !== this) {
            let ie = this;
            for (; ie; ) {
              if (ie === R.zone) throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${R.zone.name}`);
              ie = ie.parent;
            }
          }
          R._transitionTo(g, _);
          let V = [];
          R._zoneDelegates = V, R._zone = this;
          try {
            R = this._zoneDelegate.scheduleTask(this, R);
          } catch (ie) {
            throw R._transitionTo(P, g, _), this._zoneDelegate.handleError(this, ie), ie;
          }
          return R._zoneDelegates === V && this._updateTaskCount(R, 1), R.state == g && R._transitionTo(y, g), R;
        }
        scheduleMicroTask(R, V, ie, re) {
          return this.scheduleTask(new s(S, R, V, ie, re, void 0));
        }
        scheduleMacroTask(R, V, ie, re, Re) {
          return this.scheduleTask(new s(A, R, V, ie, re, Re));
        }
        scheduleEventTask(R, V, ie, re, Re) {
          return this.scheduleTask(new s(W, R, V, ie, re, Re));
        }
        cancelTask(R) {
          if (R.zone != this) throw new Error("A task can only be cancelled in the zone of creation! (Creation: " + (R.zone || v).name + "; Execution: " + this.name + ")");
          if (!(R.state !== y && R.state !== w)) {
            R._transitionTo(E, y, w);
            try {
              this._zoneDelegate.cancelTask(this, R);
            } catch (V) {
              throw R._transitionTo(P, E), this._zoneDelegate.handleError(this, V), V;
            }
            return this._updateTaskCount(R, -1), R._transitionTo(_, E), R.runCount = -1, R;
          }
        }
        _updateTaskCount(R, V) {
          let ie = R._zoneDelegates;
          V == -1 && (R._zoneDelegates = null);
          for (let re = 0; re < ie.length; re++) ie[re]._updateTaskCount(R.type, V);
        }
      }
      return k;
    })(), r = { name: "", onHasTask: (k, z, R, V) => k.hasTask(R, V), onScheduleTask: (k, z, R, V) => k.scheduleTask(R, V), onInvokeTask: (k, z, R, V, ie, re) => k.invokeTask(R, V, ie, re), onCancelTask: (k, z, R, V) => k.cancelTask(R, V) };
    class o {
      get zone() {
        return this._zone;
      }
      constructor(z, R, V) {
        this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }, this._zone = z, this._parentDelegate = R, this._forkZS = V && (V && V.onFork ? V : R._forkZS), this._forkDlgt = V && (V.onFork ? R : R._forkDlgt), this._forkCurrZone = V && (V.onFork ? this._zone : R._forkCurrZone), this._interceptZS = V && (V.onIntercept ? V : R._interceptZS), this._interceptDlgt = V && (V.onIntercept ? R : R._interceptDlgt), this._interceptCurrZone = V && (V.onIntercept ? this._zone : R._interceptCurrZone), this._invokeZS = V && (V.onInvoke ? V : R._invokeZS), this._invokeDlgt = V && (V.onInvoke ? R : R._invokeDlgt), this._invokeCurrZone = V && (V.onInvoke ? this._zone : R._invokeCurrZone), this._handleErrorZS = V && (V.onHandleError ? V : R._handleErrorZS), this._handleErrorDlgt = V && (V.onHandleError ? R : R._handleErrorDlgt), this._handleErrorCurrZone = V && (V.onHandleError ? this._zone : R._handleErrorCurrZone), this._scheduleTaskZS = V && (V.onScheduleTask ? V : R._scheduleTaskZS), this._scheduleTaskDlgt = V && (V.onScheduleTask ? R : R._scheduleTaskDlgt), this._scheduleTaskCurrZone = V && (V.onScheduleTask ? this._zone : R._scheduleTaskCurrZone), this._invokeTaskZS = V && (V.onInvokeTask ? V : R._invokeTaskZS), this._invokeTaskDlgt = V && (V.onInvokeTask ? R : R._invokeTaskDlgt), this._invokeTaskCurrZone = V && (V.onInvokeTask ? this._zone : R._invokeTaskCurrZone), this._cancelTaskZS = V && (V.onCancelTask ? V : R._cancelTaskZS), this._cancelTaskDlgt = V && (V.onCancelTask ? R : R._cancelTaskDlgt), this._cancelTaskCurrZone = V && (V.onCancelTask ? this._zone : R._cancelTaskCurrZone), this._hasTaskZS = null, this._hasTaskDlgt = null, this._hasTaskDlgtOwner = null, this._hasTaskCurrZone = null;
        let ie = V && V.onHasTask, re = R && R._hasTaskZS;
        (ie || re) && (this._hasTaskZS = ie ? V : r, this._hasTaskDlgt = R, this._hasTaskDlgtOwner = this, this._hasTaskCurrZone = this._zone, V.onScheduleTask || (this._scheduleTaskZS = r, this._scheduleTaskDlgt = R, this._scheduleTaskCurrZone = this._zone), V.onInvokeTask || (this._invokeTaskZS = r, this._invokeTaskDlgt = R, this._invokeTaskCurrZone = this._zone), V.onCancelTask || (this._cancelTaskZS = r, this._cancelTaskDlgt = R, this._cancelTaskCurrZone = this._zone));
      }
      fork(z, R) {
        return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, z, R) : new n(z, R);
      }
      intercept(z, R, V) {
        return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, z, R, V) : R;
      }
      invoke(z, R, V, ie, re) {
        return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, z, R, V, ie, re) : R.apply(V, ie);
      }
      handleError(z, R) {
        return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, z, R) : true;
      }
      scheduleTask(z, R) {
        let V = R;
        if (this._scheduleTaskZS) this._hasTaskZS && V._zoneDelegates.push(this._hasTaskDlgtOwner), V = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, z, R), V || (V = R);
        else if (R.scheduleFn) R.scheduleFn(R);
        else if (R.type == S) f(R);
        else throw new Error("Task is missing scheduleFn.");
        return V;
      }
      invokeTask(z, R, V, ie) {
        return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, z, R, V, ie) : R.callback.apply(V, ie);
      }
      cancelTask(z, R) {
        let V;
        if (this._cancelTaskZS) V = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, z, R);
        else {
          if (!R.cancelFn) throw Error("Task is not cancelable");
          V = R.cancelFn(R);
        }
        return V;
      }
      hasTask(z, R) {
        try {
          this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, z, R);
        } catch (V) {
          this.handleError(z, V);
        }
      }
      _updateTaskCount(z, R) {
        let V = this._taskCounts, ie = V[z], re = V[z] = ie + R;
        if (re < 0) throw new Error("More tasks executed then were scheduled.");
        if (ie == 0 || re == 0) {
          let Re = { microTask: V.microTask > 0, macroTask: V.macroTask > 0, eventTask: V.eventTask > 0, change: z };
          this.hasTask(this._zone, Re);
        }
      }
    }
    class s {
      constructor(z, R, V, ie, re, Re) {
        if (this._zone = null, this.runCount = 0, this._zoneDelegates = null, this._state = "notScheduled", this.type = z, this.source = R, this.data = ie, this.scheduleFn = re, this.cancelFn = Re, !V) throw new Error("callback is not defined");
        this.callback = V;
        let ne = this;
        z === W && ie && ie.useG ? this.invoke = s.invokeTask : this.invoke = function() {
          return s.invokeTask.call(Ms, ne, this, arguments);
        };
      }
      static invokeTask(z, R, V) {
        z || (z = this), j++;
        try {
          return z.runCount++, z.zone.runTask(z, R, V);
        } finally {
          j == 1 && m(), j--;
        }
      }
      get zone() {
        return this._zone;
      }
      get state() {
        return this._state;
      }
      cancelScheduleRequest() {
        this._transitionTo(_, g);
      }
      _transitionTo(z, R, V) {
        if (this._state === R || this._state === V) this._state = z, z == _ && (this._zoneDelegates = null);
        else throw new Error(`${this.type} '${this.source}': can not transition to '${z}', expecting state '${R}'${V ? " or '" + V + "'" : ""}, was '${this._state}'.`);
      }
      toString() {
        return this.data && typeof this.data.handleId < "u" ? this.data.handleId.toString() : Object.prototype.toString.call(this);
      }
      toJSON() {
        return { type: this.type, state: this.state, source: this.source, zone: this.zone.name, runCount: this.runCount };
      }
    }
    let a = Co("setTimeout"), l = Co("Promise"), c = Co("then"), d = [], u = false, h;
    function p(k) {
      if (h || Ms[l] && (h = Ms[l].resolve(0)), h) {
        let z = h[c];
        z || (z = h.then), z.call(h, k);
      } else Ms[a](k, 0);
    }
    function f(k) {
      j === 0 && d.length === 0 && p(m), k && d.push(k);
    }
    function m() {
      if (!u) {
        for (u = true; d.length; ) {
          let k = d;
          d = [];
          for (let z = 0; z < k.length; z++) {
            let R = k[z];
            try {
              R.zone.runTask(R, null, null);
            } catch (V) {
              O.onUnhandledError(V);
            }
          }
        }
        O.microtaskDrainDone(), u = false;
      }
    }
    let v = { name: "NO ZONE" }, _ = "notScheduled", g = "scheduling", y = "scheduled", w = "running", E = "canceling", P = "unknown", S = "microTask", A = "macroTask", W = "eventTask", H = {}, O = { symbol: Co, currentZoneFrame: () => I, onUnhandledError: $, microtaskDrainDone: $, scheduleMicroTask: f, showUncaughtError: () => !n[Co("ignoreConsoleErrorUncaughtError")], patchEventTarget: () => [], patchOnProperties: $, patchMethod: () => $, bindArguments: () => [], patchThen: () => $, patchMacroTask: () => $, patchEventPrototype: () => $, isIEOrEdge: () => false, getGlobalObjects: () => {
    }, ObjectDefineProperty: () => $, ObjectGetOwnPropertyDescriptor: () => {
    }, ObjectCreate: () => {
    }, ArraySlice: () => [], patchClass: () => $, wrapWithCurrentZone: () => $, filterProperties: () => [], attachOriginToPatched: () => $, _redefineProperty: () => $, patchCallbacks: () => $, nativeScheduleMicroTask: p }, I = { parent: null, zone: new n(null, null) }, F = null, j = 0;
    function $() {
    }
    return e("Zone", "Zone"), n;
  }
  function J9() {
    let i59 = globalThis, t = i59[Co("forceDuplicateZoneCheck")] === true;
    if (i59.Zone && (t || typeof i59.Zone.__symbol__ != "function")) throw new Error("Zone already loaded.");
    return i59.Zone ??= K9(), i59.Zone;
  }
  var mf = Object.getOwnPropertyDescriptor;
  var JM = Object.defineProperty;
  var eE = Object.getPrototypeOf;
  var e7 = Object.create;
  var t7 = Array.prototype.slice;
  var tE = "addEventListener";
  var nE = "removeEventListener";
  var XM = Co(tE);
  var ZM = Co(nE);
  var ua = "true";
  var ha = "false";
  var gf = Co("");
  function iE(i59, t) {
    return Zone.current.wrap(i59, t);
  }
  function rE(i59, t, e, n, r) {
    return Zone.current.scheduleMacroTask(i59, t, e, n, r);
  }
  var xn = Co;
  var iy = typeof window < "u";
  var Tu = iy ? window : void 0;
  var Di = iy && Tu || globalThis;
  var n7 = "removeAttribute";
  function oE(i59, t) {
    for (let e = i59.length - 1; e >= 0; e--) typeof i59[e] == "function" && (i59[e] = iE(i59[e], t + "_" + e));
    return i59;
  }
  function i72(i59, t) {
    let e = i59.constructor.name;
    for (let n = 0; n < t.length; n++) {
      let r = t[n], o = i59[r];
      if (o) {
        let s = mf(i59, r);
        if (!Ik(s)) continue;
        i59[r] = ((a) => {
          let l = function() {
            return a.apply(this, oE(arguments, e + "." + r));
          };
          return fa(l, a), l;
        })(o);
      }
    }
  }
  function Ik(i59) {
    return i59 ? i59.writable === false ? false : !(typeof i59.get == "function" && typeof i59.set > "u") : true;
  }
  var Dk = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
  var ry = !("nw" in Di) && typeof Di.process < "u" && Di.process.toString() === "[object process]";
  var sE = !ry && !Dk && !!(iy && Tu.HTMLElement);
  var Pk = typeof Di.process < "u" && Di.process.toString() === "[object process]" && !Dk && !!(iy && Tu.HTMLElement);
  var ny = {};
  var r7 = xn("enable_beforeunload");
  var wk = function(i59) {
    if (i59 = i59 || Di.event, !i59) return;
    let t = ny[i59.type];
    t || (t = ny[i59.type] = xn("ON_PROPERTY" + i59.type));
    let e = this || i59.target || Di, n = e[t], r;
    if (sE && e === Tu && i59.type === "error") {
      let o = i59;
      r = n && n.call(this, o.message, o.filename, o.lineno, o.colno, o.error), r === true && i59.preventDefault();
    } else r = n && n.apply(this, arguments), i59.type === "beforeunload" && Di[r7] && typeof r == "string" ? i59.returnValue = r : r != null && !r && i59.preventDefault();
    return r;
  };
  function Ck(i59, t, e) {
    let n = mf(i59, t);
    if (!n && e && mf(e, t) && (n = { enumerable: true, configurable: true }), !n || !n.configurable) return;
    let r = xn("on" + t + "patched");
    if (i59.hasOwnProperty(r) && i59[r]) return;
    delete n.writable, delete n.value;
    let o = n.get, s = n.set, a = t.slice(2), l = ny[a];
    l || (l = ny[a] = xn("ON_PROPERTY" + a)), n.set = function(c) {
      let d = this;
      if (!d && i59 === Di && (d = Di), !d) return;
      typeof d[l] == "function" && d.removeEventListener(a, wk), s && s.call(d, null), d[l] = c, typeof c == "function" && d.addEventListener(a, wk, false);
    }, n.get = function() {
      let c = this;
      if (!c && i59 === Di && (c = Di), !c) return null;
      let d = c[l];
      if (d) return d;
      if (o) {
        let u = o.call(this);
        if (u) return n.set.call(this, u), typeof c[n7] == "function" && c.removeAttribute(t), u;
      }
      return null;
    }, JM(i59, t, n), i59[r] = true;
  }
  function Rk(i59, t, e) {
    if (t) for (let n = 0; n < t.length; n++) Ck(i59, "on" + t[n], e);
    else {
      let n = [];
      for (let r in i59) r.slice(0, 2) == "on" && n.push(r);
      for (let r = 0; r < n.length; r++) Ck(i59, n[r], e);
    }
  }
  var Qo = xn("originalInstance");
  function ff(i59) {
    let t = Di[i59];
    if (!t) return;
    Di[xn(i59)] = t, Di[i59] = function() {
      let r = oE(arguments, i59);
      switch (r.length) {
        case 0:
          this[Qo] = new t();
          break;
        case 1:
          this[Qo] = new t(r[0]);
          break;
        case 2:
          this[Qo] = new t(r[0], r[1]);
          break;
        case 3:
          this[Qo] = new t(r[0], r[1], r[2]);
          break;
        case 4:
          this[Qo] = new t(r[0], r[1], r[2], r[3]);
          break;
        default:
          throw new Error("Arg list too long.");
      }
    }, fa(Di[i59], t);
    let e = new t(function() {
    }), n;
    for (n in e) i59 === "XMLHttpRequest" && n === "responseBlob" || function(r) {
      typeof e[r] == "function" ? Di[i59].prototype[r] = function() {
        return this[Qo][r].apply(this[Qo], arguments);
      } : JM(Di[i59].prototype, r, { set: function(o) {
        typeof o == "function" ? (this[Qo][r] = iE(o, i59 + "." + r), fa(this[Qo][r], o)) : this[Qo][r] = o;
      }, get: function() {
        return this[Qo][r];
      } });
    }(n);
    for (n in t) n !== "prototype" && t.hasOwnProperty(n) && (Di[i59][n] = t[n]);
  }
  function pa(i59, t, e) {
    let n = i59;
    for (; n && !n.hasOwnProperty(t); ) n = eE(n);
    !n && i59[t] && (n = i59);
    let r = xn(t), o = null;
    if (n && (!(o = n[r]) || !n.hasOwnProperty(r))) {
      o = n[r] = n[t];
      let s = n && mf(n, t);
      if (Ik(s)) {
        let a = e(o, r, t);
        n[t] = function() {
          return a(this, arguments);
        }, fa(n[t], o);
      }
    }
    return o;
  }
  function o7(i59, t, e) {
    let n = null;
    function r(o) {
      let s = o.data;
      return s.args[s.cbIdx] = function() {
        o.invoke.apply(this, arguments);
      }, n.apply(s.target, s.args), o;
    }
    n = pa(i59, t, (o) => function(s, a) {
      let l = e(s, a);
      return l.cbIdx >= 0 && typeof a[l.cbIdx] == "function" ? rE(l.name, a[l.cbIdx], l, r) : o.apply(s, a);
    });
  }
  function fa(i59, t) {
    i59[xn("OriginalDelegate")] = t;
  }
  var Sk = false;
  var QM = false;
  function s7() {
    try {
      let i59 = Tu.navigator.userAgent;
      if (i59.indexOf("MSIE ") !== -1 || i59.indexOf("Trident/") !== -1) return true;
    } catch {
    }
    return false;
  }
  function a7() {
    if (Sk) return QM;
    Sk = true;
    try {
      let i59 = Tu.navigator.userAgent;
      (i59.indexOf("MSIE ") !== -1 || i59.indexOf("Trident/") !== -1 || i59.indexOf("Edge/") !== -1) && (QM = true);
    } catch {
    }
    return QM;
  }
  function Mk(i59) {
    return typeof i59 == "function";
  }
  function Ek(i59) {
    return typeof i59 == "number";
  }
  var Eu = false;
  if (typeof window < "u") try {
    let i59 = Object.defineProperty({}, "passive", { get: function() {
      Eu = true;
    } });
    window.addEventListener("test", i59, i59), window.removeEventListener("test", i59, i59);
  } catch {
    Eu = false;
  }
  var l7 = { useG: true };
  var So = {};
  var Ok = {};
  var Ak = new RegExp("^" + gf + "(\\w+)(true|false)$");
  var Nk = xn("propagationStopped");
  function kk(i59, t) {
    let e = (t ? t(i59) : i59) + ha, n = (t ? t(i59) : i59) + ua, r = gf + e, o = gf + n;
    So[i59] = {}, So[i59][ha] = r, So[i59][ua] = o;
  }
  function c7(i59, t, e, n) {
    let r = n && n.add || tE, o = n && n.rm || nE, s = n && n.listeners || "eventListeners", a = n && n.rmAll || "removeAllListeners", l = xn(r), c = "." + r + ":", d = "prependListener", u = "." + d + ":", h = function(g, y, w) {
      if (g.isRemoved) return;
      let E = g.callback;
      typeof E == "object" && E.handleEvent && (g.callback = (A) => E.handleEvent(A), g.originalDelegate = E);
      let P;
      try {
        g.invoke(g, y, [w]);
      } catch (A) {
        P = A;
      }
      let S = g.options;
      if (S && typeof S == "object" && S.once) {
        let A = g.originalDelegate ? g.originalDelegate : g.callback;
        y[o].call(y, w.type, A, S);
      }
      return P;
    };
    function p(g, y, w) {
      if (y = y || i59.event, !y) return;
      let E = g || y.target || i59, P = E[So[y.type][w ? ua : ha]];
      if (P) {
        let S = [];
        if (P.length === 1) {
          let A = h(P[0], E, y);
          A && S.push(A);
        } else {
          let A = P.slice();
          for (let W = 0; W < A.length && !(y && y[Nk] === true); W++) {
            let H = h(A[W], E, y);
            H && S.push(H);
          }
        }
        if (S.length === 1) throw S[0];
        for (let A = 0; A < S.length; A++) {
          let W = S[A];
          t.nativeScheduleMicroTask(() => {
            throw W;
          });
        }
      }
    }
    let f = function(g) {
      return p(this, g, false);
    }, m = function(g) {
      return p(this, g, true);
    };
    function v(g, y) {
      if (!g) return false;
      let w = true;
      y && y.useG !== void 0 && (w = y.useG);
      let E = y && y.vh, P = true;
      y && y.chkDup !== void 0 && (P = y.chkDup);
      let S = false;
      y && y.rt !== void 0 && (S = y.rt);
      let A = g;
      for (; A && !A.hasOwnProperty(r); ) A = eE(A);
      if (!A && g[r] && (A = g), !A || A[l]) return false;
      let W = y && y.eventNameToString, H = {}, O = A[l] = A[r], I = A[xn(o)] = A[o], F = A[xn(s)] = A[s], j = A[xn(a)] = A[a], $;
      y && y.prepend && ($ = A[xn(y.prepend)] = A[y.prepend]);
      function k(Q, _e) {
        return !Eu && typeof Q == "object" && Q ? !!Q.capture : !Eu || !_e ? Q : typeof Q == "boolean" ? { capture: Q, passive: true } : Q ? typeof Q == "object" && Q.passive !== false ? xt(le({}, Q), { passive: true }) : Q : { passive: true };
      }
      let z = function(Q) {
        if (!H.isExisting) return O.call(H.target, H.eventName, H.capture ? m : f, H.options);
      }, R = function(Q) {
        if (!Q.isRemoved) {
          let _e = So[Q.eventName], te;
          _e && (te = _e[Q.capture ? ua : ha]);
          let fe = te && Q.target[te];
          if (fe) {
            for (let ge = 0; ge < fe.length; ge++) if (fe[ge] === Q) {
              fe.splice(ge, 1), Q.isRemoved = true, Q.removeAbortListener && (Q.removeAbortListener(), Q.removeAbortListener = null), fe.length === 0 && (Q.allRemoved = true, Q.target[te] = null);
              break;
            }
          }
        }
        if (Q.allRemoved) return I.call(Q.target, Q.eventName, Q.capture ? m : f, Q.options);
      }, V = function(Q) {
        return O.call(H.target, H.eventName, Q.invoke, H.options);
      }, ie = function(Q) {
        return $.call(H.target, H.eventName, Q.invoke, H.options);
      }, re = function(Q) {
        return I.call(Q.target, Q.eventName, Q.invoke, Q.options);
      }, Re = w ? z : V, ne = w ? R : re, oe = function(Q, _e) {
        let te = typeof _e;
        return te === "function" && Q.callback === _e || te === "object" && Q.originalDelegate === _e;
      }, Be = y && y.diff ? y.diff : oe, me = Zone[xn("UNPATCHED_EVENTS")], Ve = i59[xn("PASSIVE_EVENTS")];
      function ue(Q) {
        if (typeof Q == "object" && Q !== null) {
          let _e = le({}, Q);
          return Q.signal && (_e.signal = Q.signal), _e;
        }
        return Q;
      }
      let ee = function(Q, _e, te, fe, ge = false, Ne = false) {
        return function() {
          let Se = this || i59, B = arguments[0];
          y && y.transferEventName && (B = y.transferEventName(B));
          let N = arguments[1];
          if (!N) return Q.apply(this, arguments);
          if (ry && B === "uncaughtException") return Q.apply(this, arguments);
          let se = false;
          if (typeof N != "function") {
            if (!N.handleEvent) return Q.apply(this, arguments);
            se = true;
          }
          if (E && !E(Q, N, Se, arguments)) return;
          let Le = Eu && !!Ve && Ve.indexOf(B) !== -1, ke = ue(k(arguments[2], Le)), Xe = ke?.signal;
          if (Xe?.aborted) return;
          if (me) {
            for (let Ti = 0; Ti < me.length; Ti++) if (B === me[Ti]) return Le ? Q.call(Se, B, N, ke) : Q.apply(this, arguments);
          }
          let bt = ke ? typeof ke == "boolean" ? true : ke.capture : false, ft = ke && typeof ke == "object" ? ke.once : false, Dt = Zone.current, st = So[B];
          st || (kk(B, W), st = So[B]);
          let J = st[bt ? ua : ha], je = Se[J], Te = false;
          if (je) {
            if (Te = true, P) {
              for (let Ti = 0; Ti < je.length; Ti++) if (Be(je[Ti], N)) return;
            }
          } else je = Se[J] = [];
          let rt, ot = Se.constructor.name, Xt = Ok[ot];
          Xt && (rt = Xt[B]), rt || (rt = ot + _e + (W ? W(B) : B)), H.options = ke, ft && (H.options.once = false), H.target = Se, H.capture = bt, H.eventName = B, H.isExisting = Te;
          let Zn = w ? l7 : void 0;
          Zn && (Zn.taskData = H), Xe && (H.options.signal = void 0);
          let Mn = Dt.scheduleEventTask(rt, N, Zn, te, fe);
          if (Xe) {
            H.options.signal = Xe;
            let Ti = () => Mn.zone.cancelTask(Mn);
            Q.call(Xe, "abort", Ti, { once: true }), Mn.removeAbortListener = () => Xe.removeEventListener("abort", Ti);
          }
          if (H.target = null, Zn && (Zn.taskData = null), ft && (H.options.once = true), !Eu && typeof Mn.options == "boolean" || (Mn.options = ke), Mn.target = Se, Mn.capture = bt, Mn.eventName = B, se && (Mn.originalDelegate = N), Ne ? je.unshift(Mn) : je.push(Mn), ge) return Se;
        };
      };
      return A[r] = ee(O, c, Re, ne, S), $ && (A[d] = ee($, u, ie, ne, S, true)), A[o] = function() {
        let Q = this || i59, _e = arguments[0];
        y && y.transferEventName && (_e = y.transferEventName(_e));
        let te = arguments[2], fe = te ? typeof te == "boolean" ? true : te.capture : false, ge = arguments[1];
        if (!ge) return I.apply(this, arguments);
        if (E && !E(I, ge, Q, arguments)) return;
        let Ne = So[_e], Se;
        Ne && (Se = Ne[fe ? ua : ha]);
        let B = Se && Q[Se];
        if (B) for (let N = 0; N < B.length; N++) {
          let se = B[N];
          if (Be(se, ge)) {
            if (B.splice(N, 1), se.isRemoved = true, B.length === 0 && (se.allRemoved = true, Q[Se] = null, !fe && typeof _e == "string")) {
              let Le = gf + "ON_PROPERTY" + _e;
              Q[Le] = null;
            }
            return se.zone.cancelTask(se), S ? Q : void 0;
          }
        }
        return I.apply(this, arguments);
      }, A[s] = function() {
        let Q = this || i59, _e = arguments[0];
        y && y.transferEventName && (_e = y.transferEventName(_e));
        let te = [], fe = Lk(Q, W ? W(_e) : _e);
        for (let ge = 0; ge < fe.length; ge++) {
          let Ne = fe[ge], Se = Ne.originalDelegate ? Ne.originalDelegate : Ne.callback;
          te.push(Se);
        }
        return te;
      }, A[a] = function() {
        let Q = this || i59, _e = arguments[0];
        if (_e) {
          y && y.transferEventName && (_e = y.transferEventName(_e));
          let te = So[_e];
          if (te) {
            let fe = te[ha], ge = te[ua], Ne = Q[fe], Se = Q[ge];
            if (Ne) {
              let B = Ne.slice();
              for (let N = 0; N < B.length; N++) {
                let se = B[N], Le = se.originalDelegate ? se.originalDelegate : se.callback;
                this[o].call(this, _e, Le, se.options);
              }
            }
            if (Se) {
              let B = Se.slice();
              for (let N = 0; N < B.length; N++) {
                let se = B[N], Le = se.originalDelegate ? se.originalDelegate : se.callback;
                this[o].call(this, _e, Le, se.options);
              }
            }
          }
        } else {
          let te = Object.keys(Q);
          for (let fe = 0; fe < te.length; fe++) {
            let ge = te[fe], Ne = Ak.exec(ge), Se = Ne && Ne[1];
            Se && Se !== "removeListener" && this[a].call(this, Se);
          }
          this[a].call(this, "removeListener");
        }
        if (S) return this;
      }, fa(A[r], O), fa(A[o], I), j && fa(A[a], j), F && fa(A[s], F), true;
    }
    let _ = [];
    for (let g = 0; g < e.length; g++) _[g] = v(e[g], n);
    return _;
  }
  function Lk(i59, t) {
    if (!t) {
      let o = [];
      for (let s in i59) {
        let a = Ak.exec(s), l = a && a[1];
        if (l && (!t || l === t)) {
          let c = i59[s];
          if (c) for (let d = 0; d < c.length; d++) o.push(c[d]);
        }
      }
      return o;
    }
    let e = So[t];
    e || (kk(t), e = So[t]);
    let n = i59[e[ha]], r = i59[e[ua]];
    return n ? r ? n.concat(r) : n.slice() : r ? r.slice() : [];
  }
  function d7(i59, t) {
    let e = i59.Event;
    e && e.prototype && t.patchMethod(e.prototype, "stopImmediatePropagation", (n) => function(r, o) {
      r[Nk] = true, n && n.apply(r, o);
    });
  }
  function u7(i59, t) {
    t.patchMethod(i59, "queueMicrotask", (e) => function(n, r) {
      Zone.current.scheduleMicroTask("queueMicrotask", r[0]);
    });
  }
  var ty = xn("zoneTask");
  function Mu(i59, t, e, n) {
    let r = null, o = null;
    t += n, e += n;
    let s = {};
    function a(c) {
      let d = c.data;
      d.args[0] = function() {
        return c.invoke.apply(this, arguments);
      };
      let u = r.apply(i59, d.args);
      return Ek(u) ? d.handleId = u : (d.handle = u, d.isRefreshable = Mk(u.refresh)), c;
    }
    function l(c) {
      let { handle: d, handleId: u } = c.data;
      return o.call(i59, d ?? u);
    }
    r = pa(i59, t, (c) => function(d, u) {
      if (Mk(u[0])) {
        let h = { isRefreshable: false, isPeriodic: n === "Interval", delay: n === "Timeout" || n === "Interval" ? u[1] || 0 : void 0, args: u }, p = u[0];
        u[0] = function() {
          try {
            return p.apply(this, arguments);
          } finally {
            let { handle: w, handleId: E, isPeriodic: P, isRefreshable: S } = h;
            !P && !S && (E ? delete s[E] : w && (w[ty] = null));
          }
        };
        let f = rE(t, u[0], h, a, l);
        if (!f) return f;
        let { handleId: m, handle: v, isRefreshable: _, isPeriodic: g } = f.data;
        if (m) s[m] = f;
        else if (v && (v[ty] = f, _ && !g)) {
          let y = v.refresh;
          v.refresh = function() {
            let { zone: w, state: E } = f;
            return E === "notScheduled" ? (f._state = "scheduled", w._updateTaskCount(f, 1)) : E === "running" && (f._state = "scheduling"), y.call(this);
          };
        }
        return v ?? m ?? f;
      } else return c.apply(i59, u);
    }), o = pa(i59, e, (c) => function(d, u) {
      let h = u[0], p;
      Ek(h) ? (p = s[h], delete s[h]) : (p = h?.[ty], p ? h[ty] = null : p = h), p?.type ? p.cancelFn && p.zone.cancelTask(p) : c.apply(i59, u);
    });
  }
  function h7(i59, t) {
    let { isBrowser: e, isMix: n } = t.getGlobalObjects();
    if (!e && !n || !i59.customElements || !("customElements" in i59)) return;
    let r = ["connectedCallback", "disconnectedCallback", "adoptedCallback", "attributeChangedCallback", "formAssociatedCallback", "formDisabledCallback", "formResetCallback", "formStateRestoreCallback"];
    t.patchCallbacks(t, i59.customElements, "customElements", "define", r);
  }
  function p7(i59, t) {
    if (Zone[t.symbol("patchEventTarget")]) return;
    let { eventNames: e, zoneSymbolEventNames: n, TRUE_STR: r, FALSE_STR: o, ZONE_SYMBOL_PREFIX: s } = t.getGlobalObjects();
    for (let l = 0; l < e.length; l++) {
      let c = e[l], d = c + o, u = c + r, h = s + d, p = s + u;
      n[c] = {}, n[c][o] = h, n[c][r] = p;
    }
    let a = i59.EventTarget;
    if (!(!a || !a.prototype)) return t.patchEventTarget(i59, t, [a && a.prototype]), true;
  }
  function f7(i59, t) {
    t.patchEventPrototype(i59, t);
  }
  function Fk(i59, t, e) {
    if (!e || e.length === 0) return t;
    let n = e.filter((o) => o.target === i59);
    if (!n || n.length === 0) return t;
    let r = n[0].ignoreProperties;
    return t.filter((o) => r.indexOf(o) === -1);
  }
  function Tk(i59, t, e, n) {
    if (!i59) return;
    let r = Fk(i59, t, e);
    Rk(i59, r, n);
  }
  function KM(i59) {
    return Object.getOwnPropertyNames(i59).filter((t) => t.startsWith("on") && t.length > 2).map((t) => t.substring(2));
  }
  function m7(i59, t) {
    if (ry && !Pk || Zone[i59.symbol("patchEvents")]) return;
    let e = t.__Zone_ignore_on_properties, n = [];
    if (sE) {
      let r = window;
      n = n.concat(["Document", "SVGElement", "Element", "HTMLElement", "HTMLBodyElement", "HTMLMediaElement", "HTMLFrameSetElement", "HTMLFrameElement", "HTMLIFrameElement", "HTMLMarqueeElement", "Worker"]);
      let o = s7() ? [{ target: r, ignoreProperties: ["error"] }] : [];
      Tk(r, KM(r), e && e.concat(o), eE(r));
    }
    n = n.concat(["XMLHttpRequest", "XMLHttpRequestEventTarget", "IDBIndex", "IDBRequest", "IDBOpenDBRequest", "IDBDatabase", "IDBTransaction", "IDBCursor", "WebSocket"]);
    for (let r = 0; r < n.length; r++) {
      let o = t[n[r]];
      o && o.prototype && Tk(o.prototype, KM(o.prototype), e);
    }
  }
  function g7(i59) {
    i59.__load_patch("legacy", (t) => {
      let e = t[i59.__symbol__("legacyPatch")];
      e && e();
    }), i59.__load_patch("timers", (t) => {
      let e = "set", n = "clear";
      Mu(t, e, n, "Timeout"), Mu(t, e, n, "Interval"), Mu(t, e, n, "Immediate");
    }), i59.__load_patch("requestAnimationFrame", (t) => {
      Mu(t, "request", "cancel", "AnimationFrame"), Mu(t, "mozRequest", "mozCancel", "AnimationFrame"), Mu(t, "webkitRequest", "webkitCancel", "AnimationFrame");
    }), i59.__load_patch("blocking", (t, e) => {
      let n = ["alert", "prompt", "confirm"];
      for (let r = 0; r < n.length; r++) {
        let o = n[r];
        pa(t, o, (s, a, l) => function(c, d) {
          return e.current.run(s, t, d, l);
        });
      }
    }), i59.__load_patch("EventTarget", (t, e, n) => {
      f7(t, n), p7(t, n);
      let r = t.XMLHttpRequestEventTarget;
      r && r.prototype && n.patchEventTarget(t, n, [r.prototype]);
    }), i59.__load_patch("MutationObserver", (t, e, n) => {
      ff("MutationObserver"), ff("WebKitMutationObserver");
    }), i59.__load_patch("IntersectionObserver", (t, e, n) => {
      ff("IntersectionObserver");
    }), i59.__load_patch("FileReader", (t, e, n) => {
      ff("FileReader");
    }), i59.__load_patch("on_property", (t, e, n) => {
      m7(n, t);
    }), i59.__load_patch("customElements", (t, e, n) => {
      h7(t, n);
    }), i59.__load_patch("XHR", (t, e) => {
      c(t);
      let n = xn("xhrTask"), r = xn("xhrSync"), o = xn("xhrListener"), s = xn("xhrScheduled"), a = xn("xhrURL"), l = xn("xhrErrorBeforeScheduled");
      function c(d) {
        let u = d.XMLHttpRequest;
        if (!u) return;
        let h = u.prototype;
        function p(O) {
          return O[n];
        }
        let f = h[XM], m = h[ZM];
        if (!f) {
          let O = d.XMLHttpRequestEventTarget;
          if (O) {
            let I = O.prototype;
            f = I[XM], m = I[ZM];
          }
        }
        let v = "readystatechange", _ = "scheduled";
        function g(O) {
          let I = O.data, F = I.target;
          F[s] = false, F[l] = false;
          let j = F[o];
          f || (f = F[XM], m = F[ZM]), j && m.call(F, v, j);
          let $ = F[o] = () => {
            if (F.readyState === F.DONE) if (!I.aborted && F[s] && O.state === _) {
              let z = F[e.__symbol__("loadfalse")];
              if (F.status !== 0 && z && z.length > 0) {
                let R = O.invoke;
                O.invoke = function() {
                  let V = F[e.__symbol__("loadfalse")];
                  for (let ie = 0; ie < V.length; ie++) V[ie] === O && V.splice(ie, 1);
                  !I.aborted && O.state === _ && R.call(O);
                }, z.push(O);
              } else O.invoke();
            } else !I.aborted && F[s] === false && (F[l] = true);
          };
          return f.call(F, v, $), F[n] || (F[n] = O), W.apply(F, I.args), F[s] = true, O;
        }
        function y() {
        }
        function w(O) {
          let I = O.data;
          return I.aborted = true, H.apply(I.target, I.args);
        }
        let E = pa(h, "open", () => function(O, I) {
          return O[r] = I[2] == false, O[a] = I[1], E.apply(O, I);
        }), P = "XMLHttpRequest.send", S = xn("fetchTaskAborting"), A = xn("fetchTaskScheduling"), W = pa(h, "send", () => function(O, I) {
          if (e.current[A] === true || O[r]) return W.apply(O, I);
          {
            let F = { target: O, url: O[a], isPeriodic: false, args: I, aborted: false }, j = rE(P, y, F, g, w);
            O && O[l] === true && !F.aborted && j.state === _ && j.invoke();
          }
        }), H = pa(h, "abort", () => function(O, I) {
          let F = p(O);
          if (F && typeof F.type == "string") {
            if (F.cancelFn == null || F.data && F.data.aborted) return;
            F.zone.cancelTask(F);
          } else if (e.current[S] === true) return H.apply(O, I);
        });
      }
    }), i59.__load_patch("geolocation", (t) => {
      t.navigator && t.navigator.geolocation && i72(t.navigator.geolocation, ["getCurrentPosition", "watchPosition"]);
    }), i59.__load_patch("PromiseRejectionEvent", (t, e) => {
      function n(r) {
        return function(o) {
          Lk(t, r).forEach((a) => {
            let l = t.PromiseRejectionEvent;
            if (l) {
              let c = new l(r, { promise: o.promise, reason: o.rejection });
              a.invoke(c);
            }
          });
        };
      }
      t.PromiseRejectionEvent && (e[xn("unhandledPromiseRejectionHandler")] = n("unhandledrejection"), e[xn("rejectionHandledHandler")] = n("rejectionhandled"));
    }), i59.__load_patch("queueMicrotask", (t, e, n) => {
      u7(t, n);
    });
  }
  function _7(i59) {
    i59.__load_patch("ZoneAwarePromise", (t, e, n) => {
      let r = Object.getOwnPropertyDescriptor, o = Object.defineProperty;
      function s(ue) {
        if (ue && ue.toString === Object.prototype.toString) {
          let ee = ue.constructor && ue.constructor.name;
          return (ee || "") + ": " + JSON.stringify(ue);
        }
        return ue ? ue.toString() : Object.prototype.toString.call(ue);
      }
      let a = n.symbol, l = [], c = t[a("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")] !== false, d = a("Promise"), u = a("then"), h = "__creationTrace__";
      n.onUnhandledError = (ue) => {
        if (n.showUncaughtError()) {
          let ee = ue && ue.rejection;
          ee ? console.error("Unhandled Promise rejection:", ee instanceof Error ? ee.message : ee, "; Zone:", ue.zone.name, "; Task:", ue.task && ue.task.source, "; Value:", ee, ee instanceof Error ? ee.stack : void 0) : console.error(ue);
        }
      }, n.microtaskDrainDone = () => {
        for (; l.length; ) {
          let ue = l.shift();
          try {
            ue.zone.runGuarded(() => {
              throw ue.throwOriginal ? ue.rejection : ue;
            });
          } catch (ee) {
            f(ee);
          }
        }
      };
      let p = a("unhandledPromiseRejectionHandler");
      function f(ue) {
        n.onUnhandledError(ue);
        try {
          let ee = e[p];
          typeof ee == "function" && ee.call(this, ue);
        } catch {
        }
      }
      function m(ue) {
        return ue && ue.then;
      }
      function v(ue) {
        return ue;
      }
      function _(ue) {
        return ne.reject(ue);
      }
      let g = a("state"), y = a("value"), w = a("finally"), E = a("parentPromiseValue"), P = a("parentPromiseState"), S = "Promise.then", A = null, W = true, H = false, O = 0;
      function I(ue, ee) {
        return (Q) => {
          try {
            k(ue, ee, Q);
          } catch (_e) {
            k(ue, false, _e);
          }
        };
      }
      let F = function() {
        let ue = false;
        return function(Q) {
          return function() {
            ue || (ue = true, Q.apply(null, arguments));
          };
        };
      }, j = "Promise resolved with itself", $ = a("currentTaskTrace");
      function k(ue, ee, Q) {
        let _e = F();
        if (ue === Q) throw new TypeError(j);
        if (ue[g] === A) {
          let te = null;
          try {
            (typeof Q == "object" || typeof Q == "function") && (te = Q && Q.then);
          } catch (fe) {
            return _e(() => {
              k(ue, false, fe);
            })(), ue;
          }
          if (ee !== H && Q instanceof ne && Q.hasOwnProperty(g) && Q.hasOwnProperty(y) && Q[g] !== A) R(Q), k(ue, Q[g], Q[y]);
          else if (ee !== H && typeof te == "function") try {
            te.call(Q, _e(I(ue, ee)), _e(I(ue, false)));
          } catch (fe) {
            _e(() => {
              k(ue, false, fe);
            })();
          }
          else {
            ue[g] = ee;
            let fe = ue[y];
            if (ue[y] = Q, ue[w] === w && ee === W && (ue[g] = ue[P], ue[y] = ue[E]), ee === H && Q instanceof Error) {
              let ge = e.currentTask && e.currentTask.data && e.currentTask.data[h];
              ge && o(Q, $, { configurable: true, enumerable: false, writable: true, value: ge });
            }
            for (let ge = 0; ge < fe.length; ) V(ue, fe[ge++], fe[ge++], fe[ge++], fe[ge++]);
            if (fe.length == 0 && ee == H) {
              ue[g] = O;
              let ge = Q;
              try {
                throw new Error("Uncaught (in promise): " + s(Q) + (Q && Q.stack ? `
` + Q.stack : ""));
              } catch (Ne) {
                ge = Ne;
              }
              c && (ge.throwOriginal = true), ge.rejection = Q, ge.promise = ue, ge.zone = e.current, ge.task = e.currentTask, l.push(ge), n.scheduleMicroTask();
            }
          }
        }
        return ue;
      }
      let z = a("rejectionHandledHandler");
      function R(ue) {
        if (ue[g] === O) {
          try {
            let ee = e[z];
            ee && typeof ee == "function" && ee.call(this, { rejection: ue[y], promise: ue });
          } catch {
          }
          ue[g] = H;
          for (let ee = 0; ee < l.length; ee++) ue === l[ee].promise && l.splice(ee, 1);
        }
      }
      function V(ue, ee, Q, _e, te) {
        R(ue);
        let fe = ue[g], ge = fe ? typeof _e == "function" ? _e : v : typeof te == "function" ? te : _;
        ee.scheduleMicroTask(S, () => {
          try {
            let Ne = ue[y], Se = !!Q && w === Q[w];
            Se && (Q[E] = Ne, Q[P] = fe);
            let B = ee.run(ge, void 0, Se && ge !== _ && ge !== v ? [] : [Ne]);
            k(Q, true, B);
          } catch (Ne) {
            k(Q, false, Ne);
          }
        }, Q);
      }
      let ie = "function ZoneAwarePromise() { [native code] }", re = function() {
      }, Re = t.AggregateError;
      class ne {
        static toString() {
          return ie;
        }
        static resolve(ee) {
          return ee instanceof ne ? ee : k(new this(null), W, ee);
        }
        static reject(ee) {
          return k(new this(null), H, ee);
        }
        static withResolvers() {
          let ee = {};
          return ee.promise = new ne((Q, _e) => {
            ee.resolve = Q, ee.reject = _e;
          }), ee;
        }
        static any(ee) {
          if (!ee || typeof ee[Symbol.iterator] != "function") return Promise.reject(new Re([], "All promises were rejected"));
          let Q = [], _e = 0;
          try {
            for (let ge of ee) _e++, Q.push(ne.resolve(ge));
          } catch {
            return Promise.reject(new Re([], "All promises were rejected"));
          }
          if (_e === 0) return Promise.reject(new Re([], "All promises were rejected"));
          let te = false, fe = [];
          return new ne((ge, Ne) => {
            for (let Se = 0; Se < Q.length; Se++) Q[Se].then((B) => {
              te || (te = true, ge(B));
            }, (B) => {
              fe.push(B), _e--, _e === 0 && (te = true, Ne(new Re(fe, "All promises were rejected")));
            });
          });
        }
        static race(ee) {
          let Q, _e, te = new this((Ne, Se) => {
            Q = Ne, _e = Se;
          });
          function fe(Ne) {
            Q(Ne);
          }
          function ge(Ne) {
            _e(Ne);
          }
          for (let Ne of ee) m(Ne) || (Ne = this.resolve(Ne)), Ne.then(fe, ge);
          return te;
        }
        static all(ee) {
          return ne.allWithCallback(ee);
        }
        static allSettled(ee) {
          return (this && this.prototype instanceof ne ? this : ne).allWithCallback(ee, { thenCallback: (_e) => ({ status: "fulfilled", value: _e }), errorCallback: (_e) => ({ status: "rejected", reason: _e }) });
        }
        static allWithCallback(ee, Q) {
          let _e, te, fe = new this((B, N) => {
            _e = B, te = N;
          }), ge = 2, Ne = 0, Se = [];
          for (let B of ee) {
            m(B) || (B = this.resolve(B));
            let N = Ne;
            try {
              B.then((se) => {
                Se[N] = Q ? Q.thenCallback(se) : se, ge--, ge === 0 && _e(Se);
              }, (se) => {
                Q ? (Se[N] = Q.errorCallback(se), ge--, ge === 0 && _e(Se)) : te(se);
              });
            } catch (se) {
              te(se);
            }
            ge++, Ne++;
          }
          return ge -= 2, ge === 0 && _e(Se), fe;
        }
        constructor(ee) {
          let Q = this;
          if (!(Q instanceof ne)) throw new Error("Must be an instanceof Promise.");
          Q[g] = A, Q[y] = [];
          try {
            let _e = F();
            ee && ee(_e(I(Q, W)), _e(I(Q, H)));
          } catch (_e) {
            k(Q, false, _e);
          }
        }
        get [Symbol.toStringTag]() {
          return "Promise";
        }
        get [Symbol.species]() {
          return ne;
        }
        then(ee, Q) {
          let _e = this.constructor?.[Symbol.species];
          (!_e || typeof _e != "function") && (_e = this.constructor || ne);
          let te = new _e(re), fe = e.current;
          return this[g] == A ? this[y].push(fe, te, ee, Q) : V(this, fe, te, ee, Q), te;
        }
        catch(ee) {
          return this.then(null, ee);
        }
        finally(ee) {
          let Q = this.constructor?.[Symbol.species];
          (!Q || typeof Q != "function") && (Q = ne);
          let _e = new Q(re);
          _e[w] = w;
          let te = e.current;
          return this[g] == A ? this[y].push(te, _e, ee, ee) : V(this, te, _e, ee, ee), _e;
        }
      }
      ne.resolve = ne.resolve, ne.reject = ne.reject, ne.race = ne.race, ne.all = ne.all;
      let oe = t[d] = t.Promise;
      t.Promise = ne;
      let Be = a("thenPatched");
      function me(ue) {
        let ee = ue.prototype, Q = r(ee, "then");
        if (Q && (Q.writable === false || !Q.configurable)) return;
        let _e = ee.then;
        ee[u] = _e, ue.prototype.then = function(te, fe) {
          return new ne((Ne, Se) => {
            _e.call(this, Ne, Se);
          }).then(te, fe);
        }, ue[Be] = true;
      }
      n.patchThen = me;
      function Ve(ue) {
        return function(ee, Q) {
          let _e = ue.apply(ee, Q);
          if (_e instanceof ne) return _e;
          let te = _e.constructor;
          return te[Be] || me(te), _e;
        };
      }
      return oe && (me(oe), pa(t, "fetch", (ue) => Ve(ue))), Promise[e.__symbol__("uncaughtPromiseErrors")] = l, ne;
    });
  }
  function v7(i59) {
    i59.__load_patch("toString", (t) => {
      let e = Function.prototype.toString, n = xn("OriginalDelegate"), r = xn("Promise"), o = xn("Error"), s = function() {
        if (typeof this == "function") {
          let d = this[n];
          if (d) return typeof d == "function" ? e.call(d) : Object.prototype.toString.call(d);
          if (this === Promise) {
            let u = t[r];
            if (u) return e.call(u);
          }
          if (this === Error) {
            let u = t[o];
            if (u) return e.call(u);
          }
        }
        return e.call(this);
      };
      s[n] = e, Function.prototype.toString = s;
      let a = Object.prototype.toString, l = "[object Promise]";
      Object.prototype.toString = function() {
        return typeof Promise == "function" && this instanceof Promise ? l : a.call(this);
      };
    });
  }
  function y7(i59, t, e, n, r) {
    let o = Zone.__symbol__(n);
    if (t[o]) return;
    let s = t[o] = t[n];
    t[n] = function(a, l, c) {
      return l && l.prototype && r.forEach(function(d) {
        let u = `${e}.${n}::` + d, h = l.prototype;
        try {
          if (h.hasOwnProperty(d)) {
            let p = i59.ObjectGetOwnPropertyDescriptor(h, d);
            p && p.value ? (p.value = i59.wrapWithCurrentZone(p.value, u), i59._redefineProperty(l.prototype, d, p)) : h[d] && (h[d] = i59.wrapWithCurrentZone(h[d], u));
          } else h[d] && (h[d] = i59.wrapWithCurrentZone(h[d], u));
        } catch {
        }
      }), s.call(t, a, l, c);
    }, i59.attachOriginToPatched(t[n], s);
  }
  function b7(i59) {
    i59.__load_patch("util", (t, e, n) => {
      let r = KM(t);
      n.patchOnProperties = Rk, n.patchMethod = pa, n.bindArguments = oE, n.patchMacroTask = o7;
      let o = e.__symbol__("BLACK_LISTED_EVENTS"), s = e.__symbol__("UNPATCHED_EVENTS");
      t[s] && (t[o] = t[s]), t[o] && (e[o] = e[s] = t[o]), n.patchEventPrototype = d7, n.patchEventTarget = c7, n.isIEOrEdge = a7, n.ObjectDefineProperty = JM, n.ObjectGetOwnPropertyDescriptor = mf, n.ObjectCreate = e7, n.ArraySlice = t7, n.patchClass = ff, n.wrapWithCurrentZone = iE, n.filterProperties = Fk, n.attachOriginToPatched = fa, n._redefineProperty = Object.defineProperty, n.patchCallbacks = y7, n.getGlobalObjects = () => ({ globalSources: Ok, zoneSymbolEventNames: So, eventNames: r, isBrowser: sE, isMix: Pk, isNode: ry, TRUE_STR: ua, FALSE_STR: ha, ZONE_SYMBOL_PREFIX: gf, ADD_EVENT_LISTENER_STR: tE, REMOVE_EVENT_LISTENER_STR: nE });
    });
  }
  function x7(i59) {
    _7(i59), v7(i59), b7(i59);
  }
  var Bk = J9();
  x7(Bk);
  g7(Bk);
  var Lt = function(i59) {
    return i59[i59.State = 0] = "State", i59[i59.Transition = 1] = "Transition", i59[i59.Sequence = 2] = "Sequence", i59[i59.Group = 3] = "Group", i59[i59.Animate = 4] = "Animate", i59[i59.Keyframes = 5] = "Keyframes", i59[i59.Style = 6] = "Style", i59[i59.Trigger = 7] = "Trigger", i59[i59.Reference = 8] = "Reference", i59[i59.AnimateChild = 9] = "AnimateChild", i59[i59.AnimateRef = 10] = "AnimateRef", i59[i59.Query = 11] = "Query", i59[i59.Stagger = 12] = "Stagger", i59;
  }(Lt || {});
  var Es = "*";
  function ki(i59, t) {
    return { type: Lt.Trigger, name: i59, definitions: t, options: {} };
  }
  function oi(i59, t = null) {
    return { type: Lt.Animate, styles: t, timings: i59 };
  }
  function Vk(i59, t = null) {
    return { type: Lt.Sequence, steps: i59, options: t };
  }
  function _n(i59) {
    return { type: Lt.Style, styles: i59, offset: null };
  }
  function Zi(i59, t, e) {
    return { type: Lt.State, name: i59, styles: t, options: e };
  }
  function Yn(i59, t, e = null) {
    return { type: Lt.Transition, expr: i59, animation: t, options: e };
  }
  function zk(i59 = null) {
    return { type: Lt.AnimateChild, options: i59 };
  }
  function Uk(i59, t, e = null) {
    return { type: Lt.Query, selector: i59, animation: t, options: e };
  }
  var nl = class {
    _onDoneFns = [];
    _onStartFns = [];
    _onDestroyFns = [];
    _originalOnDoneFns = [];
    _originalOnStartFns = [];
    _started = false;
    _destroyed = false;
    _finished = false;
    _position = 0;
    parentPlayer = null;
    totalTime;
    constructor(t = 0, e = 0) {
      this.totalTime = t + e;
    }
    _onFinish() {
      this._finished || (this._finished = true, this._onDoneFns.forEach((t) => t()), this._onDoneFns = []);
    }
    onStart(t) {
      this._originalOnStartFns.push(t), this._onStartFns.push(t);
    }
    onDone(t) {
      this._originalOnDoneFns.push(t), this._onDoneFns.push(t);
    }
    onDestroy(t) {
      this._onDestroyFns.push(t);
    }
    hasStarted() {
      return this._started;
    }
    init() {
    }
    play() {
      this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = true;
    }
    triggerMicrotask() {
      queueMicrotask(() => this._onFinish());
    }
    _onStart() {
      this._onStartFns.forEach((t) => t()), this._onStartFns = [];
    }
    pause() {
    }
    restart() {
    }
    finish() {
      this._onFinish();
    }
    destroy() {
      this._destroyed || (this._destroyed = true, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach((t) => t()), this._onDestroyFns = []);
    }
    reset() {
      this._started = false, this._finished = false, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns;
    }
    setPosition(t) {
      this._position = this.totalTime ? t * this.totalTime : 1;
    }
    getPosition() {
      return this.totalTime ? this._position / this.totalTime : 1;
    }
    triggerCallback(t) {
      let e = t == "start" ? this._onStartFns : this._onDoneFns;
      e.forEach((n) => n()), e.length = 0;
    }
  };
  var _f = class {
    _onDoneFns = [];
    _onStartFns = [];
    _finished = false;
    _started = false;
    _destroyed = false;
    _onDestroyFns = [];
    parentPlayer = null;
    totalTime = 0;
    players;
    constructor(t) {
      this.players = t;
      let e = 0, n = 0, r = 0, o = this.players.length;
      o == 0 ? queueMicrotask(() => this._onFinish()) : this.players.forEach((s) => {
        s.onDone(() => {
          ++e == o && this._onFinish();
        }), s.onDestroy(() => {
          ++n == o && this._onDestroy();
        }), s.onStart(() => {
          ++r == o && this._onStart();
        });
      }), this.totalTime = this.players.reduce((s, a) => Math.max(s, a.totalTime), 0);
    }
    _onFinish() {
      this._finished || (this._finished = true, this._onDoneFns.forEach((t) => t()), this._onDoneFns = []);
    }
    init() {
      this.players.forEach((t) => t.init());
    }
    onStart(t) {
      this._onStartFns.push(t);
    }
    _onStart() {
      this.hasStarted() || (this._started = true, this._onStartFns.forEach((t) => t()), this._onStartFns = []);
    }
    onDone(t) {
      this._onDoneFns.push(t);
    }
    onDestroy(t) {
      this._onDestroyFns.push(t);
    }
    hasStarted() {
      return this._started;
    }
    play() {
      this.parentPlayer || this.init(), this._onStart(), this.players.forEach((t) => t.play());
    }
    pause() {
      this.players.forEach((t) => t.pause());
    }
    restart() {
      this.players.forEach((t) => t.restart());
    }
    finish() {
      this._onFinish(), this.players.forEach((t) => t.finish());
    }
    destroy() {
      this._onDestroy();
    }
    _onDestroy() {
      this._destroyed || (this._destroyed = true, this._onFinish(), this.players.forEach((t) => t.destroy()), this._onDestroyFns.forEach((t) => t()), this._onDestroyFns = []);
    }
    reset() {
      this.players.forEach((t) => t.reset()), this._destroyed = false, this._finished = false, this._started = false;
    }
    setPosition(t) {
      let e = t * this.totalTime;
      this.players.forEach((n) => {
        let r = n.totalTime ? Math.min(1, e / n.totalTime) : 1;
        n.setPosition(r);
      });
    }
    getPosition() {
      let t = this.players.reduce((e, n) => e === null || n.totalTime > e.totalTime ? n : e, null);
      return t != null ? t.getPosition() : 0;
    }
    beforeDestroy() {
      this.players.forEach((t) => {
        t.beforeDestroy && t.beforeDestroy();
      });
    }
    triggerCallback(t) {
      let e = t == "start" ? this._onStartFns : this._onDoneFns;
      e.forEach((n) => n()), e.length = 0;
    }
  };
  var oy = "!";
  function Gk(i59) {
    return new ze(3e3, false);
  }
  function w7() {
    return new ze(3100, false);
  }
  function C7() {
    return new ze(3101, false);
  }
  function S7(i59) {
    return new ze(3001, false);
  }
  function M7(i59) {
    return new ze(3003, false);
  }
  function E7(i59) {
    return new ze(3004, false);
  }
  function T7(i59, t) {
    return new ze(3005, false);
  }
  function I7() {
    return new ze(3006, false);
  }
  function D7() {
    return new ze(3007, false);
  }
  function P7(i59, t) {
    return new ze(3008, false);
  }
  function R7(i59) {
    return new ze(3002, false);
  }
  function O7(i59, t, e, n, r) {
    return new ze(3010, false);
  }
  function A7() {
    return new ze(3011, false);
  }
  function N7() {
    return new ze(3012, false);
  }
  function k7() {
    return new ze(3200, false);
  }
  function L7() {
    return new ze(3202, false);
  }
  function F7() {
    return new ze(3013, false);
  }
  function B7(i59) {
    return new ze(3014, false);
  }
  function V7(i59) {
    return new ze(3015, false);
  }
  function z7(i59) {
    return new ze(3016, false);
  }
  function U7(i59, t) {
    return new ze(3404, false);
  }
  function G7(i59) {
    return new ze(3502, false);
  }
  function H7(i59) {
    return new ze(3503, false);
  }
  function j7() {
    return new ze(3300, false);
  }
  function W7(i59) {
    return new ze(3504, false);
  }
  function $7(i59) {
    return new ze(3301, false);
  }
  function q7(i59, t) {
    return new ze(3302, false);
  }
  function Y7(i59) {
    return new ze(3303, false);
  }
  function X7(i59, t) {
    return new ze(3400, false);
  }
  function Z7(i59) {
    return new ze(3401, false);
  }
  function Q7(i59) {
    return new ze(3402, false);
  }
  function K7(i59, t) {
    return new ze(3505, false);
  }
  function il(i59) {
    switch (i59.length) {
      case 0:
        return new nl();
      case 1:
        return i59[0];
      default:
        return new _f(i59);
    }
  }
  function n2(i59, t, e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map()) {
    let r = [], o = [], s = -1, a = null;
    if (t.forEach((l) => {
      let c = l.get("offset"), d = c == s, u = d && a || /* @__PURE__ */ new Map();
      l.forEach((h, p) => {
        let f = p, m = h;
        if (p !== "offset") switch (f = i59.normalizePropertyName(f, r), m) {
          case oy:
            m = e.get(p);
            break;
          case Es:
            m = n.get(p);
            break;
          default:
            m = i59.normalizeStyleValue(p, f, m, r);
            break;
        }
        u.set(f, m);
      }), d || o.push(u), a = u, s = c;
    }), r.length) throw G7(r);
    return o;
  }
  function IE(i59, t, e, n) {
    switch (t) {
      case "start":
        i59.onStart(() => n(e && aE(e, "start", i59)));
        break;
      case "done":
        i59.onDone(() => n(e && aE(e, "done", i59)));
        break;
      case "destroy":
        i59.onDestroy(() => n(e && aE(e, "destroy", i59)));
        break;
    }
  }
  function aE(i59, t, e) {
    let n = e.totalTime, r = !!e.disabled, o = DE(i59.element, i59.triggerName, i59.fromState, i59.toState, t || i59.phaseName, n ?? i59.totalTime, r), s = i59._data;
    return s != null && (o._data = s), o;
  }
  function DE(i59, t, e, n, r = "", o = 0, s) {
    return { element: i59, triggerName: t, fromState: e, toState: n, phaseName: r, totalTime: o, disabled: !!s };
  }
  function oo(i59, t, e) {
    let n = i59.get(t);
    return n || i59.set(t, n = e), n;
  }
  function Hk(i59) {
    let t = i59.indexOf(":"), e = i59.substring(1, t), n = i59.slice(t + 1);
    return [e, n];
  }
  var J7 = typeof document > "u" ? null : document.documentElement;
  function PE(i59) {
    let t = i59.parentNode || i59.host || null;
    return t === J7 ? null : t;
  }
  function eq(i59) {
    return i59.substring(1, 6) == "ebkit";
  }
  var Sc = null;
  var jk = false;
  function tq(i59) {
    Sc || (Sc = nq() || {}, jk = Sc.style ? "WebkitAppearance" in Sc.style : false);
    let t = true;
    return Sc.style && !eq(i59) && (t = i59 in Sc.style, !t && jk && (t = "Webkit" + i59.charAt(0).toUpperCase() + i59.slice(1) in Sc.style)), t;
  }
  function nq() {
    return typeof document < "u" ? document.body : null;
  }
  function i22(i59, t) {
    for (; t; ) {
      if (t === i59) return true;
      t = PE(t);
    }
    return false;
  }
  function r2(i59, t, e) {
    if (e) return Array.from(i59.querySelectorAll(t));
    let n = i59.querySelector(t);
    return n ? [n] : [];
  }
  var RE = (() => {
    class i59 {
      validateStyleProperty(e) {
        return tq(e);
      }
      containsElement(e, n) {
        return i22(e, n);
      }
      getParentElement(e) {
        return PE(e);
      }
      query(e, n, r) {
        return r2(e, n, r);
      }
      computeStyle(e, n, r) {
        return r || "";
      }
      animate(e, n, r, o, s, a = [], l) {
        return new nl(r, o);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Tc = class {
    static NOOP = new RE();
  };
  var Ic = class {
  };
  var iq = 1e3;
  var o2 = "{{";
  var rq = "}}";
  var s2 = "ng-enter";
  var pE = "ng-leave";
  var sy = "ng-trigger";
  var uy = ".ng-trigger";
  var Wk = "ng-animating";
  var fE = ".ng-animating";
  function ma(i59) {
    if (typeof i59 == "number") return i59;
    let t = i59.match(/^(-?[\.\d]+)(m?s)/);
    return !t || t.length < 2 ? 0 : mE(parseFloat(t[1]), t[2]);
  }
  function mE(i59, t) {
    switch (t) {
      case "s":
        return i59 * iq;
      default:
        return i59;
    }
  }
  function hy(i59, t, e) {
    return i59.hasOwnProperty("duration") ? i59 : oq(i59, t, e);
  }
  function oq(i59, t, e) {
    let n = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i, r, o = 0, s = "";
    if (typeof i59 == "string") {
      let a = i59.match(n);
      if (a === null) return t.push(Gk(i59)), { duration: 0, delay: 0, easing: "" };
      r = mE(parseFloat(a[1]), a[2]);
      let l = a[3];
      l != null && (o = mE(parseFloat(l), a[4]));
      let c = a[5];
      c && (s = c);
    } else r = i59;
    if (!e) {
      let a = false, l = t.length;
      r < 0 && (t.push(w7()), a = true), o < 0 && (t.push(C7()), a = true), a && t.splice(l, 0, Gk(i59));
    }
    return { duration: r, delay: o, easing: s };
  }
  function sq(i59) {
    return i59.length ? i59[0] instanceof Map ? i59 : i59.map((t) => new Map(Object.entries(t))) : [];
  }
  function Ts(i59, t, e) {
    t.forEach((n, r) => {
      let o = OE(r);
      e && !e.has(r) && e.set(r, i59.style[o]), i59.style[o] = n;
    });
  }
  function Ec(i59, t) {
    t.forEach((e, n) => {
      let r = OE(n);
      i59.style[r] = "";
    });
  }
  function vf(i59) {
    return Array.isArray(i59) ? i59.length == 1 ? i59[0] : Vk(i59) : i59;
  }
  function aq(i59, t, e) {
    let n = t.params || {}, r = a2(i59);
    r.length && r.forEach((o) => {
      n.hasOwnProperty(o) || e.push(S7(o));
    });
  }
  var gE = new RegExp(`${o2}\\s*(.+?)\\s*${rq}`, "g");
  function a2(i59) {
    let t = [];
    if (typeof i59 == "string") {
      let e;
      for (; e = gE.exec(i59); ) t.push(e[1]);
      gE.lastIndex = 0;
    }
    return t;
  }
  function bf(i59, t, e) {
    let n = `${i59}`, r = n.replace(gE, (o, s) => {
      let a = t[s];
      return a == null && (e.push(M7(s)), a = ""), a.toString();
    });
    return r == n ? i59 : r;
  }
  var lq = /-+([a-z0-9])/g;
  function OE(i59) {
    return i59.replace(lq, (...t) => t[1].toUpperCase());
  }
  function cq(i59, t) {
    return i59 === 0 || t === 0;
  }
  function dq(i59, t, e) {
    if (e.size && t.length) {
      let n = t[0], r = [];
      if (e.forEach((o, s) => {
        n.has(s) || r.push(s), n.set(s, o);
      }), r.length) for (let o = 1; o < t.length; o++) {
        let s = t[o];
        r.forEach((a) => s.set(a, AE(i59, a)));
      }
    }
    return t;
  }
  function ro(i59, t, e) {
    switch (t.type) {
      case Lt.Trigger:
        return i59.visitTrigger(t, e);
      case Lt.State:
        return i59.visitState(t, e);
      case Lt.Transition:
        return i59.visitTransition(t, e);
      case Lt.Sequence:
        return i59.visitSequence(t, e);
      case Lt.Group:
        return i59.visitGroup(t, e);
      case Lt.Animate:
        return i59.visitAnimate(t, e);
      case Lt.Keyframes:
        return i59.visitKeyframes(t, e);
      case Lt.Style:
        return i59.visitStyle(t, e);
      case Lt.Reference:
        return i59.visitReference(t, e);
      case Lt.AnimateChild:
        return i59.visitAnimateChild(t, e);
      case Lt.AnimateRef:
        return i59.visitAnimateRef(t, e);
      case Lt.Query:
        return i59.visitQuery(t, e);
      case Lt.Stagger:
        return i59.visitStagger(t, e);
      default:
        throw E7(t.type);
    }
  }
  function AE(i59, t) {
    return window.getComputedStyle(i59)[t];
  }
  var uq = /* @__PURE__ */ new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
  var py = class extends Ic {
    normalizePropertyName(t, e) {
      return OE(t);
    }
    normalizeStyleValue(t, e, n, r) {
      let o = "", s = n.toString().trim();
      if (uq.has(e) && n !== 0 && n !== "0") if (typeof n == "number") o = "px";
      else {
        let a = n.match(/^[+-]?[\d\.]+([a-z]*)$/);
        a && a[1].length == 0 && r.push(T7(t, n));
      }
      return s + o;
    }
  };
  var fy = "*";
  function hq(i59, t) {
    let e = [];
    return typeof i59 == "string" ? i59.split(/\s*,\s*/).forEach((n) => pq(n, e, t)) : e.push(i59), e;
  }
  function pq(i59, t, e) {
    if (i59[0] == ":") {
      let l = fq(i59, e);
      if (typeof l == "function") {
        t.push(l);
        return;
      }
      i59 = l;
    }
    let n = i59.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
    if (n == null || n.length < 4) return e.push(V7(i59)), t;
    let r = n[1], o = n[2], s = n[3];
    t.push($k(r, s));
    let a = r == fy && s == fy;
    o[0] == "<" && !a && t.push($k(s, r));
  }
  function fq(i59, t) {
    switch (i59) {
      case ":enter":
        return "void => *";
      case ":leave":
        return "* => void";
      case ":increment":
        return (e, n) => parseFloat(n) > parseFloat(e);
      case ":decrement":
        return (e, n) => parseFloat(n) < parseFloat(e);
      default:
        return t.push(z7(i59)), "* => *";
    }
  }
  var ay = /* @__PURE__ */ new Set(["true", "1"]);
  var ly = /* @__PURE__ */ new Set(["false", "0"]);
  function $k(i59, t) {
    let e = ay.has(i59) || ly.has(i59), n = ay.has(t) || ly.has(t);
    return (r, o) => {
      let s = i59 == fy || i59 == r, a = t == fy || t == o;
      return !s && e && typeof r == "boolean" && (s = r ? ay.has(i59) : ly.has(i59)), !a && n && typeof o == "boolean" && (a = o ? ay.has(t) : ly.has(t)), s && a;
    };
  }
  var l2 = ":self";
  var mq = new RegExp(`s*${l2}s*,?`, "g");
  function c2(i59, t, e, n) {
    return new _E(i59).build(t, e, n);
  }
  var qk = "";
  var _E = class {
    _driver;
    constructor(t) {
      this._driver = t;
    }
    build(t, e, n) {
      let r = new vE(e);
      return this._resetContextStyleTimingState(r), ro(this, vf(t), r);
    }
    _resetContextStyleTimingState(t) {
      t.currentQuerySelector = qk, t.collectedStyles = /* @__PURE__ */ new Map(), t.collectedStyles.set(qk, /* @__PURE__ */ new Map()), t.currentTime = 0;
    }
    visitTrigger(t, e) {
      let n = e.queryCount = 0, r = e.depCount = 0, o = [], s = [];
      return t.name.charAt(0) == "@" && e.errors.push(I7()), t.definitions.forEach((a) => {
        if (this._resetContextStyleTimingState(e), a.type == Lt.State) {
          let l = a, c = l.name;
          c.toString().split(/\s*,\s*/).forEach((d) => {
            l.name = d, o.push(this.visitState(l, e));
          }), l.name = c;
        } else if (a.type == Lt.Transition) {
          let l = this.visitTransition(a, e);
          n += l.queryCount, r += l.depCount, s.push(l);
        } else e.errors.push(D7());
      }), { type: Lt.Trigger, name: t.name, states: o, transitions: s, queryCount: n, depCount: r, options: null };
    }
    visitState(t, e) {
      let n = this.visitStyle(t.styles, e), r = t.options && t.options.params || null;
      if (n.containsDynamicStyles) {
        let o = /* @__PURE__ */ new Set(), s = r || {};
        n.styles.forEach((a) => {
          a instanceof Map && a.forEach((l) => {
            a2(l).forEach((c) => {
              s.hasOwnProperty(c) || o.add(c);
            });
          });
        }), o.size && e.errors.push(P7(t.name, [...o.values()]));
      }
      return { type: Lt.State, name: t.name, style: n, options: r ? { params: r } : null };
    }
    visitTransition(t, e) {
      e.queryCount = 0, e.depCount = 0;
      let n = ro(this, vf(t.animation), e), r = hq(t.expr, e.errors);
      return { type: Lt.Transition, matchers: r, animation: n, queryCount: e.queryCount, depCount: e.depCount, options: Mc(t.options) };
    }
    visitSequence(t, e) {
      return { type: Lt.Sequence, steps: t.steps.map((n) => ro(this, n, e)), options: Mc(t.options) };
    }
    visitGroup(t, e) {
      let n = e.currentTime, r = 0, o = t.steps.map((s) => {
        e.currentTime = n;
        let a = ro(this, s, e);
        return r = Math.max(r, e.currentTime), a;
      });
      return e.currentTime = r, { type: Lt.Group, steps: o, options: Mc(t.options) };
    }
    visitAnimate(t, e) {
      let n = yq(t.timings, e.errors);
      e.currentAnimateTimings = n;
      let r, o = t.styles ? t.styles : _n({});
      if (o.type == Lt.Keyframes) r = this.visitKeyframes(o, e);
      else {
        let s = t.styles, a = false;
        if (!s) {
          a = true;
          let c = {};
          n.easing && (c.easing = n.easing), s = _n(c);
        }
        e.currentTime += n.duration + n.delay;
        let l = this.visitStyle(s, e);
        l.isEmptyStep = a, r = l;
      }
      return e.currentAnimateTimings = null, { type: Lt.Animate, timings: n, style: r, options: null };
    }
    visitStyle(t, e) {
      let n = this._makeStyleAst(t, e);
      return this._validateStyleAst(n, e), n;
    }
    _makeStyleAst(t, e) {
      let n = [], r = Array.isArray(t.styles) ? t.styles : [t.styles];
      for (let a of r) typeof a == "string" ? a === Es ? n.push(a) : e.errors.push(R7(a)) : n.push(new Map(Object.entries(a)));
      let o = false, s = null;
      return n.forEach((a) => {
        if (a instanceof Map && (a.has("easing") && (s = a.get("easing"), a.delete("easing")), !o)) {
          for (let l of a.values()) if (l.toString().indexOf(o2) >= 0) {
            o = true;
            break;
          }
        }
      }), { type: Lt.Style, styles: n, easing: s, offset: t.offset, containsDynamicStyles: o, options: null };
    }
    _validateStyleAst(t, e) {
      let n = e.currentAnimateTimings, r = e.currentTime, o = e.currentTime;
      n && o > 0 && (o -= n.duration + n.delay), t.styles.forEach((s) => {
        typeof s != "string" && s.forEach((a, l) => {
          let c = e.collectedStyles.get(e.currentQuerySelector), d = c.get(l), u = true;
          d && (o != r && o >= d.startTime && r <= d.endTime && (e.errors.push(O7(l, d.startTime, d.endTime, o, r)), u = false), o = d.startTime), u && c.set(l, { startTime: o, endTime: r }), e.options && aq(a, e.options, e.errors);
        });
      });
    }
    visitKeyframes(t, e) {
      let n = { type: Lt.Keyframes, styles: [], options: null };
      if (!e.currentAnimateTimings) return e.errors.push(A7()), n;
      let r = 1, o = 0, s = [], a = false, l = false, c = 0, d = t.steps.map((_) => {
        let g = this._makeStyleAst(_, e), y = g.offset != null ? g.offset : vq(g.styles), w = 0;
        return y != null && (o++, w = g.offset = y), l = l || w < 0 || w > 1, a = a || w < c, c = w, s.push(w), g;
      });
      l && e.errors.push(N7()), a && e.errors.push(k7());
      let u = t.steps.length, h = 0;
      o > 0 && o < u ? e.errors.push(L7()) : o == 0 && (h = r / (u - 1));
      let p = u - 1, f = e.currentTime, m = e.currentAnimateTimings, v = m.duration;
      return d.forEach((_, g) => {
        let y = h > 0 ? g == p ? 1 : h * g : s[g], w = y * v;
        e.currentTime = f + m.delay + w, m.duration = w, this._validateStyleAst(_, e), _.offset = y, n.styles.push(_);
      }), n;
    }
    visitReference(t, e) {
      return { type: Lt.Reference, animation: ro(this, vf(t.animation), e), options: Mc(t.options) };
    }
    visitAnimateChild(t, e) {
      return e.depCount++, { type: Lt.AnimateChild, options: Mc(t.options) };
    }
    visitAnimateRef(t, e) {
      return { type: Lt.AnimateRef, animation: this.visitReference(t.animation, e), options: Mc(t.options) };
    }
    visitQuery(t, e) {
      let n = e.currentQuerySelector, r = t.options || {};
      e.queryCount++, e.currentQuery = t;
      let [o, s] = gq(t.selector);
      e.currentQuerySelector = n.length ? n + " " + o : o, oo(e.collectedStyles, e.currentQuerySelector, /* @__PURE__ */ new Map());
      let a = ro(this, vf(t.animation), e);
      return e.currentQuery = null, e.currentQuerySelector = n, { type: Lt.Query, selector: o, limit: r.limit || 0, optional: !!r.optional, includeSelf: s, animation: a, originalSelector: t.selector, options: Mc(t.options) };
    }
    visitStagger(t, e) {
      e.currentQuery || e.errors.push(F7());
      let n = t.timings === "full" ? { duration: 0, delay: 0, easing: "full" } : hy(t.timings, e.errors, true);
      return { type: Lt.Stagger, animation: ro(this, vf(t.animation), e), timings: n, options: null };
    }
  };
  function gq(i59) {
    let t = !!i59.split(/\s*,\s*/).find((e) => e == l2);
    return t && (i59 = i59.replace(mq, "")), i59 = i59.replace(/@\*/g, uy).replace(/@\w+/g, (e) => uy + "-" + e.slice(1)).replace(/:animating/g, fE), [i59, t];
  }
  function _q(i59) {
    return i59 ? le({}, i59) : null;
  }
  var vE = class {
    errors;
    queryCount = 0;
    depCount = 0;
    currentTransition = null;
    currentQuery = null;
    currentQuerySelector = null;
    currentAnimateTimings = null;
    currentTime = 0;
    collectedStyles = /* @__PURE__ */ new Map();
    options = null;
    unsupportedCSSPropertiesFound = /* @__PURE__ */ new Set();
    constructor(t) {
      this.errors = t;
    }
  };
  function vq(i59) {
    if (typeof i59 == "string") return null;
    let t = null;
    if (Array.isArray(i59)) i59.forEach((e) => {
      if (e instanceof Map && e.has("offset")) {
        let n = e;
        t = parseFloat(n.get("offset")), n.delete("offset");
      }
    });
    else if (i59 instanceof Map && i59.has("offset")) {
      let e = i59;
      t = parseFloat(e.get("offset")), e.delete("offset");
    }
    return t;
  }
  function yq(i59, t) {
    if (i59.hasOwnProperty("duration")) return i59;
    if (typeof i59 == "number") {
      let o = hy(i59, t).duration;
      return lE(o, 0, "");
    }
    let e = i59;
    if (e.split(/\s+/).some((o) => o.charAt(0) == "{" && o.charAt(1) == "{")) {
      let o = lE(0, 0, "");
      return o.dynamic = true, o.strValue = e, o;
    }
    let r = hy(e, t);
    return lE(r.duration, r.delay, r.easing);
  }
  function Mc(i59) {
    return i59 ? (i59 = le({}, i59), i59.params && (i59.params = _q(i59.params))) : i59 = {}, i59;
  }
  function lE(i59, t, e) {
    return { duration: i59, delay: t, easing: e };
  }
  function NE(i59, t, e, n, r, o, s = null, a = false) {
    return { type: 1, element: i59, keyframes: t, preStyleProps: e, postStyleProps: n, duration: r, delay: o, totalTime: r + o, easing: s, subTimeline: a };
  }
  var xf = class {
    _map = /* @__PURE__ */ new Map();
    get(t) {
      return this._map.get(t) || [];
    }
    append(t, e) {
      let n = this._map.get(t);
      n || this._map.set(t, n = []), n.push(...e);
    }
    has(t) {
      return this._map.has(t);
    }
    clear() {
      this._map.clear();
    }
  };
  var bq = 1;
  var xq = ":enter";
  var wq = new RegExp(xq, "g");
  var Cq = ":leave";
  var Sq = new RegExp(Cq, "g");
  function d2(i59, t, e, n, r, o = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map(), a, l, c = []) {
    return new yE().buildKeyframes(i59, t, e, n, r, o, s, a, l, c);
  }
  var yE = class {
    buildKeyframes(t, e, n, r, o, s, a, l, c, d = []) {
      c = c || new xf();
      let u = new bE(t, e, c, r, o, d, []);
      u.options = l;
      let h = l.delay ? ma(l.delay) : 0;
      u.currentTimeline.delayNextStep(h), u.currentTimeline.setStyles([s], null, u.errors, l), ro(this, n, u);
      let p = u.timelines.filter((f) => f.containsAnimation());
      if (p.length && a.size) {
        let f;
        for (let m = p.length - 1; m >= 0; m--) {
          let v = p[m];
          if (v.element === e) {
            f = v;
            break;
          }
        }
        f && !f.allowOnlyTimelineStyles() && f.setStyles([a], null, u.errors, l);
      }
      return p.length ? p.map((f) => f.buildKeyframes()) : [NE(e, [], [], [], 0, h, "", false)];
    }
    visitTrigger(t, e) {
    }
    visitState(t, e) {
    }
    visitTransition(t, e) {
    }
    visitAnimateChild(t, e) {
      let n = e.subInstructions.get(e.element);
      if (n) {
        let r = e.createSubContext(t.options), o = e.currentTimeline.currentTime, s = this._visitSubInstructions(n, r, r.options);
        o != s && e.transformIntoNewTimeline(s);
      }
      e.previousNode = t;
    }
    visitAnimateRef(t, e) {
      let n = e.createSubContext(t.options);
      n.transformIntoNewTimeline(), this._applyAnimationRefDelays([t.options, t.animation.options], e, n), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t;
    }
    _applyAnimationRefDelays(t, e, n) {
      for (let r of t) {
        let o = r?.delay;
        if (o) {
          let s = typeof o == "number" ? o : ma(bf(o, r?.params ?? {}, e.errors));
          n.delayNextStep(s);
        }
      }
    }
    _visitSubInstructions(t, e, n) {
      let o = e.currentTimeline.currentTime, s = n.duration != null ? ma(n.duration) : null, a = n.delay != null ? ma(n.delay) : null;
      return s !== 0 && t.forEach((l) => {
        let c = e.appendInstructionToTimeline(l, s, a);
        o = Math.max(o, c.duration + c.delay);
      }), o;
    }
    visitReference(t, e) {
      e.updateOptions(t.options, true), ro(this, t.animation, e), e.previousNode = t;
    }
    visitSequence(t, e) {
      let n = e.subContextCount, r = e, o = t.options;
      if (o && (o.params || o.delay) && (r = e.createSubContext(o), r.transformIntoNewTimeline(), o.delay != null)) {
        r.previousNode.type == Lt.Style && (r.currentTimeline.snapshotCurrentStyles(), r.previousNode = my);
        let s = ma(o.delay);
        r.delayNextStep(s);
      }
      t.steps.length && (t.steps.forEach((s) => ro(this, s, r)), r.currentTimeline.applyStylesToKeyframe(), r.subContextCount > n && r.transformIntoNewTimeline()), e.previousNode = t;
    }
    visitGroup(t, e) {
      let n = [], r = e.currentTimeline.currentTime, o = t.options && t.options.delay ? ma(t.options.delay) : 0;
      t.steps.forEach((s) => {
        let a = e.createSubContext(t.options);
        o && a.delayNextStep(o), ro(this, s, a), r = Math.max(r, a.currentTimeline.currentTime), n.push(a.currentTimeline);
      }), n.forEach((s) => e.currentTimeline.mergeTimelineCollectedStyles(s)), e.transformIntoNewTimeline(r), e.previousNode = t;
    }
    _visitTiming(t, e) {
      if (t.dynamic) {
        let n = t.strValue, r = e.params ? bf(n, e.params, e.errors) : n;
        return hy(r, e.errors);
      } else return { duration: t.duration, delay: t.delay, easing: t.easing };
    }
    visitAnimate(t, e) {
      let n = e.currentAnimateTimings = this._visitTiming(t.timings, e), r = e.currentTimeline;
      n.delay && (e.incrementTime(n.delay), r.snapshotCurrentStyles());
      let o = t.style;
      o.type == Lt.Keyframes ? this.visitKeyframes(o, e) : (e.incrementTime(n.duration), this.visitStyle(o, e), r.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t;
    }
    visitStyle(t, e) {
      let n = e.currentTimeline, r = e.currentAnimateTimings;
      !r && n.hasCurrentStyleProperties() && n.forwardFrame();
      let o = r && r.easing || t.easing;
      t.isEmptyStep ? n.applyEmptyStep(o) : n.setStyles(t.styles, o, e.errors, e.options), e.previousNode = t;
    }
    visitKeyframes(t, e) {
      let n = e.currentAnimateTimings, r = e.currentTimeline.duration, o = n.duration, a = e.createSubContext().currentTimeline;
      a.easing = n.easing, t.styles.forEach((l) => {
        let c = l.offset || 0;
        a.forwardTime(c * o), a.setStyles(l.styles, l.easing, e.errors, e.options), a.applyStylesToKeyframe();
      }), e.currentTimeline.mergeTimelineCollectedStyles(a), e.transformIntoNewTimeline(r + o), e.previousNode = t;
    }
    visitQuery(t, e) {
      let n = e.currentTimeline.currentTime, r = t.options || {}, o = r.delay ? ma(r.delay) : 0;
      o && (e.previousNode.type === Lt.Style || n == 0 && e.currentTimeline.hasCurrentStyleProperties()) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = my);
      let s = n, a = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!r.optional, e.errors);
      e.currentQueryTotal = a.length;
      let l = null;
      a.forEach((c, d) => {
        e.currentQueryIndex = d;
        let u = e.createSubContext(t.options, c);
        o && u.delayNextStep(o), c === e.element && (l = u.currentTimeline), ro(this, t.animation, u), u.currentTimeline.applyStylesToKeyframe();
        let h = u.currentTimeline.currentTime;
        s = Math.max(s, h);
      }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(s), l && (e.currentTimeline.mergeTimelineCollectedStyles(l), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t;
    }
    visitStagger(t, e) {
      let n = e.parentContext, r = e.currentTimeline, o = t.timings, s = Math.abs(o.duration), a = s * (e.currentQueryTotal - 1), l = s * e.currentQueryIndex;
      switch (o.duration < 0 ? "reverse" : o.easing) {
        case "reverse":
          l = a - l;
          break;
        case "full":
          l = n.currentStaggerTime;
          break;
      }
      let d = e.currentTimeline;
      l && d.delayNextStep(l);
      let u = d.currentTime;
      ro(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = r.currentTime - u + (r.startTime - n.currentTimeline.startTime);
    }
  };
  var my = {};
  var bE = class i17 {
    _driver;
    element;
    subInstructions;
    _enterClassName;
    _leaveClassName;
    errors;
    timelines;
    parentContext = null;
    currentTimeline;
    currentAnimateTimings = null;
    previousNode = my;
    subContextCount = 0;
    options = {};
    currentQueryIndex = 0;
    currentQueryTotal = 0;
    currentStaggerTime = 0;
    constructor(t, e, n, r, o, s, a, l) {
      this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = r, this._leaveClassName = o, this.errors = s, this.timelines = a, this.currentTimeline = l || new gy(this._driver, e, 0), a.push(this.currentTimeline);
    }
    get params() {
      return this.options.params;
    }
    updateOptions(t, e) {
      if (!t) return;
      let n = t, r = this.options;
      n.duration != null && (r.duration = ma(n.duration)), n.delay != null && (r.delay = ma(n.delay));
      let o = n.params;
      if (o) {
        let s = r.params;
        s || (s = this.options.params = {}), Object.keys(o).forEach((a) => {
          (!e || !s.hasOwnProperty(a)) && (s[a] = bf(o[a], s, this.errors));
        });
      }
    }
    _copyOptions() {
      let t = {};
      if (this.options) {
        let e = this.options.params;
        if (e) {
          let n = t.params = {};
          Object.keys(e).forEach((r) => {
            n[r] = e[r];
          });
        }
      }
      return t;
    }
    createSubContext(t = null, e, n) {
      let r = e || this.element, o = new i17(this._driver, r, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(r, n || 0));
      return o.previousNode = this.previousNode, o.currentAnimateTimings = this.currentAnimateTimings, o.options = this._copyOptions(), o.updateOptions(t), o.currentQueryIndex = this.currentQueryIndex, o.currentQueryTotal = this.currentQueryTotal, o.parentContext = this, this.subContextCount++, o;
    }
    transformIntoNewTimeline(t) {
      return this.previousNode = my, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline;
    }
    appendInstructionToTimeline(t, e, n) {
      let r = { duration: e ?? t.duration, delay: this.currentTimeline.currentTime + (n ?? 0) + t.delay, easing: "" }, o = new xE(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, r, t.stretchStartingKeyframe);
      return this.timelines.push(o), r;
    }
    incrementTime(t) {
      this.currentTimeline.forwardTime(this.currentTimeline.duration + t);
    }
    delayNextStep(t) {
      t > 0 && this.currentTimeline.delayNextStep(t);
    }
    invokeQuery(t, e, n, r, o, s) {
      let a = [];
      if (r && a.push(this.element), t.length > 0) {
        t = t.replace(wq, "." + this._enterClassName), t = t.replace(Sq, "." + this._leaveClassName);
        let l = n != 1, c = this._driver.query(this.element, t, l);
        n !== 0 && (c = n < 0 ? c.slice(c.length + n, c.length) : c.slice(0, n)), a.push(...c);
      }
      return !o && a.length == 0 && s.push(B7(e)), a;
    }
  };
  var gy = class i18 {
    _driver;
    element;
    startTime;
    _elementTimelineStylesLookup;
    duration = 0;
    easing = null;
    _previousKeyframe = /* @__PURE__ */ new Map();
    _currentKeyframe = /* @__PURE__ */ new Map();
    _keyframes = /* @__PURE__ */ new Map();
    _styleSummary = /* @__PURE__ */ new Map();
    _localTimelineStyles = /* @__PURE__ */ new Map();
    _globalTimelineStyles;
    _pendingStyles = /* @__PURE__ */ new Map();
    _backFill = /* @__PURE__ */ new Map();
    _currentEmptyStepKeyframe = null;
    constructor(t, e, n, r) {
      this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = r, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = /* @__PURE__ */ new Map()), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe();
    }
    containsAnimation() {
      switch (this._keyframes.size) {
        case 0:
          return false;
        case 1:
          return this.hasCurrentStyleProperties();
        default:
          return true;
      }
    }
    hasCurrentStyleProperties() {
      return this._currentKeyframe.size > 0;
    }
    get currentTime() {
      return this.startTime + this.duration;
    }
    delayNextStep(t) {
      let e = this._keyframes.size === 1 && this._pendingStyles.size;
      this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t;
    }
    fork(t, e) {
      return this.applyStylesToKeyframe(), new i18(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup);
    }
    _loadKeyframe() {
      this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = /* @__PURE__ */ new Map(), this._keyframes.set(this.duration, this._currentKeyframe));
    }
    forwardFrame() {
      this.duration += bq, this._loadKeyframe();
    }
    forwardTime(t) {
      this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe();
    }
    _updateStyle(t, e) {
      this._localTimelineStyles.set(t, e), this._globalTimelineStyles.set(t, e), this._styleSummary.set(t, { time: this.currentTime, value: e });
    }
    allowOnlyTimelineStyles() {
      return this._currentEmptyStepKeyframe !== this._currentKeyframe;
    }
    applyEmptyStep(t) {
      t && this._previousKeyframe.set("easing", t);
      for (let [e, n] of this._globalTimelineStyles) this._backFill.set(e, n || Es), this._currentKeyframe.set(e, Es);
      this._currentEmptyStepKeyframe = this._currentKeyframe;
    }
    setStyles(t, e, n, r) {
      e && this._previousKeyframe.set("easing", e);
      let o = r && r.params || {}, s = Mq(t, this._globalTimelineStyles);
      for (let [a, l] of s) {
        let c = bf(l, o, n);
        this._pendingStyles.set(a, c), this._localTimelineStyles.has(a) || this._backFill.set(a, this._globalTimelineStyles.get(a) ?? Es), this._updateStyle(a, c);
      }
    }
    applyStylesToKeyframe() {
      this._pendingStyles.size != 0 && (this._pendingStyles.forEach((t, e) => {
        this._currentKeyframe.set(e, t);
      }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((t, e) => {
        this._currentKeyframe.has(e) || this._currentKeyframe.set(e, t);
      }));
    }
    snapshotCurrentStyles() {
      for (let [t, e] of this._localTimelineStyles) this._pendingStyles.set(t, e), this._updateStyle(t, e);
    }
    getFinalKeyframe() {
      return this._keyframes.get(this.duration);
    }
    get properties() {
      let t = [];
      for (let e in this._currentKeyframe) t.push(e);
      return t;
    }
    mergeTimelineCollectedStyles(t) {
      t._styleSummary.forEach((e, n) => {
        let r = this._styleSummary.get(n);
        (!r || e.time > r.time) && this._updateStyle(n, e.value);
      });
    }
    buildKeyframes() {
      this.applyStylesToKeyframe();
      let t = /* @__PURE__ */ new Set(), e = /* @__PURE__ */ new Set(), n = this._keyframes.size === 1 && this.duration === 0, r = [];
      this._keyframes.forEach((a, l) => {
        let c = new Map([...this._backFill, ...a]);
        c.forEach((d, u) => {
          d === oy ? t.add(u) : d === Es && e.add(u);
        }), n || c.set("offset", l / this.duration), r.push(c);
      });
      let o = [...t.values()], s = [...e.values()];
      if (n) {
        let a = r[0], l = new Map(a);
        a.set("offset", 0), l.set("offset", 1), r = [a, l];
      }
      return NE(this.element, r, o, s, this.duration, this.startTime, this.easing, false);
    }
  };
  var xE = class extends gy {
    keyframes;
    preStyleProps;
    postStyleProps;
    _stretchStartingKeyframe;
    timings;
    constructor(t, e, n, r, o, s, a = false) {
      super(t, e, s.delay), this.keyframes = n, this.preStyleProps = r, this.postStyleProps = o, this._stretchStartingKeyframe = a, this.timings = { duration: s.duration, delay: s.delay, easing: s.easing };
    }
    containsAnimation() {
      return this.keyframes.length > 1;
    }
    buildKeyframes() {
      let t = this.keyframes, { delay: e, duration: n, easing: r } = this.timings;
      if (this._stretchStartingKeyframe && e) {
        let o = [], s = n + e, a = e / s, l = new Map(t[0]);
        l.set("offset", 0), o.push(l);
        let c = new Map(t[0]);
        c.set("offset", Yk(a)), o.push(c);
        let d = t.length - 1;
        for (let u = 1; u <= d; u++) {
          let h = new Map(t[u]), p = h.get("offset"), f = e + p * n;
          h.set("offset", Yk(f / s)), o.push(h);
        }
        n = s, e = 0, r = "", t = o;
      }
      return NE(this.element, t, this.preStyleProps, this.postStyleProps, n, e, r, true);
    }
  };
  function Yk(i59, t = 3) {
    let e = Math.pow(10, t - 1);
    return Math.round(i59 * e) / e;
  }
  function Mq(i59, t) {
    let e = /* @__PURE__ */ new Map(), n;
    return i59.forEach((r) => {
      if (r === "*") {
        n ??= t.keys();
        for (let o of n) e.set(o, Es);
      } else for (let [o, s] of r) e.set(o, s);
    }), e;
  }
  function Xk(i59, t, e, n, r, o, s, a, l, c, d, u, h) {
    return { type: 0, element: i59, triggerName: t, isRemovalTransition: r, fromState: e, fromStyles: o, toState: n, toStyles: s, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: d, totalTime: u, errors: h };
  }
  var cE = {};
  var _y = class {
    _triggerName;
    ast;
    _stateStyles;
    constructor(t, e, n) {
      this._triggerName = t, this.ast = e, this._stateStyles = n;
    }
    match(t, e, n, r) {
      return Eq(this.ast.matchers, t, e, n, r);
    }
    buildStyles(t, e, n) {
      let r = this._stateStyles.get("*");
      return t !== void 0 && (r = this._stateStyles.get(t?.toString()) || r), r ? r.buildStyles(e, n) : /* @__PURE__ */ new Map();
    }
    build(t, e, n, r, o, s, a, l, c, d) {
      let u = [], h = this.ast.options && this.ast.options.params || cE, p = a && a.params || cE, f = this.buildStyles(n, p, u), m = l && l.params || cE, v = this.buildStyles(r, m, u), _ = /* @__PURE__ */ new Set(), g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), w = r === "void", E = { params: u2(m, h), delay: this.ast.options?.delay }, P = d ? [] : d2(t, e, this.ast.animation, o, s, f, v, E, c, u), S = 0;
      return P.forEach((A) => {
        S = Math.max(A.duration + A.delay, S);
      }), u.length ? Xk(e, this._triggerName, n, r, w, f, v, [], [], g, y, S, u) : (P.forEach((A) => {
        let W = A.element, H = oo(g, W, /* @__PURE__ */ new Set());
        A.preStyleProps.forEach((I) => H.add(I));
        let O = oo(y, W, /* @__PURE__ */ new Set());
        A.postStyleProps.forEach((I) => O.add(I)), W !== e && _.add(W);
      }), Xk(e, this._triggerName, n, r, w, f, v, P, [..._.values()], g, y, S));
    }
  };
  function Eq(i59, t, e, n, r) {
    return i59.some((o) => o(t, e, n, r));
  }
  function u2(i59, t) {
    let e = le({}, t);
    return Object.entries(i59).forEach(([n, r]) => {
      r != null && (e[n] = r);
    }), e;
  }
  var wE = class {
    styles;
    defaultParams;
    normalizer;
    constructor(t, e, n) {
      this.styles = t, this.defaultParams = e, this.normalizer = n;
    }
    buildStyles(t, e) {
      let n = /* @__PURE__ */ new Map(), r = u2(t, this.defaultParams);
      return this.styles.styles.forEach((o) => {
        typeof o != "string" && o.forEach((s, a) => {
          s && (s = bf(s, r, e));
          let l = this.normalizer.normalizePropertyName(a, e);
          s = this.normalizer.normalizeStyleValue(a, l, s, e), n.set(a, s);
        });
      }), n;
    }
  };
  function Tq(i59, t, e) {
    return new CE(i59, t, e);
  }
  var CE = class {
    name;
    ast;
    _normalizer;
    transitionFactories = [];
    fallbackTransition;
    states = /* @__PURE__ */ new Map();
    constructor(t, e, n) {
      this.name = t, this.ast = e, this._normalizer = n, e.states.forEach((r) => {
        let o = r.options && r.options.params || {};
        this.states.set(r.name, new wE(r.style, o, n));
      }), Zk(this.states, "true", "1"), Zk(this.states, "false", "0"), e.transitions.forEach((r) => {
        this.transitionFactories.push(new _y(t, r, this.states));
      }), this.fallbackTransition = Iq(t, this.states, this._normalizer);
    }
    get containsQueries() {
      return this.ast.queryCount > 0;
    }
    matchTransition(t, e, n, r) {
      return this.transitionFactories.find((s) => s.match(t, e, n, r)) || null;
    }
    matchStyles(t, e, n) {
      return this.fallbackTransition.buildStyles(t, e, n);
    }
  };
  function Iq(i59, t, e) {
    let n = [(s, a) => true], r = { type: Lt.Sequence, steps: [], options: null }, o = { type: Lt.Transition, animation: r, matchers: n, options: null, queryCount: 0, depCount: 0 };
    return new _y(i59, o, t);
  }
  function Zk(i59, t, e) {
    i59.has(t) ? i59.has(e) || i59.set(e, i59.get(t)) : i59.has(e) && i59.set(t, i59.get(e));
  }
  var Dq = new xf();
  var SE = class {
    bodyNode;
    _driver;
    _normalizer;
    _animations = /* @__PURE__ */ new Map();
    _playersById = /* @__PURE__ */ new Map();
    players = [];
    constructor(t, e, n) {
      this.bodyNode = t, this._driver = e, this._normalizer = n;
    }
    register(t, e) {
      let n = [], r = [], o = c2(this._driver, e, n, r);
      if (n.length) throw H7(n);
      this._animations.set(t, o);
    }
    _buildPlayer(t, e, n) {
      let r = t.element, o = n2(this._normalizer, t.keyframes, e, n);
      return this._driver.animate(r, o, t.duration, t.delay, t.easing, [], true);
    }
    create(t, e, n = {}) {
      let r = [], o = this._animations.get(t), s, a = /* @__PURE__ */ new Map();
      if (o ? (s = d2(this._driver, e, o, s2, pE, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), n, Dq, r), s.forEach((d) => {
        let u = oo(a, d.element, /* @__PURE__ */ new Map());
        d.postStyleProps.forEach((h) => u.set(h, null));
      })) : (r.push(j7()), s = []), r.length) throw W7(r);
      a.forEach((d, u) => {
        d.forEach((h, p) => {
          d.set(p, this._driver.computeStyle(u, p, Es));
        });
      });
      let l = s.map((d) => {
        let u = a.get(d.element);
        return this._buildPlayer(d, /* @__PURE__ */ new Map(), u);
      }), c = il(l);
      return this._playersById.set(t, c), c.onDestroy(() => this.destroy(t)), this.players.push(c), c;
    }
    destroy(t) {
      let e = this._getPlayer(t);
      e.destroy(), this._playersById.delete(t);
      let n = this.players.indexOf(e);
      n >= 0 && this.players.splice(n, 1);
    }
    _getPlayer(t) {
      let e = this._playersById.get(t);
      if (!e) throw $7(t);
      return e;
    }
    listen(t, e, n, r) {
      let o = DE(e, "", "", "");
      return IE(this._getPlayer(t), n, o, r), () => {
      };
    }
    command(t, e, n, r) {
      if (n == "register") {
        this.register(t, r[0]);
        return;
      }
      if (n == "create") {
        let s = r[0] || {};
        this.create(t, e, s);
        return;
      }
      let o = this._getPlayer(t);
      switch (n) {
        case "play":
          o.play();
          break;
        case "pause":
          o.pause();
          break;
        case "reset":
          o.reset();
          break;
        case "restart":
          o.restart();
          break;
        case "finish":
          o.finish();
          break;
        case "init":
          o.init();
          break;
        case "setPosition":
          o.setPosition(parseFloat(r[0]));
          break;
        case "destroy":
          this.destroy(t);
          break;
      }
    }
  };
  var Qk = "ng-animate-queued";
  var Pq = ".ng-animate-queued";
  var dE = "ng-animate-disabled";
  var Rq = ".ng-animate-disabled";
  var Oq = "ng-star-inserted";
  var Aq = ".ng-star-inserted";
  var Nq = [];
  var h2 = { namespaceId: "", setForRemoval: false, setForMove: false, hasAnimation: false, removedBeforeQueried: false };
  var kq = { namespaceId: "", setForMove: false, setForRemoval: false, hasAnimation: false, removedBeforeQueried: true };
  var Ko = "__ng_removed";
  var wf = class {
    namespaceId;
    value;
    options;
    get params() {
      return this.options.params;
    }
    constructor(t, e = "") {
      this.namespaceId = e;
      let n = t && t.hasOwnProperty("value"), r = n ? t.value : t;
      if (this.value = Fq(r), n) {
        let o = t, { value: s } = o, a = Hw(o, ["value"]);
        this.options = a;
      } else this.options = {};
      this.options.params || (this.options.params = {});
    }
    absorbOptions(t) {
      let e = t.params;
      if (e) {
        let n = this.options.params;
        Object.keys(e).forEach((r) => {
          n[r] == null && (n[r] = e[r]);
        });
      }
    }
  };
  var yf = "void";
  var uE = new wf(yf);
  var ME = class {
    id;
    hostElement;
    _engine;
    players = [];
    _triggers = /* @__PURE__ */ new Map();
    _queue = [];
    _elementListeners = /* @__PURE__ */ new Map();
    _hostClassName;
    constructor(t, e, n) {
      this.id = t, this.hostElement = e, this._engine = n, this._hostClassName = "ng-tns-" + t, Mo(e, this._hostClassName);
    }
    listen(t, e, n, r) {
      if (!this._triggers.has(e)) throw q7(n, e);
      if (n == null || n.length == 0) throw Y7(e);
      if (!Bq(n)) throw X7(n, e);
      let o = oo(this._elementListeners, t, []), s = { name: e, phase: n, callback: r };
      o.push(s);
      let a = oo(this._engine.statesByElement, t, /* @__PURE__ */ new Map());
      return a.has(e) || (Mo(t, sy), Mo(t, sy + "-" + e), a.set(e, uE)), () => {
        this._engine.afterFlush(() => {
          let l = o.indexOf(s);
          l >= 0 && o.splice(l, 1), this._triggers.has(e) || a.delete(e);
        });
      };
    }
    register(t, e) {
      return this._triggers.has(t) ? false : (this._triggers.set(t, e), true);
    }
    _getTrigger(t) {
      let e = this._triggers.get(t);
      if (!e) throw Z7(t);
      return e;
    }
    trigger(t, e, n, r = true) {
      let o = this._getTrigger(e), s = new Cf(this.id, e, t), a = this._engine.statesByElement.get(t);
      a || (Mo(t, sy), Mo(t, sy + "-" + e), this._engine.statesByElement.set(t, a = /* @__PURE__ */ new Map()));
      let l = a.get(e), c = new wf(n, this.id);
      if (!(n && n.hasOwnProperty("value")) && l && c.absorbOptions(l.options), a.set(e, c), l || (l = uE), !(c.value === yf) && l.value === c.value) {
        if (!Uq(l.params, c.params)) {
          let m = [], v = o.matchStyles(l.value, l.params, m), _ = o.matchStyles(c.value, c.params, m);
          m.length ? this._engine.reportError(m) : this._engine.afterFlush(() => {
            Ec(t, v), Ts(t, _);
          });
        }
        return;
      }
      let h = oo(this._engine.playersByElement, t, []);
      h.forEach((m) => {
        m.namespaceId == this.id && m.triggerName == e && m.queued && m.destroy();
      });
      let p = o.matchTransition(l.value, c.value, t, c.params), f = false;
      if (!p) {
        if (!r) return;
        p = o.fallbackTransition, f = true;
      }
      return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: p, fromState: l, toState: c, player: s, isFallbackTransition: f }), f || (Mo(t, Qk), s.onStart(() => {
        Iu(t, Qk);
      })), s.onDone(() => {
        let m = this.players.indexOf(s);
        m >= 0 && this.players.splice(m, 1);
        let v = this._engine.playersByElement.get(t);
        if (v) {
          let _ = v.indexOf(s);
          _ >= 0 && v.splice(_, 1);
        }
      }), this.players.push(s), h.push(s), s;
    }
    deregister(t) {
      this._triggers.delete(t), this._engine.statesByElement.forEach((e) => e.delete(t)), this._elementListeners.forEach((e, n) => {
        this._elementListeners.set(n, e.filter((r) => r.name != t));
      });
    }
    clearElementCache(t) {
      this._engine.statesByElement.delete(t), this._elementListeners.delete(t);
      let e = this._engine.playersByElement.get(t);
      e && (e.forEach((n) => n.destroy()), this._engine.playersByElement.delete(t));
    }
    _signalRemovalForInnerTriggers(t, e) {
      let n = this._engine.driver.query(t, uy, true);
      n.forEach((r) => {
        if (r[Ko]) return;
        let o = this._engine.fetchNamespacesByElement(r);
        o.size ? o.forEach((s) => s.triggerLeaveAnimation(r, e, false, true)) : this.clearElementCache(r);
      }), this._engine.afterFlushAnimationsDone(() => n.forEach((r) => this.clearElementCache(r)));
    }
    triggerLeaveAnimation(t, e, n, r) {
      let o = this._engine.statesByElement.get(t), s = /* @__PURE__ */ new Map();
      if (o) {
        let a = [];
        if (o.forEach((l, c) => {
          if (s.set(c, l.value), this._triggers.has(c)) {
            let d = this.trigger(t, c, yf, r);
            d && a.push(d);
          }
        }), a.length) return this._engine.markElementAsRemoved(this.id, t, true, e, s), n && il(a).onDone(() => this._engine.processLeaveNode(t)), true;
      }
      return false;
    }
    prepareLeaveAnimationListeners(t) {
      let e = this._elementListeners.get(t), n = this._engine.statesByElement.get(t);
      if (e && n) {
        let r = /* @__PURE__ */ new Set();
        e.forEach((o) => {
          let s = o.name;
          if (r.has(s)) return;
          r.add(s);
          let l = this._triggers.get(s).fallbackTransition, c = n.get(s) || uE, d = new wf(yf), u = new Cf(this.id, s, t);
          this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: l, fromState: c, toState: d, player: u, isFallbackTransition: true });
        });
      }
    }
    removeNode(t, e) {
      let n = this._engine;
      if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, true)) return;
      let r = false;
      if (n.totalAnimations) {
        let o = n.players.length ? n.playersByQueriedElement.get(t) : [];
        if (o && o.length) r = true;
        else {
          let s = t;
          for (; s = s.parentNode; ) if (n.statesByElement.get(s)) {
            r = true;
            break;
          }
        }
      }
      if (this.prepareLeaveAnimationListeners(t), r) n.markElementAsRemoved(this.id, t, false, e);
      else {
        let o = t[Ko];
        (!o || o === h2) && (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e));
      }
    }
    insertNode(t, e) {
      Mo(t, this._hostClassName);
    }
    drainQueuedTransitions(t) {
      let e = [];
      return this._queue.forEach((n) => {
        let r = n.player;
        if (r.destroyed) return;
        let o = n.element, s = this._elementListeners.get(o);
        s && s.forEach((a) => {
          if (a.name == n.triggerName) {
            let l = DE(o, n.triggerName, n.fromState.value, n.toState.value);
            l._data = t, IE(n.player, a.phase, l, a.callback);
          }
        }), r.markedForDestroy ? this._engine.afterFlush(() => {
          r.destroy();
        }) : e.push(n);
      }), this._queue = [], e.sort((n, r) => {
        let o = n.transition.ast.depCount, s = r.transition.ast.depCount;
        return o == 0 || s == 0 ? o - s : this._engine.driver.containsElement(n.element, r.element) ? 1 : -1;
      });
    }
    destroy(t) {
      this.players.forEach((e) => e.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t);
    }
  };
  var EE = class {
    bodyNode;
    driver;
    _normalizer;
    players = [];
    newHostElements = /* @__PURE__ */ new Map();
    playersByElement = /* @__PURE__ */ new Map();
    playersByQueriedElement = /* @__PURE__ */ new Map();
    statesByElement = /* @__PURE__ */ new Map();
    disabledNodes = /* @__PURE__ */ new Set();
    totalAnimations = 0;
    totalQueuedPlayers = 0;
    _namespaceLookup = {};
    _namespaceList = [];
    _flushFns = [];
    _whenQuietFns = [];
    namespacesByHostElement = /* @__PURE__ */ new Map();
    collectedEnterElements = [];
    collectedLeaveElements = [];
    onRemovalComplete = (t, e) => {
    };
    _onRemovalComplete(t, e) {
      this.onRemovalComplete(t, e);
    }
    constructor(t, e, n) {
      this.bodyNode = t, this.driver = e, this._normalizer = n;
    }
    get queuedPlayers() {
      let t = [];
      return this._namespaceList.forEach((e) => {
        e.players.forEach((n) => {
          n.queued && t.push(n);
        });
      }), t;
    }
    createNamespace(t, e) {
      let n = new ME(t, e, this);
      return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n;
    }
    _balanceNamespaceList(t, e) {
      let n = this._namespaceList, r = this.namespacesByHostElement;
      if (n.length - 1 >= 0) {
        let s = false, a = this.driver.getParentElement(e);
        for (; a; ) {
          let l = r.get(a);
          if (l) {
            let c = n.indexOf(l);
            n.splice(c + 1, 0, t), s = true;
            break;
          }
          a = this.driver.getParentElement(a);
        }
        s || n.unshift(t);
      } else n.push(t);
      return r.set(e, t), t;
    }
    register(t, e) {
      let n = this._namespaceLookup[t];
      return n || (n = this.createNamespace(t, e)), n;
    }
    registerTrigger(t, e, n) {
      let r = this._namespaceLookup[t];
      r && r.register(e, n) && this.totalAnimations++;
    }
    destroy(t, e) {
      t && (this.afterFlush(() => {
      }), this.afterFlushAnimationsDone(() => {
        let n = this._fetchNamespace(t);
        this.namespacesByHostElement.delete(n.hostElement);
        let r = this._namespaceList.indexOf(n);
        r >= 0 && this._namespaceList.splice(r, 1), n.destroy(e), delete this._namespaceLookup[t];
      }));
    }
    _fetchNamespace(t) {
      return this._namespaceLookup[t];
    }
    fetchNamespacesByElement(t) {
      let e = /* @__PURE__ */ new Set(), n = this.statesByElement.get(t);
      if (n) {
        for (let r of n.values()) if (r.namespaceId) {
          let o = this._fetchNamespace(r.namespaceId);
          o && e.add(o);
        }
      }
      return e;
    }
    trigger(t, e, n, r) {
      if (cy(e)) {
        let o = this._fetchNamespace(t);
        if (o) return o.trigger(e, n, r), true;
      }
      return false;
    }
    insertNode(t, e, n, r) {
      if (!cy(e)) return;
      let o = e[Ko];
      if (o && o.setForRemoval) {
        o.setForRemoval = false, o.setForMove = true;
        let s = this.collectedLeaveElements.indexOf(e);
        s >= 0 && this.collectedLeaveElements.splice(s, 1);
      }
      if (t) {
        let s = this._fetchNamespace(t);
        s && s.insertNode(e, n);
      }
      r && this.collectEnterElement(e);
    }
    collectEnterElement(t) {
      this.collectedEnterElements.push(t);
    }
    markElementAsDisabled(t, e) {
      e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), Mo(t, dE)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), Iu(t, dE));
    }
    removeNode(t, e, n) {
      if (cy(e)) {
        let r = t ? this._fetchNamespace(t) : null;
        r ? r.removeNode(e, n) : this.markElementAsRemoved(t, e, false, n);
        let o = this.namespacesByHostElement.get(e);
        o && o.id !== t && o.removeNode(e, n);
      } else this._onRemovalComplete(e, n);
    }
    markElementAsRemoved(t, e, n, r, o) {
      this.collectedLeaveElements.push(e), e[Ko] = { namespaceId: t, setForRemoval: r, hasAnimation: n, removedBeforeQueried: false, previousTriggersValues: o };
    }
    listen(t, e, n, r, o) {
      return cy(e) ? this._fetchNamespace(t).listen(e, n, r, o) : () => {
      };
    }
    _buildInstruction(t, e, n, r, o) {
      return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, r, t.fromState.options, t.toState.options, e, o);
    }
    destroyInnerAnimations(t) {
      let e = this.driver.query(t, uy, true);
      e.forEach((n) => this.destroyActiveAnimationsForElement(n)), this.playersByQueriedElement.size != 0 && (e = this.driver.query(t, fE, true), e.forEach((n) => this.finishActiveQueriedAnimationOnElement(n)));
    }
    destroyActiveAnimationsForElement(t) {
      let e = this.playersByElement.get(t);
      e && e.forEach((n) => {
        n.queued ? n.markedForDestroy = true : n.destroy();
      });
    }
    finishActiveQueriedAnimationOnElement(t) {
      let e = this.playersByQueriedElement.get(t);
      e && e.forEach((n) => n.finish());
    }
    whenRenderingDone() {
      return new Promise((t) => {
        if (this.players.length) return il(this.players).onDone(() => t());
        t();
      });
    }
    processLeaveNode(t) {
      let e = t[Ko];
      if (e && e.setForRemoval) {
        if (t[Ko] = h2, e.namespaceId) {
          this.destroyInnerAnimations(t);
          let n = this._fetchNamespace(e.namespaceId);
          n && n.clearElementCache(t);
        }
        this._onRemovalComplete(t, e.setForRemoval);
      }
      t.classList?.contains(dE) && this.markElementAsDisabled(t, false), this.driver.query(t, Rq, true).forEach((n) => {
        this.markElementAsDisabled(n, false);
      });
    }
    flush(t = -1) {
      let e = [];
      if (this.newHostElements.size && (this.newHostElements.forEach((n, r) => this._balanceNamespaceList(n, r)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++) {
        let r = this.collectedEnterElements[n];
        Mo(r, Oq);
      }
      if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
        let n = [];
        try {
          e = this._flushAnimations(n, t);
        } finally {
          for (let r = 0; r < n.length; r++) n[r]();
        }
      } else for (let n = 0; n < this.collectedLeaveElements.length; n++) {
        let r = this.collectedLeaveElements[n];
        this.processLeaveNode(r);
      }
      if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach((n) => n()), this._flushFns = [], this._whenQuietFns.length) {
        let n = this._whenQuietFns;
        this._whenQuietFns = [], e.length ? il(e).onDone(() => {
          n.forEach((r) => r());
        }) : n.forEach((r) => r());
      }
    }
    reportError(t) {
      throw Q7(t);
    }
    _flushAnimations(t, e) {
      let n = new xf(), r = [], o = /* @__PURE__ */ new Map(), s = [], a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Set();
      this.disabledNodes.forEach((k) => {
        d.add(k);
        let z = this.driver.query(k, Pq, true);
        for (let R = 0; R < z.length; R++) d.add(z[R]);
      });
      let u = this.bodyNode, h = Array.from(this.statesByElement.keys()), p = e2(h, this.collectedEnterElements), f = /* @__PURE__ */ new Map(), m = 0;
      p.forEach((k, z) => {
        let R = s2 + m++;
        f.set(z, R), k.forEach((V) => Mo(V, R));
      });
      let v = [], _ = /* @__PURE__ */ new Set(), g = /* @__PURE__ */ new Set();
      for (let k = 0; k < this.collectedLeaveElements.length; k++) {
        let z = this.collectedLeaveElements[k], R = z[Ko];
        R && R.setForRemoval && (v.push(z), _.add(z), R.hasAnimation ? this.driver.query(z, Aq, true).forEach((V) => _.add(V)) : g.add(z));
      }
      let y = /* @__PURE__ */ new Map(), w = e2(h, Array.from(_));
      w.forEach((k, z) => {
        let R = pE + m++;
        y.set(z, R), k.forEach((V) => Mo(V, R));
      }), t.push(() => {
        p.forEach((k, z) => {
          let R = f.get(z);
          k.forEach((V) => Iu(V, R));
        }), w.forEach((k, z) => {
          let R = y.get(z);
          k.forEach((V) => Iu(V, R));
        }), v.forEach((k) => {
          this.processLeaveNode(k);
        });
      });
      let E = [], P = [];
      for (let k = this._namespaceList.length - 1; k >= 0; k--) this._namespaceList[k].drainQueuedTransitions(e).forEach((R) => {
        let V = R.player, ie = R.element;
        if (E.push(V), this.collectedEnterElements.length) {
          let Ve = ie[Ko];
          if (Ve && Ve.setForMove) {
            if (Ve.previousTriggersValues && Ve.previousTriggersValues.has(R.triggerName)) {
              let ue = Ve.previousTriggersValues.get(R.triggerName), ee = this.statesByElement.get(R.element);
              if (ee && ee.has(R.triggerName)) {
                let Q = ee.get(R.triggerName);
                Q.value = ue, ee.set(R.triggerName, Q);
              }
            }
            V.destroy();
            return;
          }
        }
        let re = !u || !this.driver.containsElement(u, ie), Re = y.get(ie), ne = f.get(ie), oe = this._buildInstruction(R, n, ne, Re, re);
        if (oe.errors && oe.errors.length) {
          P.push(oe);
          return;
        }
        if (re) {
          V.onStart(() => Ec(ie, oe.fromStyles)), V.onDestroy(() => Ts(ie, oe.toStyles)), r.push(V);
          return;
        }
        if (R.isFallbackTransition) {
          V.onStart(() => Ec(ie, oe.fromStyles)), V.onDestroy(() => Ts(ie, oe.toStyles)), r.push(V);
          return;
        }
        let Be = [];
        oe.timelines.forEach((Ve) => {
          Ve.stretchStartingKeyframe = true, this.disabledNodes.has(Ve.element) || Be.push(Ve);
        }), oe.timelines = Be, n.append(ie, oe.timelines);
        let me = { instruction: oe, player: V, element: ie };
        s.push(me), oe.queriedElements.forEach((Ve) => oo(a, Ve, []).push(V)), oe.preStyleProps.forEach((Ve, ue) => {
          if (Ve.size) {
            let ee = l.get(ue);
            ee || l.set(ue, ee = /* @__PURE__ */ new Set()), Ve.forEach((Q, _e) => ee.add(_e));
          }
        }), oe.postStyleProps.forEach((Ve, ue) => {
          let ee = c.get(ue);
          ee || c.set(ue, ee = /* @__PURE__ */ new Set()), Ve.forEach((Q, _e) => ee.add(_e));
        });
      });
      if (P.length) {
        let k = [];
        P.forEach((z) => {
          k.push(K7(z.triggerName, z.errors));
        }), E.forEach((z) => z.destroy()), this.reportError(k);
      }
      let S = /* @__PURE__ */ new Map(), A = /* @__PURE__ */ new Map();
      s.forEach((k) => {
        let z = k.element;
        n.has(z) && (A.set(z, z), this._beforeAnimationBuild(k.player.namespaceId, k.instruction, S));
      }), r.forEach((k) => {
        let z = k.element;
        this._getPreviousPlayers(z, false, k.namespaceId, k.triggerName, null).forEach((V) => {
          oo(S, z, []).push(V), V.destroy();
        });
      });
      let W = v.filter((k) => t2(k, l, c)), H = /* @__PURE__ */ new Map();
      Jk(H, this.driver, g, c, Es).forEach((k) => {
        t2(k, l, c) && W.push(k);
      });
      let I = /* @__PURE__ */ new Map();
      p.forEach((k, z) => {
        Jk(I, this.driver, new Set(k), l, oy);
      }), W.forEach((k) => {
        let z = H.get(k), R = I.get(k);
        H.set(k, new Map([...z?.entries() ?? [], ...R?.entries() ?? []]));
      });
      let F = [], j = [], $ = {};
      s.forEach((k) => {
        let { element: z, player: R, instruction: V } = k;
        if (n.has(z)) {
          if (d.has(z)) {
            R.onDestroy(() => Ts(z, V.toStyles)), R.disabled = true, R.overrideTotalTime(V.totalTime), r.push(R);
            return;
          }
          let ie = $;
          if (A.size > 1) {
            let Re = z, ne = [];
            for (; Re = Re.parentNode; ) {
              let oe = A.get(Re);
              if (oe) {
                ie = oe;
                break;
              }
              ne.push(Re);
            }
            ne.forEach((oe) => A.set(oe, ie));
          }
          let re = this._buildAnimation(R.namespaceId, V, S, o, I, H);
          if (R.setRealPlayer(re), ie === $) F.push(R);
          else {
            let Re = this.playersByElement.get(ie);
            Re && Re.length && (R.parentPlayer = il(Re)), r.push(R);
          }
        } else Ec(z, V.fromStyles), R.onDestroy(() => Ts(z, V.toStyles)), j.push(R), d.has(z) && r.push(R);
      }), j.forEach((k) => {
        let z = o.get(k.element);
        if (z && z.length) {
          let R = il(z);
          k.setRealPlayer(R);
        }
      }), r.forEach((k) => {
        k.parentPlayer ? k.syncPlayerEvents(k.parentPlayer) : k.destroy();
      });
      for (let k = 0; k < v.length; k++) {
        let z = v[k], R = z[Ko];
        if (Iu(z, pE), R && R.hasAnimation) continue;
        let V = [];
        if (a.size) {
          let re = a.get(z);
          re && re.length && V.push(...re);
          let Re = this.driver.query(z, fE, true);
          for (let ne = 0; ne < Re.length; ne++) {
            let oe = a.get(Re[ne]);
            oe && oe.length && V.push(...oe);
          }
        }
        let ie = V.filter((re) => !re.destroyed);
        ie.length ? Vq(this, z, ie) : this.processLeaveNode(z);
      }
      return v.length = 0, F.forEach((k) => {
        this.players.push(k), k.onDone(() => {
          k.destroy();
          let z = this.players.indexOf(k);
          this.players.splice(z, 1);
        }), k.play();
      }), F;
    }
    afterFlush(t) {
      this._flushFns.push(t);
    }
    afterFlushAnimationsDone(t) {
      this._whenQuietFns.push(t);
    }
    _getPreviousPlayers(t, e, n, r, o) {
      let s = [];
      if (e) {
        let a = this.playersByQueriedElement.get(t);
        a && (s = a);
      } else {
        let a = this.playersByElement.get(t);
        if (a) {
          let l = !o || o == yf;
          a.forEach((c) => {
            c.queued || !l && c.triggerName != r || s.push(c);
          });
        }
      }
      return (n || r) && (s = s.filter((a) => !(n && n != a.namespaceId || r && r != a.triggerName))), s;
    }
    _beforeAnimationBuild(t, e, n) {
      let r = e.triggerName, o = e.element, s = e.isRemovalTransition ? void 0 : t, a = e.isRemovalTransition ? void 0 : r;
      for (let l of e.timelines) {
        let c = l.element, d = c !== o, u = oo(n, c, []);
        this._getPreviousPlayers(c, d, s, a, e.toState).forEach((p) => {
          let f = p.getRealPlayer();
          f.beforeDestroy && f.beforeDestroy(), p.destroy(), u.push(p);
        });
      }
      Ec(o, e.fromStyles);
    }
    _buildAnimation(t, e, n, r, o, s) {
      let a = e.triggerName, l = e.element, c = [], d = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set(), h = e.timelines.map((f) => {
        let m = f.element;
        d.add(m);
        let v = m[Ko];
        if (v && v.removedBeforeQueried) return new nl(f.duration, f.delay);
        let _ = m !== l, g = zq((n.get(m) || Nq).map((S) => S.getRealPlayer())).filter((S) => {
          let A = S;
          return A.element ? A.element === m : false;
        }), y = o.get(m), w = s.get(m), E = n2(this._normalizer, f.keyframes, y, w), P = this._buildPlayer(f, E, g);
        if (f.subTimeline && r && u.add(m), _) {
          let S = new Cf(t, a, m);
          S.setRealPlayer(P), c.push(S);
        }
        return P;
      });
      c.forEach((f) => {
        oo(this.playersByQueriedElement, f.element, []).push(f), f.onDone(() => Lq(this.playersByQueriedElement, f.element, f));
      }), d.forEach((f) => Mo(f, Wk));
      let p = il(h);
      return p.onDestroy(() => {
        d.forEach((f) => Iu(f, Wk)), Ts(l, e.toStyles);
      }), u.forEach((f) => {
        oo(r, f, []).push(p);
      }), p;
    }
    _buildPlayer(t, e, n) {
      return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new nl(t.duration, t.delay);
    }
  };
  var Cf = class {
    namespaceId;
    triggerName;
    element;
    _player = new nl();
    _containsRealPlayer = false;
    _queuedCallbacks = /* @__PURE__ */ new Map();
    destroyed = false;
    parentPlayer = null;
    markedForDestroy = false;
    disabled = false;
    queued = true;
    totalTime = 0;
    constructor(t, e, n) {
      this.namespaceId = t, this.triggerName = e, this.element = n;
    }
    setRealPlayer(t) {
      this._containsRealPlayer || (this._player = t, this._queuedCallbacks.forEach((e, n) => {
        e.forEach((r) => IE(t, n, void 0, r));
      }), this._queuedCallbacks.clear(), this._containsRealPlayer = true, this.overrideTotalTime(t.totalTime), this.queued = false);
    }
    getRealPlayer() {
      return this._player;
    }
    overrideTotalTime(t) {
      this.totalTime = t;
    }
    syncPlayerEvents(t) {
      let e = this._player;
      e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy());
    }
    _queueEvent(t, e) {
      oo(this._queuedCallbacks, t, []).push(e);
    }
    onDone(t) {
      this.queued && this._queueEvent("done", t), this._player.onDone(t);
    }
    onStart(t) {
      this.queued && this._queueEvent("start", t), this._player.onStart(t);
    }
    onDestroy(t) {
      this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t);
    }
    init() {
      this._player.init();
    }
    hasStarted() {
      return this.queued ? false : this._player.hasStarted();
    }
    play() {
      !this.queued && this._player.play();
    }
    pause() {
      !this.queued && this._player.pause();
    }
    restart() {
      !this.queued && this._player.restart();
    }
    finish() {
      this._player.finish();
    }
    destroy() {
      this.destroyed = true, this._player.destroy();
    }
    reset() {
      !this.queued && this._player.reset();
    }
    setPosition(t) {
      this.queued || this._player.setPosition(t);
    }
    getPosition() {
      return this.queued ? 0 : this._player.getPosition();
    }
    triggerCallback(t) {
      let e = this._player;
      e.triggerCallback && e.triggerCallback(t);
    }
  };
  function Lq(i59, t, e) {
    let n = i59.get(t);
    if (n) {
      if (n.length) {
        let r = n.indexOf(e);
        n.splice(r, 1);
      }
      n.length == 0 && i59.delete(t);
    }
    return n;
  }
  function Fq(i59) {
    return i59 ?? null;
  }
  function cy(i59) {
    return i59 && i59.nodeType === 1;
  }
  function Bq(i59) {
    return i59 == "start" || i59 == "done";
  }
  function Kk(i59, t) {
    let e = i59.style.display;
    return i59.style.display = t ?? "none", e;
  }
  function Jk(i59, t, e, n, r) {
    let o = [];
    e.forEach((l) => o.push(Kk(l)));
    let s = [];
    n.forEach((l, c) => {
      let d = /* @__PURE__ */ new Map();
      l.forEach((u) => {
        let h = t.computeStyle(c, u, r);
        d.set(u, h), (!h || h.length == 0) && (c[Ko] = kq, s.push(c));
      }), i59.set(c, d);
    });
    let a = 0;
    return e.forEach((l) => Kk(l, o[a++])), s;
  }
  function e2(i59, t) {
    let e = /* @__PURE__ */ new Map();
    if (i59.forEach((a) => e.set(a, [])), t.length == 0) return e;
    let n = 1, r = new Set(t), o = /* @__PURE__ */ new Map();
    function s(a) {
      if (!a) return n;
      let l = o.get(a);
      if (l) return l;
      let c = a.parentNode;
      return e.has(c) ? l = c : r.has(c) ? l = n : l = s(c), o.set(a, l), l;
    }
    return t.forEach((a) => {
      let l = s(a);
      l !== n && e.get(l).push(a);
    }), e;
  }
  function Mo(i59, t) {
    i59.classList?.add(t);
  }
  function Iu(i59, t) {
    i59.classList?.remove(t);
  }
  function Vq(i59, t, e) {
    il(e).onDone(() => i59.processLeaveNode(t));
  }
  function zq(i59) {
    let t = [];
    return p2(i59, t), t;
  }
  function p2(i59, t) {
    for (let e = 0; e < i59.length; e++) {
      let n = i59[e];
      n instanceof _f ? p2(n.players, t) : t.push(n);
    }
  }
  function Uq(i59, t) {
    let e = Object.keys(i59), n = Object.keys(t);
    if (e.length != n.length) return false;
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      if (!t.hasOwnProperty(o) || i59[o] !== t[o]) return false;
    }
    return true;
  }
  function t2(i59, t, e) {
    let n = e.get(i59);
    if (!n) return false;
    let r = t.get(i59);
    return r ? n.forEach((o) => r.add(o)) : t.set(i59, n), e.delete(i59), true;
  }
  var Du = class {
    _driver;
    _normalizer;
    _transitionEngine;
    _timelineEngine;
    _triggerCache = {};
    onRemovalComplete = (t, e) => {
    };
    constructor(t, e, n) {
      this._driver = e, this._normalizer = n, this._transitionEngine = new EE(t.body, e, n), this._timelineEngine = new SE(t.body, e, n), this._transitionEngine.onRemovalComplete = (r, o) => this.onRemovalComplete(r, o);
    }
    registerTrigger(t, e, n, r, o) {
      let s = t + "-" + r, a = this._triggerCache[s];
      if (!a) {
        let l = [], c = [], d = c2(this._driver, o, l, c);
        if (l.length) throw U7(r, l);
        a = Tq(r, d, this._normalizer), this._triggerCache[s] = a;
      }
      this._transitionEngine.registerTrigger(e, r, a);
    }
    register(t, e) {
      this._transitionEngine.register(t, e);
    }
    destroy(t, e) {
      this._transitionEngine.destroy(t, e);
    }
    onInsert(t, e, n, r) {
      this._transitionEngine.insertNode(t, e, n, r);
    }
    onRemove(t, e, n) {
      this._transitionEngine.removeNode(t, e, n);
    }
    disableAnimations(t, e) {
      this._transitionEngine.markElementAsDisabled(t, e);
    }
    process(t, e, n, r) {
      if (n.charAt(0) == "@") {
        let [o, s] = Hk(n), a = r;
        this._timelineEngine.command(o, e, s, a);
      } else this._transitionEngine.trigger(t, e, n, r);
    }
    listen(t, e, n, r, o) {
      if (n.charAt(0) == "@") {
        let [s, a] = Hk(n);
        return this._timelineEngine.listen(s, e, a, o);
      }
      return this._transitionEngine.listen(t, e, n, r, o);
    }
    flush(t = -1) {
      this._transitionEngine.flush(t);
    }
    get players() {
      return [...this._transitionEngine.players, ...this._timelineEngine.players];
    }
    whenRenderingDone() {
      return this._transitionEngine.whenRenderingDone();
    }
    afterFlushAnimationsDone(t) {
      this._transitionEngine.afterFlushAnimationsDone(t);
    }
  };
  function Gq(i59, t) {
    let e = null, n = null;
    return Array.isArray(t) && t.length ? (e = hE(t[0]), t.length > 1 && (n = hE(t[t.length - 1]))) : t instanceof Map && (e = hE(t)), e || n ? new Hq(i59, e, n) : null;
  }
  var Hq = /* @__PURE__ */ (() => {
    class i59 {
      _element;
      _startStyles;
      _endStyles;
      static initialStylesByElement = /* @__PURE__ */ new WeakMap();
      _state = 0;
      _initialStyles;
      constructor(e, n, r) {
        this._element = e, this._startStyles = n, this._endStyles = r;
        let o = i59.initialStylesByElement.get(e);
        o || i59.initialStylesByElement.set(e, o = /* @__PURE__ */ new Map()), this._initialStyles = o;
      }
      start() {
        this._state < 1 && (this._startStyles && Ts(this._element, this._startStyles, this._initialStyles), this._state = 1);
      }
      finish() {
        this.start(), this._state < 2 && (Ts(this._element, this._initialStyles), this._endStyles && (Ts(this._element, this._endStyles), this._endStyles = null), this._state = 1);
      }
      destroy() {
        this.finish(), this._state < 3 && (i59.initialStylesByElement.delete(this._element), this._startStyles && (Ec(this._element, this._startStyles), this._endStyles = null), this._endStyles && (Ec(this._element, this._endStyles), this._endStyles = null), Ts(this._element, this._initialStyles), this._state = 3);
      }
    }
    return i59;
  })();
  function hE(i59) {
    let t = null;
    return i59.forEach((e, n) => {
      jq(n) && (t = t || /* @__PURE__ */ new Map(), t.set(n, e));
    }), t;
  }
  function jq(i59) {
    return i59 === "display" || i59 === "position";
  }
  var vy = class {
    element;
    keyframes;
    options;
    _specialStyles;
    _onDoneFns = [];
    _onStartFns = [];
    _onDestroyFns = [];
    _duration;
    _delay;
    _initialized = false;
    _finished = false;
    _started = false;
    _destroyed = false;
    _finalKeyframe;
    _originalOnDoneFns = [];
    _originalOnStartFns = [];
    domPlayer;
    time = 0;
    parentPlayer = null;
    currentSnapshot = /* @__PURE__ */ new Map();
    constructor(t, e, n, r) {
      this.element = t, this.keyframes = e, this.options = n, this._specialStyles = r, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay;
    }
    _onFinish() {
      this._finished || (this._finished = true, this._onDoneFns.forEach((t) => t()), this._onDoneFns = []);
    }
    init() {
      this._buildPlayer(), this._preparePlayerBeforeStart();
    }
    _buildPlayer() {
      if (this._initialized) return;
      this._initialized = true;
      let t = this.keyframes;
      this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : /* @__PURE__ */ new Map();
      let e = () => this._onFinish();
      this.domPlayer.addEventListener("finish", e), this.onDestroy(() => {
        this.domPlayer.removeEventListener("finish", e);
      });
    }
    _preparePlayerBeforeStart() {
      this._delay ? this._resetDomPlayerState() : this.domPlayer.pause();
    }
    _convertKeyframesToObject(t) {
      let e = [];
      return t.forEach((n) => {
        e.push(Object.fromEntries(n));
      }), e;
    }
    _triggerWebAnimation(t, e, n) {
      return t.animate(this._convertKeyframesToObject(e), n);
    }
    onStart(t) {
      this._originalOnStartFns.push(t), this._onStartFns.push(t);
    }
    onDone(t) {
      this._originalOnDoneFns.push(t), this._onDoneFns.push(t);
    }
    onDestroy(t) {
      this._onDestroyFns.push(t);
    }
    play() {
      this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach((t) => t()), this._onStartFns = [], this._started = true, this._specialStyles && this._specialStyles.start()), this.domPlayer.play();
    }
    pause() {
      this.init(), this.domPlayer.pause();
    }
    finish() {
      this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish();
    }
    reset() {
      this._resetDomPlayerState(), this._destroyed = false, this._finished = false, this._started = false, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns;
    }
    _resetDomPlayerState() {
      this.domPlayer && this.domPlayer.cancel();
    }
    restart() {
      this.reset(), this.play();
    }
    hasStarted() {
      return this._started;
    }
    destroy() {
      this._destroyed || (this._destroyed = true, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach((t) => t()), this._onDestroyFns = []);
    }
    setPosition(t) {
      this.domPlayer === void 0 && this.init(), this.domPlayer.currentTime = t * this.time;
    }
    getPosition() {
      return +(this.domPlayer.currentTime ?? 0) / this.time;
    }
    get totalTime() {
      return this._delay + this._duration;
    }
    beforeDestroy() {
      let t = /* @__PURE__ */ new Map();
      this.hasStarted() && this._finalKeyframe.forEach((n, r) => {
        r !== "offset" && t.set(r, this._finished ? n : AE(this.element, r));
      }), this.currentSnapshot = t;
    }
    triggerCallback(t) {
      let e = t === "start" ? this._onStartFns : this._onDoneFns;
      e.forEach((n) => n()), e.length = 0;
    }
  };
  var yy = class {
    validateStyleProperty(t) {
      return true;
    }
    validateAnimatableStyleProperty(t) {
      return true;
    }
    containsElement(t, e) {
      return i22(t, e);
    }
    getParentElement(t) {
      return PE(t);
    }
    query(t, e, n) {
      return r2(t, e, n);
    }
    computeStyle(t, e, n) {
      return AE(t, e);
    }
    animate(t, e, n, r, o, s = []) {
      let a = r == 0 ? "both" : "forwards", l = { duration: n, delay: r, fill: a };
      o && (l.easing = o);
      let c = /* @__PURE__ */ new Map(), d = s.filter((p) => p instanceof vy);
      cq(n, r) && d.forEach((p) => {
        p.currentSnapshot.forEach((f, m) => c.set(m, f));
      });
      let u = sq(e).map((p) => new Map(p));
      u = dq(t, u, c);
      let h = Gq(t, u);
      return new vy(t, u, l, h);
    }
  };
  var dy = "@";
  var f2 = "@.disabled";
  var by = class {
    namespaceId;
    delegate;
    engine;
    _onDestroy;
    \u0275type = 0;
    constructor(t, e, n, r) {
      this.namespaceId = t, this.delegate = e, this.engine = n, this._onDestroy = r;
    }
    get data() {
      return this.delegate.data;
    }
    destroyNode(t) {
      this.delegate.destroyNode?.(t);
    }
    destroy() {
      this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => {
        queueMicrotask(() => {
          this.delegate.destroy();
        });
      }), this._onDestroy?.();
    }
    createElement(t, e) {
      return this.delegate.createElement(t, e);
    }
    createComment(t) {
      return this.delegate.createComment(t);
    }
    createText(t) {
      return this.delegate.createText(t);
    }
    appendChild(t, e) {
      this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, false);
    }
    insertBefore(t, e, n, r = true) {
      this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, r);
    }
    removeChild(t, e, n) {
      this.parentNode(e) && this.engine.onRemove(this.namespaceId, e, this.delegate);
    }
    selectRootElement(t, e) {
      return this.delegate.selectRootElement(t, e);
    }
    parentNode(t) {
      return this.delegate.parentNode(t);
    }
    nextSibling(t) {
      return this.delegate.nextSibling(t);
    }
    setAttribute(t, e, n, r) {
      this.delegate.setAttribute(t, e, n, r);
    }
    removeAttribute(t, e, n) {
      this.delegate.removeAttribute(t, e, n);
    }
    addClass(t, e) {
      this.delegate.addClass(t, e);
    }
    removeClass(t, e) {
      this.delegate.removeClass(t, e);
    }
    setStyle(t, e, n, r) {
      this.delegate.setStyle(t, e, n, r);
    }
    removeStyle(t, e, n) {
      this.delegate.removeStyle(t, e, n);
    }
    setProperty(t, e, n) {
      e.charAt(0) == dy && e == f2 ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n);
    }
    setValue(t, e) {
      this.delegate.setValue(t, e);
    }
    listen(t, e, n, r) {
      return this.delegate.listen(t, e, n, r);
    }
    disableAnimations(t, e) {
      this.engine.disableAnimations(t, e);
    }
  };
  var TE = class extends by {
    factory;
    constructor(t, e, n, r, o) {
      super(e, n, r, o), this.factory = t, this.namespaceId = e;
    }
    setProperty(t, e, n) {
      e.charAt(0) == dy ? e.charAt(1) == "." && e == f2 ? (n = n === void 0 ? true : !!n, this.disableAnimations(t, n)) : this.engine.process(this.namespaceId, t, e.slice(1), n) : this.delegate.setProperty(t, e, n);
    }
    listen(t, e, n, r) {
      if (e.charAt(0) == dy) {
        let o = Wq(t), s = e.slice(1), a = "";
        return s.charAt(0) != dy && ([s, a] = $q(s)), this.engine.listen(this.namespaceId, o, s, a, (l) => {
          let c = l._data || -1;
          this.factory.scheduleListenerCallback(c, n, l);
        });
      }
      return this.delegate.listen(t, e, n, r);
    }
  };
  function Wq(i59) {
    switch (i59) {
      case "body":
        return document.body;
      case "document":
        return document;
      case "window":
        return window;
      default:
        return i59;
    }
  }
  function $q(i59) {
    let t = i59.indexOf("."), e = i59.substring(0, t), n = i59.slice(t + 1);
    return [e, n];
  }
  var xy = class {
    delegate;
    engine;
    _zone;
    _currentId = 0;
    _microtaskId = 1;
    _animationCallbacksBuffer = [];
    _rendererCache = /* @__PURE__ */ new Map();
    _cdRecurDepth = 0;
    constructor(t, e, n) {
      this.delegate = t, this.engine = e, this._zone = n, e.onRemovalComplete = (r, o) => {
        o?.removeChild(null, r);
      };
    }
    createRenderer(t, e) {
      let n = "", r = this.delegate.createRenderer(t, e);
      if (!t || !e?.data?.animation) {
        let c = this._rendererCache, d = c.get(r);
        if (!d) {
          let u = () => c.delete(r);
          d = new by(n, r, this.engine, u), c.set(r, d);
        }
        return d;
      }
      let o = e.id, s = e.id + "-" + this._currentId;
      this._currentId++, this.engine.register(s, t);
      let a = (c) => {
        Array.isArray(c) ? c.forEach(a) : this.engine.registerTrigger(o, s, t, c.name, c);
      };
      return e.data.animation.forEach(a), new TE(this, s, r, this.engine);
    }
    begin() {
      this._cdRecurDepth++, this.delegate.begin && this.delegate.begin();
    }
    _scheduleCountTask() {
      queueMicrotask(() => {
        this._microtaskId++;
      });
    }
    scheduleListenerCallback(t, e, n) {
      if (t >= 0 && t < this._microtaskId) {
        this._zone.run(() => e(n));
        return;
      }
      let r = this._animationCallbacksBuffer;
      r.length == 0 && queueMicrotask(() => {
        this._zone.run(() => {
          r.forEach((o) => {
            let [s, a] = o;
            s(a);
          }), this._animationCallbacksBuffer = [];
        });
      }), r.push([e, n]);
    }
    end() {
      this._cdRecurDepth--, this._cdRecurDepth == 0 && this._zone.runOutsideAngular(() => {
        this._scheduleCountTask(), this.engine.flush(this._microtaskId);
      }), this.delegate.end && this.delegate.end();
    }
    whenRenderingDone() {
      return this.engine.whenRenderingDone();
    }
    componentReplaced(t) {
      this.engine.flush(), this.delegate.componentReplaced?.(t);
    }
  };
  var Yq = (() => {
    class i59 extends Du {
      constructor(e, n, r) {
        super(e, n, r);
      }
      ngOnDestroy() {
        this.flush();
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(yt), Ze(Tc), Ze(Ic));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  function Xq() {
    return new py();
  }
  function Zq(i59, t, e) {
    return new xy(i59, t, e);
  }
  var m2 = [{ provide: Ic, useFactory: Xq }, { provide: Du, useClass: Yq }, { provide: pr, useFactory: Zq, deps: [Jv, Du, We] }];
  var Qq = [{ provide: Tc, useFactory: () => new yy() }, { provide: An, useValue: "BrowserAnimations" }, ...m2];
  var Zwe = [{ provide: Tc, useClass: RE }, { provide: An, useValue: "NoopAnimations" }, ...m2];
  function g2() {
    return no("NgEagerAnimations"), [...Qq];
  }
  function wi(i59) {
    i59 || (pc(wi), i59 = M(pi));
    let t = new Et((e) => i59.onDestroy(e.next.bind(e)));
    return (e) => e.pipe(Je(t));
  }
  function wy(i59, t) {
    !t?.injector && pc(wy);
    let e = t?.injector ?? M(mt), n = new $o(1), r = ht(() => {
      let o;
      try {
        o = i59();
      } catch (s) {
        Rr(() => n.error(s));
        return;
      }
      Rr(() => n.next(o));
    }, { injector: e, manualCleanup: true });
    return e.get(pi).onDestroy(() => {
      r.destroy(), n.complete();
    }), n.asObservable();
  }
  var Eo = 11;
  var Cy = 4;
  var kE = 16;
  var LE = 200;
  var Sf = 12;
  var Ru = 14;
  var Sy = 6;
  var FE = 6;
  var My = 9;
  var BE = 1e3;
  var At = 1e-3;
  var VE = 25;
  var zE = 5;
  var Ey = "me_test";
  var _2 = 0.1;
  var Ty = "model_explorer_show_on_node_item_types_v2";
  var Iy = "model_explorer_show_on_edge_item_v3";
  var v2 = "model_explorer_show_on_edge_item_types_v2";
  var ga = "Node data provider: ";
  var rl = 10;
  var y2 = 7.5;
  var _a = "__value";
  var To = "__tensor_tag";
  var UE = 20;
  var Dy = { aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32" };
  var b2 = "model-explorer-export-to-resource";
  var x2 = "model-explorer-export-selected-nodes";
  var Ou = 14;
  var Au = function(i59) {
    return i59.NODE_IDS = "node_ids", i59;
  }(Au || {});
  var ol = function(i59) {
    return i59[i59.MAIN_PANEL = 0] = "MAIN_PANEL", i59[i59.POPUP = 1] = "POPUP", i59[i59.GRAPH_PANEL = 2] = "GRAPH_PANEL", i59;
  }(ol || {});
  var Kq = function(i59) {
    return i59[i59.WEBGL = 0] = "WEBGL", i59;
  }(Kq || {});
  var _t = function(i59) {
    return i59.NODE_LABEL = "title", i59.INPUT_METADATA = "input", i59.OUTPUT_METADATA = "output", i59.ATTRIBUTE = "list", i59;
  }(_t || {});
  var Wt = function(i59) {
    return i59.OP_NODE_ID = "Op node id", i59.OP_ATTRS = "Op node attributes", i59.OP_INPUTS = "Op node inputs", i59.OP_OUTPUTS = "Op node outputs", i59.LAYER_NODE_CHILDREN_COUNT = "Layer node children count", i59.LAYER_NODE_DESCENDANTS_COUNT = "Layer node descendants count", i59.LAYER_NODE_ATTRS = "Layer node attributes", i59;
  }(Wt || {});
  var hn = function(i59) {
    return i59.OFF = "Off", i59.TENSOR_SHAPE = "Tensor shape", i59.OUTPUT_METADATA = "Output metadata", i59.INPUT_METADATA = "Input metadata", i59.SOURCE_NODE_ATTR = "Source node attribute", i59.TARGET_NODE_ATTR = "Target node attribute", i59;
  }(hn || {});
  var Jt = function(i59) {
    return i59[i59.REGULAR = 0] = "REGULAR", i59[i59.MEDIUM = 1] = "MEDIUM", i59[i59.BOLD = 2] = "BOLD", i59[i59.MONOSPACE_MEDIUM = 3] = "MONOSPACE_MEDIUM", i59[i59.ICONS = 4] = "ICONS", i59;
  }(Jt || {});
  var sl = function(i59) {
    return i59.OP_NODE_ID = "id", i59.NUMBER_OF_CHILDREN = "#children", i59.NUMBER_OF_DESCENDANTS = "#descendants", i59;
  }(sl || {});
  var Is = function(i59) {
    return i59.NODE_BG_COLOR = "node_bg_color", i59.NODE_TEXT_COLOR = "node_text_color", i59.NODE_BORDER_COLOR = "node_border_color", i59;
  }(Is || {});
  var Py = function(i59) {
    return i59.V2 = "v2", i59;
  }(Py || {});
  var Dn = function(i59) {
    return i59.REGEX = "regex", i59.ATTR_VALUE_RANGE = "attr_value_range", i59.NODE_TYPE = "node_type", i59;
  }(Dn || {});
  var _r = function(i59) {
    return i59.OP_NODES = "op_nodes", i59.LAYER_NODES = "layer_nodes", i59.OP_AND_LAYER_NODES = "op_and_layer_nodes", i59;
  }(_r || {});
  var Ds = function(i59) {
    return i59[i59.OP_NODE = 0] = "OP_NODE", i59[i59.GROUP_NODE = 1] = "GROUP_NODE", i59;
  }(Ds || {});
  var mCe = new OffscreenCanvas(300, 300);
  var Mf = typeof navigator < "u" && /Macintosh/.test(navigator.userAgent);
  function dt(i59) {
    return i59?.nodeType === Ds.OP_NODE;
  }
  function ct(i59) {
    return i59?.nodeType === Ds.GROUP_NODE;
  }
  function GE(i59) {
    let t = [];
    for (let [e, n] of Object.entries(i59)) switch (e) {
      case Wt.OP_NODE_ID:
        n.selected && t.push(sl.OP_NODE_ID);
        break;
      default:
        break;
    }
    return t;
  }
  function HE(i59) {
    let t = [];
    for (let [e, n] of Object.entries(i59)) switch (e) {
      case Wt.LAYER_NODE_CHILDREN_COUNT:
        n.selected && t.push(sl.NUMBER_OF_CHILDREN);
        break;
      case Wt.LAYER_NODE_DESCENDANTS_COUNT:
        n.selected && t.push(sl.NUMBER_OF_DESCENDANTS);
        break;
      default:
        break;
    }
    return t;
  }
  function Ry(i59, t) {
    if (dt(i59)) switch (t.toLowerCase()) {
      case sl.OP_NODE_ID:
        return i59.id;
      case "namespace":
        return Dc(i59);
      default:
        break;
    }
    else if (ct(i59)) switch (t.toLowerCase()) {
      case "namespace":
        return Dc(i59);
      case sl.NUMBER_OF_CHILDREN:
        return String((i59.nsChildrenIds || []).length);
      case sl.NUMBER_OF_DESCENDANTS:
        return String((i59.descendantsNodeIds || []).length);
      default:
        break;
    }
    return "";
  }
  function Dc(i59) {
    return i59.fullNamespace || i59.namespace || "<root>";
  }
  function Li() {
    return Math.random().toString(36).slice(-6);
  }
  function Ef(i59, t, e, n = false) {
    let r = [];
    i59 == null ? r = t.rootNodes.map((o) => o.id) : r = i59.nsChildrenIds || [];
    for (let o of r) {
      let s = t.nodesById[o];
      if (s && ct(s) && (n || !n && s.expanded)) {
        let a = s.nsChildrenIds || [];
        (n ? a.filter((c) => ct(t.nodesById[c])).length === 0 : a.filter((c) => ct(t.nodesById[c])).every((c) => !t.nodesById[c].expanded)) && e.push(s.id), Ef(s, t, e, n);
      }
    }
  }
  function Nu(i59, t, e, n) {
    let r = [];
    if (i59.length === 2) r = i59;
    else if (i59.length === 3 && i59[0].x === i59[1].x && i59[1].x === i59[2].x) r = i59;
    else {
      let o = true, s = 0;
      for (let l = 0; l < i59.length - 1; l++) {
        let c = i59[l], u = i59[l + 1] > c ? 1 : -1;
        if (s !== 0 && s !== u) {
          o = false;
          break;
        }
        s = u;
      }
      let a = n.Vector3;
      if (o) {
        let c = t().x((h) => h.x).y((h) => h.y).curve(e)(i59).split(/M|C/).filter((h) => h !== "").map((h) => h.split(",").map((p) => Number(p))), d = new a(c[0][0], c[0][1], 0), u = new n.CurvePath();
        for (let h = 1; h < c.length; h++) {
          let p = c[h];
          if (p.length === 6) {
            let f = d, m = new a(p[0], p[1]), v = new a(p[2], p[3]), _ = new a(p[4], p[5]);
            d = _;
            let g = new n.CubicBezierCurve3(f, m, v, _);
            u.add(g);
          }
        }
        r = u.getPoints(VE);
      } else {
        let l = i59.map((d) => new a(d.x, d.y, 0));
        r = new n.CatmullRomCurve3(l, false, "catmullrom", _2).getPoints(VE);
      }
    }
    return r;
  }
  function Oy() {
    let i59 = w2();
    return i59 ? i59.tagName === "INPUT" || i59.tagName === "SELECT" || i59.tagName === "TEXTAREA" || i59.contentEditable === "true" : false;
  }
  function w2(i59 = document) {
    let t = i59.activeElement;
    return t ? t.shadowRoot ? w2(t.shadowRoot) : t : null;
  }
  function Jq(i59, t, e) {
    let n = e[To];
    return n ? `Input${i59}:${n} (${t.label})` : `Input${i59} (${t.label})`;
  }
  function eY(i59, t, e) {
    let n = `Output${i59}`;
    if (e.label === "GraphInputs") {
      let r = t.tensor_name;
      r != null && (n = `${n} (${r})`);
    } else {
      let r = t[To];
      r && (n = `Output${i59}:${r}`);
    }
    return n;
  }
  function C2(i59) {
    let t = ((i59 || {}).shape || "").replace(/ /g, "").replace(//g, "x");
    return t === "" && (t = "?"), t;
  }
  function jE(i59, t = "") {
    let e = i59.attrs || {}, n = [], r = new RegExp(t, "i");
    for (let o of Object.keys(e)) {
      let s = o, a = e[o];
      if (typeof a == "string") {
        let l = [`${s}:${a}`, `${s}=${a}`];
        if (t.trim() === "" || l.some((c) => r.test(c))) {
          let c = a;
          s === _a ? c = a.replace(/\s/gm, "") : c = a.replace(/(\r\n|\n|\r)/gm, " "), n.push({ key: s, value: c });
        }
      }
    }
    return n;
  }
  function WE(i59, t, e = "") {
    let n = t.groupNodeAttributes?.[i59.id.replace("___group___", "")] || {}, r = [], o = new RegExp(e, "i");
    for (let s of Object.keys(n)) {
      let a = s, l = n[s], c = [`${a}:${l}`, `${a}=${l}`];
      if (e.trim() === "" || c.some((d) => o.test(d))) {
        let d = l.replace(/(\r\n|\n|\r)/gm, " ");
        r.push({ key: a, value: d });
      }
    }
    return r;
  }
  function $E(i59, t) {
    let e = i59.incomingEdges || [], n = [];
    for (let r = 0; r < Math.min(rl, e.length); r++) {
      let o = e[r], s = o.sourceNodeId, a = t.nodesById[s], l = C2((a.outputsMetadata || {})[o.sourceNodeOutputId]), c = (i59.inputsMetadata || {})[o.targetNodeInputId] || {};
      n.push({ key: Jq(r, a, c), value: l });
    }
    if (e.length > rl) {
      let r = e.length - rl;
      n.push({ key: `(${r} more input${r === 1 ? "" : "s"} omitted)`, value: "..." });
    }
    return n;
  }
  function qE(i59) {
    let t = [], e = i59.outputsMetadata || {}, n = Object.values(e);
    for (let r = 0; r < Math.min(rl, n.length); r++) {
      let o = n[r], s = C2(o);
      t.push({ key: eY(r, o, i59), value: s });
    }
    if (n.length > rl) {
      let r = n.length - rl;
      t.push({ key: `(${r} more output${r === 1 ? "" : "s"} omitted)`, value: "..." });
    }
    return t;
  }
  function YE(i59, t, e, n, r) {
    let o = [], s = Object.keys(e).filter((l) => e[l].selected).filter((l) => l.startsWith(ga)).map((l) => l.replace(ga, "")), a = Object.values(n).filter((l) => s.includes(va(l, { id: t })));
    for (let l of a) {
      let c = ((l.results || {})?.[t] || {})[i59.id];
      if (r?.hideEmptyNodeDataEntries && !c) continue;
      let d = c?.strValue || "-";
      o.push({ key: va(l, { id: t }), value: d });
    }
    return o;
  }
  function XE(i59, t) {
    let e = i59.split("/"), n = t.split("/"), r = "";
    for (let o = Math.min(e.length, n.length); o > 0; o--) {
      let s = e.slice(0, o).join("/"), a = n.slice(0, o).join("/");
      if (s === a) {
        r = a;
        break;
      }
    }
    return r;
  }
  function ZE(i59, t, e, n, r) {
    let o = [], s = /* @__PURE__ */ new Set();
    if (i59.has(_t.NODE_LABEL) && t.test(e.label) && (o.push({ type: _t.NODE_LABEL }), s.add(_t.NODE_LABEL)), i59.has(_t.ATTRIBUTE)) {
      let a = S2(e, n, r);
      for (let l of Object.keys(a)) {
        let c = a[l], d = `${l}:${c}`, u = `${l}=${c}`;
        (t.test(d) || t.test(u)) && (o.push({ type: _t.ATTRIBUTE, matchedAttrId: l }), s.add(_t.ATTRIBUTE));
      }
    }
    if (i59.has(_t.INPUT_METADATA) && dt(e)) {
      let a = r?.inputMetadataKeysToHide ?? [];
      for (let l of e.incomingEdges || []) {
        let c = n.nodesById[l.sourceNodeId];
        t.test(c.label) && (o.push({ type: _t.INPUT_METADATA, matchedText: c.label }), s.add(_t.INPUT_METADATA));
        let d = e.inputsMetadata || {}, u = (d[l.targetNodeInputId] || {})[To];
        u && t.test(u) && (o.push({ type: _t.INPUT_METADATA, matchedText: u }), s.add(_t.INPUT_METADATA));
        let h = (c.outputsMetadata || {})[l.sourceNodeOutputId] || {};
        for (let f of Object.keys(h)) {
          if (f.startsWith("__") || a.some((g) => f.match(g))) continue;
          let m = h[f], v = `${f}:${m}`, _ = `${f}=${m}`;
          (t.test(m) || t.test(v) || t.test(_)) && (o.push({ type: _t.INPUT_METADATA, matchedText: m }), s.add(_t.INPUT_METADATA));
        }
        let p = d[l.targetNodeInputId] || {};
        for (let f of Object.keys(p)) {
          if (f.startsWith("__") || a.some((g) => f.match(g))) continue;
          let m = p[f], v = `${f}:${m}`, _ = `${f}=${m}`;
          (t.test(m) || t.test(v) || t.test(_)) && (o.push({ type: _t.INPUT_METADATA, matchedText: m }), s.add(_t.INPUT_METADATA));
        }
      }
    }
    if (i59.has(_t.OUTPUT_METADATA) && dt(e)) {
      let a = e.outputsMetadata || {}, l = r?.outputMetadataKeysToHide ?? [];
      for (let c of e.outgoingEdges || []) {
        let d = n.nodesById[c.targetNodeId];
        t.test(d.label) && (o.push({ type: _t.OUTPUT_METADATA, matchedText: d.label }), s.add(_t.OUTPUT_METADATA));
        let u = (a[c.sourceNodeOutputId] || {})[To];
        u && t.test(u) && (o.push({ type: _t.OUTPUT_METADATA, matchedText: u }), s.add(_t.OUTPUT_METADATA));
      }
      for (let c of Object.values(a)) for (let d of Object.keys(c)) {
        if (d.startsWith("__") || l.some((f) => d.match(f))) continue;
        let u = c[d], h = `${d}:${u}`, p = `${d}=${u}`;
        (t.test(u) || t.test(h) || t.test(p)) && (o.push({ type: _t.OUTPUT_METADATA, matchedText: u }), s.add(_t.OUTPUT_METADATA));
      }
    }
    return { matches: o, matchTypes: s };
  }
  function S2(i59, t, e) {
    let n = {}, r = e?.nodeInfoKeysToHide ?? [];
    if (dt(i59)) {
      for (let [o, s] of Object.entries(i59.attrs || {})) if (typeof s == "string") n[o] = s;
      else switch (s.type) {
        case Au.NODE_IDS:
          n[o] = s.nodeIds.join(",");
          break;
        default:
          break;
      }
      n.id = i59.id;
    } else if (ct(i59)) {
      n = { "#descendants": `${(i59.descendantsNodeIds || []).length}`, "#children": `${(i59.nsChildrenIds || []).length}`, namespace: i59.namespace || i59.savedNamespace || "<root>" };
      let o = t.groupNodeAttributes?.[i59.id.replace("___group___", "")] || {};
      n = le(le({}, n), o);
    }
    return n = Object.fromEntries(Object.entries(n).filter(([o, s]) => !r.some((a) => o.match(a)))), n;
  }
  function tY(i59, t, e, n, r, o) {
    let s = [], l = S2(n, r, o)[i59];
    if (l != null) {
      let c = Number(l);
      !isNaN(c) && c >= t && c <= e && s.push({ type: _t.ATTRIBUTE, matchedAttrId: i59 });
    }
    return s;
  }
  function ku(i59) {
    for (let t of i59.filter((e) => e.type !== Dn.NODE_TYPE)) switch (t.type) {
      case Dn.REGEX:
        if (t.queryRegex !== "") return true;
        break;
      case Dn.ATTR_VALUE_RANGE:
        if (t.attrName !== "") return true;
        break;
      default:
        break;
    }
    return false;
  }
  function Ay(i59) {
    return i59.map((t) => ({ queries: t.queries.map((n) => {
      switch (n.type) {
        case Dn.REGEX: {
          let r = new RegExp("", "i");
          try {
            r = new RegExp(n.queryRegex, "i");
          } catch (s) {
            console.warn("Failed to create regex", s);
          }
          return { type: Dn.REGEX, queryRegex: r, matchTypes: new Set(n.matchTypes) };
        }
        case Dn.NODE_TYPE:
        case Dn.ATTR_VALUE_RANGE:
          return n;
        default:
          return;
      }
    }), nodeType: t.nodeType, styles: t.styles }));
  }
  function Tf(i59, t, e, n) {
    let r = true;
    for (let o of t) if (o.type === Dn.NODE_TYPE) {
      let s = true;
      if ((dt(i59) && o.nodeType === _r.LAYER_NODES || ct(i59) && o.nodeType === _r.OP_NODES) && (s = false), !s) {
        r = false;
        break;
      }
    } else if (o.type === Dn.REGEX) {
      if (ZE(o.matchTypes, o.queryRegex, i59, e, n).matches.length === 0) {
        r = false;
        break;
      }
    } else if (o.type === Dn.ATTR_VALUE_RANGE) {
      if (o.attrName !== "" && tY(o.attrName, o.min ?? Number.NEGATIVE_INFINITY, o.max ?? Number.POSITIVE_INFINITY, i59, e, n).length === 0) {
        r = false;
        break;
      }
    } else r = false;
    return r;
  }
  function Ny(i59, t) {
    window.parent.postMessage({ cmd: b2, name: i59, resource: t }, "*");
  }
  function Pc() {
    return window.devicePixelRatio === 1 ? 1.5 : window.devicePixelRatio;
  }
  function Rc(i59, t) {
    let e = i59.styles[t];
    return e ? typeof e == "string" ? e : e.value : "";
  }
  function Oc(i59) {
    return i59.split(`
`).map((t) => t.trim()).filter((t) => t !== "");
  }
  function QE(i59) {
    return (Oc(i59).length - 1) * Ou;
  }
  function M2(i59, t, e = 0) {
    function n(c) {
      return { x: c.x + c.width / 2 + e * c.width, y: c.y + c.height / 2 };
    }
    function r(c, d, u) {
      let h = u.x - d.x, p = u.y - d.y, f = Number.MAX_VALUE, m = { x: 0, y: 0 };
      if (h !== 0) {
        let v = (c.x - d.x) / h, _ = d.y + v * p;
        v >= 0 && _ >= c.y && _ <= c.y + c.height && v < f && (f = v, m = { x: c.x, y: _ });
      }
      if (h !== 0) {
        let v = (c.x + c.width - d.x) / h, _ = d.y + v * p;
        v >= 0 && _ >= c.y && _ <= c.y + c.height && v < f && (f = v, m = { x: c.x + c.width, y: _ });
      }
      if (p !== 0) {
        let v = (c.y - d.y) / p, _ = d.x + v * h;
        v >= 0 && _ >= c.x && _ <= c.x + c.width && v < f && (f = v, m = { x: _, y: c.y });
      }
      if (p !== 0) {
        let v = (c.y + c.height - d.y) / p, _ = d.x + v * h;
        v >= 0 && _ >= c.x && _ <= c.x + c.width && v < f && (f = v, m = { x: _, y: c.y + c.height });
      }
      return m;
    }
    let o = n(i59), s = n(t), a = r(i59, o, s), l = r(t, s, o);
    return { intersection1: a, intersection2: l };
  }
  function va(i59, t) {
    return i59.nodeDataProviderData?.[t?.id || ""]?.name ?? i59.runName;
  }
  function If(i59, t, e) {
    let n = {}, r = i59?.descendantsOpNodeIds || t.nodes.map((o) => o.id);
    for (let o of r) {
      let s = t.nodesById[o], a = e[s.id]?.bgColor || "";
      a && (n[a] ? n[a].count++ : n[a] = { label: `${e[o]?.value || ""}`, bgColor: a, count: 1 });
    }
    return Object.values(n).sort((o, s) => o.bgColor.localeCompare(s.bgColor));
  }
  function Df(i59) {
    let t, e, n, r;
    switch (i59?.type) {
      case hn.TENSOR_SHAPE:
        t = "shape";
        break;
      case hn.OUTPUT_METADATA:
        t = i59.filterText ?? "";
        break;
      case hn.INPUT_METADATA:
        e = i59.filterText ?? "";
        break;
      case hn.SOURCE_NODE_ATTR:
        n = i59.filterText ?? "";
        break;
      case hn.TARGET_NODE_ATTR:
        r = i59.filterText ?? "";
        break;
      default:
        break;
    }
    return { outputMetadataKey: t, inputMetadataKey: e, sourceNodeAttrKey: n, targetNodeAttrKey: r };
  }
  function KE(i59, t) {
    let e = (i59.attrs ?? {})[t];
    if (e == null) return "";
    if (typeof e == "string") return e;
    switch (e.type) {
      case Au.NODE_IDS:
        return e.nodeIds.join(", ");
      default:
        break;
    }
    return "";
  }
  var Qi = function(i59) {
    return i59[i59.PROCESS_GRAPH_REQ = 0] = "PROCESS_GRAPH_REQ", i59[i59.PROCESS_GRAPH_RESP = 1] = "PROCESS_GRAPH_RESP", i59[i59.EXPAND_OR_COLLAPSE_GROUP_NODE_REQ = 2] = "EXPAND_OR_COLLAPSE_GROUP_NODE_REQ", i59[i59.EXPAND_OR_COLLAPSE_GROUP_NODE_RESP = 3] = "EXPAND_OR_COLLAPSE_GROUP_NODE_RESP", i59[i59.RELAYOUT_GRAPH_REQ = 4] = "RELAYOUT_GRAPH_REQ", i59[i59.RELAYOUT_GRAPH_RESP = 5] = "RELAYOUT_GRAPH_RESP", i59[i59.LOCATE_NODE_REQ = 6] = "LOCATE_NODE_REQ", i59[i59.LOCATE_NODE_RESP = 7] = "LOCATE_NODE_RESP", i59[i59.UPDATE_PROCESSING_PROGRESS = 8] = "UPDATE_PROCESSING_PROGRESS", i59[i59.PREPARE_POPUP_REQ = 9] = "PREPARE_POPUP_REQ", i59[i59.PREPARE_POPUP_RESP = 10] = "PREPARE_POPUP_RESP", i59[i59.CLEANUP = 11] = "CLEANUP", i59;
  }(Qi || {});
  var Ac = function(i59) {
    return i59.PROCESSING_NODES_AND_EDGES = "Processing nodes and edges", i59.PROCESSING_LAYER_NAMESPACES = "Processing layer namespaces", i59.PROCESSING_LAYOUT_DATA = "Processing layout data", i59.SPLITTING_LARGE_LAYERS = "Splitting large layers (if any)", i59.LAYING_OUT_ROOT_LAYER = "Laying out root layer", i59.FINDING_IDENTICAL_LAYERS = "Finding identical layers", i59;
  }(Ac || {});
  var E2 = [Ac.PROCESSING_NODES_AND_EDGES, Ac.PROCESSING_LAYER_NAMESPACES, Ac.PROCESSING_LAYOUT_DATA, Ac.SPLITTING_LARGE_LAYERS, Ac.LAYING_OUT_ROOT_LAYER, Ac.FINDING_IDENTICAL_LAYERS];
  var Io = (() => {
    class i59 {
      getItem(e) {
        return window.localStorage.getItem(e);
      }
      setItem(e, n) {
        window.localStorage.setItem(e, n);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var al = (() => {
    class i59 {
      curUiState = gt({ paneStates: [this.createInitialPaneState()] });
      setDeepestExpandedGroupNodeIds(e, n) {
        this.curUiState.update((r) => {
          let o = r.paneStates[n];
          return o ? (o.deepestExpandedGroupNodeIds = e, le({}, r)) : r;
        });
      }
      setSelectedNodeId(e, n) {
        this.curUiState.update((r) => {
          let o = r.paneStates[n];
          return o ? (o.selectedNodeId = e, le({}, r)) : r;
        });
      }
      setSelectedGraphId(e, n, r) {
        this.curUiState.update((o) => {
          let s = o.paneStates[r];
          return s ? (s.selectedGraphId = e, s.selectedCollectionLabel = n, le({}, o)) : o;
        });
      }
      setFlattenLayers(e, n) {
        this.curUiState.update((r) => {
          let o = r.paneStates[n];
          return o ? (o.flattenLayers = e, le({}, r)) : r;
        });
      }
      addPane() {
        this.curUiState.update((e) => {
          e.paneStates.length > 1 && (e.paneStates = [e.paneStates[0]]), e.paneStates.push(this.createInitialPaneState());
          for (let n of e.paneStates) n.widthFraction = 0.5;
          return le({}, e);
        });
      }
      removePane(e) {
        this.curUiState.update((n) => (n.paneStates.splice(e, 1), n.paneStates.length === 1 && (n.paneStates[0].widthFraction = 1), le({}, n)));
      }
      resizePane(e) {
        this.curUiState.update((n) => (n.paneStates.length === 2 && (n.paneStates[0].widthFraction = e, n.paneStates[1].widthFraction = 1 - e), le({}, n)));
      }
      swapPane() {
        this.curUiState.update((e) => (e.paneStates.length === 2 && (e.paneStates = [e.paneStates[1], e.paneStates[0]]), le({}, e)));
      }
      selectPane(e) {
        this.curUiState.update((n) => {
          for (let r = 0; r < n.paneStates.length; r++) {
            let o = n.paneStates[r];
            o.selected = r === e;
          }
          return le({}, n);
        });
      }
      reset() {
        this.curUiState.set({ paneStates: [this.createInitialPaneState()] });
      }
      createInitialPaneState() {
        return { deepestExpandedGroupNodeIds: [], selectedNodeId: "", selectedGraphId: "", selectedCollectionLabel: "", widthFraction: 1, selected: false };
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var ll = (() => {
    class i59 {
      worker;
      constructor() {
        let e = window.modelExplorer.workerScriptPath ?? "worker.js";
        this.worker = new Worker(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var nt = (() => {
    class i59 {
      localStorageService;
      uiStateService;
      workerService;
      curGraphCollections = gt([]);
      curToLocateNodeInfo = gt(void 0);
      curSelectedRenderer = gt(void 0);
      spaceKeyToZoomFitClicked = new we();
      searchKeyClicked = new we();
      addSnapshotClicked = new we();
      curSnapshotToRestore = new we();
      expandOrCollapseAllGraphLayersClicked = new we();
      downloadAsPngClicked = new we();
      config = gt(void 0);
      curInitialUiState = gt(void 0);
      panes = gt([{ id: Li(), widthFraction: 1 }]);
      selectedPaneId = gt(this.panes()[0].id);
      modelGraphProcessed$ = new we();
      remoteNodeDataPaths = gt([]);
      selectedNode = gt(void 0);
      hoveredNode = gt(void 0);
      doubleClickedNode = gt(void 0);
      testMode = false;
      groupNodeChildrenCountThresholdFromUrl = null;
      paneIdToGraph = {};
      paneIdToCurModelGraphs = {};
      constructor(e, n, r) {
        this.localStorageService = e, this.uiStateService = n, this.workerService = r, this.listenToWorker(), this.init();
      }
      addGraphCollections(e) {
        this.curGraphCollections.update((n) => {
          let r = [...n], o = {};
          for (let s of e) {
            let a = {}, l = {};
            for (let h of s.graphs) {
              (h.id == null || h.id === "") && (h.id = "unnamed_graph");
              let p = h.id, f = o[p];
              f == null ? (o[p] = 0, f = 0) : (h.id = `${h.id} (${f + 1})`, l[p] = h.id), o[p] = f + 1, a[h.id] = h, h.collectionLabel = s.label;
            }
            for (let h of s.graphs) for (let p of h.nodes) if (p.subgraphIds != null && p.subgraphIds.length > 0) {
              p.subgraphIds = p.subgraphIds.map((f) => l[f] || f), h.subGraphIds == null && (h.subGraphIds = []), h.subGraphIds.push(...p.subgraphIds);
              for (let f of p.subgraphIds) {
                let m = a[f];
                m && (m.parentGraphIds == null && (m.parentGraphIds = []), m.parentGraphIds.includes(h.id) && m.parentGraphIds.push(h.id));
              }
            }
            let c = s.graphs.filter((h) => h.parentGraphIds == null), d = [], u = (h, p = 0) => {
              let f = [];
              h == null ? f = c : f = (h.subGraphIds || []).map((_) => a[_]).filter((_) => _ != null);
              let m = [], v = {};
              for (let _ of f) v[_.id] || (m.push(_), v[_.id] = true);
              f = m, f.sort((_, g) => g.nodes.length - _.nodes.length);
              for (let _ of f) d.push({ graph: _, level: p }), u(_, p + 1);
            };
            u(), s.graphsWithLevel = d;
          }
          return r.push(...e), r;
        });
      }
      selectGraphInPane(e, n, r = false, o, s = true) {
        if (n === 1 && this.panes().length === 1) {
          this.openGraphInSplitPane(e);
          return;
        }
        if ((this.panes()[n].modelGraph?.id || "") === e.id) return;
        let l = this.panes()[n];
        l.searchResults = void 0, l.selectedNodeDataProviderRunId = void 0;
        let c = l.id;
        if (this.paneIdToGraph[c] = e, this.uiStateService.setSelectedGraphId(e.id, e.collectionLabel || "", this.getPaneIndexById(c)), l.subgraphBreadcrumbs != null && l.subgraphBreadcrumbs.length > 0) {
          let d = [...l.subgraphBreadcrumbs];
          d[d.length - 1].graphId = e.id, l.subgraphBreadcrumbs = d;
        }
        this.processGraph(c, r, o, s);
      }
      selectGraphInCurrentPane(e, n = false, r, o = true) {
        this.selectGraphInPane(e, this.getPaneIndexById(this.selectedPaneId()), n, r, o);
      }
      openGraphInSplitPane(e, n = false, r = true, o = false) {
        this.panes().length === 2 && this.panes.update((c) => o ? [c[1]] : [c[0]]);
        let s = Li();
        this.paneIdToGraph[s] = e, this.panes.update((c) => {
          let d = c[0];
          d.widthFraction = 0.5;
          let u = { id: s, widthFraction: 0.5, flattenLayers: n, showOnNodeItemTypes: { [s]: this.getSavedShowOnNodeItemTypes() } }, h = this.getSavedShowOnEdgeItem();
          return h && (u.showOnEdgeItems = { [s]: h }), o ? c.unshift(u) : c.push(u), [...c];
        }), this.curSelectedRenderer.set({ id: s, ownerType: ol.GRAPH_PANEL });
        let a = this.getPaneIndexById(s);
        this.uiStateService.addPane(), this.selectPane(s), this.uiStateService.setSelectedGraphId(e.id, e.collectionLabel || "", a), this.uiStateService.setFlattenLayers(n, a);
        let l = { eventType: Qi.PROCESS_GRAPH_REQ, graph: e, showOnNodeItemTypes: this.getShowOnNodeItemTypes(s, s), nodeDataProviderRuns: {}, config: this.config ? this.config() : void 0, paneId: s, groupNodeChildrenCountThreshold: this.getGroupNodeChildrenCountThreshold(), flattenLayers: n, keepLayersWithASingleChild: this.config()?.keepLayersWithASingleChild, initialLayout: r };
        this.workerService.worker.postMessage(l);
      }
      getIsGraphInRightPane(e) {
        let n = this.panes();
        return n.length === 2 && n[1].modelGraph?.id === e;
      }
      processGraph(e, n = false, r, o = true) {
        if (r != null) {
          let a = this.getPaneById(e);
          a && (a.snapshotToRestore = r);
        }
        this.setPaneLoading(e);
        let s = { eventType: Qi.PROCESS_GRAPH_REQ, graph: this.paneIdToGraph[e], showOnNodeItemTypes: this.getShowOnNodeItemTypes(e, e), nodeDataProviderRuns: {}, config: this.config ? this.config() : void 0, paneId: e, groupNodeChildrenCountThreshold: this.getGroupNodeChildrenCountThreshold(), flattenLayers: n, keepLayersWithASingleChild: this.config()?.keepLayersWithASingleChild, initialLayout: o };
        this.workerService.worker.postMessage(s);
      }
      setFlattenLayersInCurrentPane(e) {
        let n = this.getSelectedPane();
        if (!n) return;
        this.panes.update((o) => (n.flattenLayers = e, n.searchResults = void 0, [...o]));
        let r = this.getPaneIndexById(n.id);
        this.uiStateService.setFlattenLayers(e, r), this.uiStateService.setDeepestExpandedGroupNodeIds([], r);
      }
      toggleFlattenLayers(e) {
        let n = this.getPaneById(e);
        if (!n) return;
        let r = n.flattenLayers === true;
        this.panes.update((s) => (n.flattenLayers = !r, n.searchResults = void 0, [...s]));
        let o = this.getPaneIndexById(e);
        this.uiStateService.setFlattenLayers(!r, o), this.uiStateService.setDeepestExpandedGroupNodeIds([], o);
      }
      getFlattenLayers(e) {
        return this.getPaneById(e)?.flattenLayers === true;
      }
      selectPane(e) {
        this.selectedPaneId.set(e), this.uiStateService.selectPane(this.getPaneIndexById(e));
      }
      selectPaneByIndex(e) {
        let n = this.panes()[e];
        n && this.selectPane(n.id);
      }
      selectNode(e, n) {
        this.panes.update((o) => {
          let s = this.getPaneById(e);
          return s ? (s.selectedNodeInfo = n, [...o]) : o;
        }), this.uiStateService.setSelectedNodeId(n?.nodeId || "", this.getPaneIndexById(e));
        let r = this.getPaneById(e)?.modelGraph;
        if (r) {
          let o = n?.nodeId || "", s = r.nodesById[o];
          if (s && dt(s) && window.parent) {
            let a = s.outputsMetadata || {}, l = [];
            for (let c of Object.keys(a)) {
              let u = a[c].tensor_name;
              u && l.push(u);
            }
            window.parent.postMessage({ cmd: "model-explorer-node-selected", nodeId: o, outputTensorNames: l }, "*");
          }
        }
        if (r) {
          let o = n?.nodeId || "";
          this.updateSelectedNode(o, r.id, r.collectionLabel, r.nodesById[o]);
        }
      }
      getModelGraphFromSelectedPane() {
        return this.getPaneById(this.selectedPaneId())?.modelGraph;
      }
      getModelGraphFromPane(e) {
        return this.getPaneById(e)?.modelGraph;
      }
      getModelGraphFromPaneIndex(e) {
        return this.panes()[e]?.modelGraph;
      }
      getSelectedNodeInfoFromSelectedPane() {
        return this.getPaneById(this.selectedPaneId())?.selectedNodeInfo;
      }
      getSelectedPane() {
        return this.getPaneById(this.selectedPaneId());
      }
      setPaneWidthFraction(e) {
        this.panes.update((n) => n.length !== 2 ? n : (n[0].widthFraction = e, n[1].widthFraction = 1 - e, [...n])), this.uiStateService.resizePane(e);
      }
      setSelectedNodeDataProviderRunId(e, n) {
        this.panes.update((r) => {
          let o = this.getPaneById(e);
          return o ? (o.selectedNodeDataProviderRunId = n, [...r]) : r;
        });
      }
      getSelectedNodeDataProviderRunId(e) {
        return this.getPaneById(e)?.selectedNodeDataProviderRunId;
      }
      setPaneHasArtificialLayers(e, n) {
        this.panes.update((r) => {
          let o = this.getPaneById(e);
          return o ? (o.hasArtificialLayers = n, [...r]) : r;
        });
      }
      setNodeToReveal(e, n) {
        this.panes.update((r) => {
          let o = this.getPaneById(e);
          return o ? (o.nodeIdToReveal = n, [...r]) : r;
        });
      }
      closePane(e) {
        delete this.paneIdToGraph[e], delete this.paneIdToCurModelGraphs[e], this.panes.update((n) => {
          let r = n.findIndex((o) => o.id === e);
          return r >= 0 && (n.splice(r, 1), this.uiStateService.removePane(r)), n[0].widthFraction = 1, [...n];
        }), this.selectPane(this.panes()[0].id);
      }
      swapPane() {
        this.panes.update((e) => e.length !== 2 ? e : [e[1], e[0]]), this.uiStateService.swapPane();
      }
      getPaneById(e) {
        return this.panes().find((n) => n.id === e);
      }
      getPaneIndexById(e) {
        return this.panes().findIndex((n) => n.id === e);
      }
      addSnapshot(e, n, r) {
        this.panes.update((o) => {
          let s = this.getPaneById(r);
          return s && (s.snapshots == null && (s.snapshots = {}), s.snapshots[n] == null && (s.snapshots[n] = []), s.snapshots[n].push(e)), [...o];
        });
      }
      deleteSnapshot(e, n, r) {
        this.panes.update((o) => {
          let s = this.getPaneById(r);
          return s && s.snapshots && s.snapshots[n] && s.snapshots[n].splice(e, 1), [...o];
        });
      }
      getGraphById(e) {
        for (let n of this.curGraphCollections()) for (let r of n.graphs) if (r.id === e) return r;
      }
      addSubgraphBreadcrumbItem(e, n, r, o) {
        this.panes.update((s) => {
          let a = this.getPaneById(e);
          if (!a) return s;
          let l = [...a.subgraphBreadcrumbs || []];
          return l.length === 0 ? l.push({ graphId: n, snapshot: o }) : l[l.length - 1] = { graphId: n, snapshot: o }, l.push({ graphId: r }), a.subgraphBreadcrumbs = l, [...s];
        });
      }
      setCurrentSubgraphBreadcrumb(e, n) {
        this.panes.update((r) => {
          let o = this.getPaneById(e);
          if (!o) return r;
          let s = [...o.subgraphBreadcrumbs || []];
          return s.splice(n + 1), s.length === 1 && (s = []), o.subgraphBreadcrumbs = s, [...r];
        });
      }
      setSearchResults(e, n) {
        this.panes.update((r) => {
          let o = this.getPaneById(e);
          return o ? (o.searchResults = n, [...r]) : r;
        });
      }
      clearSearchResults(e) {
        this.panes.update((n) => {
          let r = this.getPaneById(e);
          return r ? (r.searchResults = { results: {} }, [...n]) : n;
        });
      }
      toggleShowOnNode(e, n, r, o) {
        this.panes.update((s) => {
          let a = this.getPaneById(e);
          if (!a) return s;
          a.showOnNodeItemTypes || (a.showOnNodeItemTypes = {}), a.showOnNodeItemTypes[n] == null && (a.showOnNodeItemTypes[n] = {}), a.showOnNodeItemTypes[n][r] == null && (a.showOnNodeItemTypes[n][r] = { selected: false });
          let l = a.showOnNodeItemTypes[n][r].selected;
          return a.showOnNodeItemTypes[n] = le({}, a.showOnNodeItemTypes[n]), a.showOnNodeItemTypes[n][r].selected = o ?? !l, a.showOnNodeItemTypes = le({}, a.showOnNodeItemTypes), [...s];
        });
      }
      setShowOnEdge(e, n, r, o, s, a, l, c) {
        this.panes.update((d) => {
          let u = this.getPaneById(e);
          return u ? (u.showOnEdgeItems || (u.showOnEdgeItems = {}), u.showOnEdgeItems[n] = { type: r, filterText: o, outputMetadataKey: s, inputMetadataKey: a, sourceNodeAttrKey: l, targetNodeAttrKey: c }, u.showOnEdgeItems = le({}, u.showOnEdgeItems), [...d]) : d;
        });
      }
      setShowOnNodeFilter(e, n, r, o) {
        this.panes.update((s) => {
          let a = this.getPaneById(e);
          return a ? (a.showOnNodeItemTypes || (a.showOnNodeItemTypes = {}), a.showOnNodeItemTypes[n] == null && (a.showOnNodeItemTypes[n] = {}), a.showOnNodeItemTypes[n][r] == null && (a.showOnNodeItemTypes[n][r] = { selected: false }), a.showOnNodeItemTypes[n][r].filterRegex = o, a.showOnNodeItemTypes = le({}, a.showOnNodeItemTypes), [...s]) : s;
        });
      }
      setShowOnNode(e, n, r) {
        this.panes.update((o) => {
          let s = this.getPaneById(e);
          return s ? (s.showOnNodeItemTypes || (s.showOnNodeItemTypes = {}), s.showOnNodeItemTypes = le({}, s.showOnNodeItemTypes), s.showOnNodeItemTypes[n] = r, [...o]) : o;
        });
      }
      deleteShowOnNodeItemType(e) {
        this.panes.update((n) => {
          for (let r of n) {
            r.showOnNodeItemTypes = le({}, r.showOnNodeItemTypes);
            for (let o of Object.keys(r.showOnNodeItemTypes)) for (let s of e) {
              let a = r.showOnNodeItemTypes[o][s];
              a && (a.selected = false);
            }
          }
          return [...n];
        });
      }
      getShowOnNodeItemTypes(e, n) {
        let r = this.getPaneById(e);
        return r ? JSON.parse(JSON.stringify((r.showOnNodeItemTypes || {})[n] || {})) : {};
      }
      getSavedShowOnNodeItemTypes() {
        let e = {};
        if (!this.testMode) {
          let n = this.localStorageService.getItem(Ty);
          n && (e = JSON.parse(n));
        }
        return e;
      }
      getSavedShowOnEdgeItem() {
        let e;
        if (!this.testMode) {
          let n = this.localStorageService.getItem(Iy);
          if (n) e = JSON.parse(n);
          else {
            let r = this.localStorageService.getItem(v2);
            r && JSON.parse(r)[hn.TENSOR_SHAPE]?.selected && (e = { type: hn.TENSOR_SHAPE });
          }
        }
        return e;
      }
      getShowOnEdgeItem(e, n) {
        let r = this.getPaneById(e);
        if (!r) return;
        let o = (r.showOnEdgeItems || {})[n];
        if (o) return JSON.parse(JSON.stringify(o));
      }
      getGraphByPaneId(e) {
        return this.paneIdToGraph[e];
      }
      updateCurrentModelGraph(e, n) {
        this.paneIdToCurModelGraphs[e] = n;
      }
      getCurrentModelGraphFromPane(e) {
        return this.paneIdToCurModelGraphs[e];
      }
      updateSelectedNode(e, n, r, o) {
        let s = this.selectedNode();
        (s?.nodeId !== e || s?.graphId !== n || s?.collectionLabel !== r) && this.selectedNode.set({ nodeId: e, graphId: n, collectionLabel: r, node: o });
      }
      updateHoveredNode(e, n, r, o) {
        let s = this.hoveredNode();
        (s?.nodeId !== e || s?.graphId !== n || s?.collectionLabel !== r) && this.hoveredNode.set({ nodeId: e, graphId: n, collectionLabel: r, node: o });
      }
      updateDoubleClickedNode(e, n, r, o) {
        let s = this.doubleClickedNode();
        (s?.nodeId !== e || s?.graphId !== n || s?.collectionLabel !== r) && this.doubleClickedNode.set({ nodeId: e, graphId: n, collectionLabel: r, node: o });
      }
      reset() {
        this.workerService.worker.postMessage({ eventType: Qi.CLEANUP }), this.curGraphCollections.set([]), this.curToLocateNodeInfo.set(void 0), this.curSelectedRenderer.set(void 0), this.config.set(void 0), this.curInitialUiState.set(void 0), this.panes.set([{ id: Li(), widthFraction: 1 }]), this.selectedPaneId.set(this.panes()[0].id), this.remoteNodeDataPaths.set([]), this.groupNodeChildrenCountThresholdFromUrl = null, this.paneIdToGraph = {}, this.paneIdToCurModelGraphs = {}, this.init();
      }
      listenToWorker() {
        this.workerService.worker.addEventListener("message", (e) => {
          let n = e.data;
          switch (n.eventType) {
            case Qi.PROCESS_GRAPH_RESP:
              this.handleGraphProcessed(n.modelGraph, n.paneId);
              break;
            default:
              break;
          }
        });
      }
      init() {
        this.curSelectedRenderer.set({ id: this.panes()[0].id, ownerType: ol.GRAPH_PANEL });
        let e = new URLSearchParams(document.location.search);
        this.testMode = e.get("test_mode") === "1", this.groupNodeChildrenCountThresholdFromUrl = e.get("groupNodeChildrenCountThreshold");
        let n = this.panes()[0];
        n.showOnNodeItemTypes = { [n.id]: this.getSavedShowOnNodeItemTypes() };
        let r = this.getSavedShowOnEdgeItem();
        r ? n.showOnEdgeItems = { [n.id]: r } : n.showOnEdgeItems = {};
      }
      handleGraphProcessed(e, n) {
        this.panes.update((r) => {
          for (let o of r) if (o.id === n) {
            o.modelGraph = e;
            break;
          }
          return [...r];
        }), this.modelGraphProcessed$.next({ paneIndex: this.getPaneIndexById(n), modelGraph: e });
      }
      setPaneLoading(e) {
        this.panes.update((n) => {
          for (let r of n) if (r.id === e) {
            r.modelGraph = void 0;
            break;
          }
          return [...n];
        });
      }
      getGroupNodeChildrenCountThreshold() {
        let e = BE;
        return this.config && (e = this.config()?.artificialLayerNodeCountThreshold || BE), this.groupNodeChildrenCountThresholdFromUrl != null && (e = Number(this.groupNodeChildrenCountThresholdFromUrl)), e;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(Io), Ze(al), Ze(ll));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var O2 = (() => {
    class i59 {
      _renderer;
      _elementRef;
      onChange = (e) => {
      };
      onTouched = () => {
      };
      constructor(e, n) {
        this._renderer = e, this._elementRef = n;
      }
      setProperty(e, n) {
        this._renderer.setProperty(this._elementRef.nativeElement, e, n);
      }
      registerOnTouched(e) {
        this.onTouched = e;
      }
      registerOnChange(e) {
        this.onChange = e;
      }
      setDisabledState(e) {
        this.setProperty("disabled", e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Pr), K(He));
      };
      static \u0275dir = qe({ type: i59 });
    }
    return i59;
  })();
  var A2 = (() => {
    class i59 extends O2 {
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, features: [Zt] });
    }
    return i59;
  })();
  var kc = new Ee("");
  var nY = { provide: kc, useExisting: Gr(() => kf), multi: true };
  var kf = (() => {
    class i59 extends A2 {
      writeValue(e) {
        this.setProperty("checked", e);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]], hostBindings: function(n, r) {
        n & 1 && Z("change", function(s) {
          return r.onChange(s.target.checked);
        })("blur", function() {
          return r.onTouched();
        });
      }, standalone: false, features: [Bt([nY]), Zt] });
    }
    return i59;
  })();
  var iY = { provide: kc, useExisting: Gr(() => ul), multi: true };
  function rY() {
    let i59 = da() ? da().getUserAgent() : "";
    return /android (\d+)/.test(i59.toLowerCase());
  }
  var oY = new Ee("");
  var ul = (() => {
    class i59 extends O2 {
      _compositionMode;
      _composing = false;
      constructor(e, n, r) {
        super(e, n), this._compositionMode = r, this._compositionMode == null && (this._compositionMode = !rY());
      }
      writeValue(e) {
        let n = e ?? "";
        this.setProperty("value", n);
      }
      _handleInput(e) {
        (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e);
      }
      _compositionStart() {
        this._composing = true;
      }
      _compositionEnd(e) {
        this._composing = false, this._compositionMode && this.onChange(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Pr), K(He), K(oY, 8));
      };
      static \u0275dir = qe({ type: i59, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function(n, r) {
        n & 1 && Z("input", function(s) {
          return r._handleInput(s.target.value);
        })("blur", function() {
          return r.onTouched();
        })("compositionstart", function() {
          return r._compositionStart();
        })("compositionend", function(s) {
          return r._compositionEnd(s.target.value);
        });
      }, standalone: false, features: [Bt([iY]), Zt] });
    }
    return i59;
  })();
  function cl(i59) {
    return i59 == null || (typeof i59 == "string" || Array.isArray(i59)) && i59.length === 0;
  }
  function N2(i59) {
    return i59 != null && typeof i59.length == "number";
  }
  var Lc = new Ee("");
  var oT = new Ee("");
  var sY = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
  var Fy = class {
    static min(t) {
      return aY(t);
    }
    static max(t) {
      return lY(t);
    }
    static required(t) {
      return cY(t);
    }
    static requiredTrue(t) {
      return dY(t);
    }
    static email(t) {
      return uY(t);
    }
    static minLength(t) {
      return hY(t);
    }
    static maxLength(t) {
      return pY(t);
    }
    static pattern(t) {
      return fY(t);
    }
    static nullValidator(t) {
      return k2(t);
    }
    static compose(t) {
      return U2(t);
    }
    static composeAsync(t) {
      return G2(t);
    }
  };
  function aY(i59) {
    return (t) => {
      if (cl(t.value) || cl(i59)) return null;
      let e = parseFloat(t.value);
      return !isNaN(e) && e < i59 ? { min: { min: i59, actual: t.value } } : null;
    };
  }
  function lY(i59) {
    return (t) => {
      if (cl(t.value) || cl(i59)) return null;
      let e = parseFloat(t.value);
      return !isNaN(e) && e > i59 ? { max: { max: i59, actual: t.value } } : null;
    };
  }
  function cY(i59) {
    return cl(i59.value) ? { required: true } : null;
  }
  function dY(i59) {
    return i59.value === true ? null : { required: true };
  }
  function uY(i59) {
    return cl(i59.value) || sY.test(i59.value) ? null : { email: true };
  }
  function hY(i59) {
    return (t) => cl(t.value) || !N2(t.value) ? null : t.value.length < i59 ? { minlength: { requiredLength: i59, actualLength: t.value.length } } : null;
  }
  function pY(i59) {
    return (t) => N2(t.value) && t.value.length > i59 ? { maxlength: { requiredLength: i59, actualLength: t.value.length } } : null;
  }
  function fY(i59) {
    if (!i59) return k2;
    let t, e;
    return typeof i59 == "string" ? (e = "", i59.charAt(0) !== "^" && (e += "^"), e += i59, i59.charAt(i59.length - 1) !== "$" && (e += "$"), t = new RegExp(e)) : (e = i59.toString(), t = i59), (n) => {
      if (cl(n.value)) return null;
      let r = n.value;
      return t.test(r) ? null : { pattern: { requiredPattern: e, actualValue: r } };
    };
  }
  function k2(i59) {
    return null;
  }
  function L2(i59) {
    return i59 != null;
  }
  function F2(i59) {
    return af(i59) ? Zr(i59) : i59;
  }
  function B2(i59) {
    let t = {};
    return i59.forEach((e) => {
      t = e != null ? le(le({}, t), e) : t;
    }), Object.keys(t).length === 0 ? null : t;
  }
  function V2(i59, t) {
    return t.map((e) => e(i59));
  }
  function mY(i59) {
    return !i59.validate;
  }
  function z2(i59) {
    return i59.map((t) => mY(t) ? t : (e) => t.validate(e));
  }
  function U2(i59) {
    if (!i59) return null;
    let t = i59.filter(L2);
    return t.length == 0 ? null : function(e) {
      return B2(V2(e, t));
    };
  }
  function sT(i59) {
    return i59 != null ? U2(z2(i59)) : null;
  }
  function G2(i59) {
    if (!i59) return null;
    let t = i59.filter(L2);
    return t.length == 0 ? null : function(e) {
      let n = V2(e, t).map(F2);
      return Pp(n).pipe(kt(B2));
    };
  }
  function aT(i59) {
    return i59 != null ? G2(z2(i59)) : null;
  }
  function T2(i59, t) {
    return i59 === null ? [t] : Array.isArray(i59) ? [...i59, t] : [i59, t];
  }
  function H2(i59) {
    return i59._rawValidators;
  }
  function j2(i59) {
    return i59._rawAsyncValidators;
  }
  function tT(i59) {
    return i59 ? Array.isArray(i59) ? i59 : [i59] : [];
  }
  function By(i59, t) {
    return Array.isArray(i59) ? i59.includes(t) : i59 === t;
  }
  function I2(i59, t) {
    let e = tT(t);
    return tT(i59).forEach((r) => {
      By(e, r) || e.push(r);
    }), e;
  }
  function D2(i59, t) {
    return tT(t).filter((e) => !By(i59, e));
  }
  var Vy = class {
    get value() {
      return this.control ? this.control.value : null;
    }
    get valid() {
      return this.control ? this.control.valid : null;
    }
    get invalid() {
      return this.control ? this.control.invalid : null;
    }
    get pending() {
      return this.control ? this.control.pending : null;
    }
    get disabled() {
      return this.control ? this.control.disabled : null;
    }
    get enabled() {
      return this.control ? this.control.enabled : null;
    }
    get errors() {
      return this.control ? this.control.errors : null;
    }
    get pristine() {
      return this.control ? this.control.pristine : null;
    }
    get dirty() {
      return this.control ? this.control.dirty : null;
    }
    get touched() {
      return this.control ? this.control.touched : null;
    }
    get status() {
      return this.control ? this.control.status : null;
    }
    get untouched() {
      return this.control ? this.control.untouched : null;
    }
    get statusChanges() {
      return this.control ? this.control.statusChanges : null;
    }
    get valueChanges() {
      return this.control ? this.control.valueChanges : null;
    }
    get path() {
      return null;
    }
    _composedValidatorFn;
    _composedAsyncValidatorFn;
    _rawValidators = [];
    _rawAsyncValidators = [];
    _setValidators(t) {
      this._rawValidators = t || [], this._composedValidatorFn = sT(this._rawValidators);
    }
    _setAsyncValidators(t) {
      this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = aT(this._rawAsyncValidators);
    }
    get validator() {
      return this._composedValidatorFn || null;
    }
    get asyncValidator() {
      return this._composedAsyncValidatorFn || null;
    }
    _onDestroyCallbacks = [];
    _registerOnDestroy(t) {
      this._onDestroyCallbacks.push(t);
    }
    _invokeOnDestroyCallbacks() {
      this._onDestroyCallbacks.forEach((t) => t()), this._onDestroyCallbacks = [];
    }
    reset(t = void 0) {
      this.control && this.control.reset(t);
    }
    hasError(t, e) {
      return this.control ? this.control.hasError(t, e) : false;
    }
    getError(t, e) {
      return this.control ? this.control.getError(t, e) : null;
    }
  };
  var Bu = class extends Vy {
    name;
    get formDirective() {
      return null;
    }
    get path() {
      return null;
    }
  };
  var Nc = class extends Vy {
    _parent = null;
    name = null;
    valueAccessor = null;
  };
  var nT = class {
    _cd;
    constructor(t) {
      this._cd = t;
    }
    get isTouched() {
      return this._cd?.control?._touched?.(), !!this._cd?.control?.touched;
    }
    get isUntouched() {
      return !!this._cd?.control?.untouched;
    }
    get isPristine() {
      return this._cd?.control?._pristine?.(), !!this._cd?.control?.pristine;
    }
    get isDirty() {
      return !!this._cd?.control?.dirty;
    }
    get isValid() {
      return this._cd?.control?._status?.(), !!this._cd?.control?.valid;
    }
    get isInvalid() {
      return !!this._cd?.control?.invalid;
    }
    get isPending() {
      return !!this._cd?.control?.pending;
    }
    get isSubmitted() {
      return this._cd?._submitted?.(), !!this._cd?.submitted;
    }
  };
  var gY = { "[class.ng-untouched]": "isUntouched", "[class.ng-touched]": "isTouched", "[class.ng-pristine]": "isPristine", "[class.ng-dirty]": "isDirty", "[class.ng-valid]": "isValid", "[class.ng-invalid]": "isInvalid", "[class.ng-pending]": "isPending" };
  var WCe = xt(le({}, gY), { "[class.ng-submitted]": "isSubmitted" });
  var Ps = (() => {
    class i59 extends nT {
      constructor(e) {
        super(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Nc, 2));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function(n, r) {
        n & 2 && ye("ng-untouched", r.isUntouched)("ng-touched", r.isTouched)("ng-pristine", r.isPristine)("ng-dirty", r.isDirty)("ng-valid", r.isValid)("ng-invalid", r.isInvalid)("ng-pending", r.isPending);
      }, standalone: false, features: [Zt] });
    }
    return i59;
  })();
  var Pf = "VALID";
  var Ly = "INVALID";
  var Lu = "PENDING";
  var Rf = "DISABLED";
  var dl = class {
  };
  var zy = class extends dl {
    value;
    source;
    constructor(t, e) {
      super(), this.value = t, this.source = e;
    }
  };
  var Af = class extends dl {
    pristine;
    source;
    constructor(t, e) {
      super(), this.pristine = t, this.source = e;
    }
  };
  var Nf = class extends dl {
    touched;
    source;
    constructor(t, e) {
      super(), this.touched = t, this.source = e;
    }
  };
  var Fu = class extends dl {
    status;
    source;
    constructor(t, e) {
      super(), this.status = t, this.source = e;
    }
  };
  var iT = class extends dl {
    source;
    constructor(t) {
      super(), this.source = t;
    }
  };
  var rT = class extends dl {
    source;
    constructor(t) {
      super(), this.source = t;
    }
  };
  function W2(i59) {
    return (qy(i59) ? i59.validators : i59) || null;
  }
  function _Y(i59) {
    return Array.isArray(i59) ? sT(i59) : i59 || null;
  }
  function $2(i59, t) {
    return (qy(t) ? t.asyncValidators : i59) || null;
  }
  function vY(i59) {
    return Array.isArray(i59) ? aT(i59) : i59 || null;
  }
  function qy(i59) {
    return i59 != null && !Array.isArray(i59) && typeof i59 == "object";
  }
  function yY(i59, t, e) {
    let n = i59.controls;
    if (!(t ? Object.keys(n) : n).length) throw new ze(1e3, "");
    if (!n[e]) throw new ze(1001, "");
  }
  function bY(i59, t, e) {
    i59._forEachChild((n, r) => {
      if (e[r] === void 0) throw new ze(1002, "");
    });
  }
  var Uy = class {
    _pendingDirty = false;
    _hasOwnPendingAsyncValidator = null;
    _pendingTouched = false;
    _onCollectionChange = () => {
    };
    _updateOn;
    _parent = null;
    _asyncValidationSubscription;
    _composedValidatorFn;
    _composedAsyncValidatorFn;
    _rawValidators;
    _rawAsyncValidators;
    value;
    constructor(t, e) {
      this._assignValidators(t), this._assignAsyncValidators(e);
    }
    get validator() {
      return this._composedValidatorFn;
    }
    set validator(t) {
      this._rawValidators = this._composedValidatorFn = t;
    }
    get asyncValidator() {
      return this._composedAsyncValidatorFn;
    }
    set asyncValidator(t) {
      this._rawAsyncValidators = this._composedAsyncValidatorFn = t;
    }
    get parent() {
      return this._parent;
    }
    get status() {
      return Rr(this.statusReactive);
    }
    set status(t) {
      Rr(() => this.statusReactive.set(t));
    }
    _status = It(() => this.statusReactive());
    statusReactive = gt(void 0);
    get valid() {
      return this.status === Pf;
    }
    get invalid() {
      return this.status === Ly;
    }
    get pending() {
      return this.status == Lu;
    }
    get disabled() {
      return this.status === Rf;
    }
    get enabled() {
      return this.status !== Rf;
    }
    errors;
    get pristine() {
      return Rr(this.pristineReactive);
    }
    set pristine(t) {
      Rr(() => this.pristineReactive.set(t));
    }
    _pristine = It(() => this.pristineReactive());
    pristineReactive = gt(true);
    get dirty() {
      return !this.pristine;
    }
    get touched() {
      return Rr(this.touchedReactive);
    }
    set touched(t) {
      Rr(() => this.touchedReactive.set(t));
    }
    _touched = It(() => this.touchedReactive());
    touchedReactive = gt(false);
    get untouched() {
      return !this.touched;
    }
    _events = new we();
    events = this._events.asObservable();
    valueChanges;
    statusChanges;
    get updateOn() {
      return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
    }
    setValidators(t) {
      this._assignValidators(t);
    }
    setAsyncValidators(t) {
      this._assignAsyncValidators(t);
    }
    addValidators(t) {
      this.setValidators(I2(t, this._rawValidators));
    }
    addAsyncValidators(t) {
      this.setAsyncValidators(I2(t, this._rawAsyncValidators));
    }
    removeValidators(t) {
      this.setValidators(D2(t, this._rawValidators));
    }
    removeAsyncValidators(t) {
      this.setAsyncValidators(D2(t, this._rawAsyncValidators));
    }
    hasValidator(t) {
      return By(this._rawValidators, t);
    }
    hasAsyncValidator(t) {
      return By(this._rawAsyncValidators, t);
    }
    clearValidators() {
      this.validator = null;
    }
    clearAsyncValidators() {
      this.asyncValidator = null;
    }
    markAsTouched(t = {}) {
      let e = this.touched === false;
      this.touched = true;
      let n = t.sourceControl ?? this;
      this._parent && !t.onlySelf && this._parent.markAsTouched(xt(le({}, t), { sourceControl: n })), e && t.emitEvent !== false && this._events.next(new Nf(true, n));
    }
    markAllAsTouched(t = {}) {
      this.markAsTouched({ onlySelf: true, emitEvent: t.emitEvent, sourceControl: this }), this._forEachChild((e) => e.markAllAsTouched(t));
    }
    markAsUntouched(t = {}) {
      let e = this.touched === true;
      this.touched = false, this._pendingTouched = false;
      let n = t.sourceControl ?? this;
      this._forEachChild((r) => {
        r.markAsUntouched({ onlySelf: true, emitEvent: t.emitEvent, sourceControl: n });
      }), this._parent && !t.onlySelf && this._parent._updateTouched(t, n), e && t.emitEvent !== false && this._events.next(new Nf(false, n));
    }
    markAsDirty(t = {}) {
      let e = this.pristine === true;
      this.pristine = false;
      let n = t.sourceControl ?? this;
      this._parent && !t.onlySelf && this._parent.markAsDirty(xt(le({}, t), { sourceControl: n })), e && t.emitEvent !== false && this._events.next(new Af(false, n));
    }
    markAsPristine(t = {}) {
      let e = this.pristine === false;
      this.pristine = true, this._pendingDirty = false;
      let n = t.sourceControl ?? this;
      this._forEachChild((r) => {
        r.markAsPristine({ onlySelf: true, emitEvent: t.emitEvent });
      }), this._parent && !t.onlySelf && this._parent._updatePristine(t, n), e && t.emitEvent !== false && this._events.next(new Af(true, n));
    }
    markAsPending(t = {}) {
      this.status = Lu;
      let e = t.sourceControl ?? this;
      t.emitEvent !== false && (this._events.next(new Fu(this.status, e)), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.markAsPending(xt(le({}, t), { sourceControl: e }));
    }
    disable(t = {}) {
      let e = this._parentMarkedDirty(t.onlySelf);
      this.status = Rf, this.errors = null, this._forEachChild((r) => {
        r.disable(xt(le({}, t), { onlySelf: true }));
      }), this._updateValue();
      let n = t.sourceControl ?? this;
      t.emitEvent !== false && (this._events.next(new zy(this.value, n)), this._events.next(new Fu(this.status, n)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(xt(le({}, t), { skipPristineCheck: e }), this), this._onDisabledChange.forEach((r) => r(true));
    }
    enable(t = {}) {
      let e = this._parentMarkedDirty(t.onlySelf);
      this.status = Pf, this._forEachChild((n) => {
        n.enable(xt(le({}, t), { onlySelf: true }));
      }), this.updateValueAndValidity({ onlySelf: true, emitEvent: t.emitEvent }), this._updateAncestors(xt(le({}, t), { skipPristineCheck: e }), this), this._onDisabledChange.forEach((n) => n(false));
    }
    _updateAncestors(t, e) {
      this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine({}, e), this._parent._updateTouched({}, e));
    }
    setParent(t) {
      this._parent = t;
    }
    getRawValue() {
      return this.value;
    }
    updateValueAndValidity(t = {}) {
      if (this._setInitialStatus(), this._updateValue(), this.enabled) {
        let n = this._cancelExistingSubscription();
        this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === Pf || this.status === Lu) && this._runAsyncValidator(n, t.emitEvent);
      }
      let e = t.sourceControl ?? this;
      t.emitEvent !== false && (this._events.next(new zy(this.value, e)), this._events.next(new Fu(this.status, e)), this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(xt(le({}, t), { sourceControl: e }));
    }
    _updateTreeValidity(t = { emitEvent: true }) {
      this._forEachChild((e) => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: true, emitEvent: t.emitEvent });
    }
    _setInitialStatus() {
      this.status = this._allControlsDisabled() ? Rf : Pf;
    }
    _runValidator() {
      return this.validator ? this.validator(this) : null;
    }
    _runAsyncValidator(t, e) {
      if (this.asyncValidator) {
        this.status = Lu, this._hasOwnPendingAsyncValidator = { emitEvent: e !== false };
        let n = F2(this.asyncValidator(this));
        this._asyncValidationSubscription = n.subscribe((r) => {
          this._hasOwnPendingAsyncValidator = null, this.setErrors(r, { emitEvent: e, shouldHaveEmitted: t });
        });
      }
    }
    _cancelExistingSubscription() {
      if (this._asyncValidationSubscription) {
        this._asyncValidationSubscription.unsubscribe();
        let t = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;
        return this._hasOwnPendingAsyncValidator = null, t;
      }
      return false;
    }
    setErrors(t, e = {}) {
      this.errors = t, this._updateControlsErrors(e.emitEvent !== false, this, e.shouldHaveEmitted);
    }
    get(t) {
      let e = t;
      return e == null || (Array.isArray(e) || (e = e.split(".")), e.length === 0) ? null : e.reduce((n, r) => n && n._find(r), this);
    }
    getError(t, e) {
      let n = e ? this.get(e) : this;
      return n && n.errors ? n.errors[t] : null;
    }
    hasError(t, e) {
      return !!this.getError(t, e);
    }
    get root() {
      let t = this;
      for (; t._parent; ) t = t._parent;
      return t;
    }
    _updateControlsErrors(t, e, n) {
      this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), (t || n) && this._events.next(new Fu(this.status, e)), this._parent && this._parent._updateControlsErrors(t, e, n);
    }
    _initObservables() {
      this.valueChanges = new Ue(), this.statusChanges = new Ue();
    }
    _calculateStatus() {
      return this._allControlsDisabled() ? Rf : this.errors ? Ly : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Lu) ? Lu : this._anyControlsHaveStatus(Ly) ? Ly : Pf;
    }
    _anyControlsHaveStatus(t) {
      return this._anyControls((e) => e.status === t);
    }
    _anyControlsDirty() {
      return this._anyControls((t) => t.dirty);
    }
    _anyControlsTouched() {
      return this._anyControls((t) => t.touched);
    }
    _updatePristine(t, e) {
      let n = !this._anyControlsDirty(), r = this.pristine !== n;
      this.pristine = n, this._parent && !t.onlySelf && this._parent._updatePristine(t, e), r && this._events.next(new Af(this.pristine, e));
    }
    _updateTouched(t = {}, e) {
      this.touched = this._anyControlsTouched(), this._events.next(new Nf(this.touched, e)), this._parent && !t.onlySelf && this._parent._updateTouched(t, e);
    }
    _onDisabledChange = [];
    _registerOnCollectionChange(t) {
      this._onCollectionChange = t;
    }
    _setUpdateStrategy(t) {
      qy(t) && t.updateOn != null && (this._updateOn = t.updateOn);
    }
    _parentMarkedDirty(t) {
      let e = this._parent && this._parent.dirty;
      return !t && !!e && !this._parent._anyControlsDirty();
    }
    _find(t) {
      return null;
    }
    _assignValidators(t) {
      this._rawValidators = Array.isArray(t) ? t.slice() : t, this._composedValidatorFn = _Y(this._rawValidators);
    }
    _assignAsyncValidators(t) {
      this._rawAsyncValidators = Array.isArray(t) ? t.slice() : t, this._composedAsyncValidatorFn = vY(this._rawAsyncValidators);
    }
  };
  var Gy = class extends Uy {
    constructor(t, e, n) {
      super(W2(e), $2(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: true, emitEvent: !!this.asyncValidator });
    }
    controls;
    registerControl(t, e) {
      return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e);
    }
    addControl(t, e, n = {}) {
      this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange();
    }
    removeControl(t, e = {}) {
      this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {
      }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange();
    }
    setControl(t, e, n = {}) {
      this.controls[t] && this.controls[t]._registerOnCollectionChange(() => {
      }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange();
    }
    contains(t) {
      return this.controls.hasOwnProperty(t) && this.controls[t].enabled;
    }
    setValue(t, e = {}) {
      bY(this, true, t), Object.keys(t).forEach((n) => {
        yY(this, true, n), this.controls[n].setValue(t[n], { onlySelf: true, emitEvent: e.emitEvent });
      }), this.updateValueAndValidity(e);
    }
    patchValue(t, e = {}) {
      t != null && (Object.keys(t).forEach((n) => {
        let r = this.controls[n];
        r && r.patchValue(t[n], { onlySelf: true, emitEvent: e.emitEvent });
      }), this.updateValueAndValidity(e));
    }
    reset(t = {}, e = {}) {
      this._forEachChild((n, r) => {
        n.reset(t ? t[r] : null, { onlySelf: true, emitEvent: e.emitEvent });
      }), this._updatePristine(e, this), this._updateTouched(e, this), this.updateValueAndValidity(e);
    }
    getRawValue() {
      return this._reduceChildren({}, (t, e, n) => (t[n] = e.getRawValue(), t));
    }
    _syncPendingControls() {
      let t = this._reduceChildren(false, (e, n) => n._syncPendingControls() ? true : e);
      return t && this.updateValueAndValidity({ onlySelf: true }), t;
    }
    _forEachChild(t) {
      Object.keys(this.controls).forEach((e) => {
        let n = this.controls[e];
        n && t(n, e);
      });
    }
    _setUpControls() {
      this._forEachChild((t) => {
        t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange);
      });
    }
    _updateValue() {
      this.value = this._reduceValue();
    }
    _anyControls(t) {
      for (let [e, n] of Object.entries(this.controls)) if (this.contains(e) && t(n)) return true;
      return false;
    }
    _reduceValue() {
      let t = {};
      return this._reduceChildren(t, (e, n, r) => ((n.enabled || this.disabled) && (e[r] = n.value), e));
    }
    _reduceChildren(t, e) {
      let n = t;
      return this._forEachChild((r, o) => {
        n = e(n, r, o);
      }), n;
    }
    _allControlsDisabled() {
      for (let t of Object.keys(this.controls)) if (this.controls[t].enabled) return false;
      return Object.keys(this.controls).length > 0 || this.disabled;
    }
    _find(t) {
      return this.controls.hasOwnProperty(t) ? this.controls[t] : null;
    }
  };
  var Yy = new Ee("", { providedIn: "root", factory: () => lT });
  var lT = "always";
  function Hy(i59, t, e = lT) {
    cT(i59, t), t.valueAccessor.writeValue(i59.value), (i59.disabled || e === "always") && t.valueAccessor.setDisabledState?.(i59.disabled), wY(i59, t), SY(i59, t), CY(i59, t), xY(i59, t);
  }
  function jy(i59, t, e = true) {
    let n = () => {
    };
    t.valueAccessor && (t.valueAccessor.registerOnChange(n), t.valueAccessor.registerOnTouched(n)), $y(i59, t), i59 && (t._invokeOnDestroyCallbacks(), i59._registerOnCollectionChange(() => {
    }));
  }
  function Wy(i59, t) {
    i59.forEach((e) => {
      e.registerOnValidatorChange && e.registerOnValidatorChange(t);
    });
  }
  function xY(i59, t) {
    if (t.valueAccessor.setDisabledState) {
      let e = (n) => {
        t.valueAccessor.setDisabledState(n);
      };
      i59.registerOnDisabledChange(e), t._registerOnDestroy(() => {
        i59._unregisterOnDisabledChange(e);
      });
    }
  }
  function cT(i59, t) {
    let e = H2(i59);
    t.validator !== null ? i59.setValidators(T2(e, t.validator)) : typeof e == "function" && i59.setValidators([e]);
    let n = j2(i59);
    t.asyncValidator !== null ? i59.setAsyncValidators(T2(n, t.asyncValidator)) : typeof n == "function" && i59.setAsyncValidators([n]);
    let r = () => i59.updateValueAndValidity();
    Wy(t._rawValidators, r), Wy(t._rawAsyncValidators, r);
  }
  function $y(i59, t) {
    let e = false;
    if (i59 !== null) {
      if (t.validator !== null) {
        let r = H2(i59);
        if (Array.isArray(r) && r.length > 0) {
          let o = r.filter((s) => s !== t.validator);
          o.length !== r.length && (e = true, i59.setValidators(o));
        }
      }
      if (t.asyncValidator !== null) {
        let r = j2(i59);
        if (Array.isArray(r) && r.length > 0) {
          let o = r.filter((s) => s !== t.asyncValidator);
          o.length !== r.length && (e = true, i59.setAsyncValidators(o));
        }
      }
    }
    let n = () => {
    };
    return Wy(t._rawValidators, n), Wy(t._rawAsyncValidators, n), e;
  }
  function wY(i59, t) {
    t.valueAccessor.registerOnChange((e) => {
      i59._pendingValue = e, i59._pendingChange = true, i59._pendingDirty = true, i59.updateOn === "change" && q2(i59, t);
    });
  }
  function CY(i59, t) {
    t.valueAccessor.registerOnTouched(() => {
      i59._pendingTouched = true, i59.updateOn === "blur" && i59._pendingChange && q2(i59, t), i59.updateOn !== "submit" && i59.markAsTouched();
    });
  }
  function q2(i59, t) {
    i59._pendingDirty && i59.markAsDirty(), i59.setValue(i59._pendingValue, { emitModelToViewChange: false }), t.viewToModelUpdate(i59._pendingValue), i59._pendingChange = false;
  }
  function SY(i59, t) {
    let e = (n, r) => {
      t.valueAccessor.writeValue(n), r && t.viewToModelUpdate(n);
    };
    i59.registerOnChange(e), t._registerOnDestroy(() => {
      i59._unregisterOnChange(e);
    });
  }
  function Y2(i59, t) {
    i59 == null, cT(i59, t);
  }
  function MY(i59, t) {
    return $y(i59, t);
  }
  function EY(i59, t) {
    if (!i59.hasOwnProperty("model")) return false;
    let e = i59.model;
    return e.isFirstChange() ? true : !Object.is(t, e.currentValue);
  }
  function TY(i59) {
    return Object.getPrototypeOf(i59.constructor) === A2;
  }
  function X2(i59, t) {
    i59._syncPendingControls(), t.forEach((e) => {
      let n = e.control;
      n.updateOn === "submit" && n._pendingChange && (e.viewToModelUpdate(n._pendingValue), n._pendingChange = false);
    });
  }
  function IY(i59, t) {
    if (!t) return null;
    Array.isArray(t);
    let e, n, r;
    return t.forEach((o) => {
      o.constructor === ul ? e = o : TY(o) ? n = o : r = o;
    }), r || n || e || null;
  }
  function DY(i59, t) {
    let e = i59.indexOf(t);
    e > -1 && i59.splice(e, 1);
  }
  var PY = { provide: Bu, useExisting: Gr(() => dT) };
  var Of = Promise.resolve();
  var dT = (() => {
    class i59 extends Bu {
      callSetDisabledState;
      get submitted() {
        return Rr(this.submittedReactive);
      }
      _submitted = It(() => this.submittedReactive());
      submittedReactive = gt(false);
      _directives = /* @__PURE__ */ new Set();
      form;
      ngSubmit = new Ue();
      options;
      constructor(e, n, r) {
        super(), this.callSetDisabledState = r, this.form = new Gy({}, sT(e), aT(n));
      }
      ngAfterViewInit() {
        this._setUpdateStrategy();
      }
      get formDirective() {
        return this;
      }
      get control() {
        return this.form;
      }
      get path() {
        return [];
      }
      get controls() {
        return this.form.controls;
      }
      addControl(e) {
        Of.then(() => {
          let n = this._findContainer(e.path);
          e.control = n.registerControl(e.name, e.control), Hy(e.control, e, this.callSetDisabledState), e.control.updateValueAndValidity({ emitEvent: false }), this._directives.add(e);
        });
      }
      getControl(e) {
        return this.form.get(e.path);
      }
      removeControl(e) {
        Of.then(() => {
          let n = this._findContainer(e.path);
          n && n.removeControl(e.name), this._directives.delete(e);
        });
      }
      addFormGroup(e) {
        Of.then(() => {
          let n = this._findContainer(e.path), r = new Gy({});
          Y2(r, e), n.registerControl(e.name, r), r.updateValueAndValidity({ emitEvent: false });
        });
      }
      removeFormGroup(e) {
        Of.then(() => {
          let n = this._findContainer(e.path);
          n && n.removeControl(e.name);
        });
      }
      getFormGroup(e) {
        return this.form.get(e.path);
      }
      updateModel(e, n) {
        Of.then(() => {
          this.form.get(e.path).setValue(n);
        });
      }
      setValue(e) {
        this.control.setValue(e);
      }
      onSubmit(e) {
        return this.submittedReactive.set(true), X2(this.form, this._directives), this.ngSubmit.emit(e), e?.target?.method === "dialog";
      }
      onReset() {
        this.resetForm();
      }
      resetForm(e = void 0) {
        this.form.reset(e), this.submittedReactive.set(false);
      }
      _setUpdateStrategy() {
        this.options && this.options.updateOn != null && (this.form._updateOn = this.options.updateOn);
      }
      _findContainer(e) {
        return e.pop(), e.length ? this.form.get(e) : this.form;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Lc, 10), K(oT, 10), K(Yy, 8));
      };
      static \u0275dir = qe({ type: i59, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function(n, r) {
        n & 1 && Z("submit", function(s) {
          return r.onSubmit(s);
        })("reset", function() {
          return r.onReset();
        });
      }, inputs: { options: [0, "ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], standalone: false, features: [Bt([PY]), Zt] });
    }
    return i59;
  })();
  function P2(i59, t) {
    let e = i59.indexOf(t);
    e > -1 && i59.splice(e, 1);
  }
  function R2(i59) {
    return typeof i59 == "object" && i59 !== null && Object.keys(i59).length === 2 && "value" in i59 && "disabled" in i59;
  }
  var qr = class extends Uy {
    defaultValue = null;
    _onChange = [];
    _pendingValue;
    _pendingChange = false;
    constructor(t = null, e, n) {
      super(W2(e), $2(n, e)), this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: true, emitEvent: !!this.asyncValidator }), qy(e) && (e.nonNullable || e.initialValueIsDefault) && (R2(t) ? this.defaultValue = t.value : this.defaultValue = t);
    }
    setValue(t, e = {}) {
      this.value = this._pendingValue = t, this._onChange.length && e.emitModelToViewChange !== false && this._onChange.forEach((n) => n(this.value, e.emitViewToModelChange !== false)), this.updateValueAndValidity(e);
    }
    patchValue(t, e = {}) {
      this.setValue(t, e);
    }
    reset(t = this.defaultValue, e = {}) {
      this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = false;
    }
    _updateValue() {
    }
    _anyControls(t) {
      return false;
    }
    _allControlsDisabled() {
      return this.disabled;
    }
    registerOnChange(t) {
      this._onChange.push(t);
    }
    _unregisterOnChange(t) {
      P2(this._onChange, t);
    }
    registerOnDisabledChange(t) {
      this._onDisabledChange.push(t);
    }
    _unregisterOnDisabledChange(t) {
      P2(this._onDisabledChange, t);
    }
    _forEachChild(t) {
    }
    _syncPendingControls() {
      return this.updateOn === "submit" && (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), this._pendingChange) ? (this.setValue(this._pendingValue, { onlySelf: true, emitModelToViewChange: false }), true) : false;
    }
    _applyFormState(t) {
      R2(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: true, emitEvent: false }) : this.enable({ onlySelf: true, emitEvent: false })) : this.value = this._pendingValue = t;
    }
  };
  var RY = (i59) => i59 instanceof qr;
  var Z2 = new Ee("");
  var OY = { provide: Nc, useExisting: Gr(() => Jo) };
  var Jo = (() => {
    class i59 extends Nc {
      _ngModelWarningConfig;
      callSetDisabledState;
      viewModel;
      form;
      set isDisabled(e) {
      }
      model;
      update = new Ue();
      static _ngModelWarningSentOnce = false;
      _ngModelWarningSent = false;
      constructor(e, n, r, o, s) {
        super(), this._ngModelWarningConfig = o, this.callSetDisabledState = s, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = IY(this, r);
      }
      ngOnChanges(e) {
        if (this._isControlChanged(e)) {
          let n = e.form.previousValue;
          n && jy(n, this, false), Hy(this.form, this, this.callSetDisabledState), this.form.updateValueAndValidity({ emitEvent: false });
        }
        EY(e, this.viewModel) && (this.form.setValue(this.model), this.viewModel = this.model);
      }
      ngOnDestroy() {
        this.form && jy(this.form, this, false);
      }
      get path() {
        return [];
      }
      get control() {
        return this.form;
      }
      viewToModelUpdate(e) {
        this.viewModel = e, this.update.emit(e);
      }
      _isControlChanged(e) {
        return e.hasOwnProperty("form");
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Lc, 10), K(oT, 10), K(kc, 10), K(Z2, 8), K(Yy, 8));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "formControl", ""]], inputs: { form: [0, "formControl", "form"], isDisabled: [0, "disabled", "isDisabled"], model: [0, "ngModel", "model"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngForm"], standalone: false, features: [Bt([OY]), Zt, yn] });
    }
    return i59;
  })();
  var AY = { provide: Bu, useExisting: Gr(() => uT) };
  var uT = (() => {
    class i59 extends Bu {
      callSetDisabledState;
      get submitted() {
        return Rr(this._submittedReactive);
      }
      set submitted(e) {
        this._submittedReactive.set(e);
      }
      _submitted = It(() => this._submittedReactive());
      _submittedReactive = gt(false);
      _oldForm;
      _onCollectionChange = () => this._updateDomValue();
      directives = [];
      form = null;
      ngSubmit = new Ue();
      constructor(e, n, r) {
        super(), this.callSetDisabledState = r, this._setValidators(e), this._setAsyncValidators(n);
      }
      ngOnChanges(e) {
        this._checkFormPresent(), e.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form);
      }
      ngOnDestroy() {
        this.form && ($y(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => {
        }));
      }
      get formDirective() {
        return this;
      }
      get control() {
        return this.form;
      }
      get path() {
        return [];
      }
      addControl(e) {
        let n = this.form.get(e.path);
        return Hy(n, e, this.callSetDisabledState), n.updateValueAndValidity({ emitEvent: false }), this.directives.push(e), n;
      }
      getControl(e) {
        return this.form.get(e.path);
      }
      removeControl(e) {
        jy(e.control || null, e, false), DY(this.directives, e);
      }
      addFormGroup(e) {
        this._setUpFormContainer(e);
      }
      removeFormGroup(e) {
        this._cleanUpFormContainer(e);
      }
      getFormGroup(e) {
        return this.form.get(e.path);
      }
      addFormArray(e) {
        this._setUpFormContainer(e);
      }
      removeFormArray(e) {
        this._cleanUpFormContainer(e);
      }
      getFormArray(e) {
        return this.form.get(e.path);
      }
      updateModel(e, n) {
        this.form.get(e.path).setValue(n);
      }
      onSubmit(e) {
        return this._submittedReactive.set(true), X2(this.form, this.directives), this.ngSubmit.emit(e), this.form._events.next(new iT(this.control)), e?.target?.method === "dialog";
      }
      onReset() {
        this.resetForm();
      }
      resetForm(e = void 0) {
        this.form.reset(e), this._submittedReactive.set(false), this.form._events.next(new rT(this.form));
      }
      _updateDomValue() {
        this.directives.forEach((e) => {
          let n = e.control, r = this.form.get(e.path);
          n !== r && (jy(n || null, e), RY(r) && (Hy(r, e, this.callSetDisabledState), e.control = r));
        }), this.form._updateTreeValidity({ emitEvent: false });
      }
      _setUpFormContainer(e) {
        let n = this.form.get(e.path);
        Y2(n, e), n.updateValueAndValidity({ emitEvent: false });
      }
      _cleanUpFormContainer(e) {
        if (this.form) {
          let n = this.form.get(e.path);
          n && MY(n, e) && n.updateValueAndValidity({ emitEvent: false });
        }
      }
      _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => {
        });
      }
      _updateValidators() {
        cT(this.form, this), this._oldForm && $y(this._oldForm, this);
      }
      _checkFormPresent() {
        this.form;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Lc, 10), K(oT, 10), K(Yy, 8));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "formGroup", ""]], hostBindings: function(n, r) {
        n & 1 && Z("submit", function(s) {
          return r.onSubmit(s);
        })("reset", function() {
          return r.onReset();
        });
      }, inputs: { form: [0, "formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], standalone: false, features: [Bt([AY]), Zt, yn] });
    }
    return i59;
  })();
  var NY = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  var Do = (() => {
    class i59 {
      static withConfig(e) {
        return { ngModule: i59, providers: [{ provide: Z2, useValue: e.warnOnNgModelWithFormControl ?? "always" }, { provide: Yy, useValue: e.callSetDisabledState ?? lT }] };
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [NY] });
    }
    return i59;
  })();
  var pT;
  try {
    pT = typeof Intl < "u" && Intl.v8BreakIterator;
  } catch {
    pT = false;
  }
  var Nn = (() => {
    class i59 {
      _platformId = M(el);
      isBrowser = this._platformId ? rk(this._platformId) : typeof document == "object" && !!document;
      EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
      TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
      BLINK = this.isBrowser && !!(window.chrome || pT) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT;
      WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
      IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
      FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
      ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
      SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      constructor() {
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Ff;
  function kY() {
    if (Ff == null && typeof window < "u") try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Ff = true }));
    } finally {
      Ff = Ff || false;
    }
    return Ff;
  }
  function Or(i59) {
    return kY() ? i59 : !!i59.capture;
  }
  var es = function(i59) {
    return i59[i59.NORMAL = 0] = "NORMAL", i59[i59.NEGATED = 1] = "NEGATED", i59[i59.INVERTED = 2] = "INVERTED", i59;
  }(es || {});
  var Xy;
  var Fc;
  function Zy() {
    if (Fc == null) {
      if (typeof document != "object" || !document || typeof Element != "function" || !Element) return Fc = false, Fc;
      if ("scrollBehavior" in document.documentElement.style) Fc = true;
      else {
        let i59 = Element.prototype.scrollTo;
        i59 ? Fc = !/\{\s*\[native code\]\s*\}/.test(i59.toString()) : Fc = false;
      }
    }
    return Fc;
  }
  function Vu() {
    if (typeof document != "object" || !document) return es.NORMAL;
    if (Xy == null) {
      let i59 = document.createElement("div"), t = i59.style;
      i59.dir = "rtl", t.width = "1px", t.overflow = "auto", t.visibility = "hidden", t.pointerEvents = "none", t.position = "absolute";
      let e = document.createElement("div"), n = e.style;
      n.width = "2px", n.height = "1px", i59.appendChild(e), document.body.appendChild(i59), Xy = es.NORMAL, i59.scrollLeft === 0 && (i59.scrollLeft = 1, Xy = i59.scrollLeft === 0 ? es.NEGATED : es.INVERTED), i59.remove();
    }
    return Xy;
  }
  var hT;
  function LY() {
    if (hT == null) {
      let i59 = typeof document < "u" ? document.head : null;
      hT = !!(i59 && (i59.createShadowRoot || i59.attachShadow));
    }
    return hT;
  }
  function zu(i59) {
    if (LY()) {
      let t = i59.getRootNode ? i59.getRootNode() : null;
      if (typeof ShadowRoot < "u" && ShadowRoot && t instanceof ShadowRoot) return t;
    }
    return null;
  }
  function Bf() {
    let i59 = typeof document < "u" && document ? document.activeElement : null;
    for (; i59 && i59.shadowRoot; ) {
      let t = i59.shadowRoot.activeElement;
      if (t === i59) break;
      i59 = t;
    }
    return i59;
  }
  function Fi(i59) {
    return i59.composedPath ? i59.composedPath()[0] : i59.target;
  }
  function fT() {
    return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha;
  }
  var Qy = /* @__PURE__ */ new WeakMap();
  var mi = (() => {
    class i59 {
      _appRef;
      _injector = M(mt);
      _environmentInjector = M(Jr);
      load(e) {
        let n = this._appRef = this._appRef || this._injector.get(Ur), r = Qy.get(n);
        r || (r = { loaders: /* @__PURE__ */ new Set(), refs: [] }, Qy.set(n, r), n.onDestroy(() => {
          Qy.get(n)?.refs.forEach((o) => o.destroy()), Qy.delete(n);
        })), r.loaders.has(e) || (r.loaders.add(e), r.refs.push(Wv(e, { environmentInjector: this._environmentInjector })));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Vf = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["ng-component"]], exportAs: ["cdkVisuallyHidden"], decls: 0, vars: 0, template: function(n, r) {
      }, styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  function Ki(i59, ...t) {
    return t.length ? t.some((e) => i59[e]) : i59.altKey || i59.shiftKey || i59.ctrlKey || i59.metaKey;
  }
  function Bc(i59) {
    return Js(i59) ? i59 : qt(i59);
  }
  function zf(i59) {
    return i59 != null && `${i59}` != "false";
  }
  function ya(i59, t = 0) {
    return FY(i59) ? Number(i59) : arguments.length === 2 ? t : 0;
  }
  function FY(i59) {
    return !isNaN(parseFloat(i59)) && !isNaN(Number(i59));
  }
  function Vc(i59) {
    return Array.isArray(i59) ? i59 : [i59];
  }
  function gi(i59) {
    return i59 == null ? "" : typeof i59 == "string" ? i59 : `${i59}px`;
  }
  function Ji(i59) {
    return i59 instanceof He ? i59.nativeElement : i59;
  }
  var BY = (() => {
    class i59 {
      create(e) {
        return typeof MutationObserver > "u" ? null : new MutationObserver(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Ky = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [BY] });
    }
    return i59;
  })();
  var Q2 = /* @__PURE__ */ new Set();
  var zc;
  var VY = (() => {
    class i59 {
      _platform = M(Nn);
      _nonce = M(ef, { optional: true });
      _matchMedia;
      constructor() {
        this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : UY;
      }
      matchMedia(e) {
        return (this._platform.WEBKIT || this._platform.BLINK) && zY(e, this._nonce), this._matchMedia(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function zY(i59, t) {
    if (!Q2.has(i59)) try {
      zc || (zc = document.createElement("style"), t && zc.setAttribute("nonce", t), zc.setAttribute("type", "text/css"), document.head.appendChild(zc)), zc.sheet && (zc.sheet.insertRule(`@media ${i59} {body{ }}`, 0), Q2.add(i59));
    } catch (e) {
      console.error(e);
    }
  }
  function UY(i59) {
    return { matches: i59 === "all" || i59 === "", media: i59, addListener: () => {
    }, removeListener: () => {
    } };
  }
  var Jy = (() => {
    class i59 {
      _mediaMatcher = M(VY);
      _zone = M(We);
      _queries = /* @__PURE__ */ new Map();
      _destroySubject = new we();
      constructor() {
      }
      ngOnDestroy() {
        this._destroySubject.next(), this._destroySubject.complete();
      }
      isMatched(e) {
        return K2(Vc(e)).some((r) => this._registerQuery(r).mql.matches);
      }
      observe(e) {
        let r = K2(Vc(e)).map((s) => this._registerQuery(s).observable), o = cr(r);
        return o = ea(o.pipe(On(1)), o.pipe(Ap(1), vo(0))), o.pipe(kt((s) => {
          let a = { matches: false, breakpoints: {} };
          return s.forEach(({ matches: l, query: c }) => {
            a.matches = a.matches || l, a.breakpoints[c] = l;
          }), a;
        }));
      }
      _registerQuery(e) {
        if (this._queries.has(e)) return this._queries.get(e);
        let n = this._mediaMatcher.matchMedia(e), o = { observable: new Et((s) => {
          let a = (l) => this._zone.run(() => s.next(l));
          return n.addListener(a), () => {
            n.removeListener(a);
          };
        }).pipe(ei(n), kt(({ matches: s }) => ({ query: e, matches: s })), Je(this._destroySubject)), mql: n };
        return this._queries.set(e, o), o;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function K2(i59) {
    return i59.map((t) => t.split(",")).reduce((t, e) => t.concat(e)).map((t) => t.trim());
  }
  var J2 = { XSmall: "(max-width: 599.98px)", Small: "(min-width: 600px) and (max-width: 959.98px)", Medium: "(min-width: 960px) and (max-width: 1279.98px)", Large: "(min-width: 1280px) and (max-width: 1919.98px)", XLarge: "(min-width: 1920px)", Handset: "(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)", Tablet: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)", Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)", HandsetPortrait: "(max-width: 599.98px) and (orientation: portrait)", TabletPortrait: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)", WebPortrait: "(min-width: 840px) and (orientation: portrait)", HandsetLandscape: "(max-width: 959.98px) and (orientation: landscape)", TabletLandscape: "(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)", WebLandscape: "(min-width: 1280px) and (orientation: landscape)" };
  var rL = " ";
  function CT(i59, t, e) {
    let n = ib(i59, t);
    e = e.trim(), !n.some((r) => r.trim() === e) && (n.push(e), i59.setAttribute(t, n.join(rL)));
  }
  function cb(i59, t, e) {
    let n = ib(i59, t);
    e = e.trim();
    let r = n.filter((o) => o !== e);
    r.length ? i59.setAttribute(t, r.join(rL)) : i59.removeAttribute(t);
  }
  function ib(i59, t) {
    return i59.getAttribute(t)?.match(/\S+/g) ?? [];
  }
  var oL = "cdk-describedby-message";
  var eb = "cdk-describedby-host";
  var vT = 0;
  var sL = (() => {
    class i59 {
      _platform = M(Nn);
      _document = M(yt);
      _messageRegistry = /* @__PURE__ */ new Map();
      _messagesContainer = null;
      _id = `${vT++}`;
      constructor() {
        M(mi).load(Vf), this._id = M(bu) + "-" + vT++;
      }
      describe(e, n, r) {
        if (!this._canBeDescribed(e, n)) return;
        let o = mT(n, r);
        typeof n != "string" ? (eL(n, this._id), this._messageRegistry.set(o, { messageElement: n, referenceCount: 0 })) : this._messageRegistry.has(o) || this._createMessageElement(n, r), this._isElementDescribedByMessage(e, o) || this._addMessageReference(e, o);
      }
      removeDescription(e, n, r) {
        if (!n || !this._isElementNode(e)) return;
        let o = mT(n, r);
        if (this._isElementDescribedByMessage(e, o) && this._removeMessageReference(e, o), typeof n == "string") {
          let s = this._messageRegistry.get(o);
          s && s.referenceCount === 0 && this._deleteMessageElement(o);
        }
        this._messagesContainer?.childNodes.length === 0 && (this._messagesContainer.remove(), this._messagesContainer = null);
      }
      ngOnDestroy() {
        let e = this._document.querySelectorAll(`[${eb}="${this._id}"]`);
        for (let n = 0; n < e.length; n++) this._removeCdkDescribedByReferenceIds(e[n]), e[n].removeAttribute(eb);
        this._messagesContainer?.remove(), this._messagesContainer = null, this._messageRegistry.clear();
      }
      _createMessageElement(e, n) {
        let r = this._document.createElement("div");
        eL(r, this._id), r.textContent = e, n && r.setAttribute("role", n), this._createMessagesContainer(), this._messagesContainer.appendChild(r), this._messageRegistry.set(mT(e, n), { messageElement: r, referenceCount: 0 });
      }
      _deleteMessageElement(e) {
        this._messageRegistry.get(e)?.messageElement?.remove(), this._messageRegistry.delete(e);
      }
      _createMessagesContainer() {
        if (this._messagesContainer) return;
        let e = "cdk-describedby-message-container", n = this._document.querySelectorAll(`.${e}[platform="server"]`);
        for (let o = 0; o < n.length; o++) n[o].remove();
        let r = this._document.createElement("div");
        r.style.visibility = "hidden", r.classList.add(e), r.classList.add("cdk-visually-hidden"), this._platform.isBrowser || r.setAttribute("platform", "server"), this._document.body.appendChild(r), this._messagesContainer = r;
      }
      _removeCdkDescribedByReferenceIds(e) {
        let n = ib(e, "aria-describedby").filter((r) => r.indexOf(oL) != 0);
        e.setAttribute("aria-describedby", n.join(" "));
      }
      _addMessageReference(e, n) {
        let r = this._messageRegistry.get(n);
        CT(e, "aria-describedby", r.messageElement.id), e.setAttribute(eb, this._id), r.referenceCount++;
      }
      _removeMessageReference(e, n) {
        let r = this._messageRegistry.get(n);
        r.referenceCount--, cb(e, "aria-describedby", r.messageElement.id), e.removeAttribute(eb);
      }
      _isElementDescribedByMessage(e, n) {
        let r = ib(e, "aria-describedby"), o = this._messageRegistry.get(n), s = o && o.messageElement.id;
        return !!s && r.indexOf(s) != -1;
      }
      _canBeDescribed(e, n) {
        if (!this._isElementNode(e)) return false;
        if (n && typeof n == "object") return true;
        let r = n == null ? "" : `${n}`.trim(), o = e.getAttribute("aria-label");
        return r ? !o || o.trim() !== r : false;
      }
      _isElementNode(e) {
        return e.nodeType === this._document.ELEMENT_NODE;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function mT(i59, t) {
    return typeof i59 == "string" ? `${t || ""}/${i59}` : i59;
  }
  function eL(i59, t) {
    i59.id || (i59.id = `${oL}-${t}-${vT++}`);
  }
  var tX = 200;
  var rb = class {
    _letterKeyStream = new we();
    _items = [];
    _selectedItemIndex = -1;
    _pressedLetters = [];
    _skipPredicateFn;
    _selectedItem = new we();
    selectedItem = this._selectedItem;
    constructor(t, e) {
      let n = typeof e?.debounceInterval == "number" ? e.debounceInterval : tX;
      e?.skipPredicate && (this._skipPredicateFn = e.skipPredicate), this.setItems(t), this._setupKeyHandler(n);
    }
    destroy() {
      this._pressedLetters = [], this._letterKeyStream.complete(), this._selectedItem.complete();
    }
    setCurrentSelectedItemIndex(t) {
      this._selectedItemIndex = t;
    }
    setItems(t) {
      this._items = t;
    }
    handleKey(t) {
      let e = t.keyCode;
      t.key && t.key.length === 1 ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e));
    }
    isTyping() {
      return this._pressedLetters.length > 0;
    }
    reset() {
      this._pressedLetters = [];
    }
    _setupKeyHandler(t) {
      this._letterKeyStream.pipe(Wi((e) => this._pressedLetters.push(e)), vo(t), En(() => this._pressedLetters.length > 0), kt(() => this._pressedLetters.join("").toLocaleUpperCase())).subscribe((e) => {
        for (let n = 1; n < this._items.length + 1; n++) {
          let r = (this._selectedItemIndex + n) % this._items.length, o = this._items[r];
          if (!this._skipPredicateFn?.(o) && o.getLabel?.().toLocaleUpperCase().trim().indexOf(e) === 0) {
            this._selectedItem.next(o);
            break;
          }
        }
        this._pressedLetters = [];
      });
    }
  };
  var ob = class {
    _items;
    _activeItemIndex = -1;
    _activeItem = gt(null);
    _wrap = false;
    _typeaheadSubscription = Rt.EMPTY;
    _itemChangesSubscription;
    _vertical = true;
    _horizontal;
    _allowedModifierKeys = [];
    _homeAndEnd = false;
    _pageUpAndDown = { enabled: false, delta: 10 };
    _effectRef;
    _typeahead;
    _skipPredicateFn = (t) => t.disabled;
    constructor(t, e) {
      this._items = t, t instanceof Ni ? this._itemChangesSubscription = t.changes.subscribe((n) => this._itemsChanged(n.toArray())) : Jp(t) && (this._effectRef = ht(() => this._itemsChanged(t()), { injector: e }));
    }
    tabOut = new we();
    change = new we();
    skipPredicate(t) {
      return this._skipPredicateFn = t, this;
    }
    withWrap(t = true) {
      return this._wrap = t, this;
    }
    withVerticalOrientation(t = true) {
      return this._vertical = t, this;
    }
    withHorizontalOrientation(t) {
      return this._horizontal = t, this;
    }
    withAllowedModifierKeys(t) {
      return this._allowedModifierKeys = t, this;
    }
    withTypeAhead(t = 200) {
      this._typeaheadSubscription.unsubscribe();
      let e = this._getItemsArray();
      return this._typeahead = new rb(e, { debounceInterval: typeof t == "number" ? t : void 0, skipPredicate: (n) => this._skipPredicateFn(n) }), this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((n) => {
        this.setActiveItem(n);
      }), this;
    }
    cancelTypeahead() {
      return this._typeahead?.reset(), this;
    }
    withHomeAndEnd(t = true) {
      return this._homeAndEnd = t, this;
    }
    withPageUpDown(t = true, e = 10) {
      return this._pageUpAndDown = { enabled: t, delta: e }, this;
    }
    setActiveItem(t) {
      let e = this._activeItem();
      this.updateActiveItem(t), this._activeItem() !== e && this.change.next(this._activeItemIndex);
    }
    onKeydown(t) {
      let e = t.keyCode, r = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every((o) => !t[o] || this._allowedModifierKeys.indexOf(o) > -1);
      switch (e) {
        case 9:
          this.tabOut.next();
          return;
        case 40:
          if (this._vertical && r) {
            this.setNextItemActive();
            break;
          } else return;
        case 38:
          if (this._vertical && r) {
            this.setPreviousItemActive();
            break;
          } else return;
        case 39:
          if (this._horizontal && r) {
            this._horizontal === "rtl" ? this.setPreviousItemActive() : this.setNextItemActive();
            break;
          } else return;
        case 37:
          if (this._horizontal && r) {
            this._horizontal === "rtl" ? this.setNextItemActive() : this.setPreviousItemActive();
            break;
          } else return;
        case 36:
          if (this._homeAndEnd && r) {
            this.setFirstItemActive();
            break;
          } else return;
        case 35:
          if (this._homeAndEnd && r) {
            this.setLastItemActive();
            break;
          } else return;
        case 33:
          if (this._pageUpAndDown.enabled && r) {
            let o = this._activeItemIndex - this._pageUpAndDown.delta;
            this._setActiveItemByIndex(o > 0 ? o : 0, 1);
            break;
          } else return;
        case 34:
          if (this._pageUpAndDown.enabled && r) {
            let o = this._activeItemIndex + this._pageUpAndDown.delta, s = this._getItemsArray().length;
            this._setActiveItemByIndex(o < s ? o : s - 1, -1);
            break;
          } else return;
        default:
          (r || Ki(t, "shiftKey")) && this._typeahead?.handleKey(t);
          return;
      }
      this._typeahead?.reset(), t.preventDefault();
    }
    get activeItemIndex() {
      return this._activeItemIndex;
    }
    get activeItem() {
      return this._activeItem();
    }
    isTyping() {
      return !!this._typeahead && this._typeahead.isTyping();
    }
    setFirstItemActive() {
      this._setActiveItemByIndex(0, 1);
    }
    setLastItemActive() {
      this._setActiveItemByIndex(this._getItemsArray().length - 1, -1);
    }
    setNextItemActive() {
      this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);
    }
    setPreviousItemActive() {
      this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1);
    }
    updateActiveItem(t) {
      let e = this._getItemsArray(), n = typeof t == "number" ? t : e.indexOf(t), r = e[n];
      this._activeItem.set(r ?? null), this._activeItemIndex = n, this._typeahead?.setCurrentSelectedItemIndex(n);
    }
    destroy() {
      this._typeaheadSubscription.unsubscribe(), this._itemChangesSubscription?.unsubscribe(), this._effectRef?.destroy(), this._typeahead?.destroy(), this.tabOut.complete(), this.change.complete();
    }
    _setActiveItemByDelta(t) {
      this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t);
    }
    _setActiveInWrapMode(t) {
      let e = this._getItemsArray();
      for (let n = 1; n <= e.length; n++) {
        let r = (this._activeItemIndex + t * n + e.length) % e.length, o = e[r];
        if (!this._skipPredicateFn(o)) {
          this.setActiveItem(r);
          return;
        }
      }
    }
    _setActiveInDefaultMode(t) {
      this._setActiveItemByIndex(this._activeItemIndex + t, t);
    }
    _setActiveItemByIndex(t, e) {
      let n = this._getItemsArray();
      if (n[t]) {
        for (; this._skipPredicateFn(n[t]); ) if (t += e, !n[t]) return;
        this.setActiveItem(t);
      }
    }
    _getItemsArray() {
      return Jp(this._items) ? this._items() : this._items instanceof Ni ? this._items.toArray() : this._items;
    }
    _itemsChanged(t) {
      this._typeahead?.setItems(t);
      let e = this._activeItem();
      if (e) {
        let n = t.indexOf(e);
        n > -1 && n !== this._activeItemIndex && (this._activeItemIndex = n, this._typeahead?.setCurrentSelectedItemIndex(n));
      }
    }
  };
  var sb = class extends ob {
    setActiveItem(t) {
      this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(t), this.activeItem && this.activeItem.setActiveStyles();
    }
  };
  var ab = class extends ob {
    _origin = "program";
    setFocusOrigin(t) {
      return this._origin = t, this;
    }
    setActiveItem(t) {
      super.setActiveItem(t), this.activeItem && this.activeItem.focus(this._origin);
    }
  };
  var yT = class {
    _activeItemIndex = -1;
    _activeItem = null;
    _shouldActivationFollowFocus = false;
    _horizontalOrientation = "ltr";
    _skipPredicateFn = (t) => false;
    _trackByFn = (t) => t;
    _items = [];
    _typeahead;
    _typeaheadSubscription = Rt.EMPTY;
    _hasInitialFocused = false;
    _initializeFocus() {
      if (this._hasInitialFocused || this._items.length === 0) return;
      let t = 0;
      for (let n = 0; n < this._items.length; n++) if (!this._skipPredicateFn(this._items[n]) && !this._isItemDisabled(this._items[n])) {
        t = n;
        break;
      }
      let e = this._items[t];
      e.makeFocusable ? (this._activeItem?.unfocus(), this._activeItemIndex = t, this._activeItem = e, this._typeahead?.setCurrentSelectedItemIndex(t), e.makeFocusable()) : this.focusItem(t), this._hasInitialFocused = true;
    }
    constructor(t, e) {
      t instanceof Ni ? (this._items = t.toArray(), t.changes.subscribe((n) => {
        this._items = n.toArray(), this._typeahead?.setItems(this._items), this._updateActiveItemIndex(this._items), this._initializeFocus();
      })) : Js(t) ? t.subscribe((n) => {
        this._items = n, this._typeahead?.setItems(n), this._updateActiveItemIndex(n), this._initializeFocus();
      }) : (this._items = t, this._initializeFocus()), typeof e.shouldActivationFollowFocus == "boolean" && (this._shouldActivationFollowFocus = e.shouldActivationFollowFocus), e.horizontalOrientation && (this._horizontalOrientation = e.horizontalOrientation), e.skipPredicate && (this._skipPredicateFn = e.skipPredicate), e.trackBy && (this._trackByFn = e.trackBy), typeof e.typeAheadDebounceInterval < "u" && this._setTypeAhead(e.typeAheadDebounceInterval);
    }
    change = new we();
    destroy() {
      this._typeaheadSubscription.unsubscribe(), this._typeahead?.destroy(), this.change.complete();
    }
    onKeydown(t) {
      switch (t.key) {
        case "Tab":
          return;
        case "ArrowDown":
          this._focusNextItem();
          break;
        case "ArrowUp":
          this._focusPreviousItem();
          break;
        case "ArrowRight":
          this._horizontalOrientation === "rtl" ? this._collapseCurrentItem() : this._expandCurrentItem();
          break;
        case "ArrowLeft":
          this._horizontalOrientation === "rtl" ? this._expandCurrentItem() : this._collapseCurrentItem();
          break;
        case "Home":
          this._focusFirstItem();
          break;
        case "End":
          this._focusLastItem();
          break;
        case "Enter":
        case " ":
          this._activateCurrentItem();
          break;
        default:
          if (t.key === "*") {
            this._expandAllItemsAtCurrentItemLevel();
            break;
          }
          this._typeahead?.handleKey(t);
          return;
      }
      this._typeahead?.reset(), t.preventDefault();
    }
    getActiveItemIndex() {
      return this._activeItemIndex;
    }
    getActiveItem() {
      return this._activeItem;
    }
    _focusFirstItem() {
      this.focusItem(this._findNextAvailableItemIndex(-1));
    }
    _focusLastItem() {
      this.focusItem(this._findPreviousAvailableItemIndex(this._items.length));
    }
    _focusNextItem() {
      this.focusItem(this._findNextAvailableItemIndex(this._activeItemIndex));
    }
    _focusPreviousItem() {
      this.focusItem(this._findPreviousAvailableItemIndex(this._activeItemIndex));
    }
    focusItem(t, e = {}) {
      e.emitChangeEvent ??= true;
      let n = typeof t == "number" ? t : this._items.findIndex((s) => this._trackByFn(s) === this._trackByFn(t));
      if (n < 0 || n >= this._items.length) return;
      let r = this._items[n];
      if (this._activeItem !== null && this._trackByFn(r) === this._trackByFn(this._activeItem)) return;
      let o = this._activeItem;
      this._activeItem = r ?? null, this._activeItemIndex = n, this._typeahead?.setCurrentSelectedItemIndex(n), this._activeItem?.focus(), o?.unfocus(), e.emitChangeEvent && this.change.next(this._activeItem), this._shouldActivationFollowFocus && this._activateCurrentItem();
    }
    _updateActiveItemIndex(t) {
      let e = this._activeItem;
      if (!e) return;
      let n = t.findIndex((r) => this._trackByFn(r) === this._trackByFn(e));
      n > -1 && n !== this._activeItemIndex && (this._activeItemIndex = n, this._typeahead?.setCurrentSelectedItemIndex(n));
    }
    _setTypeAhead(t) {
      this._typeahead = new rb(this._items, { debounceInterval: typeof t == "number" ? t : void 0, skipPredicate: (e) => this._skipPredicateFn(e) }), this._typeaheadSubscription = this._typeahead.selectedItem.subscribe((e) => {
        this.focusItem(e);
      });
    }
    _findNextAvailableItemIndex(t) {
      for (let e = t + 1; e < this._items.length; e++) if (!this._skipPredicateFn(this._items[e])) return e;
      return t;
    }
    _findPreviousAvailableItemIndex(t) {
      for (let e = t - 1; e >= 0; e--) if (!this._skipPredicateFn(this._items[e])) return e;
      return t;
    }
    _collapseCurrentItem() {
      if (this._activeItem) if (this._isCurrentItemExpanded()) this._activeItem.collapse();
      else {
        let t = this._activeItem.getParent();
        if (!t || this._skipPredicateFn(t)) return;
        this.focusItem(t);
      }
    }
    _expandCurrentItem() {
      this._activeItem && (this._isCurrentItemExpanded() ? Bc(this._activeItem.getChildren()).pipe(On(1)).subscribe((t) => {
        let e = t.find((n) => !this._skipPredicateFn(n));
        e && this.focusItem(e);
      }) : this._activeItem.expand());
    }
    _isCurrentItemExpanded() {
      return this._activeItem ? typeof this._activeItem.isExpanded == "boolean" ? this._activeItem.isExpanded : this._activeItem.isExpanded() : false;
    }
    _isItemDisabled(t) {
      return typeof t.isDisabled == "boolean" ? t.isDisabled : t.isDisabled?.();
    }
    _expandAllItemsAtCurrentItemLevel() {
      if (!this._activeItem) return;
      let t = this._activeItem.getParent(), e;
      t ? e = Bc(t.getChildren()) : e = qt(this._items.filter((n) => n.getParent() === null)), e.pipe(On(1)).subscribe((n) => {
        for (let r of n) r.expand();
      });
    }
    _activateCurrentItem() {
      this._activeItem?.activate();
    }
  };
  function nX() {
    return (i59, t) => new yT(i59, t);
  }
  var aL = new Ee("tree-key-manager", { providedIn: "root", factory: nX });
  var db = (() => {
    class i59 {
      _platform = M(Nn);
      constructor() {
      }
      isDisabled(e) {
        return e.hasAttribute("disabled");
      }
      isVisible(e) {
        return rX(e) && getComputedStyle(e).visibility === "visible";
      }
      isTabbable(e) {
        if (!this._platform.isBrowser) return false;
        let n = iX(hX(e));
        if (n && (tL(n) === -1 || !this.isVisible(n))) return false;
        let r = e.nodeName.toLowerCase(), o = tL(e);
        return e.hasAttribute("contenteditable") ? o !== -1 : r === "iframe" || r === "object" || this._platform.WEBKIT && this._platform.IOS && !dX(e) ? false : r === "audio" ? e.hasAttribute("controls") ? o !== -1 : false : r === "video" ? o === -1 ? false : o !== null ? true : this._platform.FIREFOX || e.hasAttribute("controls") : e.tabIndex >= 0;
      }
      isFocusable(e, n) {
        return uX(e) && !this.isDisabled(e) && (n?.ignoreVisibility || this.isVisible(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function iX(i59) {
    try {
      return i59.frameElement;
    } catch {
      return null;
    }
  }
  function rX(i59) {
    return !!(i59.offsetWidth || i59.offsetHeight || typeof i59.getClientRects == "function" && i59.getClientRects().length);
  }
  function oX(i59) {
    let t = i59.nodeName.toLowerCase();
    return t === "input" || t === "select" || t === "button" || t === "textarea";
  }
  function sX(i59) {
    return lX(i59) && i59.type == "hidden";
  }
  function aX(i59) {
    return cX(i59) && i59.hasAttribute("href");
  }
  function lX(i59) {
    return i59.nodeName.toLowerCase() == "input";
  }
  function cX(i59) {
    return i59.nodeName.toLowerCase() == "a";
  }
  function lL(i59) {
    if (!i59.hasAttribute("tabindex") || i59.tabIndex === void 0) return false;
    let t = i59.getAttribute("tabindex");
    return !!(t && !isNaN(parseInt(t, 10)));
  }
  function tL(i59) {
    if (!lL(i59)) return null;
    let t = parseInt(i59.getAttribute("tabindex") || "", 10);
    return isNaN(t) ? -1 : t;
  }
  function dX(i59) {
    let t = i59.nodeName.toLowerCase(), e = t === "input" && i59.type;
    return e === "text" || e === "password" || t === "select" || t === "textarea";
  }
  function uX(i59) {
    return sX(i59) ? false : oX(i59) || aX(i59) || i59.hasAttribute("contenteditable") || lL(i59);
  }
  function hX(i59) {
    return i59.ownerDocument && i59.ownerDocument.defaultView || window;
  }
  var lb = class {
    _element;
    _checker;
    _ngZone;
    _document;
    _injector;
    _startAnchor;
    _endAnchor;
    _hasAttached = false;
    startAnchorListener = () => this.focusLastTabbableElement();
    endAnchorListener = () => this.focusFirstTabbableElement();
    get enabled() {
      return this._enabled;
    }
    set enabled(t) {
      this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor));
    }
    _enabled = true;
    constructor(t, e, n, r, o = false, s) {
      this._element = t, this._checker = e, this._ngZone = n, this._document = r, this._injector = s, o || this.attachAnchors();
    }
    destroy() {
      let t = this._startAnchor, e = this._endAnchor;
      t && (t.removeEventListener("focus", this.startAnchorListener), t.remove()), e && (e.removeEventListener("focus", this.endAnchorListener), e.remove()), this._startAnchor = this._endAnchor = null, this._hasAttached = false;
    }
    attachAnchors() {
      return this._hasAttached ? true : (this._ngZone.runOutsideAngular(() => {
        this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener));
      }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = true), this._hasAttached);
    }
    focusInitialElementWhenReady(t) {
      return new Promise((e) => {
        this._executeOnStable(() => e(this.focusInitialElement(t)));
      });
    }
    focusFirstTabbableElementWhenReady(t) {
      return new Promise((e) => {
        this._executeOnStable(() => e(this.focusFirstTabbableElement(t)));
      });
    }
    focusLastTabbableElementWhenReady(t) {
      return new Promise((e) => {
        this._executeOnStable(() => e(this.focusLastTabbableElement(t)));
      });
    }
    _getRegionBoundary(t) {
      let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`);
      return t == "start" ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element);
    }
    focusInitialElement(t) {
      let e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]");
      if (e) {
        if (!this._checker.isFocusable(e)) {
          let n = this._getFirstTabbableElement(e);
          return n?.focus(t), !!n;
        }
        return e.focus(t), true;
      }
      return this.focusFirstTabbableElement(t);
    }
    focusFirstTabbableElement(t) {
      let e = this._getRegionBoundary("start");
      return e && e.focus(t), !!e;
    }
    focusLastTabbableElement(t) {
      let e = this._getRegionBoundary("end");
      return e && e.focus(t), !!e;
    }
    hasAttached() {
      return this._hasAttached;
    }
    _getFirstTabbableElement(t) {
      if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
      let e = t.children;
      for (let n = 0; n < e.length; n++) {
        let r = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null;
        if (r) return r;
      }
      return null;
    }
    _getLastTabbableElement(t) {
      if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t;
      let e = t.children;
      for (let n = e.length - 1; n >= 0; n--) {
        let r = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null;
        if (r) return r;
      }
      return null;
    }
    _createAnchor() {
      let t = this._document.createElement("div");
      return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t;
    }
    _toggleAnchorTabIndex(t, e) {
      t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex");
    }
    toggleAnchors(t) {
      this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor));
    }
    _executeOnStable(t) {
      this._injector ? Yi(t, { injector: this._injector }) : setTimeout(t);
    }
  };
  var cL = (() => {
    class i59 {
      _checker = M(db);
      _ngZone = M(We);
      _document = M(yt);
      _injector = M(mt);
      constructor() {
        M(mi).load(Vf);
      }
      create(e, n = false) {
        return new lb(e, this._checker, this._ngZone, this._document, n, this._injector);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var bT = class extends lb {
    _focusTrapManager;
    _inertStrategy;
    get enabled() {
      return this._enabled;
    }
    set enabled(t) {
      this._enabled = t, this._enabled ? this._focusTrapManager.register(this) : this._focusTrapManager.deregister(this);
    }
    constructor(t, e, n, r, o, s, a, l) {
      super(t, e, n, r, a.defer, l), this._focusTrapManager = o, this._inertStrategy = s, this._focusTrapManager.register(this);
    }
    destroy() {
      this._focusTrapManager.deregister(this), super.destroy();
    }
    _enable() {
      this._inertStrategy.preventFocus(this), this.toggleAnchors(true);
    }
    _disable() {
      this._inertStrategy.allowFocus(this), this.toggleAnchors(false);
    }
  };
  var xT = class {
    _listener = null;
    preventFocus(t) {
      this._listener && t._document.removeEventListener("focus", this._listener, true), this._listener = (e) => this._trapFocus(t, e), t._ngZone.runOutsideAngular(() => {
        t._document.addEventListener("focus", this._listener, true);
      });
    }
    allowFocus(t) {
      this._listener && (t._document.removeEventListener("focus", this._listener, true), this._listener = null);
    }
    _trapFocus(t, e) {
      let n = e.target, r = t._element;
      n && !r.contains(n) && !n.closest?.("div.cdk-overlay-pane") && setTimeout(() => {
        t.enabled && !r.contains(t._document.activeElement) && t.focusFirstTabbableElement();
      });
    }
  };
  var pX = new Ee("FOCUS_TRAP_INERT_STRATEGY");
  var fX = (() => {
    class i59 {
      _focusTrapStack = [];
      register(e) {
        this._focusTrapStack = this._focusTrapStack.filter((r) => r !== e);
        let n = this._focusTrapStack;
        n.length && n[n.length - 1]._disable(), n.push(e), e._enable();
      }
      deregister(e) {
        e._disable();
        let n = this._focusTrapStack, r = n.indexOf(e);
        r !== -1 && (n.splice(r, 1), n.length && n[n.length - 1]._enable());
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var $u = (() => {
    class i59 {
      _checker = M(db);
      _ngZone = M(We);
      _focusTrapManager = M(fX);
      _document = M(yt);
      _inertStrategy;
      _injector = M(mt);
      constructor() {
        let e = M(pX, { optional: true });
        this._inertStrategy = e || new xT();
      }
      create(e, n = { defer: false }) {
        let r;
        return typeof n == "boolean" ? r = { defer: n } : r = n, new bT(e, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, r, this._injector);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function Gc(i59) {
    return i59.buttons === 0 || i59.detail === 0;
  }
  function Hc(i59) {
    let t = i59.touches && i59.touches[0] || i59.changedTouches && i59.changedTouches[0];
    return !!t && t.identifier === -1 && (t.radiusX == null || t.radiusX === 1) && (t.radiusY == null || t.radiusY === 1);
  }
  var mX = new Ee("cdk-input-modality-detector-options");
  var gX = { ignoreKeys: [18, 17, 224, 91, 16] };
  var dL = 650;
  var Uu = Or({ passive: true, capture: true });
  var _X = (() => {
    class i59 {
      _platform = M(Nn);
      modalityDetected;
      modalityChanged;
      get mostRecentModality() {
        return this._modality.value;
      }
      _mostRecentTarget = null;
      _modality = new hi(null);
      _options;
      _lastTouchMs = 0;
      _onKeydown = (e) => {
        this._options?.ignoreKeys?.some((n) => n === e.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = Fi(e));
      };
      _onMousedown = (e) => {
        Date.now() - this._lastTouchMs < dL || (this._modality.next(Gc(e) ? "keyboard" : "mouse"), this._mostRecentTarget = Fi(e));
      };
      _onTouchstart = (e) => {
        if (Hc(e)) {
          this._modality.next("keyboard");
          return;
        }
        this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = Fi(e);
      };
      constructor() {
        let e = M(We), n = M(yt), r = M(mX, { optional: true });
        this._options = le(le({}, gX), r), this.modalityDetected = this._modality.pipe(Ap(1)), this.modalityChanged = this.modalityDetected.pipe(qa()), this._platform.isBrowser && e.runOutsideAngular(() => {
          n.addEventListener("keydown", this._onKeydown, Uu), n.addEventListener("mousedown", this._onMousedown, Uu), n.addEventListener("touchstart", this._onTouchstart, Uu);
        });
      }
      ngOnDestroy() {
        this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Uu), document.removeEventListener("mousedown", this._onMousedown, Uu), document.removeEventListener("touchstart", this._onTouchstart, Uu));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var vX = new Ee("liveAnnouncerElement", { providedIn: "root", factory: yX });
  function yX() {
    return null;
  }
  var bX = new Ee("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
  var xX = 0;
  var ub = (() => {
    class i59 {
      _ngZone = M(We);
      _defaultOptions = M(bX, { optional: true });
      _liveElement;
      _document = M(yt);
      _previousTimeout;
      _currentPromise;
      _currentResolve;
      constructor() {
        let e = M(vX, { optional: true });
        this._liveElement = e || this._createLiveElement();
      }
      announce(e, ...n) {
        let r = this._defaultOptions, o, s;
        return n.length === 1 && typeof n[0] == "number" ? s = n[0] : [o, s] = n, this.clear(), clearTimeout(this._previousTimeout), o || (o = r && r.politeness ? r.politeness : "polite"), s == null && r && (s = r.duration), this._liveElement.setAttribute("aria-live", o), this._liveElement.id && this._exposeAnnouncerToModals(this._liveElement.id), this._ngZone.runOutsideAngular(() => (this._currentPromise || (this._currentPromise = new Promise((a) => this._currentResolve = a)), clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => {
          this._liveElement.textContent = e, typeof s == "number" && (this._previousTimeout = setTimeout(() => this.clear(), s)), this._currentResolve?.(), this._currentPromise = this._currentResolve = void 0;
        }, 100), this._currentPromise));
      }
      clear() {
        this._liveElement && (this._liveElement.textContent = "");
      }
      ngOnDestroy() {
        clearTimeout(this._previousTimeout), this._liveElement?.remove(), this._liveElement = null, this._currentResolve?.(), this._currentPromise = this._currentResolve = void 0;
      }
      _createLiveElement() {
        let e = "cdk-live-announcer-element", n = this._document.getElementsByClassName(e), r = this._document.createElement("div");
        for (let o = 0; o < n.length; o++) n[o].remove();
        return r.classList.add(e), r.classList.add("cdk-visually-hidden"), r.setAttribute("aria-atomic", "true"), r.setAttribute("aria-live", "polite"), r.id = `cdk-live-announcer-${xX++}`, this._document.body.appendChild(r), r;
      }
      _exposeAnnouncerToModals(e) {
        let n = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
        for (let r = 0; r < n.length; r++) {
          let o = n[r], s = o.getAttribute("aria-owns");
          s ? s.indexOf(e) === -1 && o.setAttribute("aria-owns", s + " " + e) : o.setAttribute("aria-owns", e);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var nb = function(i59) {
    return i59[i59.IMMEDIATE = 0] = "IMMEDIATE", i59[i59.EVENTUAL = 1] = "EVENTUAL", i59;
  }(nb || {});
  var wX = new Ee("cdk-focus-monitor-default-options");
  var tb = Or({ passive: true, capture: true });
  var so = (() => {
    class i59 {
      _ngZone = M(We);
      _platform = M(Nn);
      _inputModalityDetector = M(_X);
      _origin = null;
      _lastFocusOrigin;
      _windowFocused = false;
      _windowFocusTimeoutId;
      _originTimeoutId;
      _originFromTouchInteraction = false;
      _elementInfo = /* @__PURE__ */ new Map();
      _monitoredElementCount = 0;
      _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
      _detectionMode;
      _windowFocusListener = () => {
        this._windowFocused = true, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
      };
      _document = M(yt, { optional: true });
      _stopInputModalityDetector = new we();
      constructor() {
        let e = M(wX, { optional: true });
        this._detectionMode = e?.detectionMode || nb.IMMEDIATE;
      }
      _rootNodeFocusAndBlurListener = (e) => {
        let n = Fi(e);
        for (let r = n; r; r = r.parentElement) e.type === "focus" ? this._onFocus(e, r) : this._onBlur(e, r);
      };
      monitor(e, n = false) {
        let r = Ji(e);
        if (!this._platform.isBrowser || r.nodeType !== 1) return qt();
        let o = zu(r) || this._getDocument(), s = this._elementInfo.get(r);
        if (s) return n && (s.checkChildren = true), s.subject;
        let a = { checkChildren: n, subject: new we(), rootNode: o };
        return this._elementInfo.set(r, a), this._registerGlobalListeners(a), a.subject;
      }
      stopMonitoring(e) {
        let n = Ji(e), r = this._elementInfo.get(n);
        r && (r.subject.complete(), this._setClasses(n), this._elementInfo.delete(n), this._removeGlobalListeners(r));
      }
      focusVia(e, n, r) {
        let o = Ji(e), s = this._getDocument().activeElement;
        o === s ? this._getClosestElementsInfo(o).forEach(([a, l]) => this._originChanged(a, n, l)) : (this._setOrigin(n), typeof o.focus == "function" && o.focus(r));
      }
      ngOnDestroy() {
        this._elementInfo.forEach((e, n) => this.stopMonitoring(n));
      }
      _getDocument() {
        return this._document || document;
      }
      _getWindow() {
        return this._getDocument().defaultView || window;
      }
      _getFocusOrigin(e) {
        return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(e) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : e && this._isLastInteractionFromInputLabel(e) ? "mouse" : "program";
      }
      _shouldBeAttributedToTouch(e) {
        return this._detectionMode === nb.EVENTUAL || !!e?.contains(this._inputModalityDetector._mostRecentTarget);
      }
      _setClasses(e, n) {
        e.classList.toggle("cdk-focused", !!n), e.classList.toggle("cdk-touch-focused", n === "touch"), e.classList.toggle("cdk-keyboard-focused", n === "keyboard"), e.classList.toggle("cdk-mouse-focused", n === "mouse"), e.classList.toggle("cdk-program-focused", n === "program");
      }
      _setOrigin(e, n = false) {
        this._ngZone.runOutsideAngular(() => {
          if (this._origin = e, this._originFromTouchInteraction = e === "touch" && n, this._detectionMode === nb.IMMEDIATE) {
            clearTimeout(this._originTimeoutId);
            let r = this._originFromTouchInteraction ? dL : 1;
            this._originTimeoutId = setTimeout(() => this._origin = null, r);
          }
        });
      }
      _onFocus(e, n) {
        let r = this._elementInfo.get(n), o = Fi(e);
        !r || !r.checkChildren && n !== o || this._originChanged(n, this._getFocusOrigin(o), r);
      }
      _onBlur(e, n) {
        let r = this._elementInfo.get(n);
        !r || r.checkChildren && e.relatedTarget instanceof Node && n.contains(e.relatedTarget) || (this._setClasses(n), this._emitOrigin(r, null));
      }
      _emitOrigin(e, n) {
        e.subject.observers.length && this._ngZone.run(() => e.subject.next(n));
      }
      _registerGlobalListeners(e) {
        if (!this._platform.isBrowser) return;
        let n = e.rootNode, r = this._rootNodeFocusListenerCount.get(n) || 0;
        r || this._ngZone.runOutsideAngular(() => {
          n.addEventListener("focus", this._rootNodeFocusAndBlurListener, tb), n.addEventListener("blur", this._rootNodeFocusAndBlurListener, tb);
        }), this._rootNodeFocusListenerCount.set(n, r + 1), ++this._monitoredElementCount === 1 && (this._ngZone.runOutsideAngular(() => {
          this._getWindow().addEventListener("focus", this._windowFocusListener);
        }), this._inputModalityDetector.modalityDetected.pipe(Je(this._stopInputModalityDetector)).subscribe((o) => {
          this._setOrigin(o, true);
        }));
      }
      _removeGlobalListeners(e) {
        let n = e.rootNode;
        if (this._rootNodeFocusListenerCount.has(n)) {
          let r = this._rootNodeFocusListenerCount.get(n);
          r > 1 ? this._rootNodeFocusListenerCount.set(n, r - 1) : (n.removeEventListener("focus", this._rootNodeFocusAndBlurListener, tb), n.removeEventListener("blur", this._rootNodeFocusAndBlurListener, tb), this._rootNodeFocusListenerCount.delete(n));
        }
        --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId));
      }
      _originChanged(e, n, r) {
        this._setClasses(e, n), this._emitOrigin(r, n), this._lastFocusOrigin = n;
      }
      _getClosestElementsInfo(e) {
        let n = [];
        return this._elementInfo.forEach((r, o) => {
          (o === e || r.checkChildren && o.contains(e)) && n.push([o, r]);
        }), n;
      }
      _isLastInteractionFromInputLabel(e) {
        let { _mostRecentTarget: n, mostRecentModality: r } = this._inputModalityDetector;
        if (r !== "mouse" || !n || n === e || e.nodeName !== "INPUT" && e.nodeName !== "TEXTAREA" || e.disabled) return false;
        let o = e.labels;
        if (o) {
          for (let s = 0; s < o.length; s++) if (o[s].contains(n)) return true;
        }
        return false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Uc = function(i59) {
    return i59[i59.NONE = 0] = "NONE", i59[i59.BLACK_ON_WHITE = 1] = "BLACK_ON_WHITE", i59[i59.WHITE_ON_BLACK = 2] = "WHITE_ON_BLACK", i59;
  }(Uc || {});
  var nL = "cdk-high-contrast-black-on-white";
  var iL = "cdk-high-contrast-white-on-black";
  var gT = "cdk-high-contrast-active";
  var ST = (() => {
    class i59 {
      _platform = M(Nn);
      _hasCheckedHighContrastMode;
      _document = M(yt);
      _breakpointSubscription;
      constructor() {
        this._breakpointSubscription = M(Jy).observe("(forced-colors: active)").subscribe(() => {
          this._hasCheckedHighContrastMode && (this._hasCheckedHighContrastMode = false, this._applyBodyHighContrastModeCssClasses());
        });
      }
      getHighContrastMode() {
        if (!this._platform.isBrowser) return Uc.NONE;
        let e = this._document.createElement("div");
        e.style.backgroundColor = "rgb(1,2,3)", e.style.position = "absolute", this._document.body.appendChild(e);
        let n = this._document.defaultView || window, r = n && n.getComputedStyle ? n.getComputedStyle(e) : null, o = (r && r.backgroundColor || "").replace(/ /g, "");
        switch (e.remove(), o) {
          case "rgb(0,0,0)":
          case "rgb(45,50,54)":
          case "rgb(32,32,32)":
            return Uc.WHITE_ON_BLACK;
          case "rgb(255,255,255)":
          case "rgb(255,250,239)":
            return Uc.BLACK_ON_WHITE;
        }
        return Uc.NONE;
      }
      ngOnDestroy() {
        this._breakpointSubscription.unsubscribe();
      }
      _applyBodyHighContrastModeCssClasses() {
        if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
          let e = this._document.body.classList;
          e.remove(gT, nL, iL), this._hasCheckedHighContrastMode = true;
          let n = this.getHighContrastMode();
          n === Uc.BLACK_ON_WHITE ? e.add(gT, nL) : n === Uc.WHITE_ON_BLACK && e.add(gT, iL);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var hb = (() => {
    class i59 {
      constructor() {
        M(ST)._applyBodyHighContrastModeCssClasses();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Ky] });
    }
    return i59;
  })();
  var _T = {};
  var kn = (() => {
    class i59 {
      _appId = M(bu);
      getId(e) {
        return this._appId !== "ng" && (e += this._appId), _T.hasOwnProperty(e) || (_T[e] = 0), `${e}${_T[e]++}`;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var CX = new Ee("cdk-dir-doc", { providedIn: "root", factory: SX });
  function SX() {
    return M(yt);
  }
  var MX = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
  function EX(i59) {
    let t = i59?.toLowerCase() || "";
    return t === "auto" && typeof navigator < "u" && navigator?.language ? MX.test(navigator.language) ? "rtl" : "ltr" : t === "rtl" ? "rtl" : "ltr";
  }
  var _i = (() => {
    class i59 {
      value = "ltr";
      change = new Ue();
      constructor() {
        let e = M(CX, { optional: true });
        if (e) {
          let n = e.body ? e.body.dir : null, r = e.documentElement ? e.documentElement.dir : null;
          this.value = EX(n || r || "ltr");
        }
      }
      ngOnDestroy() {
        this.change.complete();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var hl = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  var TX = ["*", [["mat-option"], ["ng-container"]]];
  var IX = ["*", "mat-option, ng-container"];
  var DX = ["text"];
  var PX = [[["mat-icon"]], "*"];
  var RX = ["mat-icon", "*"];
  function OX(i59, t) {
    if (i59 & 1 && ae(0, "mat-pseudo-checkbox", 1), i59 & 2) {
      let e = T();
      U("disabled", e.disabled)("state", e.selected ? "checked" : "unchecked");
    }
  }
  function AX(i59, t) {
    if (i59 & 1 && ae(0, "mat-pseudo-checkbox", 3), i59 & 2) {
      let e = T();
      U("disabled", e.disabled);
    }
  }
  function NX(i59, t) {
    if (i59 & 1 && (b(0, "span", 4), D(1), x()), i59 & 2) {
      let e = T();
      C(), Oe("(", e.group.label, ")");
    }
  }
  var kX = ["mat-internal-form-field", ""];
  var LX = ["*"];
  var RT = /* @__PURE__ */ (() => {
    class i59 {
      static STANDARD_CURVE = "cubic-bezier(0.4,0.0,0.2,1)";
      static DECELERATION_CURVE = "cubic-bezier(0.0,0.0,0.2,1)";
      static ACCELERATION_CURVE = "cubic-bezier(0.4,0.0,1,1)";
      static SHARP_CURVE = "cubic-bezier(0.4,0.0,0.6,1)";
    }
    return i59;
  })();
  var Yt = (() => {
    class i59 {
      constructor() {
        M(ST)._applyBodyHighContrastModeCssClasses();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [hl, hl] });
    }
    return i59;
  })();
  var fb = class {
    _defaultMatcher;
    ngControl;
    _parentFormGroup;
    _parentForm;
    _stateChanges;
    errorState = false;
    matcher;
    constructor(t, e, n, r, o) {
      this._defaultMatcher = t, this.ngControl = e, this._parentFormGroup = n, this._parentForm = r, this._stateChanges = o;
    }
    updateErrorState() {
      let t = this.errorState, e = this._parentFormGroup || this._parentForm, n = this.matcher || this._defaultMatcher, r = this.ngControl ? this.ngControl.control : null, o = n?.isErrorState(r, e) ?? false;
      o !== t && (this.errorState = o, this._stateChanges.next());
    }
  };
  var vL = (() => {
    class i59 {
      isErrorState(e, n) {
        return !!(e && e.invalid && (e.touched || n && n.submitted));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var ts = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["structural-styles"]], decls: 0, vars: 0, template: function(n, r) {
      }, styles: ['.mat-focus-indicator{position:relative}.mat-focus-indicator::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;display:var(--mat-focus-indicator-display, none);border-width:var(--mat-focus-indicator-border-width, 3px);border-style:var(--mat-focus-indicator-border-style, solid);border-color:var(--mat-focus-indicator-border-color, transparent);border-radius:var(--mat-focus-indicator-border-radius, 4px)}.mat-focus-indicator:focus::before{content:""}@media(forced-colors: active){html{--mat-focus-indicator-display: block}}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var Po = function(i59) {
    return i59[i59.FADING_IN = 0] = "FADING_IN", i59[i59.VISIBLE = 1] = "VISIBLE", i59[i59.FADING_OUT = 2] = "FADING_OUT", i59[i59.HIDDEN = 3] = "HIDDEN", i59;
  }(Po || {});
  var IT = class {
    _renderer;
    element;
    config;
    _animationForciblyDisabledThroughCss;
    state = Po.HIDDEN;
    constructor(t, e, n, r = false) {
      this._renderer = t, this.element = e, this.config = n, this._animationForciblyDisabledThroughCss = r;
    }
    fadeOut() {
      this._renderer.fadeOutRipple(this);
    }
  };
  var uL = Or({ passive: true, capture: true });
  var DT = class {
    _events = /* @__PURE__ */ new Map();
    addHandler(t, e, n, r) {
      let o = this._events.get(e);
      if (o) {
        let s = o.get(n);
        s ? s.add(r) : o.set(n, /* @__PURE__ */ new Set([r]));
      } else this._events.set(e, /* @__PURE__ */ new Map([[n, /* @__PURE__ */ new Set([r])]])), t.runOutsideAngular(() => {
        document.addEventListener(e, this._delegateEventHandler, uL);
      });
    }
    removeHandler(t, e, n) {
      let r = this._events.get(t);
      if (!r) return;
      let o = r.get(e);
      o && (o.delete(n), o.size === 0 && r.delete(e), r.size === 0 && (this._events.delete(t), document.removeEventListener(t, this._delegateEventHandler, uL)));
    }
    _delegateEventHandler = (t) => {
      let e = Fi(t);
      e && this._events.get(t.type)?.forEach((n, r) => {
        (r === e || r.contains(e)) && n.forEach((o) => o.handleEvent(t));
      });
    };
  };
  var mb = { enterDuration: 225, exitDuration: 150 };
  var FX = 800;
  var hL = Or({ passive: true, capture: true });
  var pL = ["mousedown", "touchstart"];
  var fL = ["mouseup", "mouseleave", "touchend", "touchcancel"];
  var BX = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["ng-component"]], hostAttrs: ["mat-ripple-style-loader", ""], decls: 0, vars: 0, template: function(n, r) {
      }, styles: [".mat-ripple{overflow:hidden;position:relative}.mat-ripple:not(:empty){transform:translateZ(0)}.mat-ripple.mat-ripple-unbounded{overflow:visible}.mat-ripple-element{position:absolute;border-radius:50%;pointer-events:none;transition:opacity,transform 0ms cubic-bezier(0, 0, 0.2, 1);transform:scale3d(0, 0, 0);background-color:var(--mat-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface) 10%, transparent))}@media(forced-colors: active){.mat-ripple-element{display:none}}.cdk-drag-preview .mat-ripple-element,.cdk-drag-placeholder .mat-ripple-element{display:none}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var gb = class i19 {
    _target;
    _ngZone;
    _platform;
    _containerElement;
    _triggerElement;
    _isPointerDown = false;
    _activeRipples = /* @__PURE__ */ new Map();
    _mostRecentTransientRipple;
    _lastTouchStartEvent;
    _pointerUpEventsRegistered = false;
    _containerRect;
    static _eventManager = new DT();
    constructor(t, e, n, r, o) {
      this._target = t, this._ngZone = e, this._platform = r, r.isBrowser && (this._containerElement = Ji(n)), o && o.get(mi).load(BX);
    }
    fadeInRipple(t, e, n = {}) {
      let r = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), o = le(le({}, mb), n.animation);
      n.centered && (t = r.left + r.width / 2, e = r.top + r.height / 2);
      let s = n.radius || VX(t, e, r), a = t - r.left, l = e - r.top, c = o.enterDuration, d = document.createElement("div");
      d.classList.add("mat-ripple-element"), d.style.left = `${a - s}px`, d.style.top = `${l - s}px`, d.style.height = `${s * 2}px`, d.style.width = `${s * 2}px`, n.color != null && (d.style.backgroundColor = n.color), d.style.transitionDuration = `${c}ms`, this._containerElement.appendChild(d);
      let u = window.getComputedStyle(d), h = u.transitionProperty, p = u.transitionDuration, f = h === "none" || p === "0s" || p === "0s, 0s" || r.width === 0 && r.height === 0, m = new IT(this, d, n, f);
      d.style.transform = "scale3d(1, 1, 1)", m.state = Po.FADING_IN, n.persistent || (this._mostRecentTransientRipple = m);
      let v = null;
      return !f && (c || o.exitDuration) && this._ngZone.runOutsideAngular(() => {
        let _ = () => {
          v && (v.fallbackTimer = null), clearTimeout(y), this._finishRippleTransition(m);
        }, g = () => this._destroyRipple(m), y = setTimeout(g, c + 100);
        d.addEventListener("transitionend", _), d.addEventListener("transitioncancel", g), v = { onTransitionEnd: _, onTransitionCancel: g, fallbackTimer: y };
      }), this._activeRipples.set(m, v), (f || !c) && this._finishRippleTransition(m), m;
    }
    fadeOutRipple(t) {
      if (t.state === Po.FADING_OUT || t.state === Po.HIDDEN) return;
      let e = t.element, n = le(le({}, mb), t.config.animation);
      e.style.transitionDuration = `${n.exitDuration}ms`, e.style.opacity = "0", t.state = Po.FADING_OUT, (t._animationForciblyDisabledThroughCss || !n.exitDuration) && this._finishRippleTransition(t);
    }
    fadeOutAll() {
      this._getActiveRipples().forEach((t) => t.fadeOut());
    }
    fadeOutAllNonPersistent() {
      this._getActiveRipples().forEach((t) => {
        t.config.persistent || t.fadeOut();
      });
    }
    setupTriggerEvents(t) {
      let e = Ji(t);
      !this._platform.isBrowser || !e || e === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = e, pL.forEach((n) => {
        i19._eventManager.addHandler(this._ngZone, n, e, this);
      }));
    }
    handleEvent(t) {
      t.type === "mousedown" ? this._onMousedown(t) : t.type === "touchstart" ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._ngZone.runOutsideAngular(() => {
        fL.forEach((e) => {
          this._triggerElement.addEventListener(e, this, hL);
        });
      }), this._pointerUpEventsRegistered = true);
    }
    _finishRippleTransition(t) {
      t.state === Po.FADING_IN ? this._startFadeOutTransition(t) : t.state === Po.FADING_OUT && this._destroyRipple(t);
    }
    _startFadeOutTransition(t) {
      let e = t === this._mostRecentTransientRipple, { persistent: n } = t.config;
      t.state = Po.VISIBLE, !n && (!e || !this._isPointerDown) && t.fadeOut();
    }
    _destroyRipple(t) {
      let e = this._activeRipples.get(t) ?? null;
      this._activeRipples.delete(t), this._activeRipples.size || (this._containerRect = null), t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), t.state = Po.HIDDEN, e !== null && (t.element.removeEventListener("transitionend", e.onTransitionEnd), t.element.removeEventListener("transitioncancel", e.onTransitionCancel), e.fallbackTimer !== null && clearTimeout(e.fallbackTimer)), t.element.remove();
    }
    _onMousedown(t) {
      let e = Gc(t), n = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + FX;
      !this._target.rippleDisabled && !e && !n && (this._isPointerDown = true, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig));
    }
    _onTouchStart(t) {
      if (!this._target.rippleDisabled && !Hc(t)) {
        this._lastTouchStartEvent = Date.now(), this._isPointerDown = true;
        let e = t.changedTouches;
        if (e) for (let n = 0; n < e.length; n++) this.fadeInRipple(e[n].clientX, e[n].clientY, this._target.rippleConfig);
      }
    }
    _onPointerUp() {
      this._isPointerDown && (this._isPointerDown = false, this._getActiveRipples().forEach((t) => {
        let e = t.state === Po.VISIBLE || t.config.terminateOnPointerUp && t.state === Po.FADING_IN;
        !t.config.persistent && e && t.fadeOut();
      }));
    }
    _getActiveRipples() {
      return Array.from(this._activeRipples.keys());
    }
    _removeTriggerEvents() {
      let t = this._triggerElement;
      t && (pL.forEach((e) => i19._eventManager.removeHandler(e, t, this)), this._pointerUpEventsRegistered && (fL.forEach((e) => t.removeEventListener(e, this, hL)), this._pointerUpEventsRegistered = false));
    }
  };
  function VX(i59, t, e) {
    let n = Math.max(Math.abs(i59 - e.left), Math.abs(i59 - e.right)), r = Math.max(Math.abs(t - e.top), Math.abs(t - e.bottom));
    return Math.sqrt(n * n + r * r);
  }
  var yL = new Ee("mat-ripple-global-options");
  var ba = (() => {
    class i59 {
      _elementRef = M(He);
      _animationMode = M(An, { optional: true });
      color;
      unbounded;
      centered;
      radius = 0;
      animation;
      get disabled() {
        return this._disabled;
      }
      set disabled(e) {
        e && this.fadeOutAllNonPersistent(), this._disabled = e, this._setupTriggerEventsIfEnabled();
      }
      _disabled = false;
      get trigger() {
        return this._trigger || this._elementRef.nativeElement;
      }
      set trigger(e) {
        this._trigger = e, this._setupTriggerEventsIfEnabled();
      }
      _trigger;
      _rippleRenderer;
      _globalOptions;
      _isInitialized = false;
      constructor() {
        let e = M(We), n = M(Nn), r = M(yL, { optional: true }), o = M(mt);
        this._globalOptions = r || {}, this._rippleRenderer = new gb(this, e, this._elementRef, n, o);
      }
      ngOnInit() {
        this._isInitialized = true, this._setupTriggerEventsIfEnabled();
      }
      ngOnDestroy() {
        this._rippleRenderer._removeTriggerEvents();
      }
      fadeOutAll() {
        this._rippleRenderer.fadeOutAll();
      }
      fadeOutAllNonPersistent() {
        this._rippleRenderer.fadeOutAllNonPersistent();
      }
      get rippleConfig() {
        return { centered: this.centered, radius: this.radius, color: this.color, animation: le(le(le({}, this._globalOptions.animation), this._animationMode === "NoopAnimations" ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp };
      }
      get rippleDisabled() {
        return this.disabled || !!this._globalOptions.disabled;
      }
      _setupTriggerEventsIfEnabled() {
        !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger);
      }
      launch(e, n = 0, r) {
        return typeof e == "number" ? this._rippleRenderer.fadeInRipple(e, n, le(le({}, this.rippleConfig), r)) : this._rippleRenderer.fadeInRipple(0, 0, le(le({}, this.rippleConfig), e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("mat-ripple-unbounded", r.unbounded);
      }, inputs: { color: [0, "matRippleColor", "color"], unbounded: [0, "matRippleUnbounded", "unbounded"], centered: [0, "matRippleCentered", "centered"], radius: [0, "matRippleRadius", "radius"], animation: [0, "matRippleAnimation", "animation"], disabled: [0, "matRippleDisabled", "disabled"], trigger: [0, "matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] });
    }
    return i59;
  })();
  var $c = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt, Yt] });
    }
    return i59;
  })();
  var zX = (() => {
    class i59 {
      _animationMode = M(An, { optional: true });
      state = "unchecked";
      disabled = false;
      appearance = "full";
      constructor() {
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 12, hostBindings: function(n, r) {
        n & 2 && ye("mat-pseudo-checkbox-indeterminate", r.state === "indeterminate")("mat-pseudo-checkbox-checked", r.state === "checked")("mat-pseudo-checkbox-disabled", r.disabled)("mat-pseudo-checkbox-minimal", r.appearance === "minimal")("mat-pseudo-checkbox-full", r.appearance === "full")("_mat-animation-noopable", r._animationMode === "NoopAnimations");
      }, inputs: { state: "state", disabled: "disabled", appearance: "appearance" }, decls: 0, vars: 0, template: function(n, r) {
      }, styles: ['.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after,.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{color:var(--mat-minimal-pseudo-checkbox-selected-checkmark-color, var(--mat-sys-primary))}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled::after,.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled::after{color:var(--mat-minimal-pseudo-checkbox-disabled-selected-checkmark-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full{border-color:var(--mat-full-pseudo-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));border-width:2px;border-style:solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-disabled{border-color:var(--mat-full-pseudo-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{background-color:var(--mat-full-pseudo-checkbox-selected-icon-color, var(--mat-sys-primary));border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{color:var(--mat-full-pseudo-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled{background-color:var(--mat-full-pseudo-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked.mat-pseudo-checkbox-disabled::after,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate.mat-pseudo-checkbox-disabled::after{color:var(--mat-full-pseudo-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var UX = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt] });
    }
    return i59;
  })();
  var _b = new Ee("MAT_OPTION_PARENT_COMPONENT");
  var vb = new Ee("MatOptgroup");
  var bL = (() => {
    class i59 {
      label;
      disabled = false;
      _labelId = M(kn).getId("mat-optgroup-label-");
      _inert;
      constructor() {
        let e = M(_b, { optional: true });
        this._inert = e?.inertGroups ?? false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-optgroup"]], hostAttrs: [1, "mat-mdc-optgroup"], hostVars: 3, hostBindings: function(n, r) {
        n & 2 && Ke("role", r._inert ? null : "group")("aria-disabled", r._inert ? null : r.disabled.toString())("aria-labelledby", r._inert ? null : r._labelId);
      }, inputs: { label: "label", disabled: [2, "disabled", "disabled", tt] }, exportAs: ["matOptgroup"], features: [Bt([{ provide: vb, useExisting: i59 }]), on], ngContentSelectors: IX, decls: 5, vars: 4, consts: [["role", "presentation", 1, "mat-mdc-optgroup-label", 3, "id"], [1, "mdc-list-item__primary-text"]], template: function(n, r) {
        n & 1 && (Tn(TX), b(0, "span", 0)(1, "span", 1), D(2), zt(3), x()(), zt(4, 1)), n & 2 && (ye("mdc-list-item--disabled", r.disabled), U("id", r._labelId), C(2), Oe("", r.label, " "));
      }, styles: [".mat-mdc-optgroup{color:var(--mat-optgroup-label-text-color, var(--mat-sys-on-surface-variant));font-family:var(--mat-optgroup-label-text-font, var(--mat-sys-title-small-font));line-height:var(--mat-optgroup-label-text-line-height, var(--mat-sys-title-small-line-height));font-size:var(--mat-optgroup-label-text-size, var(--mat-sys-title-small-size));letter-spacing:var(--mat-optgroup-label-text-tracking, var(--mat-sys-title-small-tracking));font-weight:var(--mat-optgroup-label-text-weight, var(--mat-sys-title-small-weight))}.mat-mdc-optgroup-label{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;outline:none}.mat-mdc-optgroup-label.mdc-list-item--disabled{opacity:.38}.mat-mdc-optgroup-label .mdc-list-item__primary-text{font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;white-space:normal;color:inherit}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var PT = class {
    source;
    isUserInput;
    constructor(t, e = false) {
      this.source = t, this.isUserInput = e;
    }
  };
  var yb = (() => {
    class i59 {
      _element = M(He);
      _changeDetectorRef = M(Ge);
      _parent = M(_b, { optional: true });
      group = M(vb, { optional: true });
      _signalDisableRipple = false;
      _selected = false;
      _active = false;
      _disabled = false;
      _mostRecentViewValue = "";
      get multiple() {
        return this._parent && this._parent.multiple;
      }
      get selected() {
        return this._selected;
      }
      value;
      id = M(kn).getId("mat-option-");
      get disabled() {
        return this.group && this.group.disabled || this._disabled;
      }
      set disabled(e) {
        this._disabled = e;
      }
      get disableRipple() {
        return this._signalDisableRipple ? this._parent.disableRipple() : !!this._parent?.disableRipple;
      }
      get hideSingleSelectionIndicator() {
        return !!(this._parent && this._parent.hideSingleSelectionIndicator);
      }
      onSelectionChange = new Ue();
      _text;
      _stateChanges = new we();
      constructor() {
        let e = M(mi);
        e.load(ts), e.load(Vf), this._signalDisableRipple = !!this._parent && Jp(this._parent.disableRipple);
      }
      get active() {
        return this._active;
      }
      get viewValue() {
        return (this._text?.nativeElement.textContent || "").trim();
      }
      select(e = true) {
        this._selected || (this._selected = true, this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent());
      }
      deselect(e = true) {
        this._selected && (this._selected = false, this._changeDetectorRef.markForCheck(), e && this._emitSelectionChangeEvent());
      }
      focus(e, n) {
        let r = this._getHostElement();
        typeof r.focus == "function" && r.focus(n);
      }
      setActiveStyles() {
        this._active || (this._active = true, this._changeDetectorRef.markForCheck());
      }
      setInactiveStyles() {
        this._active && (this._active = false, this._changeDetectorRef.markForCheck());
      }
      getLabel() {
        return this.viewValue;
      }
      _handleKeydown(e) {
        (e.keyCode === 13 || e.keyCode === 32) && !Ki(e) && (this._selectViaInteraction(), e.preventDefault());
      }
      _selectViaInteraction() {
        this.disabled || (this._selected = this.multiple ? !this._selected : true, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(true));
      }
      _getTabIndex() {
        return this.disabled ? "-1" : "0";
      }
      _getHostElement() {
        return this._element.nativeElement;
      }
      ngAfterViewChecked() {
        if (this._selected) {
          let e = this.viewValue;
          e !== this._mostRecentViewValue && (this._mostRecentViewValue && this._stateChanges.next(), this._mostRecentViewValue = e);
        }
      }
      ngOnDestroy() {
        this._stateChanges.complete();
      }
      _emitSelectionChangeEvent(e = false) {
        this.onSelectionChange.emit(new PT(this, e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-option"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(DX, 7), n & 2) {
          let o;
          Ie(o = De()) && (r._text = o.first);
        }
      }, hostAttrs: ["role", "option", 1, "mat-mdc-option", "mdc-list-item"], hostVars: 11, hostBindings: function(n, r) {
        n & 1 && Z("click", function() {
          return r._selectViaInteraction();
        })("keydown", function(s) {
          return r._handleKeydown(s);
        }), n & 2 && (gr("id", r.id), Ke("aria-selected", r.selected)("aria-disabled", r.disabled.toString()), ye("mdc-list-item--selected", r.selected)("mat-mdc-option-multiple", r.multiple)("mat-mdc-option-active", r.active)("mdc-list-item--disabled", r.disabled));
      }, inputs: { value: "value", id: "id", disabled: [2, "disabled", "disabled", tt] }, outputs: { onSelectionChange: "onSelectionChange" }, exportAs: ["matOption"], features: [on], ngContentSelectors: RX, decls: 8, vars: 5, consts: [["text", ""], ["aria-hidden", "true", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled", "state"], [1, "mdc-list-item__primary-text"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled"], [1, "cdk-visually-hidden"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-mdc-option-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"]], template: function(n, r) {
        n & 1 && (Tn(PX), X(0, OX, 1, 2, "mat-pseudo-checkbox", 1), zt(1), b(2, "span", 2, 0), zt(4, 1), x(), X(5, AX, 1, 1, "mat-pseudo-checkbox", 3)(6, NX, 2, 1, "span", 4), ae(7, "div", 5)), n & 2 && (he(r.multiple ? 0 : -1), C(5), he(!r.multiple && r.selected && !r.hideSingleSelectionIndicator ? 5 : -1), C(), he(r.group && r.group._inert ? 6 : -1), C(), U("matRippleTrigger", r._getHostElement())("matRippleDisabled", r.disabled || r.disableRipple));
      }, dependencies: [zX, ba], styles: ['.mat-mdc-option{-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;min-height:48px;padding:0 16px;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-option-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-option-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-option-label-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-option-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-option-label-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent));outline:0}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color, var(--mat-sys-secondary-container))}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option .mat-pseudo-checkbox{--mat-minimal-pseudo-checkbox-selected-checkmark-color: var(--mat-option-selected-state-label-text-color, var(--mat-sys-on-secondary-container))}.mat-mdc-option.mdc-list-item{align-items:center;background:rgba(0,0,0,0)}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}@media(forced-colors: active){.mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .mat-mdc-option.mdc-list-item--selected:not(:has(.mat-mdc-option-pseudo-checkbox))::after{right:auto;left:16px}}.mat-mdc-option-multiple{--mdc-list-list-item-selected-container-color:var(--mdc-list-list-item-container-color, transparent)}.mat-mdc-option-active .mat-focus-indicator::before{content:""}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  function xL(i59, t, e) {
    if (e.length) {
      let n = t.toArray(), r = e.toArray(), o = 0;
      for (let s = 0; s < i59 + 1; s++) n[s].group && n[s].group === r[o] && o++;
      return o;
    }
    return 0;
  }
  function wL(i59, t, e, n) {
    return i59 < e ? i59 : i59 + t > e + n ? Math.max(0, i59 - n + t) : e;
  }
  var OT = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [$c, Yt, UX] });
    }
    return i59;
  })();
  var mL = { capture: true };
  var gL = ["focus", "mousedown", "mouseenter", "touchstart"];
  var ET = "mat-ripple-loader-uninitialized";
  var TT = "mat-ripple-loader-class-name";
  var _L = "mat-ripple-loader-centered";
  var pb = "mat-ripple-loader-disabled";
  var CL = (() => {
    class i59 {
      _document = M(yt, { optional: true });
      _animationMode = M(An, { optional: true });
      _globalRippleOptions = M(yL, { optional: true });
      _platform = M(Nn);
      _ngZone = M(We);
      _injector = M(mt);
      _hosts = /* @__PURE__ */ new Map();
      constructor() {
        this._ngZone.runOutsideAngular(() => {
          for (let e of gL) this._document?.addEventListener(e, this._onInteraction, mL);
        });
      }
      ngOnDestroy() {
        let e = this._hosts.keys();
        for (let n of e) this.destroyRipple(n);
        for (let n of gL) this._document?.removeEventListener(n, this._onInteraction, mL);
      }
      configureRipple(e, n) {
        e.setAttribute(ET, this._globalRippleOptions?.namespace ?? ""), (n.className || !e.hasAttribute(TT)) && e.setAttribute(TT, n.className || ""), n.centered && e.setAttribute(_L, ""), n.disabled && e.setAttribute(pb, "");
      }
      setDisabled(e, n) {
        let r = this._hosts.get(e);
        r ? (r.target.rippleDisabled = n, !n && !r.hasSetUpEvents && (r.hasSetUpEvents = true, r.renderer.setupTriggerEvents(e))) : n ? e.setAttribute(pb, "") : e.removeAttribute(pb);
      }
      _onInteraction = (e) => {
        let n = Fi(e);
        if (n instanceof HTMLElement) {
          let r = n.closest(`[${ET}="${this._globalRippleOptions?.namespace ?? ""}"]`);
          r && this._createRipple(r);
        }
      };
      _createRipple(e) {
        if (!this._document || this._hosts.has(e)) return;
        e.querySelector(".mat-ripple")?.remove();
        let n = this._document.createElement("span");
        n.classList.add("mat-ripple", e.getAttribute(TT)), e.append(n);
        let r = this._animationMode === "NoopAnimations", o = this._globalRippleOptions, s = r ? 0 : o?.animation?.enterDuration ?? mb.enterDuration, a = r ? 0 : o?.animation?.exitDuration ?? mb.exitDuration, l = { rippleDisabled: r || o?.disabled || e.hasAttribute(pb), rippleConfig: { centered: e.hasAttribute(_L), terminateOnPointerUp: o?.terminateOnPointerUp, animation: { enterDuration: s, exitDuration: a } } }, c = new gb(l, this._ngZone, n, this._platform, this._injector), d = !l.rippleDisabled;
        d && c.setupTriggerEvents(e), this._hosts.set(e, { target: l, renderer: c, hasSetUpEvents: d }), e.removeAttribute(ET);
      }
      destroyRipple(e) {
        let n = this._hosts.get(e);
        n && (n.renderer._removeTriggerEvents(), this._hosts.delete(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var qu = (() => {
    class i59 {
      labelPosition;
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["div", "mat-internal-form-field", ""]], hostAttrs: [1, "mdc-form-field", "mat-internal-form-field"], hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("mdc-form-field--align-end", r.labelPosition === "before");
      }, inputs: { labelPosition: "labelPosition" }, attrs: kX, ngContentSelectors: LX, decls: 1, vars: 0, template: function(n, r) {
        n & 1 && (Tn(), zt(0));
      }, styles: [".mat-internal-form-field{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:inline-flex;align-items:center;vertical-align:middle}.mat-internal-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mat-internal-form-field>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end .mdc-form-field--align-end label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var HX = ["mat-button", ""];
  var jX = [[["", 8, "material-icons", 3, "iconPositionEnd", ""], ["mat-icon", 3, "iconPositionEnd", ""], ["", "matButtonIcon", "", 3, "iconPositionEnd", ""]], "*", [["", "iconPositionEnd", "", 8, "material-icons"], ["mat-icon", "iconPositionEnd", ""], ["", "matButtonIcon", "", "iconPositionEnd", ""]]];
  var WX = [".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])", "*", ".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"];
  var $X = "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-icon-button.mat-mdc-icon-button{outline:solid 1px}}";
  var qX = ["mat-icon-button", ""];
  var YX = ["*"];
  var XX = new Ee("MAT_BUTTON_CONFIG");
  var ZX = [{ attribute: "mat-button", mdcClasses: ["mdc-button", "mat-mdc-button"] }, { attribute: "mat-flat-button", mdcClasses: ["mdc-button", "mdc-button--unelevated", "mat-mdc-unelevated-button"] }, { attribute: "mat-raised-button", mdcClasses: ["mdc-button", "mdc-button--raised", "mat-mdc-raised-button"] }, { attribute: "mat-stroked-button", mdcClasses: ["mdc-button", "mdc-button--outlined", "mat-mdc-outlined-button"] }, { attribute: "mat-fab", mdcClasses: ["mdc-fab", "mat-mdc-fab-base", "mat-mdc-fab"] }, { attribute: "mat-mini-fab", mdcClasses: ["mdc-fab", "mat-mdc-fab-base", "mdc-fab--mini", "mat-mdc-mini-fab"] }, { attribute: "mat-icon-button", mdcClasses: ["mdc-icon-button", "mat-mdc-icon-button"] }];
  var SL = (() => {
    class i59 {
      _elementRef = M(He);
      _ngZone = M(We);
      _animationMode = M(An, { optional: true });
      _focusMonitor = M(so);
      _rippleLoader = M(CL);
      _isFab = false;
      color;
      get disableRipple() {
        return this._disableRipple;
      }
      set disableRipple(e) {
        this._disableRipple = e, this._updateRippleDisabled();
      }
      _disableRipple = false;
      get disabled() {
        return this._disabled;
      }
      set disabled(e) {
        this._disabled = e, this._updateRippleDisabled();
      }
      _disabled = false;
      ariaDisabled;
      disabledInteractive;
      constructor() {
        M(mi).load(ts);
        let e = M(XX, { optional: true }), n = this._elementRef.nativeElement, r = n.classList;
        this.disabledInteractive = e?.disabledInteractive ?? false, this.color = e?.color ?? null, this._rippleLoader?.configureRipple(n, { className: "mat-mdc-button-ripple" });
        for (let { attribute: o, mdcClasses: s } of ZX) n.hasAttribute(o) && r.add(...s);
      }
      ngAfterViewInit() {
        this._focusMonitor.monitor(this._elementRef, true);
      }
      ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef), this._rippleLoader?.destroyRipple(this._elementRef.nativeElement);
      }
      focus(e = "program", n) {
        e ? this._focusMonitor.focusVia(this._elementRef.nativeElement, e, n) : this._elementRef.nativeElement.focus(n);
      }
      _getAriaDisabled() {
        return this.ariaDisabled != null ? this.ariaDisabled : this.disabled && this.disabledInteractive ? true : null;
      }
      _getDisabledAttribute() {
        return this.disabledInteractive || !this.disabled ? null : true;
      }
      _updateRippleDisabled() {
        this._rippleLoader?.setDisabled(this._elementRef.nativeElement, this.disableRipple || this.disabled);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, inputs: { color: "color", disableRipple: [2, "disableRipple", "disableRipple", tt], disabled: [2, "disabled", "disabled", tt], ariaDisabled: [2, "aria-disabled", "ariaDisabled", tt], disabledInteractive: [2, "disabledInteractive", "disabledInteractive", tt] }, features: [on] });
    }
    return i59;
  })();
  var vr = (() => {
    class i59 extends SL {
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275cmp = xe({ type: i59, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-flat-button", ""], ["button", "mat-stroked-button", ""]], hostVars: 14, hostBindings: function(n, r) {
        n & 2 && (Ke("disabled", r._getDisabledAttribute())("aria-disabled", r._getAriaDisabled()), io(r.color ? "mat-" + r.color : ""), ye("mat-mdc-button-disabled", r.disabled)("mat-mdc-button-disabled-interactive", r.disabledInteractive)("_mat-animation-noopable", r._animationMode === "NoopAnimations")("mat-unthemed", !r.color)("mat-mdc-button-base", true));
      }, exportAs: ["matButton"], features: [Zt], attrs: HX, ngContentSelectors: WX, decls: 7, vars: 4, consts: [[1, "mat-mdc-button-persistent-ripple"], [1, "mdc-button__label"], [1, "mat-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function(n, r) {
        n & 1 && (Tn(jX), ae(0, "span", 0), zt(1), b(2, "span", 1), zt(3, 1), x(), zt(4, 2), ae(5, "span", 2)(6, "span", 3)), n & 2 && ye("mdc-button__ripple", !r._isFab)("mdc-fab__ripple", r._isFab);
      }, styles: ['.mat-mdc-button-base{text-decoration:none}.mdc-button{-webkit-user-select:none;user-select:none;position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0);padding:0 8px}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__label{position:relative}.mat-mdc-button{padding:0 var(--mat-text-button-horizontal-padding, 12px);height:var(--mdc-text-button-container-height, 40px);font-family:var(--mdc-text-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-text-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-text-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-text-button-label-text-transform);font-weight:var(--mdc-text-button-label-text-weight, var(--mat-sys-label-large-weight))}.mat-mdc-button,.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, var(--mat-sys-primary))}.mat-mdc-button[disabled],.mat-mdc-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-text-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-button:has(.material-icons,mat-icon,[matButtonIcon]){padding:0 var(--mat-text-button-with-icon-horizontal-padding, 16px)}.mat-mdc-button>.mat-icon{margin-right:var(--mat-text-button-icon-spacing, 8px);margin-left:var(--mat-text-button-icon-offset, -4px)}[dir=rtl] .mat-mdc-button>.mat-icon{margin-right:var(--mat-text-button-icon-offset, -4px);margin-left:var(--mat-text-button-icon-spacing, 8px)}.mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-text-button-icon-offset, -4px);margin-left:var(--mat-text-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon{margin-right:var(--mat-text-button-icon-spacing, 8px);margin-left:var(--mat-text-button-icon-offset, -4px)}.mat-mdc-button .mat-ripple-element{background-color:var(--mat-text-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-text-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-text-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-text-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-text-button-touch-target-display, block)}.mat-mdc-unelevated-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mdc-filled-button-container-height, 40px);font-family:var(--mdc-filled-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-filled-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-filled-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-filled-button-label-text-transform);font-weight:var(--mdc-filled-button-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-filled-button-horizontal-padding, 24px)}.mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-filled-button-icon-spacing, 8px);margin-left:var(--mat-filled-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon{margin-right:var(--mat-filled-button-icon-offset, -8px);margin-left:var(--mat-filled-button-icon-spacing, 8px)}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-filled-button-icon-offset, -8px);margin-left:var(--mat-filled-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon{margin-right:var(--mat-filled-button-icon-spacing, 8px);margin-left:var(--mat-filled-button-icon-offset, -8px)}.mat-mdc-unelevated-button .mat-ripple-element{background-color:var(--mat-filled-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-filled-button-state-layer-color, var(--mat-sys-on-primary))}.mat-mdc-unelevated-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-filled-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-unelevated-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-unelevated-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-unelevated-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-filled-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-unelevated-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-filled-button-touch-target-display, block)}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, var(--mat-sys-on-primary));background-color:var(--mdc-filled-button-container-color, var(--mat-sys-primary))}.mat-mdc-unelevated-button,.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-unelevated-button[disabled],.mat-mdc-unelevated-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-filled-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mdc-filled-button-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-unelevated-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-raised-button{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);box-shadow:var(--mdc-protected-button-container-elevation-shadow, var(--mat-sys-level1));height:var(--mdc-protected-button-container-height, 40px);font-family:var(--mdc-protected-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-protected-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-protected-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-protected-button-label-text-transform);font-weight:var(--mdc-protected-button-label-text-weight, var(--mat-sys-label-large-weight));padding:0 var(--mat-protected-button-horizontal-padding, 24px)}.mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-protected-button-icon-spacing, 8px);margin-left:var(--mat-protected-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-raised-button>.mat-icon{margin-right:var(--mat-protected-button-icon-offset, -8px);margin-left:var(--mat-protected-button-icon-spacing, 8px)}.mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-protected-button-icon-offset, -8px);margin-left:var(--mat-protected-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon{margin-right:var(--mat-protected-button-icon-spacing, 8px);margin-left:var(--mat-protected-button-icon-offset, -8px)}.mat-mdc-raised-button .mat-ripple-element{background-color:var(--mat-protected-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-protected-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-raised-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-protected-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-raised-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-raised-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-raised-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-protected-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-raised-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-protected-button-touch-target-display, block)}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, var(--mat-sys-primary));background-color:var(--mdc-protected-button-container-color, var(--mat-sys-surface))}.mat-mdc-raised-button,.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mat-sys-corner-full))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation-shadow, var(--mat-sys-level2))}.mat-mdc-raised-button:focus{box-shadow:var(--mdc-protected-button-focus-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button:active,.mat-mdc-raised-button:focus:active{box-shadow:var(--mdc-protected-button-pressed-container-elevation-shadow, var(--mat-sys-level1))}.mat-mdc-raised-button[disabled],.mat-mdc-raised-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-protected-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));background-color:var(--mdc-protected-button-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-raised-button[disabled].mat-mdc-button-disabled,.mat-mdc-raised-button.mat-mdc-button-disabled.mat-mdc-button-disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation-shadow, var(--mat-sys-level0))}.mat-mdc-raised-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1);height:var(--mdc-outlined-button-container-height, 40px);font-family:var(--mdc-outlined-button-label-text-font, var(--mat-sys-label-large-font));font-size:var(--mdc-outlined-button-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mdc-outlined-button-label-text-tracking, var(--mat-sys-label-large-tracking));text-transform:var(--mdc-outlined-button-label-text-transform);font-weight:var(--mdc-outlined-button-label-text-weight, var(--mat-sys-label-large-weight));border-radius:var(--mdc-outlined-button-container-shape, var(--mat-sys-corner-full));border-width:var(--mdc-outlined-button-outline-width, 1px);padding:0 var(--mat-outlined-button-horizontal-padding, 24px)}.mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-outlined-button-icon-spacing, 8px);margin-left:var(--mat-outlined-button-icon-offset, -8px)}[dir=rtl] .mat-mdc-outlined-button>.mat-icon{margin-right:var(--mat-outlined-button-icon-offset, -8px);margin-left:var(--mat-outlined-button-icon-spacing, 8px)}.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-outlined-button-icon-offset, -8px);margin-left:var(--mat-outlined-button-icon-spacing, 8px)}[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-right:var(--mat-outlined-button-icon-spacing, 8px);margin-left:var(--mat-outlined-button-icon-offset, -8px)}.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-outlined-button-ripple-color, color-mix(in srgb, var(--mat-sys-primary) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-outlined-button-state-layer-color, var(--mat-sys-primary))}.mat-mdc-outlined-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-outlined-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-outlined-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-outlined-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-outlined-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-outlined-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%);display:var(--mat-outlined-button-touch-target-display, block)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, var(--mat-sys-primary));border-color:var(--mdc-outlined-button-outline-color, var(--mat-sys-outline))}.mat-mdc-outlined-button[disabled],.mat-mdc-outlined-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-outlined-button-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:var(--mdc-outlined-button-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mat-mdc-outlined-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-outlined-button .mdc-button__ripple{border-width:var(--mdc-outlined-button-outline-width, 1px);border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-button .mdc-button__label,.mat-mdc-button .mat-icon,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-unelevated-button .mat-icon,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-raised-button .mat-icon,.mat-mdc-outlined-button .mdc-button__label,.mat-mdc-outlined-button .mat-icon{z-index:1;position:relative}.mat-mdc-button .mat-focus-indicator,.mat-mdc-unelevated-button .mat-focus-indicator,.mat-mdc-raised-button .mat-focus-indicator,.mat-mdc-outlined-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus>.mat-focus-indicator::before,.mat-mdc-unelevated-button:focus>.mat-focus-indicator::before,.mat-mdc-raised-button:focus>.mat-focus-indicator::before,.mat-mdc-outlined-button:focus>.mat-focus-indicator::before{content:""}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px}.mat-mdc-unelevated-button .mat-focus-indicator::before,.mat-mdc-raised-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 2px)*-1)}.mat-mdc-outlined-button .mat-focus-indicator::before{margin:calc(calc(var(--mat-focus-indicator-border-width, 3px) + 3px)*-1)}', "@media(forced-colors: active){.mat-mdc-button:not(.mdc-button--outlined),.mat-mdc-unelevated-button:not(.mdc-button--outlined),.mat-mdc-raised-button:not(.mdc-button--outlined),.mat-mdc-outlined-button:not(.mdc-button--outlined),.mat-mdc-icon-button.mat-mdc-icon-button{outline:solid 1px}}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var pl = (() => {
    class i59 extends SL {
      constructor() {
        super(), this._rippleLoader.configureRipple(this._elementRef.nativeElement, { centered: true });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["button", "mat-icon-button", ""]], hostVars: 14, hostBindings: function(n, r) {
        n & 2 && (Ke("disabled", r._getDisabledAttribute())("aria-disabled", r._getAriaDisabled()), io(r.color ? "mat-" + r.color : ""), ye("mat-mdc-button-disabled", r.disabled)("mat-mdc-button-disabled-interactive", r.disabledInteractive)("_mat-animation-noopable", r._animationMode === "NoopAnimations")("mat-unthemed", !r.color)("mat-mdc-button-base", true));
      }, exportAs: ["matButton"], features: [Zt], attrs: qX, ngContentSelectors: YX, decls: 4, vars: 0, consts: [[1, "mat-mdc-button-persistent-ripple", "mdc-icon-button__ripple"], [1, "mat-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function(n, r) {
        n & 1 && (Tn(), ae(0, "span", 0), zt(1), ae(2, "span", 1)(3, "span", 2));
      }, styles: ['.mat-mdc-icon-button{-webkit-user-select:none;user-select:none;display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;z-index:0;overflow:visible;border-radius:50%;flex-shrink:0;text-align:center;width:var(--mdc-icon-button-state-layer-size, 40px);height:var(--mdc-icon-button-state-layer-size, 40px);padding:calc(calc(var(--mdc-icon-button-state-layer-size, 40px) - var(--mdc-icon-button-icon-size, 24px)) / 2);font-size:var(--mdc-icon-button-icon-size, 24px);color:var(--mdc-icon-button-icon-color, var(--mat-sys-on-surface-variant));-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0}.mat-mdc-icon-button .mdc-button__label,.mat-mdc-icon-button .mat-icon{z-index:1;position:relative}.mat-mdc-icon-button .mat-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus>.mat-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-icon-button-ripple-color, color-mix(in srgb, var(--mat-sys-on-surface-variant) calc(var(--mat-sys-pressed-state-layer-opacity) * 100%), transparent))}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button.mat-mdc-button-disabled .mat-mdc-button-persistent-ripple::before{background-color:var(--mat-icon-button-disabled-state-layer-color, var(--mat-sys-on-surface-variant))}.mat-mdc-icon-button:hover>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-icon-button.cdk-program-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.cdk-keyboard-focused>.mat-mdc-button-persistent-ripple::before,.mat-mdc-icon-button.mat-mdc-button-disabled-interactive:focus>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity))}.mat-mdc-icon-button:active>.mat-mdc-button-persistent-ripple::before{opacity:var(--mat-icon-button-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity))}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%);display:var(--mat-icon-button-touch-target-display, block)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button[disabled],.mat-mdc-icon-button.mat-mdc-button-disabled{cursor:default;pointer-events:none;color:var(--mdc-icon-button-disabled-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-icon-button.mat-mdc-button-disabled-interactive{pointer-events:auto}.mat-mdc-icon-button img,.mat-mdc-icon-button svg{width:var(--mdc-icon-button-icon-size, 24px);height:var(--mdc-icon-button-icon-size, 24px);vertical-align:baseline}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button[hidden]{display:none}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}', $X], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var Hn = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt, $c, Yt] });
    }
    return i59;
  })();
  function Rs(i59, t) {
    return i59 < t ? -1 : i59 > t ? 1 : i59 >= t ? 0 : NaN;
  }
  function bb(i59) {
    return i59.length === 1 && (i59 = QX(i59)), { left: function(t, e, n, r) {
      for (n == null && (n = 0), r == null && (r = t.length); n < r; ) {
        var o = n + r >>> 1;
        i59(t[o], e) < 0 ? n = o + 1 : r = o;
      }
      return n;
    }, right: function(t, e, n, r) {
      for (n == null && (n = 0), r == null && (r = t.length); n < r; ) {
        var o = n + r >>> 1;
        i59(t[o], e) > 0 ? r = o : n = o + 1;
      }
      return n;
    } };
  }
  function QX(i59) {
    return function(t, e) {
      return Rs(i59(t), e);
    };
  }
  var ML = bb(Rs);
  var KX = ML.right;
  var JX = ML.left;
  var EL = Array.prototype;
  var tZ = EL.slice;
  var nZ = EL.map;
  var HMe = Math.sqrt(50);
  var jMe = Math.sqrt(10);
  var WMe = Math.sqrt(2);
  var lZ = Array.prototype.slice;
  var cZ = { value: function() {
  } };
  function RL() {
    for (var i59 = 0, t = arguments.length, e = {}, n; i59 < t; ++i59) {
      if (!(n = arguments[i59] + "") || n in e || /[\s.]/.test(n)) throw new Error("illegal type: " + n);
      e[n] = [];
    }
    return new wb(e);
  }
  function wb(i59) {
    this._ = i59;
  }
  function dZ(i59, t) {
    return i59.trim().split(/^|\s+/).map(function(e) {
      var n = "", r = e.indexOf(".");
      if (r >= 0 && (n = e.slice(r + 1), e = e.slice(0, r)), e && !t.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      return { type: e, name: n };
    });
  }
  wb.prototype = RL.prototype = { constructor: wb, on: function(i59, t) {
    var e = this._, n = dZ(i59 + "", e), r, o = -1, s = n.length;
    if (arguments.length < 2) {
      for (; ++o < s; ) if ((r = (i59 = n[o]).type) && (r = uZ(e[r], i59.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++o < s; ) if (r = (i59 = n[o]).type) e[r] = PL(e[r], i59.name, t);
    else if (t == null) for (r in e) e[r] = PL(e[r], i59.name, null);
    return this;
  }, copy: function() {
    var i59 = {}, t = this._;
    for (var e in t) i59[e] = t[e].slice();
    return new wb(i59);
  }, call: function(i59, t) {
    if ((r = arguments.length - 2) > 0) for (var e = new Array(r), n = 0, r, o; n < r; ++n) e[n] = arguments[n + 2];
    if (!this._.hasOwnProperty(i59)) throw new Error("unknown type: " + i59);
    for (o = this._[i59], n = 0, r = o.length; n < r; ++n) o[n].value.apply(t, e);
  }, apply: function(i59, t, e) {
    if (!this._.hasOwnProperty(i59)) throw new Error("unknown type: " + i59);
    for (var n = this._[i59], r = 0, o = n.length; r < o; ++r) n[r].value.apply(t, e);
  } };
  function uZ(i59, t) {
    for (var e = 0, n = i59.length, r; e < n; ++e) if ((r = i59[e]).name === t) return r.value;
  }
  function PL(i59, t, e) {
    for (var n = 0, r = i59.length; n < r; ++n) if (i59[n].name === t) {
      i59[n] = cZ, i59 = i59.slice(0, n).concat(i59.slice(n + 1));
      break;
    }
    return e != null && i59.push({ name: t, value: e }), i59;
  }
  var Hf = RL;
  var Cb = "http://www.w3.org/1999/xhtml";
  var NT = { svg: "http://www.w3.org/2000/svg", xhtml: Cb, xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" };
  function xa(i59) {
    var t = i59 += "", e = t.indexOf(":");
    return e >= 0 && (t = i59.slice(0, e)) !== "xmlns" && (i59 = i59.slice(e + 1)), NT.hasOwnProperty(t) ? { space: NT[t], local: i59 } : i59;
  }
  function hZ(i59) {
    return function() {
      var t = this.ownerDocument, e = this.namespaceURI;
      return e === Cb && t.documentElement.namespaceURI === Cb ? t.createElement(i59) : t.createElementNS(e, i59);
    };
  }
  function pZ(i59) {
    return function() {
      return this.ownerDocument.createElementNS(i59.space, i59.local);
    };
  }
  function Sb(i59) {
    var t = xa(i59);
    return (t.local ? pZ : hZ)(t);
  }
  function fZ() {
  }
  function qc(i59) {
    return i59 == null ? fZ : function() {
      return this.querySelector(i59);
    };
  }
  function OL(i59) {
    typeof i59 != "function" && (i59 = qc(i59));
    for (var t = this._groups, e = t.length, n = new Array(e), r = 0; r < e; ++r) for (var o = t[r], s = o.length, a = n[r] = new Array(s), l, c, d = 0; d < s; ++d) (l = o[d]) && (c = i59.call(l, l.__data__, d, o)) && ("__data__" in l && (c.__data__ = l.__data__), a[d] = c);
    return new si(n, this._parents);
  }
  function mZ() {
    return [];
  }
  function jf(i59) {
    return i59 == null ? mZ : function() {
      return this.querySelectorAll(i59);
    };
  }
  function AL(i59) {
    typeof i59 != "function" && (i59 = jf(i59));
    for (var t = this._groups, e = t.length, n = [], r = [], o = 0; o < e; ++o) for (var s = t[o], a = s.length, l, c = 0; c < a; ++c) (l = s[c]) && (n.push(i59.call(l, l.__data__, c, s)), r.push(l));
    return new si(n, r);
  }
  function Wf(i59) {
    return function() {
      return this.matches(i59);
    };
  }
  function NL(i59) {
    typeof i59 != "function" && (i59 = Wf(i59));
    for (var t = this._groups, e = t.length, n = new Array(e), r = 0; r < e; ++r) for (var o = t[r], s = o.length, a = n[r] = [], l, c = 0; c < s; ++c) (l = o[c]) && i59.call(l, l.__data__, c, o) && a.push(l);
    return new si(n, this._parents);
  }
  function Mb(i59) {
    return new Array(i59.length);
  }
  function kL() {
    return new si(this._enter || this._groups.map(Mb), this._parents);
  }
  function $f(i59, t) {
    this.ownerDocument = i59.ownerDocument, this.namespaceURI = i59.namespaceURI, this._next = null, this._parent = i59, this.__data__ = t;
  }
  $f.prototype = { constructor: $f, appendChild: function(i59) {
    return this._parent.insertBefore(i59, this._next);
  }, insertBefore: function(i59, t) {
    return this._parent.insertBefore(i59, t);
  }, querySelector: function(i59) {
    return this._parent.querySelector(i59);
  }, querySelectorAll: function(i59) {
    return this._parent.querySelectorAll(i59);
  } };
  function LL(i59) {
    return function() {
      return i59;
    };
  }
  var FL = "$";
  function gZ(i59, t, e, n, r, o) {
    for (var s = 0, a, l = t.length, c = o.length; s < c; ++s) (a = t[s]) ? (a.__data__ = o[s], n[s] = a) : e[s] = new $f(i59, o[s]);
    for (; s < l; ++s) (a = t[s]) && (r[s] = a);
  }
  function _Z(i59, t, e, n, r, o, s) {
    var a, l, c = {}, d = t.length, u = o.length, h = new Array(d), p;
    for (a = 0; a < d; ++a) (l = t[a]) && (h[a] = p = FL + s.call(l, l.__data__, a, t), p in c ? r[a] = l : c[p] = l);
    for (a = 0; a < u; ++a) p = FL + s.call(i59, o[a], a, o), (l = c[p]) ? (n[a] = l, l.__data__ = o[a], c[p] = null) : e[a] = new $f(i59, o[a]);
    for (a = 0; a < d; ++a) (l = t[a]) && c[h[a]] === l && (r[a] = l);
  }
  function BL(i59, t) {
    if (!i59) return p = new Array(this.size()), c = -1, this.each(function(P) {
      p[++c] = P;
    }), p;
    var e = t ? _Z : gZ, n = this._parents, r = this._groups;
    typeof i59 != "function" && (i59 = LL(i59));
    for (var o = r.length, s = new Array(o), a = new Array(o), l = new Array(o), c = 0; c < o; ++c) {
      var d = n[c], u = r[c], h = u.length, p = i59.call(d, d && d.__data__, c, n), f = p.length, m = a[c] = new Array(f), v = s[c] = new Array(f), _ = l[c] = new Array(h);
      e(d, u, m, v, _, p, t);
      for (var g = 0, y = 0, w, E; g < f; ++g) if (w = m[g]) {
        for (g >= y && (y = g + 1); !(E = v[y]) && ++y < f; ) ;
        w._next = E || null;
      }
    }
    return s = new si(s, n), s._enter = a, s._exit = l, s;
  }
  function VL() {
    return new si(this._exit || this._groups.map(Mb), this._parents);
  }
  function zL(i59, t, e) {
    var n = this.enter(), r = this, o = this.exit();
    return n = typeof i59 == "function" ? i59(n) : n.append(i59 + ""), t != null && (r = t(r)), e == null ? o.remove() : e(o), n && r ? n.merge(r).order() : r;
  }
  function UL(i59) {
    for (var t = this._groups, e = i59._groups, n = t.length, r = e.length, o = Math.min(n, r), s = new Array(n), a = 0; a < o; ++a) for (var l = t[a], c = e[a], d = l.length, u = s[a] = new Array(d), h, p = 0; p < d; ++p) (h = l[p] || c[p]) && (u[p] = h);
    for (; a < n; ++a) s[a] = t[a];
    return new si(s, this._parents);
  }
  function GL() {
    for (var i59 = this._groups, t = -1, e = i59.length; ++t < e; ) for (var n = i59[t], r = n.length - 1, o = n[r], s; --r >= 0; ) (s = n[r]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
    return this;
  }
  function HL(i59) {
    i59 || (i59 = vZ);
    function t(u, h) {
      return u && h ? i59(u.__data__, h.__data__) : !u - !h;
    }
    for (var e = this._groups, n = e.length, r = new Array(n), o = 0; o < n; ++o) {
      for (var s = e[o], a = s.length, l = r[o] = new Array(a), c, d = 0; d < a; ++d) (c = s[d]) && (l[d] = c);
      l.sort(t);
    }
    return new si(r, this._parents).order();
  }
  function vZ(i59, t) {
    return i59 < t ? -1 : i59 > t ? 1 : i59 >= t ? 0 : NaN;
  }
  function jL() {
    var i59 = arguments[0];
    return arguments[0] = this, i59.apply(null, arguments), this;
  }
  function WL() {
    var i59 = new Array(this.size()), t = -1;
    return this.each(function() {
      i59[++t] = this;
    }), i59;
  }
  function $L() {
    for (var i59 = this._groups, t = 0, e = i59.length; t < e; ++t) for (var n = i59[t], r = 0, o = n.length; r < o; ++r) {
      var s = n[r];
      if (s) return s;
    }
    return null;
  }
  function qL() {
    var i59 = 0;
    return this.each(function() {
      ++i59;
    }), i59;
  }
  function YL() {
    return !this.node();
  }
  function XL(i59) {
    for (var t = this._groups, e = 0, n = t.length; e < n; ++e) for (var r = t[e], o = 0, s = r.length, a; o < s; ++o) (a = r[o]) && i59.call(a, a.__data__, o, r);
    return this;
  }
  function yZ(i59) {
    return function() {
      this.removeAttribute(i59);
    };
  }
  function bZ(i59) {
    return function() {
      this.removeAttributeNS(i59.space, i59.local);
    };
  }
  function xZ(i59, t) {
    return function() {
      this.setAttribute(i59, t);
    };
  }
  function wZ(i59, t) {
    return function() {
      this.setAttributeNS(i59.space, i59.local, t);
    };
  }
  function CZ(i59, t) {
    return function() {
      var e = t.apply(this, arguments);
      e == null ? this.removeAttribute(i59) : this.setAttribute(i59, e);
    };
  }
  function SZ(i59, t) {
    return function() {
      var e = t.apply(this, arguments);
      e == null ? this.removeAttributeNS(i59.space, i59.local) : this.setAttributeNS(i59.space, i59.local, e);
    };
  }
  function ZL(i59, t) {
    var e = xa(i59);
    if (arguments.length < 2) {
      var n = this.node();
      return e.local ? n.getAttributeNS(e.space, e.local) : n.getAttribute(e);
    }
    return this.each((t == null ? e.local ? bZ : yZ : typeof t == "function" ? e.local ? SZ : CZ : e.local ? wZ : xZ)(e, t));
  }
  function Eb(i59) {
    return i59.ownerDocument && i59.ownerDocument.defaultView || i59.document && i59 || i59.defaultView;
  }
  function MZ(i59) {
    return function() {
      this.style.removeProperty(i59);
    };
  }
  function EZ(i59, t, e) {
    return function() {
      this.style.setProperty(i59, t, e);
    };
  }
  function TZ(i59, t, e) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.style.removeProperty(i59) : this.style.setProperty(i59, n, e);
    };
  }
  function QL(i59, t, e) {
    return arguments.length > 1 ? this.each((t == null ? MZ : typeof t == "function" ? TZ : EZ)(i59, t, e ?? "")) : fl(this.node(), i59);
  }
  function fl(i59, t) {
    return i59.style.getPropertyValue(t) || Eb(i59).getComputedStyle(i59, null).getPropertyValue(t);
  }
  function IZ(i59) {
    return function() {
      delete this[i59];
    };
  }
  function DZ(i59, t) {
    return function() {
      this[i59] = t;
    };
  }
  function PZ(i59, t) {
    return function() {
      var e = t.apply(this, arguments);
      e == null ? delete this[i59] : this[i59] = e;
    };
  }
  function KL(i59, t) {
    return arguments.length > 1 ? this.each((t == null ? IZ : typeof t == "function" ? PZ : DZ)(i59, t)) : this.node()[i59];
  }
  function JL(i59) {
    return i59.trim().split(/^|\s+/);
  }
  function kT(i59) {
    return i59.classList || new eF(i59);
  }
  function eF(i59) {
    this._node = i59, this._names = JL(i59.getAttribute("class") || "");
  }
  eF.prototype = { add: function(i59) {
    var t = this._names.indexOf(i59);
    t < 0 && (this._names.push(i59), this._node.setAttribute("class", this._names.join(" ")));
  }, remove: function(i59) {
    var t = this._names.indexOf(i59);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  }, contains: function(i59) {
    return this._names.indexOf(i59) >= 0;
  } };
  function tF(i59, t) {
    for (var e = kT(i59), n = -1, r = t.length; ++n < r; ) e.add(t[n]);
  }
  function nF(i59, t) {
    for (var e = kT(i59), n = -1, r = t.length; ++n < r; ) e.remove(t[n]);
  }
  function RZ(i59) {
    return function() {
      tF(this, i59);
    };
  }
  function OZ(i59) {
    return function() {
      nF(this, i59);
    };
  }
  function AZ(i59, t) {
    return function() {
      (t.apply(this, arguments) ? tF : nF)(this, i59);
    };
  }
  function iF(i59, t) {
    var e = JL(i59 + "");
    if (arguments.length < 2) {
      for (var n = kT(this.node()), r = -1, o = e.length; ++r < o; ) if (!n.contains(e[r])) return false;
      return true;
    }
    return this.each((typeof t == "function" ? AZ : t ? RZ : OZ)(e, t));
  }
  function NZ() {
    this.textContent = "";
  }
  function kZ(i59) {
    return function() {
      this.textContent = i59;
    };
  }
  function LZ(i59) {
    return function() {
      var t = i59.apply(this, arguments);
      this.textContent = t ?? "";
    };
  }
  function rF(i59) {
    return arguments.length ? this.each(i59 == null ? NZ : (typeof i59 == "function" ? LZ : kZ)(i59)) : this.node().textContent;
  }
  function FZ() {
    this.innerHTML = "";
  }
  function BZ(i59) {
    return function() {
      this.innerHTML = i59;
    };
  }
  function VZ(i59) {
    return function() {
      var t = i59.apply(this, arguments);
      this.innerHTML = t ?? "";
    };
  }
  function oF(i59) {
    return arguments.length ? this.each(i59 == null ? FZ : (typeof i59 == "function" ? VZ : BZ)(i59)) : this.node().innerHTML;
  }
  function zZ() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function sF() {
    return this.each(zZ);
  }
  function UZ() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function aF() {
    return this.each(UZ);
  }
  function lF(i59) {
    var t = typeof i59 == "function" ? i59 : Sb(i59);
    return this.select(function() {
      return this.appendChild(t.apply(this, arguments));
    });
  }
  function GZ() {
    return null;
  }
  function cF(i59, t) {
    var e = typeof i59 == "function" ? i59 : Sb(i59), n = t == null ? GZ : typeof t == "function" ? t : qc(t);
    return this.select(function() {
      return this.insertBefore(e.apply(this, arguments), n.apply(this, arguments) || null);
    });
  }
  function HZ() {
    var i59 = this.parentNode;
    i59 && i59.removeChild(this);
  }
  function dF() {
    return this.each(HZ);
  }
  function jZ() {
    var i59 = this.cloneNode(false), t = this.parentNode;
    return t ? t.insertBefore(i59, this.nextSibling) : i59;
  }
  function WZ() {
    var i59 = this.cloneNode(true), t = this.parentNode;
    return t ? t.insertBefore(i59, this.nextSibling) : i59;
  }
  function uF(i59) {
    return this.select(i59 ? WZ : jZ);
  }
  function hF(i59) {
    return arguments.length ? this.property("__data__", i59) : this.node().__data__;
  }
  var fF = {};
  var pt = null;
  typeof document < "u" && (pF = document.documentElement, "onmouseenter" in pF || (fF = { mouseenter: "mouseover", mouseleave: "mouseout" }));
  var pF;
  function $Z(i59, t, e) {
    return i59 = mF(i59, t, e), function(n) {
      var r = n.relatedTarget;
      (!r || r !== this && !(r.compareDocumentPosition(this) & 8)) && i59.call(this, n);
    };
  }
  function mF(i59, t, e) {
    return function(n) {
      var r = pt;
      pt = n;
      try {
        i59.call(this, this.__data__, t, e);
      } finally {
        pt = r;
      }
    };
  }
  function qZ(i59) {
    return i59.trim().split(/^|\s+/).map(function(t) {
      var e = "", n = t.indexOf(".");
      return n >= 0 && (e = t.slice(n + 1), t = t.slice(0, n)), { type: t, name: e };
    });
  }
  function YZ(i59) {
    return function() {
      var t = this.__on;
      if (t) {
        for (var e = 0, n = -1, r = t.length, o; e < r; ++e) o = t[e], (!i59.type || o.type === i59.type) && o.name === i59.name ? this.removeEventListener(o.type, o.listener, o.capture) : t[++n] = o;
        ++n ? t.length = n : delete this.__on;
      }
    };
  }
  function XZ(i59, t, e) {
    var n = fF.hasOwnProperty(i59.type) ? $Z : mF;
    return function(r, o, s) {
      var a = this.__on, l, c = n(t, o, s);
      if (a) {
        for (var d = 0, u = a.length; d < u; ++d) if ((l = a[d]).type === i59.type && l.name === i59.name) {
          this.removeEventListener(l.type, l.listener, l.capture), this.addEventListener(l.type, l.listener = c, l.capture = e), l.value = t;
          return;
        }
      }
      this.addEventListener(i59.type, c, e), l = { type: i59.type, name: i59.name, value: t, listener: c, capture: e }, a ? a.push(l) : this.__on = [l];
    };
  }
  function gF(i59, t, e) {
    var n = qZ(i59 + ""), r, o = n.length, s;
    if (arguments.length < 2) {
      var a = this.node().__on;
      if (a) {
        for (var l = 0, c = a.length, d; l < c; ++l) for (r = 0, d = a[l]; r < o; ++r) if ((s = n[r]).type === d.type && s.name === d.name) return d.value;
      }
      return;
    }
    for (a = t ? XZ : YZ, e == null && (e = false), r = 0; r < o; ++r) this.each(a(n[r], t, e));
    return this;
  }
  function LT(i59, t, e, n) {
    var r = pt;
    i59.sourceEvent = pt, pt = i59;
    try {
      return t.apply(e, n);
    } finally {
      pt = r;
    }
  }
  function _F(i59, t, e) {
    var n = Eb(i59), r = n.CustomEvent;
    typeof r == "function" ? r = new r(t, e) : (r = n.document.createEvent("Event"), e ? (r.initEvent(t, e.bubbles, e.cancelable), r.detail = e.detail) : r.initEvent(t, false, false)), i59.dispatchEvent(r);
  }
  function ZZ(i59, t) {
    return function() {
      return _F(this, i59, t);
    };
  }
  function QZ(i59, t) {
    return function() {
      return _F(this, i59, t.apply(this, arguments));
    };
  }
  function vF(i59, t) {
    return this.each((typeof t == "function" ? QZ : ZZ)(i59, t));
  }
  var FT = [null];
  function si(i59, t) {
    this._groups = i59, this._parents = t;
  }
  function yF() {
    return new si([[document.documentElement]], FT);
  }
  si.prototype = yF.prototype = { constructor: si, select: OL, selectAll: AL, filter: NL, data: BL, enter: kL, exit: VL, join: zL, merge: UL, order: GL, sort: HL, call: jL, nodes: WL, node: $L, size: qL, empty: YL, each: XL, attr: ZL, style: QL, property: KL, classed: iF, text: rF, html: oF, raise: sF, lower: aF, append: lF, insert: cF, remove: dF, clone: uF, datum: hF, on: gF, dispatch: vF };
  var wa = yF;
  function Ro(i59) {
    return typeof i59 == "string" ? new si([[document.querySelector(i59)]], [document.documentElement]) : new si([[i59]], FT);
  }
  function Tb() {
    for (var i59 = pt, t; t = i59.sourceEvent; ) i59 = t;
    return i59;
  }
  function Ib(i59, t) {
    var e = i59.ownerSVGElement || i59;
    if (e.createSVGPoint) {
      var n = e.createSVGPoint();
      return n.x = t.clientX, n.y = t.clientY, n = n.matrixTransform(i59.getScreenCTM().inverse()), [n.x, n.y];
    }
    var r = i59.getBoundingClientRect();
    return [t.clientX - r.left - i59.clientLeft, t.clientY - r.top - i59.clientTop];
  }
  function Xu(i59) {
    var t = Tb();
    return t.changedTouches && (t = t.changedTouches[0]), Ib(i59, t);
  }
  function Db(i59, t, e) {
    arguments.length < 3 && (e = t, t = Tb().changedTouches);
    for (var n = 0, r = t ? t.length : 0, o; n < r; ++n) if ((o = t[n]).identifier === e) return Ib(i59, o);
    return null;
  }
  function Pb() {
    pt.preventDefault(), pt.stopImmediatePropagation();
  }
  function BT(i59) {
    var t = i59.document.documentElement, e = Ro(i59).on("dragstart.drag", Pb, true);
    "onselectstart" in t ? e.on("selectstart.drag", Pb, true) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
  }
  function VT(i59, t) {
    var e = i59.document.documentElement, n = Ro(i59).on("dragstart.drag", null);
    t && (n.on("click.drag", Pb, true), setTimeout(function() {
      n.on("click.drag", null);
    }, 0)), "onselectstart" in e ? n.on("selectstart.drag", null) : (e.style.MozUserSelect = e.__noselect, delete e.__noselect);
  }
  function Rb(i59, t, e) {
    i59.prototype = t.prototype = e, e.constructor = i59;
  }
  function zT(i59, t) {
    var e = Object.create(i59.prototype);
    for (var n in t) e[n] = t[n];
    return e;
  }
  function Xf() {
  }
  var qf = 0.7;
  var Ab = 1 / qf;
  var Zu = "\\s*([+-]?\\d+)\\s*";
  var Yf = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var As = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var KZ = /^#([0-9a-f]{3,8})$/;
  var JZ = new RegExp("^rgb\\(" + [Zu, Zu, Zu] + "\\)$");
  var eQ = new RegExp("^rgb\\(" + [As, As, As] + "\\)$");
  var tQ = new RegExp("^rgba\\(" + [Zu, Zu, Zu, Yf] + "\\)$");
  var nQ = new RegExp("^rgba\\(" + [As, As, As, Yf] + "\\)$");
  var iQ = new RegExp("^hsl\\(" + [Yf, As, As] + "\\)$");
  var rQ = new RegExp("^hsla\\(" + [Yf, As, As, Yf] + "\\)$");
  var bF = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
  Rb(Xf, is, { copy: function(i59) {
    return Object.assign(new this.constructor(), this, i59);
  }, displayable: function() {
    return this.rgb().displayable();
  }, hex: xF, formatHex: xF, formatHsl: oQ, formatRgb: wF, toString: wF });
  function xF() {
    return this.rgb().formatHex();
  }
  function oQ() {
    return TF(this).formatHsl();
  }
  function wF() {
    return this.rgb().formatRgb();
  }
  function is(i59) {
    var t, e;
    return i59 = (i59 + "").trim().toLowerCase(), (t = KZ.exec(i59)) ? (e = t[1].length, t = parseInt(t[1], 16), e === 6 ? CF(t) : e === 3 ? new ao(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : e === 8 ? Ob(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : e === 4 ? Ob(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = JZ.exec(i59)) ? new ao(t[1], t[2], t[3], 1) : (t = eQ.exec(i59)) ? new ao(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = tQ.exec(i59)) ? Ob(t[1], t[2], t[3], t[4]) : (t = nQ.exec(i59)) ? Ob(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = iQ.exec(i59)) ? EF(t[1], t[2] / 100, t[3] / 100, 1) : (t = rQ.exec(i59)) ? EF(t[1], t[2] / 100, t[3] / 100, t[4]) : bF.hasOwnProperty(i59) ? CF(bF[i59]) : i59 === "transparent" ? new ao(NaN, NaN, NaN, 0) : null;
  }
  function CF(i59) {
    return new ao(i59 >> 16 & 255, i59 >> 8 & 255, i59 & 255, 1);
  }
  function Ob(i59, t, e, n) {
    return n <= 0 && (i59 = t = e = NaN), new ao(i59, t, e, n);
  }
  function sQ(i59) {
    return i59 instanceof Xf || (i59 = is(i59)), i59 ? (i59 = i59.rgb(), new ao(i59.r, i59.g, i59.b, i59.opacity)) : new ao();
  }
  function Qu(i59, t, e, n) {
    return arguments.length === 1 ? sQ(i59) : new ao(i59, t, e, n ?? 1);
  }
  function ao(i59, t, e, n) {
    this.r = +i59, this.g = +t, this.b = +e, this.opacity = +n;
  }
  Rb(ao, Qu, zT(Xf, { brighter: function(i59) {
    return i59 = i59 == null ? Ab : Math.pow(Ab, i59), new ao(this.r * i59, this.g * i59, this.b * i59, this.opacity);
  }, darker: function(i59) {
    return i59 = i59 == null ? qf : Math.pow(qf, i59), new ao(this.r * i59, this.g * i59, this.b * i59, this.opacity);
  }, rgb: function() {
    return this;
  }, displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  }, hex: SF, formatHex: SF, formatRgb: MF, toString: MF }));
  function SF() {
    return "#" + UT(this.r) + UT(this.g) + UT(this.b);
  }
  function MF() {
    var i59 = this.opacity;
    return i59 = isNaN(i59) ? 1 : Math.max(0, Math.min(1, i59)), (i59 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (i59 === 1 ? ")" : ", " + i59 + ")");
  }
  function UT(i59) {
    return i59 = Math.max(0, Math.min(255, Math.round(i59) || 0)), (i59 < 16 ? "0" : "") + i59.toString(16);
  }
  function EF(i59, t, e, n) {
    return n <= 0 ? i59 = t = e = NaN : e <= 0 || e >= 1 ? i59 = t = NaN : t <= 0 && (i59 = NaN), new Os(i59, t, e, n);
  }
  function TF(i59) {
    if (i59 instanceof Os) return new Os(i59.h, i59.s, i59.l, i59.opacity);
    if (i59 instanceof Xf || (i59 = is(i59)), !i59) return new Os();
    if (i59 instanceof Os) return i59;
    i59 = i59.rgb();
    var t = i59.r / 255, e = i59.g / 255, n = i59.b / 255, r = Math.min(t, e, n), o = Math.max(t, e, n), s = NaN, a = o - r, l = (o + r) / 2;
    return a ? (t === o ? s = (e - n) / a + (e < n) * 6 : e === o ? s = (n - t) / a + 2 : s = (t - e) / a + 4, a /= l < 0.5 ? o + r : 2 - o - r, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new Os(s, a, l, i59.opacity);
  }
  function IF(i59, t, e, n) {
    return arguments.length === 1 ? TF(i59) : new Os(i59, t, e, n ?? 1);
  }
  function Os(i59, t, e, n) {
    this.h = +i59, this.s = +t, this.l = +e, this.opacity = +n;
  }
  Rb(Os, IF, zT(Xf, { brighter: function(i59) {
    return i59 = i59 == null ? Ab : Math.pow(Ab, i59), new Os(this.h, this.s, this.l * i59, this.opacity);
  }, darker: function(i59) {
    return i59 = i59 == null ? qf : Math.pow(qf, i59), new Os(this.h, this.s, this.l * i59, this.opacity);
  }, rgb: function() {
    var i59 = this.h % 360 + (this.h < 0) * 360, t = isNaN(i59) || isNaN(this.s) ? 0 : this.s, e = this.l, n = e + (e < 0.5 ? e : 1 - e) * t, r = 2 * e - n;
    return new ao(GT(i59 >= 240 ? i59 - 240 : i59 + 120, r, n), GT(i59, r, n), GT(i59 < 120 ? i59 + 240 : i59 - 120, r, n), this.opacity);
  }, displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }, formatHsl: function() {
    var i59 = this.opacity;
    return i59 = isNaN(i59) ? 1 : Math.max(0, Math.min(1, i59)), (i59 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (i59 === 1 ? ")" : ", " + i59 + ")");
  } }));
  function GT(i59, t, e) {
    return (i59 < 60 ? t + (e - t) * i59 / 60 : i59 < 180 ? e : i59 < 240 ? t + (e - t) * (240 - i59) / 60 : t) * 255;
  }
  function HT(i59, t, e, n, r) {
    var o = i59 * i59, s = o * i59;
    return ((1 - 3 * i59 + 3 * o - s) * t + (4 - 6 * o + 3 * s) * e + (1 + 3 * i59 + 3 * o - 3 * s) * n + s * r) / 6;
  }
  function DF(i59) {
    var t = i59.length - 1;
    return function(e) {
      var n = e <= 0 ? e = 0 : e >= 1 ? (e = 1, t - 1) : Math.floor(e * t), r = i59[n], o = i59[n + 1], s = n > 0 ? i59[n - 1] : 2 * r - o, a = n < t - 1 ? i59[n + 2] : 2 * o - r;
      return HT((e - n / t) * t, s, r, o, a);
    };
  }
  function PF(i59) {
    var t = i59.length;
    return function(e) {
      var n = Math.floor(((e %= 1) < 0 ? ++e : e) * t), r = i59[(n + t - 1) % t], o = i59[n % t], s = i59[(n + 1) % t], a = i59[(n + 2) % t];
      return HT((e - n / t) * t, r, o, s, a);
    };
  }
  function Zf(i59) {
    return function() {
      return i59;
    };
  }
  function aQ(i59, t) {
    return function(e) {
      return i59 + e * t;
    };
  }
  function lQ(i59, t, e) {
    return i59 = Math.pow(i59, e), t = Math.pow(t, e) - i59, e = 1 / e, function(n) {
      return Math.pow(i59 + n * t, e);
    };
  }
  function RF(i59) {
    return (i59 = +i59) == 1 ? Nb : function(t, e) {
      return e - t ? lQ(t, e, i59) : Zf(isNaN(t) ? e : t);
    };
  }
  function Nb(i59, t) {
    var e = t - i59;
    return e ? aQ(i59, e) : Zf(isNaN(i59) ? t : i59);
  }
  var Yc = function i20(t) {
    var e = RF(t);
    function n(r, o) {
      var s = e((r = Qu(r)).r, (o = Qu(o)).r), a = e(r.g, o.g), l = e(r.b, o.b), c = Nb(r.opacity, o.opacity);
      return function(d) {
        return r.r = s(d), r.g = a(d), r.b = l(d), r.opacity = c(d), r + "";
      };
    }
    return n.gamma = i20, n;
  }(1);
  function OF(i59) {
    return function(t) {
      var e = t.length, n = new Array(e), r = new Array(e), o = new Array(e), s, a;
      for (s = 0; s < e; ++s) a = Qu(t[s]), n[s] = a.r || 0, r[s] = a.g || 0, o[s] = a.b || 0;
      return n = i59(n), r = i59(r), o = i59(o), a.opacity = 1, function(l) {
        return a.r = n(l), a.g = r(l), a.b = o(l), a + "";
      };
    };
  }
  var cQ = OF(DF);
  var dQ = OF(PF);
  function AF(i59, t) {
    t || (t = []);
    var e = i59 ? Math.min(t.length, i59.length) : 0, n = t.slice(), r;
    return function(o) {
      for (r = 0; r < e; ++r) n[r] = i59[r] * (1 - o) + t[r] * o;
      return n;
    };
  }
  function NF(i59) {
    return ArrayBuffer.isView(i59) && !(i59 instanceof DataView);
  }
  function kF(i59, t) {
    var e = t ? t.length : 0, n = i59 ? Math.min(e, i59.length) : 0, r = new Array(n), o = new Array(e), s;
    for (s = 0; s < n; ++s) r[s] = Xc(i59[s], t[s]);
    for (; s < e; ++s) o[s] = t[s];
    return function(a) {
      for (s = 0; s < n; ++s) o[s] = r[s](a);
      return o;
    };
  }
  function LF(i59, t) {
    var e = /* @__PURE__ */ new Date();
    return i59 = +i59, t = +t, function(n) {
      return e.setTime(i59 * (1 - n) + t * n), e;
    };
  }
  function Ar(i59, t) {
    return i59 = +i59, t = +t, function(e) {
      return i59 * (1 - e) + t * e;
    };
  }
  function FF(i59, t) {
    var e = {}, n = {}, r;
    (i59 === null || typeof i59 != "object") && (i59 = {}), (t === null || typeof t != "object") && (t = {});
    for (r in t) r in i59 ? e[r] = Xc(i59[r], t[r]) : n[r] = t[r];
    return function(o) {
      for (r in e) n[r] = e[r](o);
      return n;
    };
  }
  var WT = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var jT = new RegExp(WT.source, "g");
  function uQ(i59) {
    return function() {
      return i59;
    };
  }
  function hQ(i59) {
    return function(t) {
      return i59(t) + "";
    };
  }
  function Qf(i59, t) {
    var e = WT.lastIndex = jT.lastIndex = 0, n, r, o, s = -1, a = [], l = [];
    for (i59 = i59 + "", t = t + ""; (n = WT.exec(i59)) && (r = jT.exec(t)); ) (o = r.index) > e && (o = t.slice(e, o), a[s] ? a[s] += o : a[++s] = o), (n = n[0]) === (r = r[0]) ? a[s] ? a[s] += r : a[++s] = r : (a[++s] = null, l.push({ i: s, x: Ar(n, r) })), e = jT.lastIndex;
    return e < t.length && (o = t.slice(e), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? hQ(l[0].x) : uQ(t) : (t = l.length, function(c) {
      for (var d = 0, u; d < t; ++d) a[(u = l[d]).i] = u.x(c);
      return a.join("");
    });
  }
  function Xc(i59, t) {
    var e = typeof t, n;
    return t == null || e === "boolean" ? Zf(t) : (e === "number" ? Ar : e === "string" ? (n = is(t)) ? (t = n, Yc) : Qf : t instanceof is ? Yc : t instanceof Date ? LF : NF(t) ? AF : Array.isArray(t) ? kF : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? FF : Ar)(i59, t);
  }
  var BF = 180 / Math.PI;
  var kb = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 };
  function $T(i59, t, e, n, r, o) {
    var s, a, l;
    return (s = Math.sqrt(i59 * i59 + t * t)) && (i59 /= s, t /= s), (l = i59 * e + t * n) && (e -= i59 * l, n -= t * l), (a = Math.sqrt(e * e + n * n)) && (e /= a, n /= a, l /= a), i59 * n < t * e && (i59 = -i59, t = -t, l = -l, s = -s), { translateX: r, translateY: o, rotate: Math.atan2(t, i59) * BF, skewX: Math.atan(l) * BF, scaleX: s, scaleY: a };
  }
  var Kf;
  var qT;
  var VF;
  var Lb;
  function zF(i59) {
    return i59 === "none" ? kb : (Kf || (Kf = document.createElement("DIV"), qT = document.documentElement, VF = document.defaultView), Kf.style.transform = i59, i59 = VF.getComputedStyle(qT.appendChild(Kf), null).getPropertyValue("transform"), qT.removeChild(Kf), i59 = i59.slice(7, -1).split(","), $T(+i59[0], +i59[1], +i59[2], +i59[3], +i59[4], +i59[5]));
  }
  function UF(i59) {
    return i59 == null ? kb : (Lb || (Lb = document.createElementNS("http://www.w3.org/2000/svg", "g")), Lb.setAttribute("transform", i59), (i59 = Lb.transform.baseVal.consolidate()) ? (i59 = i59.matrix, $T(i59.a, i59.b, i59.c, i59.d, i59.e, i59.f)) : kb);
  }
  function GF(i59, t, e, n) {
    function r(c) {
      return c.length ? c.pop() + " " : "";
    }
    function o(c, d, u, h, p, f) {
      if (c !== u || d !== h) {
        var m = p.push("translate(", null, t, null, e);
        f.push({ i: m - 4, x: Ar(c, u) }, { i: m - 2, x: Ar(d, h) });
      } else (u || h) && p.push("translate(" + u + t + h + e);
    }
    function s(c, d, u, h) {
      c !== d ? (c - d > 180 ? d += 360 : d - c > 180 && (c += 360), h.push({ i: u.push(r(u) + "rotate(", null, n) - 2, x: Ar(c, d) })) : d && u.push(r(u) + "rotate(" + d + n);
    }
    function a(c, d, u, h) {
      c !== d ? h.push({ i: u.push(r(u) + "skewX(", null, n) - 2, x: Ar(c, d) }) : d && u.push(r(u) + "skewX(" + d + n);
    }
    function l(c, d, u, h, p, f) {
      if (c !== u || d !== h) {
        var m = p.push(r(p) + "scale(", null, ",", null, ")");
        f.push({ i: m - 4, x: Ar(c, u) }, { i: m - 2, x: Ar(d, h) });
      } else (u !== 1 || h !== 1) && p.push(r(p) + "scale(" + u + "," + h + ")");
    }
    return function(c, d) {
      var u = [], h = [];
      return c = i59(c), d = i59(d), o(c.translateX, c.translateY, d.translateX, d.translateY, u, h), s(c.rotate, d.rotate, u, h), a(c.skewX, d.skewX, u, h), l(c.scaleX, c.scaleY, d.scaleX, d.scaleY, u, h), c = d = null, function(p) {
        for (var f = -1, m = h.length, v; ++f < m; ) u[(v = h[f]).i] = v.x(p);
        return u.join("");
      };
    };
  }
  var YT = GF(zF, "px, ", "px)", "deg)");
  var XT = GF(UF, ", ", ")", ")");
  var Jf = Math.SQRT2;
  var ZT = 2;
  var HF = 4;
  var pQ = 1e-12;
  function jF(i59) {
    return ((i59 = Math.exp(i59)) + 1 / i59) / 2;
  }
  function fQ(i59) {
    return ((i59 = Math.exp(i59)) - 1 / i59) / 2;
  }
  function mQ(i59) {
    return ((i59 = Math.exp(2 * i59)) - 1) / (i59 + 1);
  }
  function QT(i59, t) {
    var e = i59[0], n = i59[1], r = i59[2], o = t[0], s = t[1], a = t[2], l = o - e, c = s - n, d = l * l + c * c, u, h;
    if (d < pQ) h = Math.log(a / r) / Jf, u = function(g) {
      return [e + g * l, n + g * c, r * Math.exp(Jf * g * h)];
    };
    else {
      var p = Math.sqrt(d), f = (a * a - r * r + HF * d) / (2 * r * ZT * p), m = (a * a - r * r - HF * d) / (2 * a * ZT * p), v = Math.log(Math.sqrt(f * f + 1) - f), _ = Math.log(Math.sqrt(m * m + 1) - m);
      h = (_ - v) / Jf, u = function(g) {
        var y = g * h, w = jF(v), E = r / (ZT * p) * (w * mQ(Jf * y + v) - fQ(v));
        return [e + E * l, n + E * c, r * w / jF(Jf * y + v)];
      };
    }
    return u.duration = h * 1e3, u;
  }
  var Ku = 0;
  var tm = 0;
  var em = 0;
  var $F = 1e3;
  var Fb;
  var nm;
  var Bb = 0;
  var Zc = 0;
  var Vb = 0;
  var im = typeof performance == "object" && performance.now ? performance : Date;
  var qF = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(i59) {
    setTimeout(i59, 17);
  };
  function Ju() {
    return Zc || (qF(gQ), Zc = im.now() + Vb);
  }
  function gQ() {
    Zc = 0;
  }
  function rm() {
    this._call = this._time = this._next = null;
  }
  rm.prototype = zb.prototype = { constructor: rm, restart: function(i59, t, e) {
    if (typeof i59 != "function") throw new TypeError("callback is not a function");
    e = (e == null ? Ju() : +e) + (t == null ? 0 : +t), !this._next && nm !== this && (nm ? nm._next = this : Fb = this, nm = this), this._call = i59, this._time = e, KT();
  }, stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, KT());
  } };
  function zb(i59, t, e) {
    var n = new rm();
    return n.restart(i59, t, e), n;
  }
  function YF() {
    Ju(), ++Ku;
    for (var i59 = Fb, t; i59; ) (t = Zc - i59._time) >= 0 && i59._call.call(null, t), i59 = i59._next;
    --Ku;
  }
  function WF() {
    Zc = (Bb = im.now()) + Vb, Ku = tm = 0;
    try {
      YF();
    } finally {
      Ku = 0, vQ(), Zc = 0;
    }
  }
  function _Q() {
    var i59 = im.now(), t = i59 - Bb;
    t > $F && (Vb -= t, Bb = i59);
  }
  function vQ() {
    for (var i59, t = Fb, e, n = 1 / 0; t; ) t._call ? (n > t._time && (n = t._time), i59 = t, t = t._next) : (e = t._next, t._next = null, t = i59 ? i59._next = e : Fb = e);
    nm = i59, KT(n);
  }
  function KT(i59) {
    if (!Ku) {
      tm && (tm = clearTimeout(tm));
      var t = i59 - Zc;
      t > 24 ? (i59 < 1 / 0 && (tm = setTimeout(WF, i59 - im.now() - Vb)), em && (em = clearInterval(em))) : (em || (Bb = im.now(), em = setInterval(_Q, $F)), Ku = 1, qF(WF));
    }
  }
  function Ub(i59, t, e) {
    var n = new rm();
    return t = t == null ? 0 : +t, n.restart(function(r) {
      n.stop(), i59(r + t);
    }, t, e), n;
  }
  var yQ = Hf("start", "end", "cancel", "interrupt");
  var bQ = [];
  var ZF = 0;
  var JT = 1;
  var Hb = 2;
  var Gb = 3;
  var XF = 4;
  var jb = 5;
  var om = 6;
  function ml(i59, t, e, n, r, o) {
    var s = i59.__transition;
    if (!s) i59.__transition = {};
    else if (e in s) return;
    xQ(i59, e, { name: t, index: n, group: r, on: yQ, tween: bQ, time: o.time, delay: o.delay, duration: o.duration, ease: o.ease, timer: null, state: ZF });
  }
  function sm(i59, t) {
    var e = Pi(i59, t);
    if (e.state > ZF) throw new Error("too late; already scheduled");
    return e;
  }
  function Nr(i59, t) {
    var e = Pi(i59, t);
    if (e.state > Gb) throw new Error("too late; already running");
    return e;
  }
  function Pi(i59, t) {
    var e = i59.__transition;
    if (!e || !(e = e[t])) throw new Error("transition not found");
    return e;
  }
  function xQ(i59, t, e) {
    var n = i59.__transition, r;
    n[t] = e, e.timer = zb(o, 0, e.time);
    function o(c) {
      e.state = JT, e.timer.restart(s, e.delay, e.time), e.delay <= c && s(c - e.delay);
    }
    function s(c) {
      var d, u, h, p;
      if (e.state !== JT) return l();
      for (d in n) if (p = n[d], p.name === e.name) {
        if (p.state === Gb) return Ub(s);
        p.state === XF ? (p.state = om, p.timer.stop(), p.on.call("interrupt", i59, i59.__data__, p.index, p.group), delete n[d]) : +d < t && (p.state = om, p.timer.stop(), p.on.call("cancel", i59, i59.__data__, p.index, p.group), delete n[d]);
      }
      if (Ub(function() {
        e.state === Gb && (e.state = XF, e.timer.restart(a, e.delay, e.time), a(c));
      }), e.state = Hb, e.on.call("start", i59, i59.__data__, e.index, e.group), e.state === Hb) {
        for (e.state = Gb, r = new Array(h = e.tween.length), d = 0, u = -1; d < h; ++d) (p = e.tween[d].value.call(i59, i59.__data__, e.index, e.group)) && (r[++u] = p);
        r.length = u + 1;
      }
    }
    function a(c) {
      for (var d = c < e.duration ? e.ease.call(null, c / e.duration) : (e.timer.restart(l), e.state = jb, 1), u = -1, h = r.length; ++u < h; ) r[u].call(i59, d);
      e.state === jb && (e.on.call("end", i59, i59.__data__, e.index, e.group), l());
    }
    function l() {
      e.state = om, e.timer.stop(), delete n[t];
      for (var c in n) return;
      delete i59.__transition;
    }
  }
  function gl(i59, t) {
    var e = i59.__transition, n, r, o = true, s;
    if (e) {
      t = t == null ? null : t + "";
      for (s in e) {
        if ((n = e[s]).name !== t) {
          o = false;
          continue;
        }
        r = n.state > Hb && n.state < jb, n.state = om, n.timer.stop(), n.on.call(r ? "interrupt" : "cancel", i59, i59.__data__, n.index, n.group), delete e[s];
      }
      o && delete i59.__transition;
    }
  }
  function QF(i59) {
    return this.each(function() {
      gl(this, i59);
    });
  }
  function wQ(i59, t) {
    var e, n;
    return function() {
      var r = Nr(this, i59), o = r.tween;
      if (o !== e) {
        n = e = o;
        for (var s = 0, a = n.length; s < a; ++s) if (n[s].name === t) {
          n = n.slice(), n.splice(s, 1);
          break;
        }
      }
      r.tween = n;
    };
  }
  function CQ(i59, t, e) {
    var n, r;
    if (typeof e != "function") throw new Error();
    return function() {
      var o = Nr(this, i59), s = o.tween;
      if (s !== n) {
        r = (n = s).slice();
        for (var a = { name: t, value: e }, l = 0, c = r.length; l < c; ++l) if (r[l].name === t) {
          r[l] = a;
          break;
        }
        l === c && r.push(a);
      }
      o.tween = r;
    };
  }
  function KF(i59, t) {
    var e = this._id;
    if (i59 += "", arguments.length < 2) {
      for (var n = Pi(this.node(), e).tween, r = 0, o = n.length, s; r < o; ++r) if ((s = n[r]).name === i59) return s.value;
      return null;
    }
    return this.each((t == null ? wQ : CQ)(e, i59, t));
  }
  function eh(i59, t, e) {
    var n = i59._id;
    return i59.each(function() {
      var r = Nr(this, n);
      (r.value || (r.value = {}))[t] = e.apply(this, arguments);
    }), function(r) {
      return Pi(r, n).value[t];
    };
  }
  function Wb(i59, t) {
    var e;
    return (typeof t == "number" ? Ar : t instanceof is ? Yc : (e = is(t)) ? (t = e, Yc) : Qf)(i59, t);
  }
  function SQ(i59) {
    return function() {
      this.removeAttribute(i59);
    };
  }
  function MQ(i59) {
    return function() {
      this.removeAttributeNS(i59.space, i59.local);
    };
  }
  function EQ(i59, t, e) {
    var n, r = e + "", o;
    return function() {
      var s = this.getAttribute(i59);
      return s === r ? null : s === n ? o : o = t(n = s, e);
    };
  }
  function TQ(i59, t, e) {
    var n, r = e + "", o;
    return function() {
      var s = this.getAttributeNS(i59.space, i59.local);
      return s === r ? null : s === n ? o : o = t(n = s, e);
    };
  }
  function IQ(i59, t, e) {
    var n, r, o;
    return function() {
      var s, a = e(this), l;
      return a == null ? void this.removeAttribute(i59) : (s = this.getAttribute(i59), l = a + "", s === l ? null : s === n && l === r ? o : (r = l, o = t(n = s, a)));
    };
  }
  function DQ(i59, t, e) {
    var n, r, o;
    return function() {
      var s, a = e(this), l;
      return a == null ? void this.removeAttributeNS(i59.space, i59.local) : (s = this.getAttributeNS(i59.space, i59.local), l = a + "", s === l ? null : s === n && l === r ? o : (r = l, o = t(n = s, a)));
    };
  }
  function JF(i59, t) {
    var e = xa(i59), n = e === "transform" ? XT : Wb;
    return this.attrTween(i59, typeof t == "function" ? (e.local ? DQ : IQ)(e, n, eh(this, "attr." + i59, t)) : t == null ? (e.local ? MQ : SQ)(e) : (e.local ? TQ : EQ)(e, n, t));
  }
  function PQ(i59, t) {
    return function(e) {
      this.setAttribute(i59, t.call(this, e));
    };
  }
  function RQ(i59, t) {
    return function(e) {
      this.setAttributeNS(i59.space, i59.local, t.call(this, e));
    };
  }
  function OQ(i59, t) {
    var e, n;
    function r() {
      var o = t.apply(this, arguments);
      return o !== n && (e = (n = o) && RQ(i59, o)), e;
    }
    return r._value = t, r;
  }
  function AQ(i59, t) {
    var e, n;
    function r() {
      var o = t.apply(this, arguments);
      return o !== n && (e = (n = o) && PQ(i59, o)), e;
    }
    return r._value = t, r;
  }
  function e3(i59, t) {
    var e = "attr." + i59;
    if (arguments.length < 2) return (e = this.tween(e)) && e._value;
    if (t == null) return this.tween(e, null);
    if (typeof t != "function") throw new Error();
    var n = xa(i59);
    return this.tween(e, (n.local ? OQ : AQ)(n, t));
  }
  function NQ(i59, t) {
    return function() {
      sm(this, i59).delay = +t.apply(this, arguments);
    };
  }
  function kQ(i59, t) {
    return t = +t, function() {
      sm(this, i59).delay = t;
    };
  }
  function t3(i59) {
    var t = this._id;
    return arguments.length ? this.each((typeof i59 == "function" ? NQ : kQ)(t, i59)) : Pi(this.node(), t).delay;
  }
  function LQ(i59, t) {
    return function() {
      Nr(this, i59).duration = +t.apply(this, arguments);
    };
  }
  function FQ(i59, t) {
    return t = +t, function() {
      Nr(this, i59).duration = t;
    };
  }
  function n3(i59) {
    var t = this._id;
    return arguments.length ? this.each((typeof i59 == "function" ? LQ : FQ)(t, i59)) : Pi(this.node(), t).duration;
  }
  function BQ(i59, t) {
    if (typeof t != "function") throw new Error();
    return function() {
      Nr(this, i59).ease = t;
    };
  }
  function i32(i59) {
    var t = this._id;
    return arguments.length ? this.each(BQ(t, i59)) : Pi(this.node(), t).ease;
  }
  function r3(i59) {
    typeof i59 != "function" && (i59 = Wf(i59));
    for (var t = this._groups, e = t.length, n = new Array(e), r = 0; r < e; ++r) for (var o = t[r], s = o.length, a = n[r] = [], l, c = 0; c < s; ++c) (l = o[c]) && i59.call(l, l.__data__, c, o) && a.push(l);
    return new yr(n, this._parents, this._name, this._id);
  }
  function o3(i59) {
    if (i59._id !== this._id) throw new Error();
    for (var t = this._groups, e = i59._groups, n = t.length, r = e.length, o = Math.min(n, r), s = new Array(n), a = 0; a < o; ++a) for (var l = t[a], c = e[a], d = l.length, u = s[a] = new Array(d), h, p = 0; p < d; ++p) (h = l[p] || c[p]) && (u[p] = h);
    for (; a < n; ++a) s[a] = t[a];
    return new yr(s, this._parents, this._name, this._id);
  }
  function VQ(i59) {
    return (i59 + "").trim().split(/^|\s+/).every(function(t) {
      var e = t.indexOf(".");
      return e >= 0 && (t = t.slice(0, e)), !t || t === "start";
    });
  }
  function zQ(i59, t, e) {
    var n, r, o = VQ(t) ? sm : Nr;
    return function() {
      var s = o(this, i59), a = s.on;
      a !== n && (r = (n = a).copy()).on(t, e), s.on = r;
    };
  }
  function s3(i59, t) {
    var e = this._id;
    return arguments.length < 2 ? Pi(this.node(), e).on.on(i59) : this.each(zQ(e, i59, t));
  }
  function UQ(i59) {
    return function() {
      var t = this.parentNode;
      for (var e in this.__transition) if (+e !== i59) return;
      t && t.removeChild(this);
    };
  }
  function a3() {
    return this.on("end.remove", UQ(this._id));
  }
  function l3(i59) {
    var t = this._name, e = this._id;
    typeof i59 != "function" && (i59 = qc(i59));
    for (var n = this._groups, r = n.length, o = new Array(r), s = 0; s < r; ++s) for (var a = n[s], l = a.length, c = o[s] = new Array(l), d, u, h = 0; h < l; ++h) (d = a[h]) && (u = i59.call(d, d.__data__, h, a)) && ("__data__" in d && (u.__data__ = d.__data__), c[h] = u, ml(c[h], t, e, h, c, Pi(d, e)));
    return new yr(o, this._parents, t, e);
  }
  function c3(i59) {
    var t = this._name, e = this._id;
    typeof i59 != "function" && (i59 = jf(i59));
    for (var n = this._groups, r = n.length, o = [], s = [], a = 0; a < r; ++a) for (var l = n[a], c = l.length, d, u = 0; u < c; ++u) if (d = l[u]) {
      for (var h = i59.call(d, d.__data__, u, l), p, f = Pi(d, e), m = 0, v = h.length; m < v; ++m) (p = h[m]) && ml(p, t, e, m, h, f);
      o.push(h), s.push(d);
    }
    return new yr(o, s, t, e);
  }
  var GQ = wa.prototype.constructor;
  function d3() {
    return new GQ(this._groups, this._parents);
  }
  function HQ(i59, t) {
    var e, n, r;
    return function() {
      var o = fl(this, i59), s = (this.style.removeProperty(i59), fl(this, i59));
      return o === s ? null : o === e && s === n ? r : r = t(e = o, n = s);
    };
  }
  function u3(i59) {
    return function() {
      this.style.removeProperty(i59);
    };
  }
  function jQ(i59, t, e) {
    var n, r = e + "", o;
    return function() {
      var s = fl(this, i59);
      return s === r ? null : s === n ? o : o = t(n = s, e);
    };
  }
  function WQ(i59, t, e) {
    var n, r, o;
    return function() {
      var s = fl(this, i59), a = e(this), l = a + "";
      return a == null && (l = a = (this.style.removeProperty(i59), fl(this, i59))), s === l ? null : s === n && l === r ? o : (r = l, o = t(n = s, a));
    };
  }
  function $Q(i59, t) {
    var e, n, r, o = "style." + t, s = "end." + o, a;
    return function() {
      var l = Nr(this, i59), c = l.on, d = l.value[o] == null ? a || (a = u3(t)) : void 0;
      (c !== e || r !== d) && (n = (e = c).copy()).on(s, r = d), l.on = n;
    };
  }
  function h3(i59, t, e) {
    var n = (i59 += "") == "transform" ? YT : Wb;
    return t == null ? this.styleTween(i59, HQ(i59, n)).on("end.style." + i59, u3(i59)) : typeof t == "function" ? this.styleTween(i59, WQ(i59, n, eh(this, "style." + i59, t))).each($Q(this._id, i59)) : this.styleTween(i59, jQ(i59, n, t), e).on("end.style." + i59, null);
  }
  function qQ(i59, t, e) {
    return function(n) {
      this.style.setProperty(i59, t.call(this, n), e);
    };
  }
  function YQ(i59, t, e) {
    var n, r;
    function o() {
      var s = t.apply(this, arguments);
      return s !== r && (n = (r = s) && qQ(i59, s, e)), n;
    }
    return o._value = t, o;
  }
  function p3(i59, t, e) {
    var n = "style." + (i59 += "");
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (t == null) return this.tween(n, null);
    if (typeof t != "function") throw new Error();
    return this.tween(n, YQ(i59, t, e ?? ""));
  }
  function XQ(i59) {
    return function() {
      this.textContent = i59;
    };
  }
  function ZQ(i59) {
    return function() {
      var t = i59(this);
      this.textContent = t ?? "";
    };
  }
  function f3(i59) {
    return this.tween("text", typeof i59 == "function" ? ZQ(eh(this, "text", i59)) : XQ(i59 == null ? "" : i59 + ""));
  }
  function QQ(i59) {
    return function(t) {
      this.textContent = i59.call(this, t);
    };
  }
  function KQ(i59) {
    var t, e;
    function n() {
      var r = i59.apply(this, arguments);
      return r !== e && (t = (e = r) && QQ(r)), t;
    }
    return n._value = i59, n;
  }
  function m3(i59) {
    var t = "text";
    if (arguments.length < 1) return (t = this.tween(t)) && t._value;
    if (i59 == null) return this.tween(t, null);
    if (typeof i59 != "function") throw new Error();
    return this.tween(t, KQ(i59));
  }
  function g3() {
    for (var i59 = this._name, t = this._id, e = $b(), n = this._groups, r = n.length, o = 0; o < r; ++o) for (var s = n[o], a = s.length, l, c = 0; c < a; ++c) if (l = s[c]) {
      var d = Pi(l, t);
      ml(l, i59, e, c, s, { time: d.time + d.delay + d.duration, delay: 0, duration: d.duration, ease: d.ease });
    }
    return new yr(n, this._parents, i59, e);
  }
  function _3() {
    var i59, t, e = this, n = e._id, r = e.size();
    return new Promise(function(o, s) {
      var a = { value: s }, l = { value: function() {
        --r === 0 && o();
      } };
      e.each(function() {
        var c = Nr(this, n), d = c.on;
        d !== i59 && (t = (i59 = d).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), c.on = t;
      });
    });
  }
  var JQ = 0;
  function yr(i59, t, e, n) {
    this._groups = i59, this._parents = t, this._name = e, this._id = n;
  }
  function eI(i59) {
    return wa().transition(i59);
  }
  function $b() {
    return ++JQ;
  }
  var th = wa.prototype;
  yr.prototype = eI.prototype = { constructor: yr, select: l3, selectAll: c3, filter: r3, merge: o3, selection: d3, transition: g3, call: th.call, nodes: th.nodes, node: th.node, size: th.size, empty: th.empty, each: th.each, on: s3, attr: JF, attrTween: e3, style: h3, styleTween: p3, text: f3, textTween: m3, remove: a3, tween: KF, delay: t3, duration: n3, ease: i32, end: _3 };
  function qb(i59) {
    return ((i59 *= 2) <= 1 ? i59 * i59 * i59 : (i59 -= 2) * i59 * i59 + 2) / 2;
  }
  function v3(i59) {
    return (Math.pow(2, -10 * i59) - 9765625e-10) * 1.0009775171065494;
  }
  function tI(i59) {
    return 1 - v3(i59);
  }
  var nI = { time: null, delay: 0, duration: 250, ease: qb };
  function tK(i59, t) {
    for (var e; !(e = i59.__transition) || !(e = e[t]); ) if (!(i59 = i59.parentNode)) return nI.time = Ju(), nI;
    return e;
  }
  function y3(i59) {
    var t, e;
    i59 instanceof yr ? (t = i59._id, i59 = i59._name) : (t = $b(), (e = nI).time = Ju(), i59 = i59 == null ? null : i59 + "");
    for (var n = this._groups, r = n.length, o = 0; o < r; ++o) for (var s = n[o], a = s.length, l, c = 0; c < a; ++c) (l = s[c]) && ml(l, i59, t, c, s, e || tK(l, t));
    return new yr(n, this._parents, i59, t);
  }
  wa.prototype.interrupt = QF;
  wa.prototype.transition = y3;
  function b3(i59) {
    return [+i59[0], +i59[1]];
  }
  function nK(i59) {
    return [b3(i59[0]), b3(i59[1])];
  }
  var lOe = { name: "x", handles: ["w", "e"].map(iI), input: function(i59, t) {
    return i59 == null ? null : [[+i59[0], t[0][1]], [+i59[1], t[1][1]]];
  }, output: function(i59) {
    return i59 && [i59[0][0], i59[1][0]];
  } };
  var cOe = { name: "y", handles: ["n", "s"].map(iI), input: function(i59, t) {
    return i59 == null ? null : [[t[0][0], +i59[0]], [t[1][0], +i59[1]]];
  }, output: function(i59) {
    return i59 && [i59[0][1], i59[1][1]];
  } };
  var dOe = { name: "xy", handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(iI), input: function(i59) {
    return i59 == null ? null : nK(i59);
  }, output: function(i59) {
    return i59;
  } };
  function iI(i59) {
    return { type: i59 };
  }
  var x3 = Math.PI;
  var iK = x3 / 2;
  var rK = x3 * 2;
  var oK = Array.prototype.slice;
  var rI = Math.PI;
  var oI = 2 * rI;
  var Qc = 1e-6;
  var sK = oI - Qc;
  function sI() {
    this._x0 = this._y0 = this._x1 = this._y1 = null, this._ = "";
  }
  function w3() {
    return new sI();
  }
  sI.prototype = w3.prototype = { constructor: sI, moveTo: function(i59, t) {
    this._ += "M" + (this._x0 = this._x1 = +i59) + "," + (this._y0 = this._y1 = +t);
  }, closePath: function() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }, lineTo: function(i59, t) {
    this._ += "L" + (this._x1 = +i59) + "," + (this._y1 = +t);
  }, quadraticCurveTo: function(i59, t, e, n) {
    this._ += "Q" + +i59 + "," + +t + "," + (this._x1 = +e) + "," + (this._y1 = +n);
  }, bezierCurveTo: function(i59, t, e, n, r, o) {
    this._ += "C" + +i59 + "," + +t + "," + +e + "," + +n + "," + (this._x1 = +r) + "," + (this._y1 = +o);
  }, arcTo: function(i59, t, e, n, r) {
    i59 = +i59, t = +t, e = +e, n = +n, r = +r;
    var o = this._x1, s = this._y1, a = e - i59, l = n - t, c = o - i59, d = s - t, u = c * c + d * d;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) this._ += "M" + (this._x1 = i59) + "," + (this._y1 = t);
    else if (u > Qc) if (!(Math.abs(d * a - l * c) > Qc) || !r) this._ += "L" + (this._x1 = i59) + "," + (this._y1 = t);
    else {
      var h = e - o, p = n - s, f = a * a + l * l, m = h * h + p * p, v = Math.sqrt(f), _ = Math.sqrt(u), g = r * Math.tan((rI - Math.acos((f + u - m) / (2 * v * _))) / 2), y = g / _, w = g / v;
      Math.abs(y - 1) > Qc && (this._ += "L" + (i59 + y * c) + "," + (t + y * d)), this._ += "A" + r + "," + r + ",0,0," + +(d * h > c * p) + "," + (this._x1 = i59 + w * a) + "," + (this._y1 = t + w * l);
    }
  }, arc: function(i59, t, e, n, r, o) {
    i59 = +i59, t = +t, e = +e, o = !!o;
    var s = e * Math.cos(n), a = e * Math.sin(n), l = i59 + s, c = t + a, d = 1 ^ o, u = o ? n - r : r - n;
    if (e < 0) throw new Error("negative radius: " + e);
    this._x1 === null ? this._ += "M" + l + "," + c : (Math.abs(this._x1 - l) > Qc || Math.abs(this._y1 - c) > Qc) && (this._ += "L" + l + "," + c), e && (u < 0 && (u = u % oI + oI), u > sK ? this._ += "A" + e + "," + e + ",0,1," + d + "," + (i59 - s) + "," + (t - a) + "A" + e + "," + e + ",0,1," + d + "," + (this._x1 = l) + "," + (this._y1 = c) : u > Qc && (this._ += "A" + e + "," + e + ",0," + +(u >= rI) + "," + d + "," + (this._x1 = i59 + e * Math.cos(r)) + "," + (this._y1 = t + e * Math.sin(r))));
  }, rect: function(i59, t, e, n) {
    this._ += "M" + (this._x0 = this._x1 = +i59) + "," + (this._y0 = this._y1 = +t) + "h" + +e + "v" + +n + "h" + -e + "Z";
  }, toString: function() {
    return this._;
  } };
  var aI = w3;
  var lo = "$";
  function Yb() {
  }
  Yb.prototype = C3.prototype = { constructor: Yb, has: function(i59) {
    return lo + i59 in this;
  }, get: function(i59) {
    return this[lo + i59];
  }, set: function(i59, t) {
    return this[lo + i59] = t, this;
  }, remove: function(i59) {
    var t = lo + i59;
    return t in this && delete this[t];
  }, clear: function() {
    for (var i59 in this) i59[0] === lo && delete this[i59];
  }, keys: function() {
    var i59 = [];
    for (var t in this) t[0] === lo && i59.push(t.slice(1));
    return i59;
  }, values: function() {
    var i59 = [];
    for (var t in this) t[0] === lo && i59.push(this[t]);
    return i59;
  }, entries: function() {
    var i59 = [];
    for (var t in this) t[0] === lo && i59.push({ key: t.slice(1), value: this[t] });
    return i59;
  }, size: function() {
    var i59 = 0;
    for (var t in this) t[0] === lo && ++i59;
    return i59;
  }, empty: function() {
    for (var i59 in this) if (i59[0] === lo) return false;
    return true;
  }, each: function(i59) {
    for (var t in this) t[0] === lo && i59(this[t], t.slice(1), this);
  } };
  function C3(i59, t) {
    var e = new Yb();
    if (i59 instanceof Yb) i59.each(function(a, l) {
      e.set(l, a);
    });
    else if (Array.isArray(i59)) {
      var n = -1, r = i59.length, o;
      if (t == null) for (; ++n < r; ) e.set(n, i59[n]);
      else for (; ++n < r; ) e.set(t(o = i59[n], n, i59), o);
    } else if (i59) for (var s in i59) e.set(s, i59[s]);
    return e;
  }
  var Kc = C3;
  function Xb() {
  }
  var Jc = Kc.prototype;
  Xb.prototype = aK.prototype = { constructor: Xb, has: Jc.has, add: function(i59) {
    return i59 += "", this[lo + i59] = i59, this;
  }, remove: Jc.remove, clear: Jc.clear, values: Jc.keys, size: Jc.size, empty: Jc.empty, each: Jc.each };
  function aK(i59, t) {
    var e = new Xb();
    if (i59 instanceof Xb) i59.each(function(o) {
      e.add(o);
    });
    else if (i59) {
      var n = -1, r = i59.length;
      if (t == null) for (; ++n < r; ) e.add(i59[n]);
      else for (; ++n < r; ) e.add(t(i59[n], n, i59));
    }
    return e;
  }
  var lK = Array.prototype;
  var S3 = lK.slice;
  var YAe = Math.PI * (3 - Math.sqrt(5));
  function Oo() {
    return Math.random();
  }
  var uK = function i21(t) {
    function e(n, r) {
      return n = n == null ? 0 : +n, r = r == null ? 1 : +r, arguments.length === 1 ? (r = n, n = 0) : r -= n, function() {
        return t() * r + n;
      };
    }
    return e.source = i21, e;
  }(Oo);
  var lI = function i23(t) {
    function e(n, r) {
      var o, s;
      return n = n == null ? 0 : +n, r = r == null ? 1 : +r, function() {
        var a;
        if (o != null) a = o, o = null;
        else do
          o = t() * 2 - 1, a = t() * 2 - 1, s = o * o + a * a;
        while (!s || s > 1);
        return n + r * a * Math.sqrt(-2 * Math.log(s) / s);
      };
    }
    return e.source = i23, e;
  }(Oo);
  var hK = function i24(t) {
    function e() {
      var n = lI.source(t).apply(this, arguments);
      return function() {
        return Math.exp(n());
      };
    }
    return e.source = i24, e;
  }(Oo);
  var cI = function i25(t) {
    function e(n) {
      return function() {
        for (var r = 0, o = 0; o < n; ++o) r += t();
        return r;
      };
    }
    return e.source = i25, e;
  }(Oo);
  var pK = function i26(t) {
    function e(n) {
      var r = cI.source(t)(n);
      return function() {
        return r() / n;
      };
    }
    return e.source = i26, e;
  }(Oo);
  var fK = function i27(t) {
    function e(n) {
      return function() {
        return -Math.log(1 - t()) / n;
      };
    }
    return e.source = i27, e;
  }(Oo);
  var E3 = Array.prototype;
  var dI = E3.map;
  var lm = E3.slice;
  var bK = 1e3;
  var xK = bK * 60;
  var wK = xK * 60;
  var uI = wK * 24;
  var e2e = uI * 7;
  var t2e = uI * 30;
  var n2e = uI * 365;
  function um(i59) {
    return function() {
      return i59;
    };
  }
  function D3(i59) {
    this._context = i59;
  }
  D3.prototype = { areaStart: function() {
    this._line = 0;
  }, areaEnd: function() {
    this._line = NaN;
  }, lineStart: function() {
    this._point = 0;
  }, lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }, point: function(i59, t) {
    switch (i59 = +i59, t = +t, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(i59, t) : this._context.moveTo(i59, t);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(i59, t);
        break;
    }
  } };
  function P3(i59) {
    return new D3(i59);
  }
  function R3(i59) {
    return i59[0];
  }
  function O3(i59) {
    return i59[1];
  }
  function nh() {
    var i59 = R3, t = O3, e = um(true), n = null, r = P3, o = null;
    function s(a) {
      var l, c = a.length, d, u = false, h;
      for (n == null && (o = r(h = aI())), l = 0; l <= c; ++l) !(l < c && e(d = a[l], l, a)) === u && ((u = !u) ? o.lineStart() : o.lineEnd()), u && o.point(+i59(d, l, a), +t(d, l, a));
      if (h) return o = null, h + "" || null;
    }
    return s.x = function(a) {
      return arguments.length ? (i59 = typeof a == "function" ? a : um(+a), s) : i59;
    }, s.y = function(a) {
      return arguments.length ? (t = typeof a == "function" ? a : um(+a), s) : t;
    }, s.defined = function(a) {
      return arguments.length ? (e = typeof a == "function" ? a : um(!!a), s) : e;
    }, s.curve = function(a) {
      return arguments.length ? (r = a, n != null && (o = r(n)), s) : r;
    }, s.context = function(a) {
      return arguments.length ? (a == null ? n = o = null : o = r(n = a), s) : n;
    }, s;
  }
  function A3(i59) {
    return i59 < 0 ? -1 : 1;
  }
  function N3(i59, t, e) {
    var n = i59._x1 - i59._x0, r = t - i59._x1, o = (i59._y1 - i59._y0) / (n || r < 0 && -0), s = (e - i59._y1) / (r || n < 0 && -0), a = (o * r + s * n) / (n + r);
    return (A3(o) + A3(s)) * Math.min(Math.abs(o), Math.abs(s), 0.5 * Math.abs(a)) || 0;
  }
  function k3(i59, t) {
    var e = i59._x1 - i59._x0;
    return e ? (3 * (i59._y1 - i59._y0) / e - t) / 2 : t;
  }
  function hI(i59, t, e) {
    var n = i59._x0, r = i59._y0, o = i59._x1, s = i59._y1, a = (o - n) / 3;
    i59._context.bezierCurveTo(n + a, r + a * t, o - a, s - a * e, o, s);
  }
  function pI(i59) {
    this._context = i59;
  }
  pI.prototype = { areaStart: function() {
    this._line = 0;
  }, areaEnd: function() {
    this._line = NaN;
  }, lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0;
  }, lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        hI(this, this._t0, k3(this, this._t0));
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  }, point: function(i59, t) {
    var e = NaN;
    if (i59 = +i59, t = +t, !(i59 === this._x1 && t === this._y1)) {
      switch (this._point) {
        case 0:
          this._point = 1, this._line ? this._context.lineTo(i59, t) : this._context.moveTo(i59, t);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3, hI(this, k3(this, e = N3(this, i59, t)), e);
          break;
        default:
          hI(this, this._t0, e = N3(this, i59, t));
          break;
      }
      this._x0 = this._x1, this._x1 = i59, this._y0 = this._y1, this._y1 = t, this._t0 = e;
    }
  } };
  function L3(i59) {
    this._context = new F3(i59);
  }
  (L3.prototype = Object.create(pI.prototype)).point = function(i59, t) {
    pI.prototype.point.call(this, t, i59);
  };
  function F3(i59) {
    this._context = i59;
  }
  F3.prototype = { moveTo: function(i59, t) {
    this._context.moveTo(t, i59);
  }, closePath: function() {
    this._context.closePath();
  }, lineTo: function(i59, t) {
    this._context.lineTo(t, i59);
  }, bezierCurveTo: function(i59, t, e, n, r, o) {
    this._context.bezierCurveTo(t, i59, n, e, o, r);
  } };
  function ih(i59) {
    return new L3(i59);
  }
  function fI() {
    this._ = null;
  }
  function rh(i59) {
    i59.U = i59.C = i59.L = i59.R = i59.P = i59.N = null;
  }
  fI.prototype = { constructor: fI, insert: function(i59, t) {
    var e, n, r;
    if (i59) {
      if (t.P = i59, t.N = i59.N, i59.N && (i59.N.P = t), i59.N = t, i59.R) {
        for (i59 = i59.R; i59.L; ) i59 = i59.L;
        i59.L = t;
      } else i59.R = t;
      e = i59;
    } else this._ ? (i59 = B3(this._), t.P = null, t.N = i59, i59.P = i59.L = t, e = i59) : (t.P = t.N = null, this._ = t, e = null);
    for (t.L = t.R = null, t.U = e, t.C = true, i59 = t; e && e.C; ) n = e.U, e === n.L ? (r = n.R, r && r.C ? (e.C = r.C = false, n.C = true, i59 = n) : (i59 === e.R && (hm(this, e), i59 = e, e = i59.U), e.C = false, n.C = true, pm(this, n))) : (r = n.L, r && r.C ? (e.C = r.C = false, n.C = true, i59 = n) : (i59 === e.L && (pm(this, e), i59 = e, e = i59.U), e.C = false, n.C = true, hm(this, n))), e = i59.U;
    this._.C = false;
  }, remove: function(i59) {
    i59.N && (i59.N.P = i59.P), i59.P && (i59.P.N = i59.N), i59.N = i59.P = null;
    var t = i59.U, e, n = i59.L, r = i59.R, o, s;
    if (n ? r ? o = B3(r) : o = n : o = r, t ? t.L === i59 ? t.L = o : t.R = o : this._ = o, n && r ? (s = o.C, o.C = i59.C, o.L = n, n.U = o, o !== r ? (t = o.U, o.U = i59.U, i59 = o.R, t.L = i59, o.R = r, r.U = o) : (o.U = t, t = o, i59 = o.R)) : (s = i59.C, i59 = o), i59 && (i59.U = t), !s) {
      if (i59 && i59.C) {
        i59.C = false;
        return;
      }
      do {
        if (i59 === this._) break;
        if (i59 === t.L) {
          if (e = t.R, e.C && (e.C = false, t.C = true, hm(this, t), e = t.R), e.L && e.L.C || e.R && e.R.C) {
            (!e.R || !e.R.C) && (e.L.C = false, e.C = true, pm(this, e), e = t.R), e.C = t.C, t.C = e.R.C = false, hm(this, t), i59 = this._;
            break;
          }
        } else if (e = t.L, e.C && (e.C = false, t.C = true, pm(this, t), e = t.L), e.L && e.L.C || e.R && e.R.C) {
          (!e.L || !e.L.C) && (e.R.C = false, e.C = true, hm(this, e), e = t.L), e.C = t.C, t.C = e.L.C = false, pm(this, t), i59 = this._;
          break;
        }
        e.C = true, i59 = t, t = t.U;
      } while (!i59.C);
      i59 && (i59.C = false);
    }
  } };
  function hm(i59, t) {
    var e = t, n = t.R, r = e.U;
    r ? r.L === e ? r.L = n : r.R = n : i59._ = n, n.U = r, e.U = n, e.R = n.L, e.R && (e.R.U = e), n.L = e;
  }
  function pm(i59, t) {
    var e = t, n = t.L, r = e.U;
    r ? r.L === e ? r.L = n : r.R = n : i59._ = n, n.U = r, e.U = n, e.L = n.R, e.L && (e.L.U = e), n.R = e;
  }
  function B3(i59) {
    for (; i59.L; ) i59 = i59.L;
    return i59;
  }
  var mI = fI;
  function oh(i59, t, e, n) {
    var r = [null, null], o = Bi.push(r) - 1;
    return r.left = i59, r.right = t, e && fm(r, i59, t, e), n && fm(r, t, i59, n), kr[i59.index].halfedges.push(o), kr[t.index].halfedges.push(o), r;
  }
  function sh(i59, t, e) {
    var n = [t, e];
    return n.left = i59, n;
  }
  function fm(i59, t, e, n) {
    !i59[0] && !i59[1] ? (i59[0] = n, i59.left = t, i59.right = e) : i59.left === e ? i59[1] = n : i59[0] = n;
  }
  function EK(i59, t, e, n, r) {
    var o = i59[0], s = i59[1], a = o[0], l = o[1], c = s[0], d = s[1], u = 0, h = 1, p = c - a, f = d - l, m;
    if (m = t - a, !(!p && m > 0)) {
      if (m /= p, p < 0) {
        if (m < u) return;
        m < h && (h = m);
      } else if (p > 0) {
        if (m > h) return;
        m > u && (u = m);
      }
      if (m = n - a, !(!p && m < 0)) {
        if (m /= p, p < 0) {
          if (m > h) return;
          m > u && (u = m);
        } else if (p > 0) {
          if (m < u) return;
          m < h && (h = m);
        }
        if (m = e - l, !(!f && m > 0)) {
          if (m /= f, f < 0) {
            if (m < u) return;
            m < h && (h = m);
          } else if (f > 0) {
            if (m > h) return;
            m > u && (u = m);
          }
          if (m = r - l, !(!f && m < 0)) {
            if (m /= f, f < 0) {
              if (m > h) return;
              m > u && (u = m);
            } else if (f > 0) {
              if (m < u) return;
              m < h && (h = m);
            }
            return !(u > 0) && !(h < 1) || (u > 0 && (i59[0] = [a + u * p, l + u * f]), h < 1 && (i59[1] = [a + h * p, l + h * f])), true;
          }
        }
      }
    }
  }
  function TK(i59, t, e, n, r) {
    var o = i59[1];
    if (o) return true;
    var s = i59[0], a = i59.left, l = i59.right, c = a[0], d = a[1], u = l[0], h = l[1], p = (c + u) / 2, f = (d + h) / 2, m, v;
    if (h === d) {
      if (p < t || p >= n) return;
      if (c > u) {
        if (!s) s = [p, e];
        else if (s[1] >= r) return;
        o = [p, r];
      } else {
        if (!s) s = [p, r];
        else if (s[1] < e) return;
        o = [p, e];
      }
    } else if (m = (c - u) / (h - d), v = f - m * p, m < -1 || m > 1) if (c > u) {
      if (!s) s = [(e - v) / m, e];
      else if (s[1] >= r) return;
      o = [(r - v) / m, r];
    } else {
      if (!s) s = [(r - v) / m, r];
      else if (s[1] < e) return;
      o = [(e - v) / m, e];
    }
    else if (d < h) {
      if (!s) s = [t, m * t + v];
      else if (s[0] >= n) return;
      o = [n, m * n + v];
    } else {
      if (!s) s = [n, m * n + v];
      else if (s[0] < t) return;
      o = [t, m * t + v];
    }
    return i59[0] = s, i59[1] = o, true;
  }
  function V3(i59, t, e, n) {
    for (var r = Bi.length, o; r--; ) (!TK(o = Bi[r], i59, t, e, n) || !EK(o, i59, t, e, n) || !(Math.abs(o[0][0] - o[1][0]) > Rn || Math.abs(o[0][1] - o[1][1]) > Rn)) && delete Bi[r];
  }
  function z3(i59) {
    return kr[i59.index] = { site: i59, halfedges: [] };
  }
  function IK(i59, t) {
    var e = i59.site, n = t.left, r = t.right;
    return e === r && (r = n, n = e), r ? Math.atan2(r[1] - n[1], r[0] - n[0]) : (e === n ? (n = t[1], r = t[0]) : (n = t[0], r = t[1]), Math.atan2(n[0] - r[0], r[1] - n[1]));
  }
  function gI(i59, t) {
    return t[+(t.left !== i59.site)];
  }
  function DK(i59, t) {
    return t[+(t.left === i59.site)];
  }
  function U3() {
    for (var i59 = 0, t = kr.length, e, n, r, o; i59 < t; ++i59) if ((e = kr[i59]) && (o = (n = e.halfedges).length)) {
      var s = new Array(o), a = new Array(o);
      for (r = 0; r < o; ++r) s[r] = r, a[r] = IK(e, Bi[n[r]]);
      for (s.sort(function(l, c) {
        return a[c] - a[l];
      }), r = 0; r < o; ++r) a[r] = n[s[r]];
      for (r = 0; r < o; ++r) n[r] = a[r];
    }
  }
  function G3(i59, t, e, n) {
    var r = kr.length, o, s, a, l, c, d, u, h, p, f, m, v, _ = true;
    for (o = 0; o < r; ++o) if (s = kr[o]) {
      for (a = s.site, c = s.halfedges, l = c.length; l--; ) Bi[c[l]] || c.splice(l, 1);
      for (l = 0, d = c.length; l < d; ) f = DK(s, Bi[c[l]]), m = f[0], v = f[1], u = gI(s, Bi[c[++l % d]]), h = u[0], p = u[1], (Math.abs(m - h) > Rn || Math.abs(v - p) > Rn) && (c.splice(l, 0, Bi.push(sh(a, f, Math.abs(m - i59) < Rn && n - v > Rn ? [i59, Math.abs(h - i59) < Rn ? p : n] : Math.abs(v - n) < Rn && e - m > Rn ? [Math.abs(p - n) < Rn ? h : e, n] : Math.abs(m - e) < Rn && v - t > Rn ? [e, Math.abs(h - e) < Rn ? p : t] : Math.abs(v - t) < Rn && m - i59 > Rn ? [Math.abs(p - t) < Rn ? h : i59, t] : null)) - 1), ++d);
      d && (_ = false);
    }
    if (_) {
      var g, y, w, E = 1 / 0;
      for (o = 0, _ = null; o < r; ++o) (s = kr[o]) && (a = s.site, g = a[0] - i59, y = a[1] - t, w = g * g + y * y, w < E && (E = w, _ = s));
      if (_) {
        var P = [i59, t], S = [i59, n], A = [e, n], W = [e, t];
        _.halfedges.push(Bi.push(sh(a = _.site, P, S)) - 1, Bi.push(sh(a, S, A)) - 1, Bi.push(sh(a, A, W)) - 1, Bi.push(sh(a, W, P)) - 1);
      }
    }
    for (o = 0; o < r; ++o) (s = kr[o]) && (s.halfedges.length || delete kr[o]);
  }
  var H3 = [];
  var Qb;
  function PK() {
    rh(this), this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function ed(i59) {
    var t = i59.P, e = i59.N;
    if (!(!t || !e)) {
      var n = t.site, r = i59.site, o = e.site;
      if (n !== o) {
        var s = r[0], a = r[1], l = n[0] - s, c = n[1] - a, d = o[0] - s, u = o[1] - a, h = 2 * (l * u - c * d);
        if (!(h >= -j3)) {
          var p = l * l + c * c, f = d * d + u * u, m = (u * p - c * f) / h, v = (l * f - d * p) / h, _ = H3.pop() || new PK();
          _.arc = i59, _.site = r, _.x = m + s, _.y = (_.cy = v + a) + Math.sqrt(m * m + v * v), i59.circle = _;
          for (var g = null, y = ah._; y; ) if (_.y < y.y || _.y === y.y && _.x <= y.x) if (y.L) y = y.L;
          else {
            g = y.P;
            break;
          }
          else if (y.R) y = y.R;
          else {
            g = y;
            break;
          }
          ah.insert(g, _), g || (Qb = _);
        }
      }
    }
  }
  function td(i59) {
    var t = i59.circle;
    t && (t.P || (Qb = t.N), ah.remove(t), H3.push(t), rh(t), i59.circle = null);
  }
  var $3 = [];
  function RK() {
    rh(this), this.edge = this.site = this.circle = null;
  }
  function W3(i59) {
    var t = $3.pop() || new RK();
    return t.site = i59, t;
  }
  function _I(i59) {
    td(i59), nd.remove(i59), $3.push(i59), rh(i59);
  }
  function q3(i59) {
    var t = i59.circle, e = t.x, n = t.cy, r = [e, n], o = i59.P, s = i59.N, a = [i59];
    _I(i59);
    for (var l = o; l.circle && Math.abs(e - l.circle.x) < Rn && Math.abs(n - l.circle.cy) < Rn; ) o = l.P, a.unshift(l), _I(l), l = o;
    a.unshift(l), td(l);
    for (var c = s; c.circle && Math.abs(e - c.circle.x) < Rn && Math.abs(n - c.circle.cy) < Rn; ) s = c.N, a.push(c), _I(c), c = s;
    a.push(c), td(c);
    var d = a.length, u;
    for (u = 1; u < d; ++u) c = a[u], l = a[u - 1], fm(c.edge, l.site, c.site, r);
    l = a[0], c = a[d - 1], c.edge = oh(l.site, c.site, null, r), ed(l), ed(c);
  }
  function Y3(i59) {
    for (var t = i59[0], e = i59[1], n, r, o, s, a = nd._; a; ) if (o = X3(a, e) - t, o > Rn) a = a.L;
    else if (s = t - OK(a, e), s > Rn) {
      if (!a.R) {
        n = a;
        break;
      }
      a = a.R;
    } else {
      o > -Rn ? (n = a.P, r = a) : s > -Rn ? (n = a, r = a.N) : n = r = a;
      break;
    }
    z3(i59);
    var l = W3(i59);
    if (nd.insert(n, l), !(!n && !r)) {
      if (n === r) {
        td(n), r = W3(n.site), nd.insert(l, r), l.edge = r.edge = oh(n.site, l.site), ed(n), ed(r);
        return;
      }
      if (!r) {
        l.edge = oh(n.site, l.site);
        return;
      }
      td(n), td(r);
      var c = n.site, d = c[0], u = c[1], h = i59[0] - d, p = i59[1] - u, f = r.site, m = f[0] - d, v = f[1] - u, _ = 2 * (h * v - p * m), g = h * h + p * p, y = m * m + v * v, w = [(v * g - p * y) / _ + d, (h * y - m * g) / _ + u];
      fm(r.edge, c, f, w), l.edge = oh(c, i59, null, w), r.edge = oh(i59, f, null, w), ed(n), ed(r);
    }
  }
  function X3(i59, t) {
    var e = i59.site, n = e[0], r = e[1], o = r - t;
    if (!o) return n;
    var s = i59.P;
    if (!s) return -1 / 0;
    e = s.site;
    var a = e[0], l = e[1], c = l - t;
    if (!c) return a;
    var d = a - n, u = 1 / o - 1 / c, h = d / c;
    return u ? (-h + Math.sqrt(h * h - 2 * u * (d * d / (-2 * c) - l + c / 2 + r - o / 2))) / u + n : (n + a) / 2;
  }
  function OK(i59, t) {
    var e = i59.N;
    if (e) return X3(e, t);
    var n = i59.site;
    return n[1] === t ? n[0] : 1 / 0;
  }
  var Rn = 1e-6;
  var j3 = 1e-12;
  var nd;
  var kr;
  var ah;
  var Bi;
  function AK(i59, t, e) {
    return (i59[0] - e[0]) * (t[1] - i59[1]) - (i59[0] - t[0]) * (e[1] - i59[1]);
  }
  function NK(i59, t) {
    return t[1] - i59[1] || t[0] - i59[0];
  }
  function Kb(i59, t) {
    var e = i59.sort(NK).pop(), n, r, o;
    for (Bi = [], kr = new Array(i59.length), nd = new mI(), ah = new mI(); ; ) if (o = Qb, e && (!o || e[1] < o.y || e[1] === o.y && e[0] < o.x)) (e[0] !== n || e[1] !== r) && (Y3(e), n = e[0], r = e[1]), e = i59.pop();
    else if (o) q3(o.arc);
    else break;
    if (U3(), t) {
      var s = +t[0][0], a = +t[0][1], l = +t[1][0], c = +t[1][1];
      V3(s, a, l, c), G3(s, a, l, c);
    }
    this.edges = Bi, this.cells = kr, nd = ah = Bi = kr = null;
  }
  Kb.prototype = { constructor: Kb, polygons: function() {
    var i59 = this.edges;
    return this.cells.map(function(t) {
      var e = t.halfedges.map(function(n) {
        return gI(t, i59[n]);
      });
      return e.data = t.site.data, e;
    });
  }, triangles: function() {
    var i59 = [], t = this.edges;
    return this.cells.forEach(function(e, n) {
      if (a = (o = e.halfedges).length) for (var r = e.site, o, s = -1, a, l, c = t[o[a - 1]], d = c.left === r ? c.right : c.left; ++s < a; ) l = d, c = t[o[s]], d = c.left === r ? c.right : c.left, l && d && n < l.index && n < d.index && AK(r, l, d) < 0 && i59.push([r.data, l.data, d.data]);
    }), i59;
  }, links: function() {
    return this.edges.filter(function(i59) {
      return i59.right;
    }).map(function(i59) {
      return { source: i59.left.data, target: i59.right.data };
    });
  }, find: function(i59, t, e) {
    for (var n = this, r, o = n._found || 0, s = n.cells.length, a; !(a = n.cells[o]); ) if (++o >= s) return null;
    var l = i59 - a.site[0], c = t - a.site[1], d = l * l + c * c;
    do
      a = n.cells[r = o], o = null, a.halfedges.forEach(function(u) {
        var h = n.edges[u], p = h.left;
        if (!((p === a.site || !p) && !(p = h.right))) {
          var f = i59 - p[0], m = t - p[1], v = f * f + m * m;
          v < d && (d = v, o = p.index);
        }
      });
    while (o !== null);
    return n._found = r, e == null || d <= e * e ? a.site : null;
  } };
  function mm(i59) {
    return function() {
      return i59;
    };
  }
  function vI(i59, t, e) {
    this.target = i59, this.type = t, this.transform = e;
  }
  function ks(i59, t, e) {
    this.k = i59, this.x = t, this.y = e;
  }
  ks.prototype = { constructor: ks, scale: function(i59) {
    return i59 === 1 ? this : new ks(this.k * i59, this.x, this.y);
  }, translate: function(i59, t) {
    return i59 === 0 & t === 0 ? this : new ks(this.k, this.x + this.k * i59, this.y + this.k * t);
  }, apply: function(i59) {
    return [i59[0] * this.k + this.x, i59[1] * this.k + this.y];
  }, applyX: function(i59) {
    return i59 * this.k + this.x;
  }, applyY: function(i59) {
    return i59 * this.k + this.y;
  }, invert: function(i59) {
    return [(i59[0] - this.x) / this.k, (i59[1] - this.y) / this.k];
  }, invertX: function(i59) {
    return (i59 - this.x) / this.k;
  }, invertY: function(i59) {
    return (i59 - this.y) / this.k;
  }, rescaleX: function(i59) {
    return i59.copy().domain(i59.range().map(this.invertX, this).map(i59.invert, i59));
  }, rescaleY: function(i59) {
    return i59.copy().domain(i59.range().map(this.invertY, this).map(i59.invert, i59));
  }, toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  } };
  var id = new ks(1, 0, 0);
  yI.prototype = ks.prototype;
  function yI(i59) {
    for (; !i59.__zoom; ) if (!(i59 = i59.parentNode)) return id;
    return i59.__zoom;
  }
  function Jb() {
    pt.stopImmediatePropagation();
  }
  function lh() {
    pt.preventDefault(), pt.stopImmediatePropagation();
  }
  function kK() {
    return !pt.ctrlKey && !pt.button;
  }
  function LK() {
    var i59 = this;
    return i59 instanceof SVGElement ? (i59 = i59.ownerSVGElement || i59, i59.hasAttribute("viewBox") ? (i59 = i59.viewBox.baseVal, [[i59.x, i59.y], [i59.x + i59.width, i59.y + i59.height]]) : [[0, 0], [i59.width.baseVal.value, i59.height.baseVal.value]]) : [[0, 0], [i59.clientWidth, i59.clientHeight]];
  }
  function Z3() {
    return this.__zoom || id;
  }
  function FK() {
    return -pt.deltaY * (pt.deltaMode === 1 ? 0.05 : pt.deltaMode ? 1 : 2e-3);
  }
  function BK() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function VK(i59, t, e) {
    var n = i59.invertX(t[0][0]) - e[0][0], r = i59.invertX(t[1][0]) - e[1][0], o = i59.invertY(t[0][1]) - e[0][1], s = i59.invertY(t[1][1]) - e[1][1];
    return i59.translate(r > n ? (n + r) / 2 : Math.min(0, n) || Math.max(0, r), s > o ? (o + s) / 2 : Math.min(0, o) || Math.max(0, s));
  }
  function bI() {
    var i59 = kK, t = LK, e = VK, n = FK, r = BK, o = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, l = QT, c = Hf("start", "zoom", "end"), d, u, h = 500, p = 150, f = 0;
    function m(I) {
      I.property("__zoom", Z3).on("wheel.zoom", P).on("mousedown.zoom", S).on("dblclick.zoom", A).filter(r).on("touchstart.zoom", W).on("touchmove.zoom", H).on("touchend.zoom touchcancel.zoom", O).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    m.transform = function(I, F, j) {
      var $ = I.selection ? I.selection() : I;
      $.property("__zoom", Z3), I !== $ ? y(I, F, j) : $.interrupt().each(function() {
        w(this, arguments).start().zoom(null, typeof F == "function" ? F.apply(this, arguments) : F).end();
      });
    }, m.scaleBy = function(I, F, j) {
      m.scaleTo(I, function() {
        var $ = this.__zoom.k, k = typeof F == "function" ? F.apply(this, arguments) : F;
        return $ * k;
      }, j);
    }, m.scaleTo = function(I, F, j) {
      m.transform(I, function() {
        var $ = t.apply(this, arguments), k = this.__zoom, z = j == null ? g($) : typeof j == "function" ? j.apply(this, arguments) : j, R = k.invert(z), V = typeof F == "function" ? F.apply(this, arguments) : F;
        return e(_(v(k, V), z, R), $, s);
      }, j);
    }, m.translateBy = function(I, F, j) {
      m.transform(I, function() {
        return e(this.__zoom.translate(typeof F == "function" ? F.apply(this, arguments) : F, typeof j == "function" ? j.apply(this, arguments) : j), t.apply(this, arguments), s);
      });
    }, m.translateTo = function(I, F, j, $) {
      m.transform(I, function() {
        var k = t.apply(this, arguments), z = this.__zoom, R = $ == null ? g(k) : typeof $ == "function" ? $.apply(this, arguments) : $;
        return e(id.translate(R[0], R[1]).scale(z.k).translate(typeof F == "function" ? -F.apply(this, arguments) : -F, typeof j == "function" ? -j.apply(this, arguments) : -j), k, s);
      }, $);
    };
    function v(I, F) {
      return F = Math.max(o[0], Math.min(o[1], F)), F === I.k ? I : new ks(F, I.x, I.y);
    }
    function _(I, F, j) {
      var $ = F[0] - j[0] * I.k, k = F[1] - j[1] * I.k;
      return $ === I.x && k === I.y ? I : new ks(I.k, $, k);
    }
    function g(I) {
      return [(+I[0][0] + +I[1][0]) / 2, (+I[0][1] + +I[1][1]) / 2];
    }
    function y(I, F, j) {
      I.on("start.zoom", function() {
        w(this, arguments).start();
      }).on("interrupt.zoom end.zoom", function() {
        w(this, arguments).end();
      }).tween("zoom", function() {
        var $ = this, k = arguments, z = w($, k), R = t.apply($, k), V = j == null ? g(R) : typeof j == "function" ? j.apply($, k) : j, ie = Math.max(R[1][0] - R[0][0], R[1][1] - R[0][1]), re = $.__zoom, Re = typeof F == "function" ? F.apply($, k) : F, ne = l(re.invert(V).concat(ie / re.k), Re.invert(V).concat(ie / Re.k));
        return function(oe) {
          if (oe === 1) oe = Re;
          else {
            var Be = ne(oe), me = ie / Be[2];
            oe = new ks(me, V[0] - Be[0] * me, V[1] - Be[1] * me);
          }
          z.zoom(null, oe);
        };
      });
    }
    function w(I, F, j) {
      return !j && I.__zooming || new E(I, F);
    }
    function E(I, F) {
      this.that = I, this.args = F, this.active = 0, this.extent = t.apply(I, F), this.taps = 0;
    }
    E.prototype = { start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    }, zoom: function(I, F) {
      return this.mouse && I !== "mouse" && (this.mouse[1] = F.invert(this.mouse[0])), this.touch0 && I !== "touch" && (this.touch0[1] = F.invert(this.touch0[0])), this.touch1 && I !== "touch" && (this.touch1[1] = F.invert(this.touch1[0])), this.that.__zoom = F, this.emit("zoom"), this;
    }, end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    }, emit: function(I) {
      LT(new vI(m, I, this.that.__zoom), c.apply, c, [I, this.that, this.args]);
    } };
    function P() {
      if (!i59.apply(this, arguments)) return;
      var I = w(this, arguments), F = this.__zoom, j = Math.max(o[0], Math.min(o[1], F.k * Math.pow(2, n.apply(this, arguments)))), $ = Xu(this);
      if (I.wheel) (I.mouse[0][0] !== $[0] || I.mouse[0][1] !== $[1]) && (I.mouse[1] = F.invert(I.mouse[0] = $)), clearTimeout(I.wheel);
      else {
        if (F.k === j) return;
        I.mouse = [$, F.invert($)], gl(this), I.start();
      }
      lh(), I.wheel = setTimeout(k, p), I.zoom("mouse", e(_(v(F, j), I.mouse[0], I.mouse[1]), I.extent, s));
      function k() {
        I.wheel = null, I.end();
      }
    }
    function S() {
      if (u || !i59.apply(this, arguments)) return;
      var I = w(this, arguments, true), F = Ro(pt.view).on("mousemove.zoom", z, true).on("mouseup.zoom", R, true), j = Xu(this), $ = pt.clientX, k = pt.clientY;
      BT(pt.view), Jb(), I.mouse = [j, this.__zoom.invert(j)], gl(this), I.start();
      function z() {
        if (lh(), !I.moved) {
          var V = pt.clientX - $, ie = pt.clientY - k;
          I.moved = V * V + ie * ie > f;
        }
        I.zoom("mouse", e(_(I.that.__zoom, I.mouse[0] = Xu(I.that), I.mouse[1]), I.extent, s));
      }
      function R() {
        F.on("mousemove.zoom mouseup.zoom", null), VT(pt.view, I.moved), lh(), I.end();
      }
    }
    function A() {
      if (i59.apply(this, arguments)) {
        var I = this.__zoom, F = Xu(this), j = I.invert(F), $ = I.k * (pt.shiftKey ? 0.5 : 2), k = e(_(v(I, $), F, j), t.apply(this, arguments), s);
        lh(), a > 0 ? Ro(this).transition().duration(a).call(y, k, F) : Ro(this).call(m.transform, k);
      }
    }
    function W() {
      if (i59.apply(this, arguments)) {
        var I = pt.touches, F = I.length, j = w(this, arguments, pt.changedTouches.length === F), $, k, z, R;
        for (Jb(), k = 0; k < F; ++k) z = I[k], R = Db(this, I, z.identifier), R = [R, this.__zoom.invert(R), z.identifier], j.touch0 ? !j.touch1 && j.touch0[2] !== R[2] && (j.touch1 = R, j.taps = 0) : (j.touch0 = R, $ = true, j.taps = 1 + !!d);
        d && (d = clearTimeout(d)), $ && (j.taps < 2 && (d = setTimeout(function() {
          d = null;
        }, h)), gl(this), j.start());
      }
    }
    function H() {
      if (this.__zooming) {
        var I = w(this, arguments), F = pt.changedTouches, j = F.length, $, k, z, R;
        for (lh(), d && (d = clearTimeout(d)), I.taps = 0, $ = 0; $ < j; ++$) k = F[$], z = Db(this, F, k.identifier), I.touch0 && I.touch0[2] === k.identifier ? I.touch0[0] = z : I.touch1 && I.touch1[2] === k.identifier && (I.touch1[0] = z);
        if (k = I.that.__zoom, I.touch1) {
          var V = I.touch0[0], ie = I.touch0[1], re = I.touch1[0], Re = I.touch1[1], ne = (ne = re[0] - V[0]) * ne + (ne = re[1] - V[1]) * ne, oe = (oe = Re[0] - ie[0]) * oe + (oe = Re[1] - ie[1]) * oe;
          k = v(k, Math.sqrt(ne / oe)), z = [(V[0] + re[0]) / 2, (V[1] + re[1]) / 2], R = [(ie[0] + Re[0]) / 2, (ie[1] + Re[1]) / 2];
        } else if (I.touch0) z = I.touch0[0], R = I.touch0[1];
        else return;
        I.zoom("touch", e(_(k, z, R), I.extent, s));
      }
    }
    function O() {
      if (this.__zooming) {
        var I = w(this, arguments), F = pt.changedTouches, j = F.length, $, k;
        for (Jb(), u && clearTimeout(u), u = setTimeout(function() {
          u = null;
        }, h), $ = 0; $ < j; ++$) k = F[$], I.touch0 && I.touch0[2] === k.identifier ? delete I.touch0 : I.touch1 && I.touch1[2] === k.identifier && delete I.touch1;
        if (I.touch1 && !I.touch0 && (I.touch0 = I.touch1, delete I.touch1), I.touch0) I.touch0[1] = this.__zoom.invert(I.touch0[0]);
        else if (I.end(), I.taps === 2) {
          var z = Ro(this).on("dblclick.zoom");
          z && z.apply(this, arguments);
        }
      }
    }
    return m.wheelDelta = function(I) {
      return arguments.length ? (n = typeof I == "function" ? I : mm(+I), m) : n;
    }, m.filter = function(I) {
      return arguments.length ? (i59 = typeof I == "function" ? I : mm(!!I), m) : i59;
    }, m.touchable = function(I) {
      return arguments.length ? (r = typeof I == "function" ? I : mm(!!I), m) : r;
    }, m.extent = function(I) {
      return arguments.length ? (t = typeof I == "function" ? I : mm([[+I[0][0], +I[0][1]], [+I[1][0], +I[1][1]]]), m) : t;
    }, m.scaleExtent = function(I) {
      return arguments.length ? (o[0] = +I[0], o[1] = +I[1], m) : [o[0], o[1]];
    }, m.translateExtent = function(I) {
      return arguments.length ? (s[0][0] = +I[0][0], s[1][0] = +I[1][0], s[0][1] = +I[0][1], s[1][1] = +I[1][1], m) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
    }, m.constrain = function(I) {
      return arguments.length ? (e = I, m) : e;
    }, m.duration = function(I) {
      return arguments.length ? (a = +I, m) : a;
    }, m.interpolate = function(I) {
      return arguments.length ? (l = I, m) : l;
    }, m.on = function() {
      var I = c.on.apply(c, arguments);
      return I === c ? m : I;
    }, m.clickDistance = function(I) {
      return arguments.length ? (f = (I = +I) * I, m) : Math.sqrt(f);
    }, m;
  }
  var pn = {};
  D4(pn, { ACESFilmicToneMapping: () => YV, AddEquation: () => hd, AddOperation: () => jV, AdditiveAnimationBlendMode: () => tD, AdditiveBlending: () => r1, AlphaFormat: () => nz, AlwaysDepth: () => FV, AlwaysStencilFunc: () => Zz, AmbientLight: () => Pg, AmbientLightProbe: () => Cx, AnimationClip: () => Od, AnimationLoader: () => E1, AnimationMixer: () => Ix, AnimationObjectGroup: () => Tx, AnimationUtils: () => jn, ArcCurve: () => eg, ArrayCamera: () => jm, ArrowHelper: () => $1, Audio: () => Ng, AudioAnalyser: () => Mx, AudioContext: () => dD, AudioListener: () => P1, AudioLoader: () => xx, AxesHelper: () => Lx, AxisHelper: () => Soe, BackSide: () => bi, BasicDepthPacking: () => qz, BasicShadowMap: () => HK, BinaryTextureLoader: () => Doe, Bone: () => Zh, BooleanKeyframeTrack: () => Va, BoundingBoxHelper: () => Moe, Box2: () => kl, Box3: () => Lr, Box3Helper: () => j1, BoxBufferGeometry: () => Il, BoxGeometry: () => Il, BoxHelper: () => kx, BufferAttribute: () => an, BufferGeometry: () => Ct, BufferGeometryLoader: () => yx, ByteType: () => ZV, Cache: () => Ad, Camera: () => wd, CameraHelper: () => H1, CanvasRenderer: () => Roe, CanvasTexture: () => ox, CatmullRomCurve3: () => tg, CineonToneMapping: () => qV, CircleBufferGeometry: () => Zm, CircleGeometry: () => Zm, ClampToEdgeWrapping: () => nr, Clock: () => Sx, Color: () => Ye, ColorKeyframeTrack: () => Cg, CompressedTexture: () => Xm, CompressedTextureLoader: () => T1, ConeBufferGeometry: () => Qm, ConeGeometry: () => Qm, CubeCamera: () => zh, CubeReflectionMapping: () => Ld, CubeRefractionMapping: () => Fd, CubeTexture: () => Dl, CubeTextureLoader: () => hx, CubeUVReflectionMapping: () => sp, CubeUVRefractionMapping: () => Lg, CubicBezierCurve: () => Qh, CubicBezierCurve3: () => ng, CubicInterpolant: () => cx, CullFaceBack: () => i1, CullFaceFront: () => wV, CullFaceFrontBack: () => GK, CullFaceNone: () => xV, Curve: () => Br, CurvePath: () => lx, CustomBlending: () => SV, CustomToneMapping: () => XV, CylinderBufferGeometry: () => Ed, CylinderGeometry: () => Ed, Cylindrical: () => F1, DataTexture: () => Ra, DataTexture2DArray: () => Hh, DataTexture3D: () => Hm, DataTextureLoader: () => px, DataUtils: () => Y1, DecrementStencilOp: () => eJ, DecrementWrapStencilOp: () => nJ, DefaultLoadingManager: () => _U, DepthFormat: () => _d, DepthStencilFormat: () => Nh, DepthTexture: () => sx, DirectionalLight: () => Dg, DirectionalLightHelper: () => G1, DiscreteInterpolant: () => dx, DodecahedronBufferGeometry: () => Km, DodecahedronGeometry: () => Km, DoubleSide: () => bd, DstAlphaFactor: () => RV, DstColorFactor: () => AV, DynamicBufferAttribute: () => foe, DynamicCopyUsage: () => gJ, DynamicDrawUsage: () => Lh, DynamicReadUsage: () => pJ, EdgesGeometry: () => Jm, EdgesHelper: () => Eoe, EllipseCurve: () => Td, EqualDepth: () => VV, EqualStencilFunc: () => sJ, EquirectangularReflectionMapping: () => Om, EquirectangularRefractionMapping: () => Am, Euler: () => xd, EventDispatcher: () => Vs, ExtrudeBufferGeometry: () => Ba, ExtrudeGeometry: () => Ba, FaceColors: () => ioe, FileLoader: () => Lo, FlatShading: () => Q1, Float16BufferAttribute: () => K0, Float32Attribute: () => woe, Float32BufferAttribute: () => it, Float64Attribute: () => Coe, Float64BufferAttribute: () => J0, FloatType: () => Fs, Fog: () => $m, FogExp2: () => Wm, Font: () => Boe, FontLoader: () => Foe, FrontSide: () => yd, Frustum: () => Cd, GLBufferAttribute: () => Rx, GLSL1: () => vJ, GLSL3: () => y1, GammaEncoding: () => Vx, GreaterDepth: () => UV, GreaterEqualDepth: () => zV, GreaterEqualStencilFunc: () => dJ, GreaterStencilFunc: () => lJ, GridHelper: () => Nx, Group: () => Da, HalfFloatType: () => md, HemisphereLight: () => Mg, HemisphereLightHelper: () => z1, HemisphereLightProbe: () => wx, IcosahedronBufferGeometry: () => sg, IcosahedronGeometry: () => sg, ImageBitmapLoader: () => bx, ImageLoader: () => Nd, ImageUtils: () => Aa, ImmediateRenderObject: () => Voe, IncrementStencilOp: () => JK, IncrementWrapStencilOp: () => tJ, InstancedBufferAttribute: () => ka, InstancedBufferGeometry: () => Ag, InstancedInterleavedBuffer: () => Px, InstancedMesh: () => qm, Int16Attribute: () => voe, Int16BufferAttribute: () => Z0, Int32Attribute: () => boe, Int32BufferAttribute: () => Q0, Int8Attribute: () => moe, Int8BufferAttribute: () => q0, IntType: () => KV, InterleavedBuffer: () => Na, InterleavedBufferAttribute: () => Ol, Interpolant: () => us, InterpolateDiscrete: () => Fm, InterpolateLinear: () => Bm, InterpolateSmooth: () => U0, InvertStencilOp: () => iJ, JSONLoader: () => Ooe, KeepStencilOp: () => G0, KeyframeTrack: () => fo, LOD: () => nx, LatheBufferGeometry: () => ag, LatheGeometry: () => ag, Layers: () => Gm, LensFlare: () => Noe, LessDepth: () => BV, LessEqualDepth: () => H0, LessEqualStencilFunc: () => aJ, LessStencilFunc: () => oJ, Light: () => mo, LightProbe: () => kd, Line: () => ds, Line3: () => Ox, LineBasicMaterial: () => Ei, LineCurve: () => Id, LineCurve3: () => ax, LineDashedMaterial: () => xg, LineLoop: () => Ym, LinePieces: () => toe, LineSegments: () => wr, LineStrip: () => eoe, LinearEncoding: () => or, LinearFilter: () => Ri, LinearInterpolant: () => wg, LinearMipMapLinearFilter: () => YK, LinearMipMapNearestFilter: () => qK, LinearMipmapLinearFilter: () => Bd, LinearMipmapNearestFilter: () => eD, LinearToneMapping: () => WV, Loader: () => sr, LoaderUtils: () => op, LoadingManager: () => Sg, LogLuvEncoding: () => $z, LoopOnce: () => Gz, LoopPingPong: () => jz, LoopRepeat: () => Hz, LuminanceAlphaFormat: () => rz, LuminanceFormat: () => iz, MOUSE: () => zK, Material: () => Mi, MaterialLoader: () => vx, Math: () => AJ, MathUtils: () => AJ, Matrix3: () => xi, Matrix4: () => ut, MaxEquation: () => l1, Mesh: () => li, MeshBasicMaterial: () => ls, MeshDepthMaterial: () => jh, MeshDistanceMaterial: () => Wh, MeshFaceMaterial: () => ooe, MeshLambertMaterial: () => yg, MeshMatcapMaterial: () => bg, MeshNormalMaterial: () => vg, MeshPhongMaterial: () => gg, MeshPhysicalMaterial: () => mg, MeshStandardMaterial: () => rp, MeshToonMaterial: () => _g, MinEquation: () => a1, MirroredRepeatWrapping: () => km, MixOperation: () => HV, MultiMaterial: () => soe, MultiplyBlending: () => s1, MultiplyOperation: () => kg, NearestFilter: () => Si, NearestMipMapLinearFilter: () => $K, NearestMipMapNearestFilter: () => WK, NearestMipmapLinearFilter: () => W0, NearestMipmapNearestFilter: () => j0, NeverDepth: () => LV, NeverStencilFunc: () => rJ, NoBlending: () => Pa, NoColors: () => noe, NoToneMapping: () => Ml, NormalAnimationBlendMode: () => Bx, NormalBlending: () => Rh, NotEqualDepth: () => GV, NotEqualStencilFunc: () => cJ, NumberKeyframeTrack: () => Pd, Object3D: () => ln, ObjectLoader: () => I1, ObjectSpaceNormalMap: () => Xz, OctahedronBufferGeometry: () => tp, OctahedronGeometry: () => tp, OneFactor: () => IV, OneMinusDstAlphaFactor: () => OV, OneMinusDstColorFactor: () => NV, OneMinusSrcAlphaFactor: () => J1, OneMinusSrcColorFactor: () => PV, OrthographicCamera: () => Sd, PCFShadowMap: () => Z1, PCFSoftShadowMap: () => CV, PMREMGenerator: () => ex, ParametricGeometry: () => koe, Particle: () => loe, ParticleBasicMaterial: () => uoe, ParticleSystem: () => coe, ParticleSystemMaterial: () => hoe, Path: () => Dd, PerspectiveCamera: () => Ci, Plane: () => No, PlaneBufferGeometry: () => Gh, PlaneGeometry: () => Gh, PlaneHelper: () => W1, PointCloud: () => aoe, PointCloudMaterial: () => doe, PointLight: () => Ig, PointLightHelper: () => V1, Points: () => Md, PointsMaterial: () => La, PolarGridHelper: () => U1, PolyhedronBufferGeometry: () => Fa, PolyhedronGeometry: () => Fa, PositionalAudio: () => R1, PropertyBinding: () => Fn, PropertyMixer: () => Ex, QuadraticBezierCurve: () => Kh, QuadraticBezierCurve3: () => Jh, Quaternion: () => Oi, QuaternionKeyframeTrack: () => Nl, QuaternionLinearInterpolant: () => ux, REVISION: () => X1, RGBADepthPacking: () => Yz, RGBAFormat: () => ir, RGBAIntegerFormat: () => uz, RGBA_ASTC_10x10_Format: () => Sz, RGBA_ASTC_10x5_Format: () => xz, RGBA_ASTC_10x6_Format: () => wz, RGBA_ASTC_10x8_Format: () => Cz, RGBA_ASTC_12x10_Format: () => Mz, RGBA_ASTC_12x12_Format: () => Ez, RGBA_ASTC_4x4_Format: () => pz, RGBA_ASTC_5x4_Format: () => fz, RGBA_ASTC_5x5_Format: () => mz, RGBA_ASTC_6x5_Format: () => gz, RGBA_ASTC_6x6_Format: () => _z, RGBA_ASTC_8x5_Format: () => vz, RGBA_ASTC_8x6_Format: () => yz, RGBA_ASTC_8x8_Format: () => bz, RGBA_BPTC_Format: () => Tz, RGBA_ETC2_EAC_Format: () => v1, RGBA_PVRTC_2BPPV1_Format: () => g1, RGBA_PVRTC_4BPPV1_Format: () => m1, RGBA_S3TC_DXT1_Format: () => d1, RGBA_S3TC_DXT3_Format: () => u1, RGBA_S3TC_DXT5_Format: () => h1, RGBDEncoding: () => rD, RGBEEncoding: () => zx, RGBEFormat: () => oz, RGBFormat: () => gd, RGBIntegerFormat: () => dz, RGBM16Encoding: () => iD, RGBM7Encoding: () => nD, RGB_ETC1_Format: () => hz, RGB_ETC2_Format: () => _1, RGB_PVRTC_2BPPV1_Format: () => f1, RGB_PVRTC_4BPPV1_Format: () => p1, RGB_S3TC_DXT1_Format: () => c1, RGFormat: () => lz, RGIntegerFormat: () => cz, RawShaderMaterial: () => Pl, Ray: () => Us, Raycaster: () => N1, RectAreaLight: () => Rg, RedFormat: () => sz, RedIntegerFormat: () => az, ReinhardToneMapping: () => $V, RepeatWrapping: () => Nm, ReplaceStencilOp: () => KK, ReverseSubtractEquation: () => EV, RingBufferGeometry: () => lg, RingGeometry: () => lg, SRGB8_ALPHA8_ASTC_10x10_Format: () => Vz, SRGB8_ALPHA8_ASTC_10x5_Format: () => Lz, SRGB8_ALPHA8_ASTC_10x6_Format: () => Fz, SRGB8_ALPHA8_ASTC_10x8_Format: () => Bz, SRGB8_ALPHA8_ASTC_12x10_Format: () => zz, SRGB8_ALPHA8_ASTC_12x12_Format: () => Uz, SRGB8_ALPHA8_ASTC_4x4_Format: () => Iz, SRGB8_ALPHA8_ASTC_5x4_Format: () => Dz, SRGB8_ALPHA8_ASTC_5x5_Format: () => Pz, SRGB8_ALPHA8_ASTC_6x5_Format: () => Rz, SRGB8_ALPHA8_ASTC_6x6_Format: () => Oz, SRGB8_ALPHA8_ASTC_8x5_Format: () => Az, SRGB8_ALPHA8_ASTC_8x6_Format: () => Nz, SRGB8_ALPHA8_ASTC_8x8_Format: () => kz, Scene: () => $h, SceneUtils: () => Aoe, ShaderChunk: () => en, ShaderLib: () => as, ShaderMaterial: () => cs, ShadowMaterial: () => fg, Shape: () => ko, ShapeBufferGeometry: () => np, ShapeGeometry: () => np, ShapePath: () => q1, ShapeUtils: () => Bs, ShortType: () => QV, Skeleton: () => ix, SkeletonHelper: () => Ax, SkinnedMesh: () => Xh, SmoothShading: () => jK, Sphere: () => zs, SphereBufferGeometry: () => ip, SphereGeometry: () => ip, Spherical: () => L1, SphericalHarmonics3: () => Og, SplineCurve: () => ep, SpotLight: () => Tg, SpotLightHelper: () => B1, Sprite: () => Yh, SpriteMaterial: () => qh, SrcAlphaFactor: () => K1, SrcAlphaSaturateFactor: () => kV, SrcColorFactor: () => DV, StaticCopyUsage: () => mJ, StaticDrawUsage: () => kh, StaticReadUsage: () => hJ, StereoCamera: () => D1, StreamCopyUsage: () => _J, StreamDrawUsage: () => uJ, StreamReadUsage: () => fJ, StringKeyframeTrack: () => za, SubtractEquation: () => MV, SubtractiveBlending: () => o1, TOUCH: () => UK, TangentSpaceNormalMap: () => Vd, TetrahedronBufferGeometry: () => cg, TetrahedronGeometry: () => cg, TextGeometry: () => Loe, Texture: () => zi, TextureLoader: () => fx, TorusBufferGeometry: () => dg, TorusGeometry: () => dg, TorusKnotBufferGeometry: () => ug, TorusKnotGeometry: () => ug, Triangle: () => rr, TriangleFanDrawMode: () => ZK, TriangleStripDrawMode: () => XK, TrianglesDrawMode: () => Wz, TubeBufferGeometry: () => hg, TubeGeometry: () => hg, UVMapping: () => Fx, Uint16Attribute: () => yoe, Uint16BufferAttribute: () => Fh, Uint32Attribute: () => xoe, Uint32BufferAttribute: () => Bh, Uint8Attribute: () => goe, Uint8BufferAttribute: () => Y0, Uint8ClampedAttribute: () => _oe, Uint8ClampedBufferAttribute: () => X0, Uniform: () => Dx, UniformsLib: () => $e, UniformsUtils: () => eU, UnsignedByteType: () => Oa, UnsignedInt248Type: () => Oh, UnsignedIntType: () => Tm, UnsignedShort4444Type: () => JV, UnsignedShort5551Type: () => ez, UnsignedShort565Type: () => tz, UnsignedShortType: () => Lm, VSMShadowMap: () => Ih, Vector2: () => Me, Vector3: () => L, Vector4: () => bn, VectorKeyframeTrack: () => Rd, Vertex: () => poe, VertexColors: () => roe, VideoTexture: () => rx, WebGL1Renderer: () => tx, WebGLCubeRenderTarget: () => Uh, WebGLMultipleRenderTargets: () => $0, WebGLMultisampleRenderTarget: () => Um, WebGLRenderTarget: () => po, WebGLRenderTargetCube: () => Poe, WebGLRenderer: () => Sn, WebGLUtils: () => hU, WireframeGeometry: () => pg, WireframeHelper: () => Toe, WrapAroundEnding: () => Vm, XHRLoader: () => Ioe, ZeroCurvatureEnding: () => pd, ZeroFactor: () => TV, ZeroSlopeEnding: () => fd, ZeroStencilOp: () => QK, sRGBEncoding: () => Ll });
  var X1 = "134";
  var zK = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
  var UK = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
  var xV = 0;
  var i1 = 1;
  var wV = 2;
  var GK = 3;
  var HK = 0;
  var Z1 = 1;
  var CV = 2;
  var Ih = 3;
  var yd = 0;
  var bi = 1;
  var bd = 2;
  var Q1 = 1;
  var jK = 2;
  var Pa = 0;
  var Rh = 1;
  var r1 = 2;
  var o1 = 3;
  var s1 = 4;
  var SV = 5;
  var hd = 100;
  var MV = 101;
  var EV = 102;
  var a1 = 103;
  var l1 = 104;
  var TV = 200;
  var IV = 201;
  var DV = 202;
  var PV = 203;
  var K1 = 204;
  var J1 = 205;
  var RV = 206;
  var OV = 207;
  var AV = 208;
  var NV = 209;
  var kV = 210;
  var LV = 0;
  var FV = 1;
  var BV = 2;
  var H0 = 3;
  var VV = 4;
  var zV = 5;
  var UV = 6;
  var GV = 7;
  var kg = 0;
  var HV = 1;
  var jV = 2;
  var Ml = 0;
  var WV = 1;
  var $V = 2;
  var qV = 3;
  var YV = 4;
  var XV = 5;
  var Fx = 300;
  var Ld = 301;
  var Fd = 302;
  var Om = 303;
  var Am = 304;
  var sp = 306;
  var Lg = 307;
  var Nm = 1e3;
  var nr = 1001;
  var km = 1002;
  var Si = 1003;
  var j0 = 1004;
  var WK = 1004;
  var W0 = 1005;
  var $K = 1005;
  var Ri = 1006;
  var eD = 1007;
  var qK = 1007;
  var Bd = 1008;
  var YK = 1008;
  var Oa = 1009;
  var ZV = 1010;
  var QV = 1011;
  var Lm = 1012;
  var KV = 1013;
  var Tm = 1014;
  var Fs = 1015;
  var md = 1016;
  var JV = 1017;
  var ez = 1018;
  var tz = 1019;
  var Oh = 1020;
  var nz = 1021;
  var gd = 1022;
  var ir = 1023;
  var iz = 1024;
  var rz = 1025;
  var oz = ir;
  var _d = 1026;
  var Nh = 1027;
  var sz = 1028;
  var az = 1029;
  var lz = 1030;
  var cz = 1031;
  var dz = 1032;
  var uz = 1033;
  var c1 = 33776;
  var d1 = 33777;
  var u1 = 33778;
  var h1 = 33779;
  var p1 = 35840;
  var f1 = 35841;
  var m1 = 35842;
  var g1 = 35843;
  var hz = 36196;
  var _1 = 37492;
  var v1 = 37496;
  var pz = 37808;
  var fz = 37809;
  var mz = 37810;
  var gz = 37811;
  var _z = 37812;
  var vz = 37813;
  var yz = 37814;
  var bz = 37815;
  var xz = 37816;
  var wz = 37817;
  var Cz = 37818;
  var Sz = 37819;
  var Mz = 37820;
  var Ez = 37821;
  var Tz = 36492;
  var Iz = 37840;
  var Dz = 37841;
  var Pz = 37842;
  var Rz = 37843;
  var Oz = 37844;
  var Az = 37845;
  var Nz = 37846;
  var kz = 37847;
  var Lz = 37848;
  var Fz = 37849;
  var Bz = 37850;
  var Vz = 37851;
  var zz = 37852;
  var Uz = 37853;
  var Gz = 2200;
  var Hz = 2201;
  var jz = 2202;
  var Fm = 2300;
  var Bm = 2301;
  var U0 = 2302;
  var pd = 2400;
  var fd = 2401;
  var Vm = 2402;
  var Bx = 2500;
  var tD = 2501;
  var Wz = 0;
  var XK = 1;
  var ZK = 2;
  var or = 3e3;
  var Ll = 3001;
  var Vx = 3007;
  var zx = 3002;
  var $z = 3003;
  var nD = 3004;
  var iD = 3005;
  var rD = 3006;
  var qz = 3200;
  var Yz = 3201;
  var Vd = 0;
  var Xz = 1;
  var QK = 0;
  var G0 = 7680;
  var KK = 7681;
  var JK = 7682;
  var eJ = 7683;
  var tJ = 34055;
  var nJ = 34056;
  var iJ = 5386;
  var rJ = 512;
  var oJ = 513;
  var sJ = 514;
  var aJ = 515;
  var lJ = 516;
  var cJ = 517;
  var dJ = 518;
  var Zz = 519;
  var kh = 35044;
  var Lh = 35048;
  var uJ = 35040;
  var hJ = 35045;
  var pJ = 35049;
  var fJ = 35041;
  var mJ = 35046;
  var gJ = 35050;
  var _J = 35042;
  var vJ = "100";
  var y1 = "300 es";
  var Vs = class {
    addEventListener(t, e) {
      this._listeners === void 0 && (this._listeners = {});
      let n = this._listeners;
      n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e);
    }
    hasEventListener(t, e) {
      if (this._listeners === void 0) return false;
      let n = this._listeners;
      return n[t] !== void 0 && n[t].indexOf(e) !== -1;
    }
    removeEventListener(t, e) {
      if (this._listeners === void 0) return;
      let r = this._listeners[t];
      if (r !== void 0) {
        let o = r.indexOf(e);
        o !== -1 && r.splice(o, 1);
      }
    }
    dispatchEvent(t) {
      if (this._listeners === void 0) return;
      let n = this._listeners[t.type];
      if (n !== void 0) {
        t.target = this;
        let r = n.slice(0);
        for (let o = 0, s = r.length; o < s; o++) r[o].call(this, t);
        t.target = null;
      }
    }
  };
  var e0 = 1234567;
  var vd = Math.PI / 180;
  var zm = 180 / Math.PI;
  var er = [];
  for (let i59 = 0; i59 < 256; i59++) er[i59] = (i59 < 16 ? "0" : "") + i59.toString(16);
  var yJ = typeof crypto < "u" && "randomUUID" in crypto;
  function ho() {
    if (yJ) return crypto.randomUUID().toUpperCase();
    let i59 = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
    return (er[i59 & 255] + er[i59 >> 8 & 255] + er[i59 >> 16 & 255] + er[i59 >> 24 & 255] + "-" + er[t & 255] + er[t >> 8 & 255] + "-" + er[t >> 16 & 15 | 64] + er[t >> 24 & 255] + "-" + er[e & 63 | 128] + er[e >> 8 & 255] + "-" + er[e >> 16 & 255] + er[e >> 24 & 255] + er[n & 255] + er[n >> 8 & 255] + er[n >> 16 & 255] + er[n >> 24 & 255]).toUpperCase();
  }
  function tr(i59, t, e) {
    return Math.max(t, Math.min(e, i59));
  }
  function oD(i59, t) {
    return (i59 % t + t) % t;
  }
  function bJ(i59, t, e, n, r) {
    return n + (i59 - t) * (r - n) / (e - t);
  }
  function xJ(i59, t, e) {
    return i59 !== t ? (e - i59) / (t - i59) : 0;
  }
  function Im(i59, t, e) {
    return (1 - e) * i59 + e * t;
  }
  function wJ(i59, t, e, n) {
    return Im(i59, t, 1 - Math.exp(-e * n));
  }
  function CJ(i59, t = 1) {
    return t - Math.abs(oD(i59, t * 2) - t);
  }
  function SJ(i59, t, e) {
    return i59 <= t ? 0 : i59 >= e ? 1 : (i59 = (i59 - t) / (e - t), i59 * i59 * (3 - 2 * i59));
  }
  function MJ(i59, t, e) {
    return i59 <= t ? 0 : i59 >= e ? 1 : (i59 = (i59 - t) / (e - t), i59 * i59 * i59 * (i59 * (i59 * 6 - 15) + 10));
  }
  function EJ(i59, t) {
    return i59 + Math.floor(Math.random() * (t - i59 + 1));
  }
  function TJ(i59, t) {
    return i59 + Math.random() * (t - i59);
  }
  function IJ(i59) {
    return i59 * (0.5 - Math.random());
  }
  function DJ(i59) {
    return i59 !== void 0 && (e0 = i59 % 2147483647), e0 = e0 * 16807 % 2147483647, (e0 - 1) / 2147483646;
  }
  function PJ(i59) {
    return i59 * vd;
  }
  function RJ(i59) {
    return i59 * zm;
  }
  function b1(i59) {
    return (i59 & i59 - 1) === 0 && i59 !== 0;
  }
  function Qz(i59) {
    return Math.pow(2, Math.ceil(Math.log(i59) / Math.LN2));
  }
  function Kz(i59) {
    return Math.pow(2, Math.floor(Math.log(i59) / Math.LN2));
  }
  function OJ(i59, t, e, n, r) {
    let o = Math.cos, s = Math.sin, a = o(e / 2), l = s(e / 2), c = o((t + n) / 2), d = s((t + n) / 2), u = o((t - n) / 2), h = s((t - n) / 2), p = o((n - t) / 2), f = s((n - t) / 2);
    switch (r) {
      case "XYX":
        i59.set(a * d, l * u, l * h, a * c);
        break;
      case "YZY":
        i59.set(l * h, a * d, l * u, a * c);
        break;
      case "ZXZ":
        i59.set(l * u, l * h, a * d, a * c);
        break;
      case "XZX":
        i59.set(a * d, l * f, l * p, a * c);
        break;
      case "YXY":
        i59.set(l * p, a * d, l * f, a * c);
        break;
      case "ZYZ":
        i59.set(l * f, l * p, a * d, a * c);
        break;
      default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
    }
  }
  var AJ = Object.freeze({ __proto__: null, DEG2RAD: vd, RAD2DEG: zm, generateUUID: ho, clamp: tr, euclideanModulo: oD, mapLinear: bJ, inverseLerp: xJ, lerp: Im, damp: wJ, pingpong: CJ, smoothstep: SJ, smootherstep: MJ, randInt: EJ, randFloat: TJ, randFloatSpread: IJ, seededRandom: DJ, degToRad: PJ, radToDeg: RJ, isPowerOfTwo: b1, ceilPowerOfTwo: Qz, floorPowerOfTwo: Kz, setQuaternionFromProperEuler: OJ });
  var Me = class {
    constructor(t = 0, e = 0) {
      this.x = t, this.y = e;
    }
    get width() {
      return this.x;
    }
    set width(t) {
      this.x = t;
    }
    get height() {
      return this.y;
    }
    set height(t) {
      this.y = t;
    }
    set(t, e) {
      return this.x = t, this.y = e, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this;
    }
    add(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this);
    }
    addScalar(t) {
      return this.x += t, this.y += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this;
    }
    sub(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this);
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this;
    }
    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this;
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this;
    }
    divide(t) {
      return this.x /= t.x, this.y /= t.y, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    applyMatrix3(t) {
      let e = this.x, n = this.y, r = t.elements;
      return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this;
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this;
    }
    clampLength(t, e) {
      let n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y;
    }
    cross(t) {
      return this.x * t.y - this.y * t.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      let e = this.x - t.x, n = this.y - t.y;
      return e * e + n * n;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t;
    }
    fromBufferAttribute(t, e, n) {
      return n !== void 0 && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this;
    }
    rotateAround(t, e) {
      let n = Math.cos(e), r = Math.sin(e), o = this.x - t.x, s = this.y - t.y;
      return this.x = o * n - s * r + t.x, this.y = o * r + s * n + t.y, this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  };
  Me.prototype.isVector2 = true;
  var xi = class {
    constructor() {
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t, e, n, r, o, s, a, l, c) {
      let d = this.elements;
      return d[0] = t, d[1] = r, d[2] = a, d[3] = e, d[4] = o, d[5] = l, d[6] = n, d[7] = s, d[8] = c, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(t) {
      let e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this;
    }
    extractBasis(t, e, n) {
      return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
    }
    setFromMatrix4(t) {
      let e = t.elements;
      return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
    }
    multiply(t) {
      return this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      let n = t.elements, r = e.elements, o = this.elements, s = n[0], a = n[3], l = n[6], c = n[1], d = n[4], u = n[7], h = n[2], p = n[5], f = n[8], m = r[0], v = r[3], _ = r[6], g = r[1], y = r[4], w = r[7], E = r[2], P = r[5], S = r[8];
      return o[0] = s * m + a * g + l * E, o[3] = s * v + a * y + l * P, o[6] = s * _ + a * w + l * S, o[1] = c * m + d * g + u * E, o[4] = c * v + d * y + u * P, o[7] = c * _ + d * w + u * S, o[2] = h * m + p * g + f * E, o[5] = h * v + p * y + f * P, o[8] = h * _ + p * w + f * S, this;
    }
    multiplyScalar(t) {
      let e = this.elements;
      return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this;
    }
    determinant() {
      let t = this.elements, e = t[0], n = t[1], r = t[2], o = t[3], s = t[4], a = t[5], l = t[6], c = t[7], d = t[8];
      return e * s * d - e * a * c - n * o * d + n * a * l + r * o * c - r * s * l;
    }
    invert() {
      let t = this.elements, e = t[0], n = t[1], r = t[2], o = t[3], s = t[4], a = t[5], l = t[6], c = t[7], d = t[8], u = d * s - a * c, h = a * l - d * o, p = c * o - s * l, f = e * u + n * h + r * p;
      if (f === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      let m = 1 / f;
      return t[0] = u * m, t[1] = (r * c - d * n) * m, t[2] = (a * n - r * s) * m, t[3] = h * m, t[4] = (d * e - r * l) * m, t[5] = (r * o - a * e) * m, t[6] = p * m, t[7] = (n * l - c * e) * m, t[8] = (s * e - n * o) * m, this;
    }
    transpose() {
      let t, e = this.elements;
      return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this;
    }
    getNormalMatrix(t) {
      return this.setFromMatrix4(t).invert().transpose();
    }
    transposeIntoArray(t) {
      let e = this.elements;
      return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this;
    }
    setUvTransform(t, e, n, r, o, s, a) {
      let l = Math.cos(o), c = Math.sin(o);
      return this.set(n * l, n * c, -n * (l * s + c * a) + s + t, -r * c, r * l, -r * (-c * s + l * a) + a + e, 0, 0, 1), this;
    }
    scale(t, e) {
      let n = this.elements;
      return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this;
    }
    rotate(t) {
      let e = Math.cos(t), n = Math.sin(t), r = this.elements, o = r[0], s = r[3], a = r[6], l = r[1], c = r[4], d = r[7];
      return r[0] = e * o + n * l, r[3] = e * s + n * c, r[6] = e * a + n * d, r[1] = -n * o + e * l, r[4] = -n * s + e * c, r[7] = -n * a + e * d, this;
    }
    translate(t, e) {
      let n = this.elements;
      return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this;
    }
    equals(t) {
      let e = this.elements, n = t.elements;
      for (let r = 0; r < 9; r++) if (e[r] !== n[r]) return false;
      return true;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      let n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t;
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  };
  xi.prototype.isMatrix3 = true;
  function Jz(i59) {
    if (i59.length === 0) return -1 / 0;
    let t = i59[0];
    for (let e = 1, n = i59.length; e < n; ++e) i59[e] > t && (t = i59[e]);
    return t;
  }
  var NJ = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
  function Dh(i59, t) {
    return new NJ[i59](t);
  }
  function Ux(i59) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", i59);
  }
  function Q3(i59, t = 0) {
    let e = 3735928559 ^ t, n = 1103547991 ^ t;
    for (let r = 0, o; r < i59.length; r++) o = i59.charCodeAt(r), e = Math.imul(e ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
    return e = Math.imul(e ^ e >>> 16, 2246822507) ^ Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507) ^ Math.imul(e ^ e >>> 13, 3266489909), 4294967296 * (2097151 & n) + (e >>> 0);
  }
  var ch;
  var Aa = class {
    static getDataURL(t) {
      if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src;
      let e;
      if (t instanceof HTMLCanvasElement) e = t;
      else {
        ch === void 0 && (ch = Ux("canvas")), ch.width = t.width, ch.height = t.height;
        let n = ch.getContext("2d");
        t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = ch;
      }
      return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", 0.6)) : e.toDataURL("image/png");
    }
  };
  var kJ = 0;
  var zi = class i28 extends Vs {
    constructor(t = i28.DEFAULT_IMAGE, e = i28.DEFAULT_MAPPING, n = nr, r = nr, o = Ri, s = Bd, a = ir, l = Oa, c = 1, d = or) {
      super(), Object.defineProperty(this, "id", { value: kJ++ }), this.uuid = ho(), this.name = "", this.image = t, this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = o, this.minFilter = s, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Me(0, 0), this.repeat = new Me(1, 1), this.center = new Me(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new xi(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.encoding = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false;
    }
    updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }
    toJSON(t) {
      let e = t === void 0 || typeof t == "string";
      if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid];
      let n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
      if (this.image !== void 0) {
        let r = this.image;
        if (r.uuid === void 0 && (r.uuid = ho()), !e && t.images[r.uuid] === void 0) {
          let o;
          if (Array.isArray(r)) {
            o = [];
            for (let s = 0, a = r.length; s < a; s++) r[s].isDataTexture ? o.push(wI(r[s].image)) : o.push(wI(r[s]));
          } else o = wI(r);
          t.images[r.uuid] = { uuid: r.uuid, url: o };
        }
        n.image = r.uuid;
      }
      return JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(t) {
      if (this.mapping !== Fx) return t;
      if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
        case Nm:
          t.x = t.x - Math.floor(t.x);
          break;
        case nr:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case km:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
      if (t.y < 0 || t.y > 1) switch (this.wrapT) {
        case Nm:
          t.y = t.y - Math.floor(t.y);
          break;
        case nr:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case km:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
      return this.flipY && (t.y = 1 - t.y), t;
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
  };
  zi.DEFAULT_IMAGE = void 0;
  zi.DEFAULT_MAPPING = Fx;
  zi.prototype.isTexture = true;
  function wI(i59) {
    return typeof HTMLImageElement < "u" && i59 instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i59 instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i59 instanceof ImageBitmap ? Aa.getDataURL(i59) : i59.data ? { data: Array.prototype.slice.call(i59.data), width: i59.width, height: i59.height, type: i59.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  var bn = class {
    constructor(t = 0, e = 0, n = 0, r = 1) {
      this.x = t, this.y = e, this.z = n, this.w = r;
    }
    get width() {
      return this.z;
    }
    set width(t) {
      this.z = t;
    }
    get height() {
      return this.w;
    }
    set height(t) {
      this.w = t;
    }
    set(t, e, n, r) {
      return this.x = t, this.y = e, this.z = n, this.w = r, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this.w = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setZ(t) {
      return this.z = t, this;
    }
    setW(t) {
      return this.w = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        case 3:
          this.w = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
    }
    add(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this);
    }
    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this.w += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this;
    }
    sub(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this);
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this;
    }
    multiply(t) {
      return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
    }
    applyMatrix4(t) {
      let e = this.x, n = this.y, r = this.z, o = this.w, s = t.elements;
      return this.x = s[0] * e + s[4] * n + s[8] * r + s[12] * o, this.y = s[1] * e + s[5] * n + s[9] * r + s[13] * o, this.z = s[2] * e + s[6] * n + s[10] * r + s[14] * o, this.w = s[3] * e + s[7] * n + s[11] * r + s[15] * o, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    setAxisAngleFromQuaternion(t) {
      this.w = 2 * Math.acos(t.w);
      let e = Math.sqrt(1 - t.w * t.w);
      return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this;
    }
    setAxisAngleFromRotationMatrix(t) {
      let e, n, r, o, l = t.elements, c = l[0], d = l[4], u = l[8], h = l[1], p = l[5], f = l[9], m = l[2], v = l[6], _ = l[10];
      if (Math.abs(d - h) < 0.01 && Math.abs(u - m) < 0.01 && Math.abs(f - v) < 0.01) {
        if (Math.abs(d + h) < 0.1 && Math.abs(u + m) < 0.1 && Math.abs(f + v) < 0.1 && Math.abs(c + p + _ - 3) < 0.1) return this.set(1, 0, 0, 0), this;
        e = Math.PI;
        let y = (c + 1) / 2, w = (p + 1) / 2, E = (_ + 1) / 2, P = (d + h) / 4, S = (u + m) / 4, A = (f + v) / 4;
        return y > w && y > E ? y < 0.01 ? (n = 0, r = 0.707106781, o = 0.707106781) : (n = Math.sqrt(y), r = P / n, o = S / n) : w > E ? w < 0.01 ? (n = 0.707106781, r = 0, o = 0.707106781) : (r = Math.sqrt(w), n = P / r, o = A / r) : E < 0.01 ? (n = 0.707106781, r = 0.707106781, o = 0) : (o = Math.sqrt(E), n = S / o, r = A / o), this.set(n, r, o, e), this;
      }
      let g = Math.sqrt((v - f) * (v - f) + (u - m) * (u - m) + (h - d) * (h - d));
      return Math.abs(g) < 1e-3 && (g = 1), this.x = (v - f) / g, this.y = (u - m) / g, this.z = (h - d) / g, this.w = Math.acos((c + p + _ - 1) / 2), this;
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this;
    }
    clampLength(t, e) {
      let n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this;
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t;
    }
    fromBufferAttribute(t, e, n) {
      return n !== void 0 && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  };
  bn.prototype.isVector4 = true;
  var po = class extends Vs {
    constructor(t, e, n = {}) {
      super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new bn(0, 0, t, e), this.scissorTest = false, this.viewport = new bn(0, 0, t, e), this.texture = new zi(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = true, this.texture.image = { width: t, height: e, depth: 1 }, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : false, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Ri, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : true, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : false, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null;
    }
    setTexture(t) {
      t.image = { width: this.width, height: this.height, depth: this.depth }, this.texture = t;
    }
    setSize(t, e, n = 1) {
      (this.width !== t || this.height !== e || this.depth !== n) && (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.image = le({}, this.texture.image), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  po.prototype.isWebGLRenderTarget = true;
  var $0 = class extends po {
    constructor(t, e, n) {
      super(t, e);
      let r = this.texture;
      this.texture = [];
      for (let o = 0; o < n; o++) this.texture[o] = r.clone();
    }
    setSize(t, e, n = 1) {
      if (this.width !== t || this.height !== e || this.depth !== n) {
        this.width = t, this.height = e, this.depth = n;
        for (let r = 0, o = this.texture.length; r < o; r++) this.texture[r].image.width = t, this.texture[r].image.height = e, this.texture[r].image.depth = n;
        this.dispose();
      }
      return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this;
    }
    copy(t) {
      this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this.texture.length = 0;
      for (let e = 0, n = t.texture.length; e < n; e++) this.texture[e] = t.texture[e].clone();
      return this;
    }
  };
  $0.prototype.isWebGLMultipleRenderTargets = true;
  var Um = class extends po {
    constructor(t, e, n) {
      super(t, e, n), this.samples = 4;
    }
    copy(t) {
      return super.copy.call(this, t), this.samples = t.samples, this;
    }
  };
  Um.prototype.isWebGLMultisampleRenderTarget = true;
  var Oi = class {
    constructor(t = 0, e = 0, n = 0, r = 1) {
      this._x = t, this._y = e, this._z = n, this._w = r;
    }
    static slerp(t, e, n, r) {
      return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r);
    }
    static slerpFlat(t, e, n, r, o, s, a) {
      let l = n[r + 0], c = n[r + 1], d = n[r + 2], u = n[r + 3], h = o[s + 0], p = o[s + 1], f = o[s + 2], m = o[s + 3];
      if (a === 0) {
        t[e + 0] = l, t[e + 1] = c, t[e + 2] = d, t[e + 3] = u;
        return;
      }
      if (a === 1) {
        t[e + 0] = h, t[e + 1] = p, t[e + 2] = f, t[e + 3] = m;
        return;
      }
      if (u !== m || l !== h || c !== p || d !== f) {
        let v = 1 - a, _ = l * h + c * p + d * f + u * m, g = _ >= 0 ? 1 : -1, y = 1 - _ * _;
        if (y > Number.EPSILON) {
          let E = Math.sqrt(y), P = Math.atan2(E, _ * g);
          v = Math.sin(v * P) / E, a = Math.sin(a * P) / E;
        }
        let w = a * g;
        if (l = l * v + h * w, c = c * v + p * w, d = d * v + f * w, u = u * v + m * w, v === 1 - a) {
          let E = 1 / Math.sqrt(l * l + c * c + d * d + u * u);
          l *= E, c *= E, d *= E, u *= E;
        }
      }
      t[e] = l, t[e + 1] = c, t[e + 2] = d, t[e + 3] = u;
    }
    static multiplyQuaternionsFlat(t, e, n, r, o, s) {
      let a = n[r], l = n[r + 1], c = n[r + 2], d = n[r + 3], u = o[s], h = o[s + 1], p = o[s + 2], f = o[s + 3];
      return t[e] = a * f + d * u + l * p - c * h, t[e + 1] = l * f + d * h + c * u - a * p, t[e + 2] = c * f + d * p + a * h - l * u, t[e + 3] = d * f - a * u - l * h - c * p, t;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      this._z = t, this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(t) {
      this._w = t, this._onChangeCallback();
    }
    set(t, e, n, r) {
      return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(t) {
      return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
    }
    setFromEuler(t, e) {
      if (!(t && t.isEuler)) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      let n = t._x, r = t._y, o = t._z, s = t._order, a = Math.cos, l = Math.sin, c = a(n / 2), d = a(r / 2), u = a(o / 2), h = l(n / 2), p = l(r / 2), f = l(o / 2);
      switch (s) {
        case "XYZ":
          this._x = h * d * u + c * p * f, this._y = c * p * u - h * d * f, this._z = c * d * f + h * p * u, this._w = c * d * u - h * p * f;
          break;
        case "YXZ":
          this._x = h * d * u + c * p * f, this._y = c * p * u - h * d * f, this._z = c * d * f - h * p * u, this._w = c * d * u + h * p * f;
          break;
        case "ZXY":
          this._x = h * d * u - c * p * f, this._y = c * p * u + h * d * f, this._z = c * d * f + h * p * u, this._w = c * d * u - h * p * f;
          break;
        case "ZYX":
          this._x = h * d * u - c * p * f, this._y = c * p * u + h * d * f, this._z = c * d * f - h * p * u, this._w = c * d * u + h * p * f;
          break;
        case "YZX":
          this._x = h * d * u + c * p * f, this._y = c * p * u + h * d * f, this._z = c * d * f - h * p * u, this._w = c * d * u - h * p * f;
          break;
        case "XZY":
          this._x = h * d * u - c * p * f, this._y = c * p * u - h * d * f, this._z = c * d * f + h * p * u, this._w = c * d * u + h * p * f;
          break;
        default:
          console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + s);
      }
      return e !== false && this._onChangeCallback(), this;
    }
    setFromAxisAngle(t, e) {
      let n = e / 2, r = Math.sin(n);
      return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t) {
      let e = t.elements, n = e[0], r = e[4], o = e[8], s = e[1], a = e[5], l = e[9], c = e[2], d = e[6], u = e[10], h = n + a + u;
      if (h > 0) {
        let p = 0.5 / Math.sqrt(h + 1);
        this._w = 0.25 / p, this._x = (d - l) * p, this._y = (o - c) * p, this._z = (s - r) * p;
      } else if (n > a && n > u) {
        let p = 2 * Math.sqrt(1 + n - a - u);
        this._w = (d - l) / p, this._x = 0.25 * p, this._y = (r + s) / p, this._z = (o + c) / p;
      } else if (a > u) {
        let p = 2 * Math.sqrt(1 + a - n - u);
        this._w = (o - c) / p, this._x = (r + s) / p, this._y = 0.25 * p, this._z = (l + d) / p;
      } else {
        let p = 2 * Math.sqrt(1 + u - n - a);
        this._w = (s - r) / p, this._x = (o + c) / p, this._y = (l + d) / p, this._z = 0.25 * p;
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(t, e) {
      let n = t.dot(e) + 1;
      return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize();
    }
    angleTo(t) {
      return 2 * Math.acos(Math.abs(tr(this.dot(t), -1, 1)));
    }
    rotateTowards(t, e) {
      let n = this.angleTo(t);
      if (n === 0) return this;
      let r = Math.min(1, e / n);
      return this.slerp(t, r), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
    }
    dot(t) {
      return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
    }
    lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    }
    length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    }
    normalize() {
      let t = this.length();
      return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
    }
    multiply(t, e) {
      return e !== void 0 ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t);
    }
    premultiply(t) {
      return this.multiplyQuaternions(t, this);
    }
    multiplyQuaternions(t, e) {
      let n = t._x, r = t._y, o = t._z, s = t._w, a = e._x, l = e._y, c = e._z, d = e._w;
      return this._x = n * d + s * a + r * c - o * l, this._y = r * d + s * l + o * a - n * c, this._z = o * d + s * c + n * l - r * a, this._w = s * d - n * a - r * l - o * c, this._onChangeCallback(), this;
    }
    slerp(t, e) {
      if (e === 0) return this;
      if (e === 1) return this.copy(t);
      let n = this._x, r = this._y, o = this._z, s = this._w, a = s * t._w + n * t._x + r * t._y + o * t._z;
      if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = s, this._x = n, this._y = r, this._z = o, this;
      let l = 1 - a * a;
      if (l <= Number.EPSILON) {
        let p = 1 - e;
        return this._w = p * s + e * this._w, this._x = p * n + e * this._x, this._y = p * r + e * this._y, this._z = p * o + e * this._z, this.normalize(), this._onChangeCallback(), this;
      }
      let c = Math.sqrt(l), d = Math.atan2(c, a), u = Math.sin((1 - e) * d) / c, h = Math.sin(e * d) / c;
      return this._w = s * u + this._w * h, this._x = n * u + this._x * h, this._y = r * u + this._y * h, this._z = o * u + this._z * h, this._onChangeCallback(), this;
    }
    slerpQuaternions(t, e, n) {
      this.copy(t).slerp(e, n);
    }
    random() {
      let t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), r = 2 * Math.PI * Math.random(), o = 2 * Math.PI * Math.random();
      return this.set(e * Math.cos(r), n * Math.sin(o), n * Math.cos(o), e * Math.sin(r));
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
    }
    fromArray(t, e = 0) {
      return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t;
    }
    fromBufferAttribute(t, e) {
      return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this;
    }
    _onChange(t) {
      return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {
    }
  };
  Oi.prototype.isQuaternion = true;
  var L = class {
    constructor(t = 0, e = 0, n = 0) {
      this.x = t, this.y = e, this.z = n;
    }
    set(t, e, n) {
      return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this;
    }
    setScalar(t) {
      return this.x = t, this.y = t, this.z = t, this;
    }
    setX(t) {
      return this.x = t, this;
    }
    setY(t) {
      return this.y = t, this;
    }
    setZ(t) {
      return this.z = t, this;
    }
    setComponent(t, e) {
      switch (t) {
        case 0:
          this.x = e;
          break;
        case 1:
          this.y = e;
          break;
        case 2:
          this.z = e;
          break;
        default:
          throw new Error("index is out of range: " + t);
      }
      return this;
    }
    getComponent(t) {
      switch (t) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + t);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(t) {
      return this.x = t.x, this.y = t.y, this.z = t.z, this;
    }
    add(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this);
    }
    addScalar(t) {
      return this.x += t, this.y += t, this.z += t, this;
    }
    addVectors(t, e) {
      return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this;
    }
    addScaledVector(t, e) {
      return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this;
    }
    sub(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this);
    }
    subScalar(t) {
      return this.x -= t, this.y -= t, this.z -= t, this;
    }
    subVectors(t, e) {
      return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this;
    }
    multiply(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this);
    }
    multiplyScalar(t) {
      return this.x *= t, this.y *= t, this.z *= t, this;
    }
    multiplyVectors(t, e) {
      return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this;
    }
    applyEuler(t) {
      return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(K3.setFromEuler(t));
    }
    applyAxisAngle(t, e) {
      return this.applyQuaternion(K3.setFromAxisAngle(t, e));
    }
    applyMatrix3(t) {
      let e = this.x, n = this.y, r = this.z, o = t.elements;
      return this.x = o[0] * e + o[3] * n + o[6] * r, this.y = o[1] * e + o[4] * n + o[7] * r, this.z = o[2] * e + o[5] * n + o[8] * r, this;
    }
    applyNormalMatrix(t) {
      return this.applyMatrix3(t).normalize();
    }
    applyMatrix4(t) {
      let e = this.x, n = this.y, r = this.z, o = t.elements, s = 1 / (o[3] * e + o[7] * n + o[11] * r + o[15]);
      return this.x = (o[0] * e + o[4] * n + o[8] * r + o[12]) * s, this.y = (o[1] * e + o[5] * n + o[9] * r + o[13]) * s, this.z = (o[2] * e + o[6] * n + o[10] * r + o[14]) * s, this;
    }
    applyQuaternion(t) {
      let e = this.x, n = this.y, r = this.z, o = t.x, s = t.y, a = t.z, l = t.w, c = l * e + s * r - a * n, d = l * n + a * e - o * r, u = l * r + o * n - s * e, h = -o * e - s * n - a * r;
      return this.x = c * l + h * -o + d * -a - u * -s, this.y = d * l + h * -s + u * -o - c * -a, this.z = u * l + h * -a + c * -s - d * -o, this;
    }
    project(t) {
      return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
    }
    unproject(t) {
      return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
    }
    transformDirection(t) {
      let e = this.x, n = this.y, r = this.z, o = t.elements;
      return this.x = o[0] * e + o[4] * n + o[8] * r, this.y = o[1] * e + o[5] * n + o[9] * r, this.z = o[2] * e + o[6] * n + o[10] * r, this.normalize();
    }
    divide(t) {
      return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
    }
    divideScalar(t) {
      return this.multiplyScalar(1 / t);
    }
    min(t) {
      return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
    }
    max(t) {
      return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
    }
    clamp(t, e) {
      return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this;
    }
    clampScalar(t, e) {
      return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this;
    }
    clampLength(t, e) {
      let n = this.length();
      return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)));
    }
    floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
    }
    ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
    }
    round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
    }
    roundToZero() {
      return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this;
    }
    negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
    }
    dot(t) {
      return this.x * t.x + this.y * t.y + this.z * t.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(t) {
      return this.normalize().multiplyScalar(t);
    }
    lerp(t, e) {
      return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this;
    }
    lerpVectors(t, e, n) {
      return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this;
    }
    cross(t, e) {
      return e !== void 0 ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t);
    }
    crossVectors(t, e) {
      let n = t.x, r = t.y, o = t.z, s = e.x, a = e.y, l = e.z;
      return this.x = r * l - o * a, this.y = o * s - n * l, this.z = n * a - r * s, this;
    }
    projectOnVector(t) {
      let e = t.lengthSq();
      if (e === 0) return this.set(0, 0, 0);
      let n = t.dot(this) / e;
      return this.copy(t).multiplyScalar(n);
    }
    projectOnPlane(t) {
      return CI.copy(this).projectOnVector(t), this.sub(CI);
    }
    reflect(t) {
      return this.sub(CI.copy(t).multiplyScalar(2 * this.dot(t)));
    }
    angleTo(t) {
      let e = Math.sqrt(this.lengthSq() * t.lengthSq());
      if (e === 0) return Math.PI / 2;
      let n = this.dot(t) / e;
      return Math.acos(tr(n, -1, 1));
    }
    distanceTo(t) {
      return Math.sqrt(this.distanceToSquared(t));
    }
    distanceToSquared(t) {
      let e = this.x - t.x, n = this.y - t.y, r = this.z - t.z;
      return e * e + n * n + r * r;
    }
    manhattanDistanceTo(t) {
      return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
    }
    setFromSpherical(t) {
      return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
    }
    setFromSphericalCoords(t, e, n) {
      let r = Math.sin(e) * t;
      return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this;
    }
    setFromCylindrical(t) {
      return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
    }
    setFromCylindricalCoords(t, e, n) {
      return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this;
    }
    setFromMatrixPosition(t) {
      let e = t.elements;
      return this.x = e[12], this.y = e[13], this.z = e[14], this;
    }
    setFromMatrixScale(t) {
      let e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length();
      return this.x = e, this.y = n, this.z = r, this;
    }
    setFromMatrixColumn(t, e) {
      return this.fromArray(t.elements, e * 4);
    }
    setFromMatrix3Column(t, e) {
      return this.fromArray(t.elements, e * 3);
    }
    equals(t) {
      return t.x === this.x && t.y === this.y && t.z === this.z;
    }
    fromArray(t, e = 0) {
      return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t;
    }
    fromBufferAttribute(t, e, n) {
      return n !== void 0 && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this;
    }
    random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
    }
    randomDirection() {
      let t = (Math.random() - 0.5) * 2, e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2);
      return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  };
  L.prototype.isVector3 = true;
  var CI = new L();
  var K3 = new Oi();
  var Lr = class {
    constructor(t = new L(1 / 0, 1 / 0, 1 / 0), e = new L(-1 / 0, -1 / 0, -1 / 0)) {
      this.min = t, this.max = e;
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromArray(t) {
      let e = 1 / 0, n = 1 / 0, r = 1 / 0, o = -1 / 0, s = -1 / 0, a = -1 / 0;
      for (let l = 0, c = t.length; l < c; l += 3) {
        let d = t[l], u = t[l + 1], h = t[l + 2];
        d < e && (e = d), u < n && (n = u), h < r && (r = h), d > o && (o = d), u > s && (s = u), h > a && (a = h);
      }
      return this.min.set(e, n, r), this.max.set(o, s, a), this;
    }
    setFromBufferAttribute(t) {
      let e = 1 / 0, n = 1 / 0, r = 1 / 0, o = -1 / 0, s = -1 / 0, a = -1 / 0;
      for (let l = 0, c = t.count; l < c; l++) {
        let d = t.getX(l), u = t.getY(l), h = t.getZ(l);
        d < e && (e = d), u < n && (n = u), h < r && (r = h), d > o && (o = d), u > s && (s = u), h > a && (a = h);
      }
      return this.min.set(e, n, r), this.max.set(o, s, a), this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      let n = gm.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    setFromObject(t) {
      return this.makeEmpty(), this.expandByObject(t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    }
    getCenter(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    expandByObject(t) {
      t.updateWorldMatrix(false, false);
      let e = t.geometry;
      e !== void 0 && (e.boundingBox === null && e.computeBoundingBox(), SI.copy(e.boundingBox), SI.applyMatrix4(t.matrixWorld), this.union(SI));
      let n = t.children;
      for (let r = 0, o = n.length; r < o; r++) this.expandByObject(n[r]);
      return this;
    }
    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z);
    }
    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
    }
    getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z));
    }
    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z);
    }
    intersectsSphere(t) {
      return this.clampPoint(t.center, gm), gm.distanceToSquared(t.center) <= t.radius * t.radius;
    }
    intersectsPlane(t) {
      let e, n;
      return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant;
    }
    intersectsTriangle(t) {
      if (this.isEmpty()) return false;
      this.getCenter(_m), t0.subVectors(this.max, _m), dh.subVectors(t.a, _m), uh.subVectors(t.b, _m), hh.subVectors(t.c, _m), _l.subVectors(uh, dh), vl.subVectors(hh, uh), rd.subVectors(dh, hh);
      let e = [0, -_l.z, _l.y, 0, -vl.z, vl.y, 0, -rd.z, rd.y, _l.z, 0, -_l.x, vl.z, 0, -vl.x, rd.z, 0, -rd.x, -_l.y, _l.x, 0, -vl.y, vl.x, 0, -rd.y, rd.x, 0];
      return !MI(e, dh, uh, hh, t0) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !MI(e, dh, uh, hh, t0)) ? false : (n0.crossVectors(_l, vl), e = [n0.x, n0.y, n0.z], MI(e, dh, uh, hh, t0));
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return gm.copy(t).clamp(this.min, this.max).sub(t).length();
    }
    getBoundingSphere(t) {
      return this.getCenter(t.center), t.radius = this.getSize(gm).length() * 0.5, t;
    }
    intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    applyMatrix4(t) {
      return this.isEmpty() ? this : (Ca[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), Ca[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), Ca[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), Ca[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), Ca[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), Ca[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), Ca[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), Ca[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(Ca), this);
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  };
  Lr.prototype.isBox3 = true;
  var Ca = [new L(), new L(), new L(), new L(), new L(), new L(), new L(), new L()];
  var gm = new L();
  var SI = new Lr();
  var dh = new L();
  var uh = new L();
  var hh = new L();
  var _l = new L();
  var vl = new L();
  var rd = new L();
  var _m = new L();
  var t0 = new L();
  var n0 = new L();
  var od = new L();
  function MI(i59, t, e, n, r) {
    for (let o = 0, s = i59.length - 3; o <= s; o += 3) {
      od.fromArray(i59, o);
      let a = r.x * Math.abs(od.x) + r.y * Math.abs(od.y) + r.z * Math.abs(od.z), l = t.dot(od), c = e.dot(od), d = n.dot(od);
      if (Math.max(-Math.max(l, c, d), Math.min(l, c, d)) > a) return false;
    }
    return true;
  }
  var LJ = new Lr();
  var J3 = new L();
  var EI = new L();
  var TI = new L();
  var zs = class {
    constructor(t = new L(), e = -1) {
      this.center = t, this.radius = e;
    }
    set(t, e) {
      return this.center.copy(t), this.radius = e, this;
    }
    setFromPoints(t, e) {
      let n = this.center;
      e !== void 0 ? n.copy(e) : LJ.setFromPoints(t).getCenter(n);
      let r = 0;
      for (let o = 0, s = t.length; o < s; o++) r = Math.max(r, n.distanceToSquared(t[o]));
      return this.radius = Math.sqrt(r), this;
    }
    copy(t) {
      return this.center.copy(t.center), this.radius = t.radius, this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this;
    }
    containsPoint(t) {
      return t.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(t) {
      return t.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(t) {
      let e = this.radius + t.radius;
      return t.center.distanceToSquared(this.center) <= e * e;
    }
    intersectsBox(t) {
      return t.intersectsSphere(this);
    }
    intersectsPlane(t) {
      return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(t, e) {
      let n = this.center.distanceToSquared(t);
      return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e;
    }
    getBoundingBox(t) {
      return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
    }
    applyMatrix4(t) {
      return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
    }
    translate(t) {
      return this.center.add(t), this;
    }
    expandByPoint(t) {
      TI.subVectors(t, this.center);
      let e = TI.lengthSq();
      if (e > this.radius * this.radius) {
        let n = Math.sqrt(e), r = (n - this.radius) * 0.5;
        this.center.add(TI.multiplyScalar(r / n)), this.radius += r;
      }
      return this;
    }
    union(t) {
      return EI.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(J3.copy(t.center).add(EI)), this.expandByPoint(J3.copy(t.center).sub(EI)), this;
    }
    equals(t) {
      return t.center.equals(this.center) && t.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var Sa = new L();
  var II = new L();
  var i0 = new L();
  var yl = new L();
  var DI = new L();
  var r0 = new L();
  var PI = new L();
  var Us = class {
    constructor(t = new L(), e = new L(0, 0, -1)) {
      this.origin = t, this.direction = e;
    }
    set(t, e) {
      return this.origin.copy(t), this.direction.copy(e), this;
    }
    copy(t) {
      return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
    }
    at(t, e) {
      return e.copy(this.direction).multiplyScalar(t).add(this.origin);
    }
    lookAt(t) {
      return this.direction.copy(t).sub(this.origin).normalize(), this;
    }
    recast(t) {
      return this.origin.copy(this.at(t, Sa)), this;
    }
    closestPointToPoint(t, e) {
      e.subVectors(t, this.origin);
      let n = e.dot(this.direction);
      return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin);
    }
    distanceToPoint(t) {
      return Math.sqrt(this.distanceSqToPoint(t));
    }
    distanceSqToPoint(t) {
      let e = Sa.subVectors(t, this.origin).dot(this.direction);
      return e < 0 ? this.origin.distanceToSquared(t) : (Sa.copy(this.direction).multiplyScalar(e).add(this.origin), Sa.distanceToSquared(t));
    }
    distanceSqToSegment(t, e, n, r) {
      II.copy(t).add(e).multiplyScalar(0.5), i0.copy(e).sub(t).normalize(), yl.copy(this.origin).sub(II);
      let o = t.distanceTo(e) * 0.5, s = -this.direction.dot(i0), a = yl.dot(this.direction), l = -yl.dot(i0), c = yl.lengthSq(), d = Math.abs(1 - s * s), u, h, p, f;
      if (d > 0) if (u = s * l - a, h = s * a - l, f = o * d, u >= 0) if (h >= -f) if (h <= f) {
        let m = 1 / d;
        u *= m, h *= m, p = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * l) + c;
      } else h = o, u = Math.max(0, -(s * h + a)), p = -u * u + h * (h + 2 * l) + c;
      else h = -o, u = Math.max(0, -(s * h + a)), p = -u * u + h * (h + 2 * l) + c;
      else h <= -f ? (u = Math.max(0, -(-s * o + a)), h = u > 0 ? -o : Math.min(Math.max(-o, -l), o), p = -u * u + h * (h + 2 * l) + c) : h <= f ? (u = 0, h = Math.min(Math.max(-o, -l), o), p = h * (h + 2 * l) + c) : (u = Math.max(0, -(s * o + a)), h = u > 0 ? o : Math.min(Math.max(-o, -l), o), p = -u * u + h * (h + 2 * l) + c);
      else h = s > 0 ? -o : o, u = Math.max(0, -(s * h + a)), p = -u * u + h * (h + 2 * l) + c;
      return n && n.copy(this.direction).multiplyScalar(u).add(this.origin), r && r.copy(i0).multiplyScalar(h).add(II), p;
    }
    intersectSphere(t, e) {
      Sa.subVectors(t.center, this.origin);
      let n = Sa.dot(this.direction), r = Sa.dot(Sa) - n * n, o = t.radius * t.radius;
      if (r > o) return null;
      let s = Math.sqrt(o - r), a = n - s, l = n + s;
      return a < 0 && l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e);
    }
    intersectsSphere(t) {
      return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
    }
    distanceToPlane(t) {
      let e = t.normal.dot(this.direction);
      if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null;
      let n = -(this.origin.dot(t.normal) + t.constant) / e;
      return n >= 0 ? n : null;
    }
    intersectPlane(t, e) {
      let n = this.distanceToPlane(t);
      return n === null ? null : this.at(n, e);
    }
    intersectsPlane(t) {
      let e = t.distanceToPoint(this.origin);
      return e === 0 || t.normal.dot(this.direction) * e < 0;
    }
    intersectBox(t, e) {
      let n, r, o, s, a, l, c = 1 / this.direction.x, d = 1 / this.direction.y, u = 1 / this.direction.z, h = this.origin;
      return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), d >= 0 ? (o = (t.min.y - h.y) * d, s = (t.max.y - h.y) * d) : (o = (t.max.y - h.y) * d, s = (t.min.y - h.y) * d), n > s || o > r || ((o > n || n !== n) && (n = o), (s < r || r !== r) && (r = s), u >= 0 ? (a = (t.min.z - h.z) * u, l = (t.max.z - h.z) * u) : (a = (t.max.z - h.z) * u, l = (t.min.z - h.z) * u), n > l || a > r) || ((a > n || n !== n) && (n = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(n >= 0 ? n : r, e);
    }
    intersectsBox(t) {
      return this.intersectBox(t, Sa) !== null;
    }
    intersectTriangle(t, e, n, r, o) {
      DI.subVectors(e, t), r0.subVectors(n, t), PI.crossVectors(DI, r0);
      let s = this.direction.dot(PI), a;
      if (s > 0) {
        if (r) return null;
        a = 1;
      } else if (s < 0) a = -1, s = -s;
      else return null;
      yl.subVectors(this.origin, t);
      let l = a * this.direction.dot(r0.crossVectors(yl, r0));
      if (l < 0) return null;
      let c = a * this.direction.dot(DI.cross(yl));
      if (c < 0 || l + c > s) return null;
      let d = -a * yl.dot(PI);
      return d < 0 ? null : this.at(d / s, o);
    }
    applyMatrix4(t) {
      return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
    }
    equals(t) {
      return t.origin.equals(this.origin) && t.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var ut = class i29 {
    constructor() {
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
    set(t, e, n, r, o, s, a, l, c, d, u, h, p, f, m, v) {
      let _ = this.elements;
      return _[0] = t, _[4] = e, _[8] = n, _[12] = r, _[1] = o, _[5] = s, _[9] = a, _[13] = l, _[2] = c, _[6] = d, _[10] = u, _[14] = h, _[3] = p, _[7] = f, _[11] = m, _[15] = v, this;
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new i29().fromArray(this.elements);
    }
    copy(t) {
      let e = this.elements, n = t.elements;
      return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this;
    }
    copyPosition(t) {
      let e = this.elements, n = t.elements;
      return e[12] = n[12], e[13] = n[13], e[14] = n[14], this;
    }
    setFromMatrix3(t) {
      let e = t.elements;
      return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this;
    }
    extractBasis(t, e, n) {
      return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
    }
    makeBasis(t, e, n) {
      return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this;
    }
    extractRotation(t) {
      let e = this.elements, n = t.elements, r = 1 / ph.setFromMatrixColumn(t, 0).length(), o = 1 / ph.setFromMatrixColumn(t, 1).length(), s = 1 / ph.setFromMatrixColumn(t, 2).length();
      return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * o, e[5] = n[5] * o, e[6] = n[6] * o, e[7] = 0, e[8] = n[8] * s, e[9] = n[9] * s, e[10] = n[10] * s, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
    makeRotationFromEuler(t) {
      t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      let e = this.elements, n = t.x, r = t.y, o = t.z, s = Math.cos(n), a = Math.sin(n), l = Math.cos(r), c = Math.sin(r), d = Math.cos(o), u = Math.sin(o);
      if (t.order === "XYZ") {
        let h = s * d, p = s * u, f = a * d, m = a * u;
        e[0] = l * d, e[4] = -l * u, e[8] = c, e[1] = p + f * c, e[5] = h - m * c, e[9] = -a * l, e[2] = m - h * c, e[6] = f + p * c, e[10] = s * l;
      } else if (t.order === "YXZ") {
        let h = l * d, p = l * u, f = c * d, m = c * u;
        e[0] = h + m * a, e[4] = f * a - p, e[8] = s * c, e[1] = s * u, e[5] = s * d, e[9] = -a, e[2] = p * a - f, e[6] = m + h * a, e[10] = s * l;
      } else if (t.order === "ZXY") {
        let h = l * d, p = l * u, f = c * d, m = c * u;
        e[0] = h - m * a, e[4] = -s * u, e[8] = f + p * a, e[1] = p + f * a, e[5] = s * d, e[9] = m - h * a, e[2] = -s * c, e[6] = a, e[10] = s * l;
      } else if (t.order === "ZYX") {
        let h = s * d, p = s * u, f = a * d, m = a * u;
        e[0] = l * d, e[4] = f * c - p, e[8] = h * c + m, e[1] = l * u, e[5] = m * c + h, e[9] = p * c - f, e[2] = -c, e[6] = a * l, e[10] = s * l;
      } else if (t.order === "YZX") {
        let h = s * l, p = s * c, f = a * l, m = a * c;
        e[0] = l * d, e[4] = m - h * u, e[8] = f * u + p, e[1] = u, e[5] = s * d, e[9] = -a * d, e[2] = -c * d, e[6] = p * u + f, e[10] = h - m * u;
      } else if (t.order === "XZY") {
        let h = s * l, p = s * c, f = a * l, m = a * c;
        e[0] = l * d, e[4] = -u, e[8] = c * d, e[1] = h * u + m, e[5] = s * d, e[9] = p * u - f, e[2] = f * u - p, e[6] = a * d, e[10] = m * u + h;
      }
      return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this;
    }
    makeRotationFromQuaternion(t) {
      return this.compose(FJ, t, BJ);
    }
    lookAt(t, e, n) {
      let r = this.elements;
      return co.subVectors(t, e), co.lengthSq() === 0 && (co.z = 1), co.normalize(), bl.crossVectors(n, co), bl.lengthSq() === 0 && (Math.abs(n.z) === 1 ? co.x += 1e-4 : co.z += 1e-4, co.normalize(), bl.crossVectors(n, co)), bl.normalize(), o0.crossVectors(co, bl), r[0] = bl.x, r[4] = o0.x, r[8] = co.x, r[1] = bl.y, r[5] = o0.y, r[9] = co.y, r[2] = bl.z, r[6] = o0.z, r[10] = co.z, this;
    }
    multiply(t, e) {
      return e !== void 0 ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t);
    }
    premultiply(t) {
      return this.multiplyMatrices(t, this);
    }
    multiplyMatrices(t, e) {
      let n = t.elements, r = e.elements, o = this.elements, s = n[0], a = n[4], l = n[8], c = n[12], d = n[1], u = n[5], h = n[9], p = n[13], f = n[2], m = n[6], v = n[10], _ = n[14], g = n[3], y = n[7], w = n[11], E = n[15], P = r[0], S = r[4], A = r[8], W = r[12], H = r[1], O = r[5], I = r[9], F = r[13], j = r[2], $ = r[6], k = r[10], z = r[14], R = r[3], V = r[7], ie = r[11], re = r[15];
      return o[0] = s * P + a * H + l * j + c * R, o[4] = s * S + a * O + l * $ + c * V, o[8] = s * A + a * I + l * k + c * ie, o[12] = s * W + a * F + l * z + c * re, o[1] = d * P + u * H + h * j + p * R, o[5] = d * S + u * O + h * $ + p * V, o[9] = d * A + u * I + h * k + p * ie, o[13] = d * W + u * F + h * z + p * re, o[2] = f * P + m * H + v * j + _ * R, o[6] = f * S + m * O + v * $ + _ * V, o[10] = f * A + m * I + v * k + _ * ie, o[14] = f * W + m * F + v * z + _ * re, o[3] = g * P + y * H + w * j + E * R, o[7] = g * S + y * O + w * $ + E * V, o[11] = g * A + y * I + w * k + E * ie, o[15] = g * W + y * F + w * z + E * re, this;
    }
    multiplyScalar(t) {
      let e = this.elements;
      return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this;
    }
    determinant() {
      let t = this.elements, e = t[0], n = t[4], r = t[8], o = t[12], s = t[1], a = t[5], l = t[9], c = t[13], d = t[2], u = t[6], h = t[10], p = t[14], f = t[3], m = t[7], v = t[11], _ = t[15];
      return f * (+o * l * u - r * c * u - o * a * h + n * c * h + r * a * p - n * l * p) + m * (+e * l * p - e * c * h + o * s * h - r * s * p + r * c * d - o * l * d) + v * (+e * c * u - e * a * p - o * s * u + n * s * p + o * a * d - n * c * d) + _ * (-r * a * d - e * l * u + e * a * h + r * s * u - n * s * h + n * l * d);
    }
    transpose() {
      let t = this.elements, e;
      return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this;
    }
    setPosition(t, e, n) {
      let r = this.elements;
      return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this;
    }
    invert() {
      let t = this.elements, e = t[0], n = t[1], r = t[2], o = t[3], s = t[4], a = t[5], l = t[6], c = t[7], d = t[8], u = t[9], h = t[10], p = t[11], f = t[12], m = t[13], v = t[14], _ = t[15], g = u * v * c - m * h * c + m * l * p - a * v * p - u * l * _ + a * h * _, y = f * h * c - d * v * c - f * l * p + s * v * p + d * l * _ - s * h * _, w = d * m * c - f * u * c + f * a * p - s * m * p - d * a * _ + s * u * _, E = f * u * l - d * m * l - f * a * h + s * m * h + d * a * v - s * u * v, P = e * g + n * y + r * w + o * E;
      if (P === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      let S = 1 / P;
      return t[0] = g * S, t[1] = (m * h * o - u * v * o - m * r * p + n * v * p + u * r * _ - n * h * _) * S, t[2] = (a * v * o - m * l * o + m * r * c - n * v * c - a * r * _ + n * l * _) * S, t[3] = (u * l * o - a * h * o - u * r * c + n * h * c + a * r * p - n * l * p) * S, t[4] = y * S, t[5] = (d * v * o - f * h * o + f * r * p - e * v * p - d * r * _ + e * h * _) * S, t[6] = (f * l * o - s * v * o - f * r * c + e * v * c + s * r * _ - e * l * _) * S, t[7] = (s * h * o - d * l * o + d * r * c - e * h * c - s * r * p + e * l * p) * S, t[8] = w * S, t[9] = (f * u * o - d * m * o - f * n * p + e * m * p + d * n * _ - e * u * _) * S, t[10] = (s * m * o - f * a * o + f * n * c - e * m * c - s * n * _ + e * a * _) * S, t[11] = (d * a * o - s * u * o - d * n * c + e * u * c + s * n * p - e * a * p) * S, t[12] = E * S, t[13] = (d * m * r - f * u * r + f * n * h - e * m * h - d * n * v + e * u * v) * S, t[14] = (f * a * r - s * m * r - f * n * l + e * m * l + s * n * v - e * a * v) * S, t[15] = (s * u * r - d * a * r + d * n * l - e * u * l - s * n * h + e * a * h) * S, this;
    }
    scale(t) {
      let e = this.elements, n = t.x, r = t.y, o = t.z;
      return e[0] *= n, e[4] *= r, e[8] *= o, e[1] *= n, e[5] *= r, e[9] *= o, e[2] *= n, e[6] *= r, e[10] *= o, e[3] *= n, e[7] *= r, e[11] *= o, this;
    }
    getMaxScaleOnAxis() {
      let t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
      return Math.sqrt(Math.max(e, n, r));
    }
    makeTranslation(t, e, n) {
      return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this;
    }
    makeRotationX(t) {
      let e = Math.cos(t), n = Math.sin(t);
      return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(t) {
      let e = Math.cos(t), n = Math.sin(t);
      return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(t) {
      let e = Math.cos(t), n = Math.sin(t);
      return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(t, e) {
      let n = Math.cos(e), r = Math.sin(e), o = 1 - n, s = t.x, a = t.y, l = t.z, c = o * s, d = o * a;
      return this.set(c * s + n, c * a - r * l, c * l + r * a, 0, c * a + r * l, d * a + n, d * l - r * s, 0, c * l - r * a, d * l + r * s, o * l * l + n, 0, 0, 0, 0, 1), this;
    }
    makeScale(t, e, n) {
      return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
    }
    makeShear(t, e, n, r, o, s) {
      return this.set(1, n, o, 0, t, 1, s, 0, e, r, 1, 0, 0, 0, 0, 1), this;
    }
    compose(t, e, n) {
      let r = this.elements, o = e._x, s = e._y, a = e._z, l = e._w, c = o + o, d = s + s, u = a + a, h = o * c, p = o * d, f = o * u, m = s * d, v = s * u, _ = a * u, g = l * c, y = l * d, w = l * u, E = n.x, P = n.y, S = n.z;
      return r[0] = (1 - (m + _)) * E, r[1] = (p + w) * E, r[2] = (f - y) * E, r[3] = 0, r[4] = (p - w) * P, r[5] = (1 - (h + _)) * P, r[6] = (v + g) * P, r[7] = 0, r[8] = (f + y) * S, r[9] = (v - g) * S, r[10] = (1 - (h + m)) * S, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this;
    }
    decompose(t, e, n) {
      let r = this.elements, o = ph.set(r[0], r[1], r[2]).length(), s = ph.set(r[4], r[5], r[6]).length(), a = ph.set(r[8], r[9], r[10]).length();
      this.determinant() < 0 && (o = -o), t.x = r[12], t.y = r[13], t.z = r[14], rs.copy(this);
      let c = 1 / o, d = 1 / s, u = 1 / a;
      return rs.elements[0] *= c, rs.elements[1] *= c, rs.elements[2] *= c, rs.elements[4] *= d, rs.elements[5] *= d, rs.elements[6] *= d, rs.elements[8] *= u, rs.elements[9] *= u, rs.elements[10] *= u, e.setFromRotationMatrix(rs), n.x = o, n.y = s, n.z = a, this;
    }
    makePerspective(t, e, n, r, o, s) {
      s === void 0 && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      let a = this.elements, l = 2 * o / (e - t), c = 2 * o / (n - r), d = (e + t) / (e - t), u = (n + r) / (n - r), h = -(s + o) / (s - o), p = -2 * s * o / (s - o);
      return a[0] = l, a[4] = 0, a[8] = d, a[12] = 0, a[1] = 0, a[5] = c, a[9] = u, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this;
    }
    makeOrthographic(t, e, n, r, o, s) {
      let a = this.elements, l = 1 / (e - t), c = 1 / (n - r), d = 1 / (s - o), u = (e + t) * l, h = (n + r) * c, p = (s + o) * d;
      return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -u, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * d, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this;
    }
    equals(t) {
      let e = this.elements, n = t.elements;
      for (let r = 0; r < 16; r++) if (e[r] !== n[r]) return false;
      return true;
    }
    fromArray(t, e = 0) {
      for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
      return this;
    }
    toArray(t = [], e = 0) {
      let n = this.elements;
      return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t;
    }
  };
  ut.prototype.isMatrix4 = true;
  var ph = new L();
  var rs = new ut();
  var FJ = new L(0, 0, 0);
  var BJ = new L(1, 1, 1);
  var bl = new L();
  var o0 = new L();
  var co = new L();
  var eB = new ut();
  var tB = new Oi();
  var xd = class i30 {
    constructor(t = 0, e = 0, n = 0, r = i30.DefaultOrder) {
      this._x = t, this._y = e, this._z = n, this._order = r;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x = t, this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y = t, this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(t) {
      this._z = t, this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(t) {
      this._order = t, this._onChangeCallback();
    }
    set(t, e, n, r = this._order) {
      return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this;
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(t) {
      return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
    }
    setFromRotationMatrix(t, e = this._order, n = true) {
      let r = t.elements, o = r[0], s = r[4], a = r[8], l = r[1], c = r[5], d = r[9], u = r[2], h = r[6], p = r[10];
      switch (e) {
        case "XYZ":
          this._y = Math.asin(tr(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-d, p), this._z = Math.atan2(-s, o)) : (this._x = Math.atan2(h, c), this._z = 0);
          break;
        case "YXZ":
          this._x = Math.asin(-tr(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(a, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-u, o), this._z = 0);
          break;
        case "ZXY":
          this._x = Math.asin(tr(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(-u, p), this._z = Math.atan2(-s, c)) : (this._y = 0, this._z = Math.atan2(l, o));
          break;
        case "ZYX":
          this._y = Math.asin(-tr(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(h, p), this._z = Math.atan2(l, o)) : (this._x = 0, this._z = Math.atan2(-s, c));
          break;
        case "YZX":
          this._z = Math.asin(tr(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-d, c), this._y = Math.atan2(-u, o)) : (this._x = 0, this._y = Math.atan2(a, p));
          break;
        case "XZY":
          this._z = Math.asin(-tr(s, -1, 1)), Math.abs(s) < 0.9999999 ? (this._x = Math.atan2(h, c), this._y = Math.atan2(a, o)) : (this._x = Math.atan2(-d, p), this._y = 0);
          break;
        default:
          console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e);
      }
      return this._order = e, n === true && this._onChangeCallback(), this;
    }
    setFromQuaternion(t, e, n) {
      return eB.makeRotationFromQuaternion(t), this.setFromRotationMatrix(eB, e, n);
    }
    setFromVector3(t, e = this._order) {
      return this.set(t.x, t.y, t.z, e);
    }
    reorder(t) {
      return tB.setFromEuler(this), this.setFromQuaternion(tB, t);
    }
    equals(t) {
      return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
    }
    fromArray(t) {
      return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
    }
    toArray(t = [], e = 0) {
      return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t;
    }
    toVector3(t) {
      return t ? t.set(this._x, this._y, this._z) : new L(this._x, this._y, this._z);
    }
    _onChange(t) {
      return this._onChangeCallback = t, this;
    }
    _onChangeCallback() {
    }
  };
  xd.prototype.isEuler = true;
  xd.DefaultOrder = "XYZ";
  xd.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  var Gm = class {
    constructor() {
      this.mask = 1;
    }
    set(t) {
      this.mask = 1 << t | 0;
    }
    enable(t) {
      this.mask |= 1 << t | 0;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(t) {
      this.mask ^= 1 << t | 0;
    }
    disable(t) {
      this.mask &= ~(1 << t | 0);
    }
    disableAll() {
      this.mask = 0;
    }
    test(t) {
      return (this.mask & t.mask) !== 0;
    }
  };
  var VJ = 0;
  var nB = new L();
  var fh = new Oi();
  var Ma = new ut();
  var s0 = new L();
  var vm = new L();
  var zJ = new L();
  var UJ = new Oi();
  var iB = new L(1, 0, 0);
  var rB = new L(0, 1, 0);
  var oB = new L(0, 0, 1);
  var GJ = { type: "added" };
  var sB = { type: "removed" };
  var ln = class i31 extends Vs {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: VJ++ }), this.uuid = ho(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = i31.DefaultUp.clone();
      let t = new L(), e = new xd(), n = new Oi(), r = new L(1, 1, 1);
      function o() {
        n.setFromEuler(e, false);
      }
      function s() {
        e.setFromQuaternion(n, void 0, false);
      }
      e._onChange(o), n._onChange(s), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: t }, rotation: { configurable: true, enumerable: true, value: e }, quaternion: { configurable: true, enumerable: true, value: n }, scale: { configurable: true, enumerable: true, value: r }, modelViewMatrix: { value: new ut() }, normalMatrix: { value: new xi() } }), this.matrix = new ut(), this.matrixWorld = new ut(), this.matrixAutoUpdate = i31.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = false, this.layers = new Gm(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
    }
    onBeforeRender() {
    }
    onAfterRender() {
    }
    applyMatrix4(t) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(t) {
      return this.quaternion.premultiply(t), this;
    }
    setRotationFromAxisAngle(t, e) {
      this.quaternion.setFromAxisAngle(t, e);
    }
    setRotationFromEuler(t) {
      this.quaternion.setFromEuler(t, true);
    }
    setRotationFromMatrix(t) {
      this.quaternion.setFromRotationMatrix(t);
    }
    setRotationFromQuaternion(t) {
      this.quaternion.copy(t);
    }
    rotateOnAxis(t, e) {
      return fh.setFromAxisAngle(t, e), this.quaternion.multiply(fh), this;
    }
    rotateOnWorldAxis(t, e) {
      return fh.setFromAxisAngle(t, e), this.quaternion.premultiply(fh), this;
    }
    rotateX(t) {
      return this.rotateOnAxis(iB, t);
    }
    rotateY(t) {
      return this.rotateOnAxis(rB, t);
    }
    rotateZ(t) {
      return this.rotateOnAxis(oB, t);
    }
    translateOnAxis(t, e) {
      return nB.copy(t).applyQuaternion(this.quaternion), this.position.add(nB.multiplyScalar(e)), this;
    }
    translateX(t) {
      return this.translateOnAxis(iB, t);
    }
    translateY(t) {
      return this.translateOnAxis(rB, t);
    }
    translateZ(t) {
      return this.translateOnAxis(oB, t);
    }
    localToWorld(t) {
      return t.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(t) {
      return t.applyMatrix4(Ma.copy(this.matrixWorld).invert());
    }
    lookAt(t, e, n) {
      t.isVector3 ? s0.copy(t) : s0.set(t, e, n);
      let r = this.parent;
      this.updateWorldMatrix(true, false), vm.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ma.lookAt(vm, s0, this.up) : Ma.lookAt(s0, vm, this.up), this.quaternion.setFromRotationMatrix(Ma), r && (Ma.extractRotation(r.matrixWorld), fh.setFromRotationMatrix(Ma), this.quaternion.premultiply(fh.invert()));
    }
    add(t) {
      if (arguments.length > 1) {
        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
        return this;
      }
      return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(GJ)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
    }
    remove(t) {
      if (arguments.length > 1) {
        for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
        return this;
      }
      let e = this.children.indexOf(t);
      return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(sB)), this;
    }
    removeFromParent() {
      let t = this.parent;
      return t !== null && t.remove(this), this;
    }
    clear() {
      for (let t = 0; t < this.children.length; t++) {
        let e = this.children[t];
        e.parent = null, e.dispatchEvent(sB);
      }
      return this.children.length = 0, this;
    }
    attach(t) {
      return this.updateWorldMatrix(true, false), Ma.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(true, false), Ma.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ma), this.add(t), t.updateWorldMatrix(false, true), this;
    }
    getObjectById(t) {
      return this.getObjectByProperty("id", t);
    }
    getObjectByName(t) {
      return this.getObjectByProperty("name", t);
    }
    getObjectByProperty(t, e) {
      if (this[t] === e) return this;
      for (let n = 0, r = this.children.length; n < r; n++) {
        let s = this.children[n].getObjectByProperty(t, e);
        if (s !== void 0) return s;
      }
    }
    getWorldPosition(t) {
      return this.updateWorldMatrix(true, false), t.setFromMatrixPosition(this.matrixWorld);
    }
    getWorldQuaternion(t) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(vm, t, zJ), t;
    }
    getWorldScale(t) {
      return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(vm, UJ, t), t;
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(true, false);
      let e = this.matrixWorld.elements;
      return t.set(e[8], e[9], e[10]).normalize();
    }
    raycast() {
    }
    traverse(t) {
      t(this);
      let e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].traverse(t);
    }
    traverseVisible(t) {
      if (this.visible === false) return;
      t(this);
      let e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t);
    }
    traverseAncestors(t) {
      let e = this.parent;
      e !== null && (t(e), e.traverseAncestors(t));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
    }
    updateMatrixWorld(t) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, t = true);
      let e = this.children;
      for (let n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t);
    }
    updateWorldMatrix(t, e) {
      let n = this.parent;
      if (t === true && n !== null && n.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === true) {
        let r = this.children;
        for (let o = 0, s = r.length; o < s; o++) r[o].updateWorldMatrix(false, true);
      }
    }
    toJSON(t) {
      let e = t === void 0 || typeof t == "string", n = {};
      e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" });
      let r = {};
      r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === true && (r.castShadow = true), this.receiveShadow === true && (r.receiveShadow = true), this.visible === false && (r.visible = false), this.frustumCulled === false && (r.frustumCulled = false), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), JSON.stringify(this.userData) !== "{}" && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === false && (r.matrixAutoUpdate = false), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON()));
      function o(a, l) {
        return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid;
      }
      if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && (r.environment = this.environment.toJSON(t).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        r.geometry = o(t.geometries, this.geometry);
        let a = this.geometry.parameters;
        if (a !== void 0 && a.shapes !== void 0) {
          let l = a.shapes;
          if (Array.isArray(l)) for (let c = 0, d = l.length; c < d; c++) {
            let u = l[c];
            o(t.shapes, u);
          }
          else o(t.shapes, l);
        }
      }
      if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
        let a = [];
        for (let l = 0, c = this.material.length; l < c; l++) a.push(o(t.materials, this.material[l]));
        r.material = a;
      } else r.material = o(t.materials, this.material);
      if (this.children.length > 0) {
        r.children = [];
        for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(t).object);
      }
      if (this.animations.length > 0) {
        r.animations = [];
        for (let a = 0; a < this.animations.length; a++) {
          let l = this.animations[a];
          r.animations.push(o(t.animations, l));
        }
      }
      if (e) {
        let a = s(t.geometries), l = s(t.materials), c = s(t.textures), d = s(t.images), u = s(t.shapes), h = s(t.skeletons), p = s(t.animations);
        a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), d.length > 0 && (n.images = d), u.length > 0 && (n.shapes = u), h.length > 0 && (n.skeletons = h), p.length > 0 && (n.animations = p);
      }
      return n.object = r, n;
      function s(a) {
        let l = [];
        for (let c in a) {
          let d = a[c];
          delete d.metadata, l.push(d);
        }
        return l;
      }
    }
    clone(t) {
      return new this.constructor().copy(this, t);
    }
    copy(t, e = true) {
      if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === true) for (let n = 0; n < t.children.length; n++) {
        let r = t.children[n];
        this.add(r.clone());
      }
      return this;
    }
  };
  ln.DefaultUp = new L(0, 1, 0);
  ln.DefaultMatrixAutoUpdate = true;
  ln.prototype.isObject3D = true;
  var os = new L();
  var Ea = new L();
  var RI = new L();
  var Ta = new L();
  var mh = new L();
  var gh = new L();
  var aB = new L();
  var OI = new L();
  var AI = new L();
  var NI = new L();
  var rr = class i33 {
    constructor(t = new L(), e = new L(), n = new L()) {
      this.a = t, this.b = e, this.c = n;
    }
    static getNormal(t, e, n, r) {
      r.subVectors(n, e), os.subVectors(t, e), r.cross(os);
      let o = r.lengthSq();
      return o > 0 ? r.multiplyScalar(1 / Math.sqrt(o)) : r.set(0, 0, 0);
    }
    static getBarycoord(t, e, n, r, o) {
      os.subVectors(r, e), Ea.subVectors(n, e), RI.subVectors(t, e);
      let s = os.dot(os), a = os.dot(Ea), l = os.dot(RI), c = Ea.dot(Ea), d = Ea.dot(RI), u = s * c - a * a;
      if (u === 0) return o.set(-2, -1, -1);
      let h = 1 / u, p = (c * l - a * d) * h, f = (s * d - a * l) * h;
      return o.set(1 - p - f, f, p);
    }
    static containsPoint(t, e, n, r) {
      return this.getBarycoord(t, e, n, r, Ta), Ta.x >= 0 && Ta.y >= 0 && Ta.x + Ta.y <= 1;
    }
    static getUV(t, e, n, r, o, s, a, l) {
      return this.getBarycoord(t, e, n, r, Ta), l.set(0, 0), l.addScaledVector(o, Ta.x), l.addScaledVector(s, Ta.y), l.addScaledVector(a, Ta.z), l;
    }
    static isFrontFacing(t, e, n, r) {
      return os.subVectors(n, e), Ea.subVectors(t, e), os.cross(Ea).dot(r) < 0;
    }
    set(t, e, n) {
      return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
    }
    setFromPointsAndIndices(t, e, n, r) {
      return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this;
    }
    setFromAttributeAndIndices(t, e, n, r) {
      return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
    }
    getArea() {
      return os.subVectors(this.c, this.b), Ea.subVectors(this.a, this.b), os.cross(Ea).length() * 0.5;
    }
    getMidpoint(t) {
      return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    }
    getNormal(t) {
      return i33.getNormal(this.a, this.b, this.c, t);
    }
    getPlane(t) {
      return t.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(t, e) {
      return i33.getBarycoord(t, this.a, this.b, this.c, e);
    }
    getUV(t, e, n, r, o) {
      return i33.getUV(t, this.a, this.b, this.c, e, n, r, o);
    }
    containsPoint(t) {
      return i33.containsPoint(t, this.a, this.b, this.c);
    }
    isFrontFacing(t) {
      return i33.isFrontFacing(this.a, this.b, this.c, t);
    }
    intersectsBox(t) {
      return t.intersectsTriangle(this);
    }
    closestPointToPoint(t, e) {
      let n = this.a, r = this.b, o = this.c, s, a;
      mh.subVectors(r, n), gh.subVectors(o, n), OI.subVectors(t, n);
      let l = mh.dot(OI), c = gh.dot(OI);
      if (l <= 0 && c <= 0) return e.copy(n);
      AI.subVectors(t, r);
      let d = mh.dot(AI), u = gh.dot(AI);
      if (d >= 0 && u <= d) return e.copy(r);
      let h = l * u - d * c;
      if (h <= 0 && l >= 0 && d <= 0) return s = l / (l - d), e.copy(n).addScaledVector(mh, s);
      NI.subVectors(t, o);
      let p = mh.dot(NI), f = gh.dot(NI);
      if (f >= 0 && p <= f) return e.copy(o);
      let m = p * c - l * f;
      if (m <= 0 && c >= 0 && f <= 0) return a = c / (c - f), e.copy(n).addScaledVector(gh, a);
      let v = d * f - p * u;
      if (v <= 0 && u - d >= 0 && p - f >= 0) return aB.subVectors(o, r), a = (u - d) / (u - d + (p - f)), e.copy(r).addScaledVector(aB, a);
      let _ = 1 / (v + m + h);
      return s = m * _, a = h * _, e.copy(n).addScaledVector(mh, s).addScaledVector(gh, a);
    }
    equals(t) {
      return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
    }
  };
  var HJ = 0;
  var Mi = class extends Vs {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: HJ++ }), this.uuid = ho(), this.name = "", this.type = "Material", this.fog = true, this.blending = Rh, this.side = yd, this.vertexColors = false, this.opacity = 1, this.format = ir, this.transparent = false, this.blendSrc = K1, this.blendDst = J1, this.blendEquation = hd, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = H0, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = Zz, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = G0, this.stencilZFail = G0, this.stencilZPass = G0, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(t) {
      this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
    }
    onBuild() {
    }
    onBeforeRender() {
    }
    onBeforeCompile() {
    }
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(t) {
      if (t !== void 0) for (let e in t) {
        let n = t[e];
        if (n === void 0) {
          console.warn("THREE.Material: '" + e + "' parameter is undefined.");
          continue;
        }
        if (e === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === Q1;
          continue;
        }
        let r = this[e];
        if (r === void 0) {
          console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.");
          continue;
        }
        r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n;
      }
    }
    toJSON(t) {
      let e = t === void 0 || typeof t == "string";
      e && (t = { textures: {}, images: {} });
      let n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } };
      n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Rh && (n.blending = this.blending), this.side !== yd && (n.side = this.side), this.vertexColors && (n.vertexColors = true), this.opacity < 1 && (n.opacity = this.opacity), this.format !== ir && (n.format = this.format), this.transparent === true && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === true && (n.polygonOffset = true), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === true && (n.dithering = true), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === true && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === true && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === true && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (n.flatShading = this.flatShading), this.visible === false && (n.visible = false), this.toneMapped === false && (n.toneMapped = false), JSON.stringify(this.userData) !== "{}" && (n.userData = this.userData);
      function r(o) {
        let s = [];
        for (let a in o) {
          let l = o[a];
          delete l.metadata, s.push(l);
        }
        return s;
      }
      if (e) {
        let o = r(t.textures), s = r(t.images);
        o.length > 0 && (n.textures = o), s.length > 0 && (n.images = s);
      }
      return n;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      this.name = t.name, this.fog = t.fog, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.format = t.format, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
      let e = t.clippingPlanes, n = null;
      if (e !== null) {
        let r = e.length;
        n = new Array(r);
        for (let o = 0; o !== r; ++o) n[o] = e[o].clone();
      }
      return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
  };
  Mi.prototype.isMaterial = true;
  var lB = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 };
  var ss = { h: 0, s: 0, l: 0 };
  var a0 = { h: 0, s: 0, l: 0 };
  function kI(i59, t, e) {
    return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i59 + (t - i59) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i59 + (t - i59) * 6 * (2 / 3 - e) : i59;
  }
  function LI(i59) {
    return i59 < 0.04045 ? i59 * 0.0773993808 : Math.pow(i59 * 0.9478672986 + 0.0521327014, 2.4);
  }
  function FI(i59) {
    return i59 < 31308e-7 ? i59 * 12.92 : 1.055 * Math.pow(i59, 0.41666) - 0.055;
  }
  var Ye = (() => {
    class i59 {
      constructor(e, n, r) {
        return n === void 0 && r === void 0 ? this.set(e) : this.setRGB(e, n, r);
      }
      set(e) {
        return e && e.isColor ? this.copy(e) : typeof e == "number" ? this.setHex(e) : typeof e == "string" && this.setStyle(e), this;
      }
      setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this;
      }
      setHex(e) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, this;
      }
      setRGB(e, n, r) {
        return this.r = e, this.g = n, this.b = r, this;
      }
      setHSL(e, n, r) {
        if (e = oD(e, 1), n = tr(n, 0, 1), r = tr(r, 0, 1), n === 0) this.r = this.g = this.b = r;
        else {
          let o = r <= 0.5 ? r * (1 + n) : r + n - r * n, s = 2 * r - o;
          this.r = kI(s, o, e + 1 / 3), this.g = kI(s, o, e), this.b = kI(s, o, e - 1 / 3);
        }
        return this;
      }
      setStyle(e) {
        function n(o) {
          o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
        }
        let r;
        if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
          let o, s = r[1], a = r[2];
          switch (s) {
            case "rgb":
            case "rgba":
              if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(o[1], 10)) / 255, this.g = Math.min(255, parseInt(o[2], 10)) / 255, this.b = Math.min(255, parseInt(o[3], 10)) / 255, n(o[4]), this;
              if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(o[1], 10)) / 100, this.g = Math.min(100, parseInt(o[2], 10)) / 100, this.b = Math.min(100, parseInt(o[3], 10)) / 100, n(o[4]), this;
              break;
            case "hsl":
            case "hsla":
              if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) {
                let l = parseFloat(o[1]) / 360, c = parseInt(o[2], 10) / 100, d = parseInt(o[3], 10) / 100;
                return n(o[4]), this.setHSL(l, c, d);
              }
              break;
          }
        } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
          let o = r[1], s = o.length;
          if (s === 3) return this.r = parseInt(o.charAt(0) + o.charAt(0), 16) / 255, this.g = parseInt(o.charAt(1) + o.charAt(1), 16) / 255, this.b = parseInt(o.charAt(2) + o.charAt(2), 16) / 255, this;
          if (s === 6) return this.r = parseInt(o.charAt(0) + o.charAt(1), 16) / 255, this.g = parseInt(o.charAt(2) + o.charAt(3), 16) / 255, this.b = parseInt(o.charAt(4) + o.charAt(5), 16) / 255, this;
        }
        return e && e.length > 0 ? this.setColorName(e) : this;
      }
      setColorName(e) {
        let n = lB[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + e), this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this;
      }
      copyGammaToLinear(e, n = 2) {
        return this.r = Math.pow(e.r, n), this.g = Math.pow(e.g, n), this.b = Math.pow(e.b, n), this;
      }
      copyLinearToGamma(e, n = 2) {
        let r = n > 0 ? 1 / n : 1;
        return this.r = Math.pow(e.r, r), this.g = Math.pow(e.g, r), this.b = Math.pow(e.b, r), this;
      }
      convertGammaToLinear(e) {
        return this.copyGammaToLinear(this, e), this;
      }
      convertLinearToGamma(e) {
        return this.copyLinearToGamma(this, e), this;
      }
      copySRGBToLinear(e) {
        return this.r = LI(e.r), this.g = LI(e.g), this.b = LI(e.b), this;
      }
      copyLinearToSRGB(e) {
        return this.r = FI(e.r), this.g = FI(e.g), this.b = FI(e.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex() {
        return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
      }
      getHexString() {
        return ("000000" + this.getHex().toString(16)).slice(-6);
      }
      getHSL(e) {
        let n = this.r, r = this.g, o = this.b, s = Math.max(n, r, o), a = Math.min(n, r, o), l, c, d = (a + s) / 2;
        if (a === s) l = 0, c = 0;
        else {
          let u = s - a;
          switch (c = d <= 0.5 ? u / (s + a) : u / (2 - s - a), s) {
            case n:
              l = (r - o) / u + (r < o ? 6 : 0);
              break;
            case r:
              l = (o - n) / u + 2;
              break;
            case o:
              l = (n - r) / u + 4;
              break;
          }
          l /= 6;
        }
        return e.h = l, e.s = c, e.l = d, e;
      }
      getStyle() {
        return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
      }
      offsetHSL(e, n, r) {
        return this.getHSL(ss), ss.h += e, ss.s += n, ss.l += r, this.setHSL(ss.h, ss.s, ss.l), this;
      }
      add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this;
      }
      addColors(e, n) {
        return this.r = e.r + n.r, this.g = e.g + n.g, this.b = e.b + n.b, this;
      }
      addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this;
      }
      sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
      }
      multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
      }
      multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this;
      }
      lerp(e, n) {
        return this.r += (e.r - this.r) * n, this.g += (e.g - this.g) * n, this.b += (e.b - this.b) * n, this;
      }
      lerpColors(e, n, r) {
        return this.r = e.r + (n.r - e.r) * r, this.g = e.g + (n.g - e.g) * r, this.b = e.b + (n.b - e.b) * r, this;
      }
      lerpHSL(e, n) {
        this.getHSL(ss), e.getHSL(a0);
        let r = Im(ss.h, a0.h, n), o = Im(ss.s, a0.s, n), s = Im(ss.l, a0.l, n);
        return this.setHSL(r, o, s), this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, n = 0) {
        return this.r = e[n], this.g = e[n + 1], this.b = e[n + 2], this;
      }
      toArray(e = [], n = 0) {
        return e[n] = this.r, e[n + 1] = this.g, e[n + 2] = this.b, e;
      }
      fromBufferAttribute(e, n) {
        return this.r = e.getX(n), this.g = e.getY(n), this.b = e.getZ(n), e.normalized === true && (this.r /= 255, this.g /= 255, this.b /= 255), this;
      }
      toJSON() {
        return this.getHex();
      }
    }
    return i59.NAMES = lB, i59;
  })();
  Ye.prototype.isColor = true;
  Ye.prototype.r = 1;
  Ye.prototype.g = 1;
  Ye.prototype.b = 1;
  var ls = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshBasicMaterial", this.color = new Ye(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
  };
  ls.prototype.isMeshBasicMaterial = true;
  var Ln = new L();
  var l0 = new Me();
  var an = class {
    constructor(t, e, n) {
      if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n === true, this.usage = kh, this.updateRange = { offset: 0, count: -1 }, this.version = 0;
    }
    onUploadCallback() {
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    setUsage(t) {
      return this.usage = t, this;
    }
    copy(t) {
      return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this;
    }
    copyAt(t, e, n) {
      t *= this.itemSize, n *= e.itemSize;
      for (let r = 0, o = this.itemSize; r < o; r++) this.array[t + r] = e.array[n + r];
      return this;
    }
    copyArray(t) {
      return this.array.set(t), this;
    }
    copyColorsArray(t) {
      let e = this.array, n = 0;
      for (let r = 0, o = t.length; r < o; r++) {
        let s = t[r];
        s === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), s = new Ye()), e[n++] = s.r, e[n++] = s.g, e[n++] = s.b;
      }
      return this;
    }
    copyVector2sArray(t) {
      let e = this.array, n = 0;
      for (let r = 0, o = t.length; r < o; r++) {
        let s = t[r];
        s === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), s = new Me()), e[n++] = s.x, e[n++] = s.y;
      }
      return this;
    }
    copyVector3sArray(t) {
      let e = this.array, n = 0;
      for (let r = 0, o = t.length; r < o; r++) {
        let s = t[r];
        s === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), s = new L()), e[n++] = s.x, e[n++] = s.y, e[n++] = s.z;
      }
      return this;
    }
    copyVector4sArray(t) {
      let e = this.array, n = 0;
      for (let r = 0, o = t.length; r < o; r++) {
        let s = t[r];
        s === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), s = new bn()), e[n++] = s.x, e[n++] = s.y, e[n++] = s.z, e[n++] = s.w;
      }
      return this;
    }
    applyMatrix3(t) {
      if (this.itemSize === 2) for (let e = 0, n = this.count; e < n; e++) l0.fromBufferAttribute(this, e), l0.applyMatrix3(t), this.setXY(e, l0.x, l0.y);
      else if (this.itemSize === 3) for (let e = 0, n = this.count; e < n; e++) Ln.fromBufferAttribute(this, e), Ln.applyMatrix3(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
      return this;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.count; e < n; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.applyMatrix4(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.applyNormalMatrix(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) Ln.x = this.getX(e), Ln.y = this.getY(e), Ln.z = this.getZ(e), Ln.transformDirection(t), this.setXYZ(e, Ln.x, Ln.y, Ln.z);
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    getX(t) {
      return this.array[t * this.itemSize];
    }
    setX(t, e) {
      return this.array[t * this.itemSize] = e, this;
    }
    getY(t) {
      return this.array[t * this.itemSize + 1];
    }
    setY(t, e) {
      return this.array[t * this.itemSize + 1] = e, this;
    }
    getZ(t) {
      return this.array[t * this.itemSize + 2];
    }
    setZ(t, e) {
      return this.array[t * this.itemSize + 2] = e, this;
    }
    getW(t) {
      return this.array[t * this.itemSize + 3];
    }
    setW(t, e) {
      return this.array[t * this.itemSize + 3] = e, this;
    }
    setXY(t, e, n) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this;
    }
    setXYZ(t, e, n, r) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this;
    }
    setXYZW(t, e, n, r, o) {
      return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = o, this;
    }
    onUpload(t) {
      return this.onUploadCallback = t, this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      let t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized };
      return this.name !== "" && (t.name = this.name), this.usage !== kh && (t.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (t.updateRange = this.updateRange), t;
    }
  };
  an.prototype.isBufferAttribute = true;
  var q0 = class extends an {
    constructor(t, e, n) {
      super(new Int8Array(t), e, n);
    }
  };
  var Y0 = class extends an {
    constructor(t, e, n) {
      super(new Uint8Array(t), e, n);
    }
  };
  var X0 = class extends an {
    constructor(t, e, n) {
      super(new Uint8ClampedArray(t), e, n);
    }
  };
  var Z0 = class extends an {
    constructor(t, e, n) {
      super(new Int16Array(t), e, n);
    }
  };
  var Fh = class extends an {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  };
  var Q0 = class extends an {
    constructor(t, e, n) {
      super(new Int32Array(t), e, n);
    }
  };
  var Bh = class extends an {
    constructor(t, e, n) {
      super(new Uint32Array(t), e, n);
    }
  };
  var K0 = class extends an {
    constructor(t, e, n) {
      super(new Uint16Array(t), e, n);
    }
  };
  K0.prototype.isFloat16BufferAttribute = true;
  var it = class extends an {
    constructor(t, e, n) {
      super(new Float32Array(t), e, n);
    }
  };
  var J0 = class extends an {
    constructor(t, e, n) {
      super(new Float64Array(t), e, n);
    }
  };
  var jJ = 0;
  var Ao = new ut();
  var BI = new ln();
  var _h = new L();
  var uo = new Lr();
  var ym = new Lr();
  var Vi = new L();
  var Ct = class i34 extends Vs {
    constructor() {
      super(), Object.defineProperty(this, "id", { value: jJ++ }), this.uuid = ho(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
    }
    getIndex() {
      return this.index;
    }
    setIndex(t) {
      return Array.isArray(t) ? this.index = new (Jz(t) > 65535 ? Bh : Fh)(t, 1) : this.index = t, this;
    }
    getAttribute(t) {
      return this.attributes[t];
    }
    setAttribute(t, e) {
      return this.attributes[t] = e, this;
    }
    deleteAttribute(t) {
      return delete this.attributes[t], this;
    }
    hasAttribute(t) {
      return this.attributes[t] !== void 0;
    }
    addGroup(t, e, n = 0) {
      this.groups.push({ start: t, count: e, materialIndex: n });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(t, e) {
      this.drawRange.start = t, this.drawRange.count = e;
    }
    applyMatrix4(t) {
      let e = this.attributes.position;
      e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = true);
      let n = this.attributes.normal;
      if (n !== void 0) {
        let o = new xi().getNormalMatrix(t);
        n.applyNormalMatrix(o), n.needsUpdate = true;
      }
      let r = this.attributes.tangent;
      return r !== void 0 && (r.transformDirection(t), r.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
    }
    applyQuaternion(t) {
      return Ao.makeRotationFromQuaternion(t), this.applyMatrix4(Ao), this;
    }
    rotateX(t) {
      return Ao.makeRotationX(t), this.applyMatrix4(Ao), this;
    }
    rotateY(t) {
      return Ao.makeRotationY(t), this.applyMatrix4(Ao), this;
    }
    rotateZ(t) {
      return Ao.makeRotationZ(t), this.applyMatrix4(Ao), this;
    }
    translate(t, e, n) {
      return Ao.makeTranslation(t, e, n), this.applyMatrix4(Ao), this;
    }
    scale(t, e, n) {
      return Ao.makeScale(t, e, n), this.applyMatrix4(Ao), this;
    }
    lookAt(t) {
      return BI.lookAt(t), BI.updateMatrix(), this.applyMatrix4(BI.matrix), this;
    }
    center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(_h).negate(), this.translate(_h.x, _h.y, _h.z), this;
    }
    setFromPoints(t) {
      let e = [];
      for (let n = 0, r = t.length; n < r; n++) {
        let o = t[n];
        e.push(o.x, o.y, o.z || 0);
      }
      return this.setAttribute("position", new it(e, 3)), this;
    }
    computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new Lr());
      let t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new L(-1 / 0, -1 / 0, -1 / 0), new L(1 / 0, 1 / 0, 1 / 0));
        return;
      }
      if (t !== void 0) {
        if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, r = e.length; n < r; n++) {
          let o = e[n];
          uo.setFromBufferAttribute(o), this.morphTargetsRelative ? (Vi.addVectors(this.boundingBox.min, uo.min), this.boundingBox.expandByPoint(Vi), Vi.addVectors(this.boundingBox.max, uo.max), this.boundingBox.expandByPoint(Vi)) : (this.boundingBox.expandByPoint(uo.min), this.boundingBox.expandByPoint(uo.max));
        }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
    computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new zs());
      let t = this.attributes.position, e = this.morphAttributes.position;
      if (t && t.isGLBufferAttribute) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new L(), 1 / 0);
        return;
      }
      if (t) {
        let n = this.boundingSphere.center;
        if (uo.setFromBufferAttribute(t), e) for (let o = 0, s = e.length; o < s; o++) {
          let a = e[o];
          ym.setFromBufferAttribute(a), this.morphTargetsRelative ? (Vi.addVectors(uo.min, ym.min), uo.expandByPoint(Vi), Vi.addVectors(uo.max, ym.max), uo.expandByPoint(Vi)) : (uo.expandByPoint(ym.min), uo.expandByPoint(ym.max));
        }
        uo.getCenter(n);
        let r = 0;
        for (let o = 0, s = t.count; o < s; o++) Vi.fromBufferAttribute(t, o), r = Math.max(r, n.distanceToSquared(Vi));
        if (e) for (let o = 0, s = e.length; o < s; o++) {
          let a = e[o], l = this.morphTargetsRelative;
          for (let c = 0, d = a.count; c < d; c++) Vi.fromBufferAttribute(a, c), l && (_h.fromBufferAttribute(t, c), Vi.add(_h)), r = Math.max(r, n.distanceToSquared(Vi));
        }
        this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
    computeTangents() {
      let t = this.index, e = this.attributes;
      if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) {
        console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
        return;
      }
      let n = t.array, r = e.position.array, o = e.normal.array, s = e.uv.array, a = r.length / 3;
      e.tangent === void 0 && this.setAttribute("tangent", new an(new Float32Array(4 * a), 4));
      let l = e.tangent.array, c = [], d = [];
      for (let H = 0; H < a; H++) c[H] = new L(), d[H] = new L();
      let u = new L(), h = new L(), p = new L(), f = new Me(), m = new Me(), v = new Me(), _ = new L(), g = new L();
      function y(H, O, I) {
        u.fromArray(r, H * 3), h.fromArray(r, O * 3), p.fromArray(r, I * 3), f.fromArray(s, H * 2), m.fromArray(s, O * 2), v.fromArray(s, I * 2), h.sub(u), p.sub(u), m.sub(f), v.sub(f);
        let F = 1 / (m.x * v.y - v.x * m.y);
        isFinite(F) && (_.copy(h).multiplyScalar(v.y).addScaledVector(p, -m.y).multiplyScalar(F), g.copy(p).multiplyScalar(m.x).addScaledVector(h, -v.x).multiplyScalar(F), c[H].add(_), c[O].add(_), c[I].add(_), d[H].add(g), d[O].add(g), d[I].add(g));
      }
      let w = this.groups;
      w.length === 0 && (w = [{ start: 0, count: n.length }]);
      for (let H = 0, O = w.length; H < O; ++H) {
        let I = w[H], F = I.start, j = I.count;
        for (let $ = F, k = F + j; $ < k; $ += 3) y(n[$ + 0], n[$ + 1], n[$ + 2]);
      }
      let E = new L(), P = new L(), S = new L(), A = new L();
      function W(H) {
        S.fromArray(o, H * 3), A.copy(S);
        let O = c[H];
        E.copy(O), E.sub(S.multiplyScalar(S.dot(O))).normalize(), P.crossVectors(A, O);
        let F = P.dot(d[H]) < 0 ? -1 : 1;
        l[H * 4] = E.x, l[H * 4 + 1] = E.y, l[H * 4 + 2] = E.z, l[H * 4 + 3] = F;
      }
      for (let H = 0, O = w.length; H < O; ++H) {
        let I = w[H], F = I.start, j = I.count;
        for (let $ = F, k = F + j; $ < k; $ += 3) W(n[$ + 0]), W(n[$ + 1]), W(n[$ + 2]);
      }
    }
    computeVertexNormals() {
      let t = this.index, e = this.getAttribute("position");
      if (e !== void 0) {
        let n = this.getAttribute("normal");
        if (n === void 0) n = new an(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n);
        else for (let h = 0, p = n.count; h < p; h++) n.setXYZ(h, 0, 0, 0);
        let r = new L(), o = new L(), s = new L(), a = new L(), l = new L(), c = new L(), d = new L(), u = new L();
        if (t) for (let h = 0, p = t.count; h < p; h += 3) {
          let f = t.getX(h + 0), m = t.getX(h + 1), v = t.getX(h + 2);
          r.fromBufferAttribute(e, f), o.fromBufferAttribute(e, m), s.fromBufferAttribute(e, v), d.subVectors(s, o), u.subVectors(r, o), d.cross(u), a.fromBufferAttribute(n, f), l.fromBufferAttribute(n, m), c.fromBufferAttribute(n, v), a.add(d), l.add(d), c.add(d), n.setXYZ(f, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, c.x, c.y, c.z);
        }
        else for (let h = 0, p = e.count; h < p; h += 3) r.fromBufferAttribute(e, h + 0), o.fromBufferAttribute(e, h + 1), s.fromBufferAttribute(e, h + 2), d.subVectors(s, o), u.subVectors(r, o), d.cross(u), n.setXYZ(h + 0, d.x, d.y, d.z), n.setXYZ(h + 1, d.x, d.y, d.z), n.setXYZ(h + 2, d.x, d.y, d.z);
        this.normalizeNormals(), n.needsUpdate = true;
      }
    }
    merge(t, e) {
      if (!(t && t.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
        return;
      }
      e === void 0 && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
      let n = this.attributes;
      for (let r in n) {
        if (t.attributes[r] === void 0) continue;
        let s = n[r].array, a = t.attributes[r], l = a.array, c = a.itemSize * e, d = Math.min(l.length, s.length - c);
        for (let u = 0, h = c; u < d; u++, h++) s[h] = l[u];
      }
      return this;
    }
    normalizeNormals() {
      let t = this.attributes.normal;
      for (let e = 0, n = t.count; e < n; e++) Vi.fromBufferAttribute(t, e), Vi.normalize(), t.setXYZ(e, Vi.x, Vi.y, Vi.z);
    }
    toNonIndexed() {
      function t(a, l) {
        let c = a.array, d = a.itemSize, u = a.normalized, h = new c.constructor(l.length * d), p = 0, f = 0;
        for (let m = 0, v = l.length; m < v; m++) {
          a.isInterleavedBufferAttribute ? p = l[m] * a.data.stride + a.offset : p = l[m] * d;
          for (let _ = 0; _ < d; _++) h[f++] = c[p++];
        }
        return new an(h, d, u);
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      let e = new i34(), n = this.index.array, r = this.attributes;
      for (let a in r) {
        let l = r[a], c = t(l, n);
        e.setAttribute(a, c);
      }
      let o = this.morphAttributes;
      for (let a in o) {
        let l = [], c = o[a];
        for (let d = 0, u = c.length; d < u; d++) {
          let h = c[d], p = t(h, n);
          l.push(p);
        }
        e.morphAttributes[a] = l;
      }
      e.morphTargetsRelative = this.morphTargetsRelative;
      let s = this.groups;
      for (let a = 0, l = s.length; a < l; a++) {
        let c = s[a];
        e.addGroup(c.start, c.count, c.materialIndex);
      }
      return e;
    }
    toJSON() {
      let t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
      if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
        let l = this.parameters;
        for (let c in l) l[c] !== void 0 && (t[c] = l[c]);
        return t;
      }
      t.data = { attributes: {} };
      let e = this.index;
      e !== null && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) });
      let n = this.attributes;
      for (let l in n) {
        let c = n[l];
        t.data.attributes[l] = c.toJSON(t.data);
      }
      let r = {}, o = false;
      for (let l in this.morphAttributes) {
        let c = this.morphAttributes[l], d = [];
        for (let u = 0, h = c.length; u < h; u++) {
          let p = c[u];
          d.push(p.toJSON(t.data));
        }
        d.length > 0 && (r[l] = d, o = true);
      }
      o && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative);
      let s = this.groups;
      s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
      let a = this.boundingSphere;
      return a !== null && (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), t;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      let e = {};
      this.name = t.name;
      let n = t.index;
      n !== null && this.setIndex(n.clone(e));
      let r = t.attributes;
      for (let c in r) {
        let d = r[c];
        this.setAttribute(c, d.clone(e));
      }
      let o = t.morphAttributes;
      for (let c in o) {
        let d = [], u = o[c];
        for (let h = 0, p = u.length; h < p; h++) d.push(u[h].clone(e));
        this.morphAttributes[c] = d;
      }
      this.morphTargetsRelative = t.morphTargetsRelative;
      let s = t.groups;
      for (let c = 0, d = s.length; c < d; c++) {
        let u = s[c];
        this.addGroup(u.start, u.count, u.materialIndex);
      }
      let a = t.boundingBox;
      a !== null && (this.boundingBox = a.clone());
      let l = t.boundingSphere;
      return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, t.parameters !== void 0 && (this.parameters = Object.assign({}, t.parameters)), this;
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  Ct.prototype.isBufferGeometry = true;
  var cB = new ut();
  var vh = new Us();
  var VI = new zs();
  var xl = new L();
  var wl = new L();
  var Cl = new L();
  var zI = new L();
  var UI = new L();
  var GI = new L();
  var c0 = new L();
  var d0 = new L();
  var u0 = new L();
  var h0 = new Me();
  var p0 = new Me();
  var f0 = new Me();
  var HI = new L();
  var m0 = new L();
  var li = class extends ln {
    constructor(t = new Ct(), e = new ls()) {
      super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t) {
      return super.copy(t), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this;
    }
    updateMorphTargets() {
      let t = this.geometry;
      if (t.isBufferGeometry) {
        let e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          let r = e[n[0]];
          if (r !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let o = 0, s = r.length; o < s; o++) {
              let a = r[o].name || String(o);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o;
            }
          }
        }
      } else {
        let e = t.morphTargets;
        e !== void 0 && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
    raycast(t, e) {
      let n = this.geometry, r = this.material, o = this.matrixWorld;
      if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), VI.copy(n.boundingSphere), VI.applyMatrix4(o), t.ray.intersectsSphere(VI) === false) || (cB.copy(o).invert(), vh.copy(t.ray).applyMatrix4(cB), n.boundingBox !== null && vh.intersectsBox(n.boundingBox) === false)) return;
      let s;
      if (n.isBufferGeometry) {
        let a = n.index, l = n.attributes.position, c = n.morphAttributes.position, d = n.morphTargetsRelative, u = n.attributes.uv, h = n.attributes.uv2, p = n.groups, f = n.drawRange;
        if (a !== null) if (Array.isArray(r)) for (let m = 0, v = p.length; m < v; m++) {
          let _ = p[m], g = r[_.materialIndex], y = Math.max(_.start, f.start), w = Math.min(a.count, Math.min(_.start + _.count, f.start + f.count));
          for (let E = y, P = w; E < P; E += 3) {
            let S = a.getX(E), A = a.getX(E + 1), W = a.getX(E + 2);
            s = g0(this, g, t, vh, l, c, d, u, h, S, A, W), s && (s.faceIndex = Math.floor(E / 3), s.face.materialIndex = _.materialIndex, e.push(s));
          }
        }
        else {
          let m = Math.max(0, f.start), v = Math.min(a.count, f.start + f.count);
          for (let _ = m, g = v; _ < g; _ += 3) {
            let y = a.getX(_), w = a.getX(_ + 1), E = a.getX(_ + 2);
            s = g0(this, r, t, vh, l, c, d, u, h, y, w, E), s && (s.faceIndex = Math.floor(_ / 3), e.push(s));
          }
        }
        else if (l !== void 0) if (Array.isArray(r)) for (let m = 0, v = p.length; m < v; m++) {
          let _ = p[m], g = r[_.materialIndex], y = Math.max(_.start, f.start), w = Math.min(l.count, Math.min(_.start + _.count, f.start + f.count));
          for (let E = y, P = w; E < P; E += 3) {
            let S = E, A = E + 1, W = E + 2;
            s = g0(this, g, t, vh, l, c, d, u, h, S, A, W), s && (s.faceIndex = Math.floor(E / 3), s.face.materialIndex = _.materialIndex, e.push(s));
          }
        }
        else {
          let m = Math.max(0, f.start), v = Math.min(l.count, f.start + f.count);
          for (let _ = m, g = v; _ < g; _ += 3) {
            let y = _, w = _ + 1, E = _ + 2;
            s = g0(this, r, t, vh, l, c, d, u, h, y, w, E), s && (s.faceIndex = Math.floor(_ / 3), e.push(s));
          }
        }
      } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
  };
  li.prototype.isMesh = true;
  function WJ(i59, t, e, n, r, o, s, a) {
    let l;
    if (t.side === bi ? l = n.intersectTriangle(s, o, r, true, a) : l = n.intersectTriangle(r, o, s, t.side !== bd, a), l === null) return null;
    m0.copy(a), m0.applyMatrix4(i59.matrixWorld);
    let c = e.ray.origin.distanceTo(m0);
    return c < e.near || c > e.far ? null : { distance: c, point: m0.clone(), object: i59 };
  }
  function g0(i59, t, e, n, r, o, s, a, l, c, d, u) {
    xl.fromBufferAttribute(r, c), wl.fromBufferAttribute(r, d), Cl.fromBufferAttribute(r, u);
    let h = i59.morphTargetInfluences;
    if (o && h) {
      c0.set(0, 0, 0), d0.set(0, 0, 0), u0.set(0, 0, 0);
      for (let f = 0, m = o.length; f < m; f++) {
        let v = h[f], _ = o[f];
        v !== 0 && (zI.fromBufferAttribute(_, c), UI.fromBufferAttribute(_, d), GI.fromBufferAttribute(_, u), s ? (c0.addScaledVector(zI, v), d0.addScaledVector(UI, v), u0.addScaledVector(GI, v)) : (c0.addScaledVector(zI.sub(xl), v), d0.addScaledVector(UI.sub(wl), v), u0.addScaledVector(GI.sub(Cl), v)));
      }
      xl.add(c0), wl.add(d0), Cl.add(u0);
    }
    i59.isSkinnedMesh && (i59.boneTransform(c, xl), i59.boneTransform(d, wl), i59.boneTransform(u, Cl));
    let p = WJ(i59, t, e, n, xl, wl, Cl, HI);
    if (p) {
      a && (h0.fromBufferAttribute(a, c), p0.fromBufferAttribute(a, d), f0.fromBufferAttribute(a, u), p.uv = rr.getUV(HI, xl, wl, Cl, h0, p0, f0, new Me())), l && (h0.fromBufferAttribute(l, c), p0.fromBufferAttribute(l, d), f0.fromBufferAttribute(l, u), p.uv2 = rr.getUV(HI, xl, wl, Cl, h0, p0, f0, new Me()));
      let f = { a: c, b: d, c: u, normal: new L(), materialIndex: 0 };
      rr.getNormal(xl, wl, Cl, f.normal), p.face = f;
    }
    return p;
  }
  var Il = class i35 extends Ct {
    constructor(t = 1, e = 1, n = 1, r = 1, o = 1, s = 1) {
      super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: o, depthSegments: s };
      let a = this;
      r = Math.floor(r), o = Math.floor(o), s = Math.floor(s);
      let l = [], c = [], d = [], u = [], h = 0, p = 0;
      f("z", "y", "x", -1, -1, n, e, t, s, o, 0), f("z", "y", "x", 1, -1, n, e, -t, s, o, 1), f("x", "z", "y", 1, 1, t, n, e, r, s, 2), f("x", "z", "y", 1, -1, t, n, -e, r, s, 3), f("x", "y", "z", 1, -1, t, e, n, r, o, 4), f("x", "y", "z", -1, -1, t, e, -n, r, o, 5), this.setIndex(l), this.setAttribute("position", new it(c, 3)), this.setAttribute("normal", new it(d, 3)), this.setAttribute("uv", new it(u, 2));
      function f(m, v, _, g, y, w, E, P, S, A, W) {
        let H = w / S, O = E / A, I = w / 2, F = E / 2, j = P / 2, $ = S + 1, k = A + 1, z = 0, R = 0, V = new L();
        for (let ie = 0; ie < k; ie++) {
          let re = ie * O - F;
          for (let Re = 0; Re < $; Re++) {
            let ne = Re * H - I;
            V[m] = ne * g, V[v] = re * y, V[_] = j, c.push(V.x, V.y, V.z), V[m] = 0, V[v] = 0, V[_] = P > 0 ? 1 : -1, d.push(V.x, V.y, V.z), u.push(Re / S), u.push(1 - ie / A), z += 1;
          }
        }
        for (let ie = 0; ie < A; ie++) for (let re = 0; re < S; re++) {
          let Re = h + re + $ * ie, ne = h + re + $ * (ie + 1), oe = h + (re + 1) + $ * (ie + 1), Be = h + (re + 1) + $ * ie;
          l.push(Re, ne, Be), l.push(ne, oe, Be), R += 6;
        }
        a.addGroup(p, R, W), p += R, h += z;
      }
    }
    static fromJSON(t) {
      return new i35(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments);
    }
  };
  function Vh(i59) {
    let t = {};
    for (let e in i59) {
      t[e] = {};
      for (let n in i59[e]) {
        let r = i59[e][n];
        r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[e][n] = r.clone() : Array.isArray(r) ? t[e][n] = r.slice() : t[e][n] = r;
      }
    }
    return t;
  }
  function br(i59) {
    let t = {};
    for (let e = 0; e < i59.length; e++) {
      let n = Vh(i59[e]);
      for (let r in n) t[r] = n[r];
    }
    return t;
  }
  var eU = { clone: Vh, merge: br };
  var $J = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
  var qJ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
  var cs = class extends Mi {
    constructor(t) {
      super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = $J, this.fragmentShader = qJ, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, t !== void 0 && (t.attributes !== void 0 && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t));
    }
    copy(t) {
      return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Vh(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      e.glslVersion = this.glslVersion, e.uniforms = {};
      for (let r in this.uniforms) {
        let s = this.uniforms[r].value;
        s && s.isTexture ? e.uniforms[r] = { type: "t", value: s.toJSON(t).uuid } : s && s.isColor ? e.uniforms[r] = { type: "c", value: s.getHex() } : s && s.isVector2 ? e.uniforms[r] = { type: "v2", value: s.toArray() } : s && s.isVector3 ? e.uniforms[r] = { type: "v3", value: s.toArray() } : s && s.isVector4 ? e.uniforms[r] = { type: "v4", value: s.toArray() } : s && s.isMatrix3 ? e.uniforms[r] = { type: "m3", value: s.toArray() } : s && s.isMatrix4 ? e.uniforms[r] = { type: "m4", value: s.toArray() } : e.uniforms[r] = { value: s };
      }
      Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
      let n = {};
      for (let r in this.extensions) this.extensions[r] === true && (n[r] = true);
      return Object.keys(n).length > 0 && (e.extensions = n), e;
    }
  };
  cs.prototype.isShaderMaterial = true;
  var wd = class extends ln {
    constructor() {
      super(), this.type = "Camera", this.matrixWorldInverse = new ut(), this.projectionMatrix = new ut(), this.projectionMatrixInverse = new ut();
    }
    copy(t, e) {
      return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this;
    }
    getWorldDirection(t) {
      this.updateWorldMatrix(true, false);
      let e = this.matrixWorld.elements;
      return t.set(-e[8], -e[9], -e[10]).normalize();
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(t, e) {
      super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  wd.prototype.isCamera = true;
  var Ci = class extends wd {
    constructor(t = 50, e = 1, n = 0.1, r = 2e3) {
      super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
    }
    copy(t, e) {
      return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this;
    }
    setFocalLength(t) {
      let e = 0.5 * this.getFilmHeight() / t;
      this.fov = zm * 2 * Math.atan(e), this.updateProjectionMatrix();
    }
    getFocalLength() {
      let t = Math.tan(vd * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / t;
    }
    getEffectiveFOV() {
      return zm * 2 * Math.atan(Math.tan(vd * 0.5 * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(t, e, n, r, o, s) {
      this.aspect = t / e, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let t = this.near, e = t * Math.tan(vd * 0.5 * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, o = -0.5 * r, s = this.view;
      if (this.view !== null && this.view.enabled) {
        let l = s.fullWidth, c = s.fullHeight;
        o += s.offsetX * r / l, e -= s.offsetY * n / c, r *= s.width / l, n *= s.height / c;
      }
      let a = this.filmOffset;
      a !== 0 && (o += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e;
    }
  };
  Ci.prototype.isPerspectiveCamera = true;
  var yh = 90;
  var bh = 1;
  var zh = class extends ln {
    constructor(t, e, n) {
      if (super(), this.type = "CubeCamera", n.isWebGLCubeRenderTarget !== true) {
        console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
        return;
      }
      this.renderTarget = n;
      let r = new Ci(yh, bh, t, e);
      r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new L(1, 0, 0)), this.add(r);
      let o = new Ci(yh, bh, t, e);
      o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new L(-1, 0, 0)), this.add(o);
      let s = new Ci(yh, bh, t, e);
      s.layers = this.layers, s.up.set(0, 0, 1), s.lookAt(new L(0, 1, 0)), this.add(s);
      let a = new Ci(yh, bh, t, e);
      a.layers = this.layers, a.up.set(0, 0, -1), a.lookAt(new L(0, -1, 0)), this.add(a);
      let l = new Ci(yh, bh, t, e);
      l.layers = this.layers, l.up.set(0, -1, 0), l.lookAt(new L(0, 0, 1)), this.add(l);
      let c = new Ci(yh, bh, t, e);
      c.layers = this.layers, c.up.set(0, -1, 0), c.lookAt(new L(0, 0, -1)), this.add(c);
    }
    update(t, e) {
      this.parent === null && this.updateMatrixWorld();
      let n = this.renderTarget, [r, o, s, a, l, c] = this.children, d = t.xr.enabled, u = t.getRenderTarget();
      t.xr.enabled = false;
      let h = n.texture.generateMipmaps;
      n.texture.generateMipmaps = false, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, o), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, l), n.texture.generateMipmaps = h, t.setRenderTarget(n, 5), t.render(e, c), t.setRenderTarget(u), t.xr.enabled = d;
    }
  };
  var Dl = class extends zi {
    constructor(t, e, n, r, o, s, a, l, c, d) {
      t = t !== void 0 ? t : [], e = e !== void 0 ? e : Ld, super(t, e, n, r, o, s, a, l, c, d), this.flipY = false;
    }
    get images() {
      return this.image;
    }
    set images(t) {
      this.image = t;
    }
  };
  Dl.prototype.isCubeTexture = true;
  var Uh = class extends po {
    constructor(t, e, n) {
      Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new Dl(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : false, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Ri, this.texture._needsFlipEnvMap = false;
    }
    fromEquirectangularTexture(t, e) {
      this.texture.type = e.type, this.texture.format = ir, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
      let n = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new Il(5, 5, 5), o = new cs({ name: "CubemapFromEquirect", uniforms: Vh(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: bi, blending: Pa });
      o.uniforms.tEquirect.value = e;
      let s = new li(r, o), a = e.minFilter;
      return e.minFilter === Bd && (e.minFilter = Ri), new zh(1, 10, this).update(t, s), e.minFilter = a, s.geometry.dispose(), s.material.dispose(), this;
    }
    clear(t, e, n, r) {
      let o = t.getRenderTarget();
      for (let s = 0; s < 6; s++) t.setRenderTarget(this, s), t.clear(e, n, r);
      t.setRenderTarget(o);
    }
  };
  Uh.prototype.isWebGLCubeRenderTarget = true;
  var jI = new L();
  var YJ = new L();
  var XJ = new xi();
  var No = class {
    constructor(t = new L(1, 0, 0), e = 0) {
      this.normal = t, this.constant = e;
    }
    set(t, e) {
      return this.normal.copy(t), this.constant = e, this;
    }
    setComponents(t, e, n, r) {
      return this.normal.set(t, e, n), this.constant = r, this;
    }
    setFromNormalAndCoplanarPoint(t, e) {
      return this.normal.copy(t), this.constant = -e.dot(this.normal), this;
    }
    setFromCoplanarPoints(t, e, n) {
      let r = jI.subVectors(n, e).cross(YJ.subVectors(t, e)).normalize();
      return this.setFromNormalAndCoplanarPoint(r, t), this;
    }
    copy(t) {
      return this.normal.copy(t.normal), this.constant = t.constant, this;
    }
    normalize() {
      let t = 1 / this.normal.length();
      return this.normal.multiplyScalar(t), this.constant *= t, this;
    }
    negate() {
      return this.constant *= -1, this.normal.negate(), this;
    }
    distanceToPoint(t) {
      return this.normal.dot(t) + this.constant;
    }
    distanceToSphere(t) {
      return this.distanceToPoint(t.center) - t.radius;
    }
    projectPoint(t, e) {
      return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t);
    }
    intersectLine(t, e) {
      let n = t.delta(jI), r = this.normal.dot(n);
      if (r === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null;
      let o = -(t.start.dot(this.normal) + this.constant) / r;
      return o < 0 || o > 1 ? null : e.copy(n).multiplyScalar(o).add(t.start);
    }
    intersectsLine(t) {
      let e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end);
      return e < 0 && n > 0 || n < 0 && e > 0;
    }
    intersectsBox(t) {
      return t.intersectsPlane(this);
    }
    intersectsSphere(t) {
      return t.intersectsPlane(this);
    }
    coplanarPoint(t) {
      return t.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(t, e) {
      let n = e || XJ.getNormalMatrix(t), r = this.coplanarPoint(jI).applyMatrix4(t), o = this.normal.applyMatrix3(n).normalize();
      return this.constant = -r.dot(o), this;
    }
    translate(t) {
      return this.constant -= t.dot(this.normal), this;
    }
    equals(t) {
      return t.normal.equals(this.normal) && t.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  No.prototype.isPlane = true;
  var xh = new zs();
  var _0 = new L();
  var Cd = class {
    constructor(t = new No(), e = new No(), n = new No(), r = new No(), o = new No(), s = new No()) {
      this.planes = [t, e, n, r, o, s];
    }
    set(t, e, n, r, o, s) {
      let a = this.planes;
      return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(o), a[5].copy(s), this;
    }
    copy(t) {
      let e = this.planes;
      for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
      return this;
    }
    setFromProjectionMatrix(t) {
      let e = this.planes, n = t.elements, r = n[0], o = n[1], s = n[2], a = n[3], l = n[4], c = n[5], d = n[6], u = n[7], h = n[8], p = n[9], f = n[10], m = n[11], v = n[12], _ = n[13], g = n[14], y = n[15];
      return e[0].setComponents(a - r, u - l, m - h, y - v).normalize(), e[1].setComponents(a + r, u + l, m + h, y + v).normalize(), e[2].setComponents(a + o, u + c, m + p, y + _).normalize(), e[3].setComponents(a - o, u - c, m - p, y - _).normalize(), e[4].setComponents(a - s, u - d, m - f, y - g).normalize(), e[5].setComponents(a + s, u + d, m + f, y + g).normalize(), this;
    }
    intersectsObject(t) {
      let e = t.geometry;
      return e.boundingSphere === null && e.computeBoundingSphere(), xh.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(xh);
    }
    intersectsSprite(t) {
      return xh.center.set(0, 0, 0), xh.radius = 0.7071067811865476, xh.applyMatrix4(t.matrixWorld), this.intersectsSphere(xh);
    }
    intersectsSphere(t) {
      let e = this.planes, n = t.center, r = -t.radius;
      for (let o = 0; o < 6; o++) if (e[o].distanceToPoint(n) < r) return false;
      return true;
    }
    intersectsBox(t) {
      let e = this.planes;
      for (let n = 0; n < 6; n++) {
        let r = e[n];
        if (_0.x = r.normal.x > 0 ? t.max.x : t.min.x, _0.y = r.normal.y > 0 ? t.max.y : t.min.y, _0.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(_0) < 0) return false;
      }
      return true;
    }
    containsPoint(t) {
      let e = this.planes;
      for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return false;
      return true;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  function tU() {
    let i59 = null, t = false, e = null, n = null;
    function r(o, s) {
      e(o, s), n = i59.requestAnimationFrame(r);
    }
    return { start: function() {
      t !== true && e !== null && (n = i59.requestAnimationFrame(r), t = true);
    }, stop: function() {
      i59.cancelAnimationFrame(n), t = false;
    }, setAnimationLoop: function(o) {
      e = o;
    }, setContext: function(o) {
      i59 = o;
    } };
  }
  function ZJ(i59, t) {
    let e = t.isWebGL2, n = /* @__PURE__ */ new WeakMap();
    function r(c, d) {
      let u = c.array, h = c.usage, p = i59.createBuffer();
      i59.bindBuffer(d, p), i59.bufferData(d, u, h), c.onUploadCallback();
      let f = 5126;
      return u instanceof Float32Array ? f = 5126 : u instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : u instanceof Uint16Array ? c.isFloat16BufferAttribute ? e ? f = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : f = 5123 : u instanceof Int16Array ? f = 5122 : u instanceof Uint32Array ? f = 5125 : u instanceof Int32Array ? f = 5124 : u instanceof Int8Array ? f = 5120 : (u instanceof Uint8Array || u instanceof Uint8ClampedArray) && (f = 5121), { buffer: p, type: f, bytesPerElement: u.BYTES_PER_ELEMENT, version: c.version };
    }
    function o(c, d, u) {
      let h = d.array, p = d.updateRange;
      i59.bindBuffer(u, c), p.count === -1 ? i59.bufferSubData(u, 0, h) : (e ? i59.bufferSubData(u, p.offset * h.BYTES_PER_ELEMENT, h, p.offset, p.count) : i59.bufferSubData(u, p.offset * h.BYTES_PER_ELEMENT, h.subarray(p.offset, p.offset + p.count)), p.count = -1);
    }
    function s(c) {
      return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
    }
    function a(c) {
      c.isInterleavedBufferAttribute && (c = c.data);
      let d = n.get(c);
      d && (i59.deleteBuffer(d.buffer), n.delete(c));
    }
    function l(c, d) {
      if (c.isGLBufferAttribute) {
        let h = n.get(c);
        (!h || h.version < c.version) && n.set(c, { buffer: c.buffer, type: c.type, bytesPerElement: c.elementSize, version: c.version });
        return;
      }
      c.isInterleavedBufferAttribute && (c = c.data);
      let u = n.get(c);
      u === void 0 ? n.set(c, r(c, d)) : u.version < c.version && (o(u.buffer, c, d), u.version = c.version);
    }
    return { get: s, remove: a, update: l };
  }
  var Gh = class i36 extends Ct {
    constructor(t = 1, e = 1, n = 1, r = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r };
      let o = t / 2, s = e / 2, a = Math.floor(n), l = Math.floor(r), c = a + 1, d = l + 1, u = t / a, h = e / l, p = [], f = [], m = [], v = [];
      for (let _ = 0; _ < d; _++) {
        let g = _ * h - s;
        for (let y = 0; y < c; y++) {
          let w = y * u - o;
          f.push(w, -g, 0), m.push(0, 0, 1), v.push(y / a), v.push(1 - _ / l);
        }
      }
      for (let _ = 0; _ < l; _++) for (let g = 0; g < a; g++) {
        let y = g + c * _, w = g + c * (_ + 1), E = g + 1 + c * (_ + 1), P = g + 1 + c * _;
        p.push(y, w, P), p.push(w, E, P);
      }
      this.setIndex(p), this.setAttribute("position", new it(f, 3)), this.setAttribute("normal", new it(m, 3)), this.setAttribute("uv", new it(v, 2));
    }
    static fromJSON(t) {
      return new i36(t.width, t.height, t.widthSegments, t.heightSegments);
    }
  };
  var QJ = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`;
  var KJ = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`;
  var JJ = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`;
  var eee = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`;
  var tee = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`;
  var nee = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`;
  var iee = "vec3 transformed = vec3( position );";
  var ree = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`;
  var oee = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`;
  var see = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`;
  var aee = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`;
  var lee = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`;
  var cee = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`;
  var dee = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`;
  var uee = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`;
  var hee = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`;
  var pee = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`;
  var fee = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`;
  var mee = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`;
  var gee = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`;
  var _ee = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`;
  var vee = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`;
  var yee = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`;
  var bee = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`;
  var xee = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`;
  var wee = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var Cee = `
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`;
  var See = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`;
  var Mee = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`;
  var Eee = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`;
  var Tee = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`;
  var Iee = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`;
  var Dee = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`;
  var Pee = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`;
  var Ree = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`;
  var Oee = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`;
  var Aee = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`;
  var Nee = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`;
  var kee = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`;
  var Lee = `vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`;
  var Fee = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`;
  var Bee = `#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`;
  var Vee = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`;
  var zee = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`;
  var Uee = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`;
  var Gee = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`;
  var Hee = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`;
  var jee = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`;
  var Wee = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`;
  var $ee = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`;
  var qee = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`;
  var Yee = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`;
  var Xee = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`;
  var Zee = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`;
  var Qee = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`;
  var Kee = `#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`;
  var Jee = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`;
  var ete = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`;
  var tte = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`;
  var nte = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`;
  var ite = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`;
  var rte = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`;
  var ote = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`;
  var ste = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`;
  var ate = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`;
  var lte = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`;
  var cte = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`;
  var dte = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`;
  var ute = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`;
  var hte = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`;
  var pte = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`;
  var fte = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`;
  var mte = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`;
  var gte = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`;
  var _te = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`;
  var vte = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`;
  var yte = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`;
  var bte = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`;
  var xte = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`;
  var wte = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`;
  var Cte = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`;
  var Ste = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`;
  var Mte = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`;
  var Ete = `#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`;
  var Tte = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`;
  var Ite = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`;
  var Dte = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`;
  var Pte = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`;
  var Rte = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`;
  var Ote = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`;
  var Ate = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`;
  var Nte = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`;
  var kte = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`;
  var Lte = `#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`;
  var Fte = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`;
  var Bte = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`;
  var Vte = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`;
  var zte = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`;
  var Ute = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`;
  var Gte = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`;
  var Hte = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`;
  var jte = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
  var Wte = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`;
  var $te = `uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`;
  var qte = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`;
  var Yte = `#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`;
  var Xte = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`;
  var Zte = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`;
  var Qte = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`;
  var Kte = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`;
  var Jte = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`;
  var ene = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`;
  var tne = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
  var nne = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`;
  var ine = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`;
  var rne = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var one = `#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`;
  var sne = `uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var ane = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`;
  var lne = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var cne = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`;
  var dne = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`;
  var une = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`;
  var hne = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var pne = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`;
  var fne = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var mne = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`;
  var gne = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`;
  var _ne = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`;
  var vne = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`;
  var yne = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`;
  var bne = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`;
  var xne = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;
  var wne = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`;
  var en = { alphamap_fragment: QJ, alphamap_pars_fragment: KJ, alphatest_fragment: JJ, alphatest_pars_fragment: eee, aomap_fragment: tee, aomap_pars_fragment: nee, begin_vertex: iee, beginnormal_vertex: ree, bsdfs: oee, bumpmap_pars_fragment: see, clipping_planes_fragment: aee, clipping_planes_pars_fragment: lee, clipping_planes_pars_vertex: cee, clipping_planes_vertex: dee, color_fragment: uee, color_pars_fragment: hee, color_pars_vertex: pee, color_vertex: fee, common: mee, cube_uv_reflection_fragment: gee, defaultnormal_vertex: _ee, displacementmap_pars_vertex: vee, displacementmap_vertex: yee, emissivemap_fragment: bee, emissivemap_pars_fragment: xee, encodings_fragment: wee, encodings_pars_fragment: Cee, envmap_fragment: See, envmap_common_pars_fragment: Mee, envmap_pars_fragment: Eee, envmap_pars_vertex: Tee, envmap_physical_pars_fragment: Bee, envmap_vertex: Iee, fog_vertex: Dee, fog_pars_vertex: Pee, fog_fragment: Ree, fog_pars_fragment: Oee, gradientmap_pars_fragment: Aee, lightmap_fragment: Nee, lightmap_pars_fragment: kee, lights_lambert_vertex: Lee, lights_pars_begin: Fee, lights_toon_fragment: Vee, lights_toon_pars_fragment: zee, lights_phong_fragment: Uee, lights_phong_pars_fragment: Gee, lights_physical_fragment: Hee, lights_physical_pars_fragment: jee, lights_fragment_begin: Wee, lights_fragment_maps: $ee, lights_fragment_end: qee, logdepthbuf_fragment: Yee, logdepthbuf_pars_fragment: Xee, logdepthbuf_pars_vertex: Zee, logdepthbuf_vertex: Qee, map_fragment: Kee, map_pars_fragment: Jee, map_particle_fragment: ete, map_particle_pars_fragment: tte, metalnessmap_fragment: nte, metalnessmap_pars_fragment: ite, morphnormal_vertex: rte, morphtarget_pars_vertex: ote, morphtarget_vertex: ste, normal_fragment_begin: ate, normal_fragment_maps: lte, normal_pars_fragment: cte, normal_pars_vertex: dte, normal_vertex: ute, normalmap_pars_fragment: hte, clearcoat_normal_fragment_begin: pte, clearcoat_normal_fragment_maps: fte, clearcoat_pars_fragment: mte, output_fragment: gte, packing: _te, premultiplied_alpha_fragment: vte, project_vertex: yte, dithering_fragment: bte, dithering_pars_fragment: xte, roughnessmap_fragment: wte, roughnessmap_pars_fragment: Cte, shadowmap_pars_fragment: Ste, shadowmap_pars_vertex: Mte, shadowmap_vertex: Ete, shadowmask_pars_fragment: Tte, skinbase_vertex: Ite, skinning_pars_vertex: Dte, skinning_vertex: Pte, skinnormal_vertex: Rte, specularmap_fragment: Ote, specularmap_pars_fragment: Ate, tonemapping_fragment: Nte, tonemapping_pars_fragment: kte, transmission_fragment: Lte, transmission_pars_fragment: Fte, uv_pars_fragment: Bte, uv_pars_vertex: Vte, uv_vertex: zte, uv2_pars_fragment: Ute, uv2_pars_vertex: Gte, uv2_vertex: Hte, worldpos_vertex: jte, background_vert: Wte, background_frag: $te, cube_vert: qte, cube_frag: Yte, depth_vert: Xte, depth_frag: Zte, distanceRGBA_vert: Qte, distanceRGBA_frag: Kte, equirect_vert: Jte, equirect_frag: ene, linedashed_vert: tne, linedashed_frag: nne, meshbasic_vert: ine, meshbasic_frag: rne, meshlambert_vert: one, meshlambert_frag: sne, meshmatcap_vert: ane, meshmatcap_frag: lne, meshnormal_vert: cne, meshnormal_frag: dne, meshphong_vert: une, meshphong_frag: hne, meshphysical_vert: pne, meshphysical_frag: fne, meshtoon_vert: mne, meshtoon_frag: gne, points_vert: _ne, points_frag: vne, shadow_vert: yne, shadow_frag: bne, sprite_vert: xne, sprite_frag: wne };
  var $e = { common: { diffuse: { value: new Ye(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new xi() }, uv2Transform: { value: new xi() }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new Me(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ye(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ye(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new xi() } }, sprite: { diffuse: { value: new Ye(16777215) }, opacity: { value: 1 }, center: { value: new Me(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new xi() } } };
  var as = { basic: { uniforms: br([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.fog]), vertexShader: en.meshbasic_vert, fragmentShader: en.meshbasic_frag }, lambert: { uniforms: br([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.fog, $e.lights, { emissive: { value: new Ye(0) } }]), vertexShader: en.meshlambert_vert, fragmentShader: en.meshlambert_frag }, phong: { uniforms: br([$e.common, $e.specularmap, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, $e.lights, { emissive: { value: new Ye(0) }, specular: { value: new Ye(1118481) }, shininess: { value: 30 } }]), vertexShader: en.meshphong_vert, fragmentShader: en.meshphong_frag }, standard: { uniforms: br([$e.common, $e.envmap, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.roughnessmap, $e.metalnessmap, $e.fog, $e.lights, { emissive: { value: new Ye(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: en.meshphysical_vert, fragmentShader: en.meshphysical_frag }, toon: { uniforms: br([$e.common, $e.aomap, $e.lightmap, $e.emissivemap, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.gradientmap, $e.fog, $e.lights, { emissive: { value: new Ye(0) } }]), vertexShader: en.meshtoon_vert, fragmentShader: en.meshtoon_frag }, matcap: { uniforms: br([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, $e.fog, { matcap: { value: null } }]), vertexShader: en.meshmatcap_vert, fragmentShader: en.meshmatcap_frag }, points: { uniforms: br([$e.points, $e.fog]), vertexShader: en.points_vert, fragmentShader: en.points_frag }, dashed: { uniforms: br([$e.common, $e.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: en.linedashed_vert, fragmentShader: en.linedashed_frag }, depth: { uniforms: br([$e.common, $e.displacementmap]), vertexShader: en.depth_vert, fragmentShader: en.depth_frag }, normal: { uniforms: br([$e.common, $e.bumpmap, $e.normalmap, $e.displacementmap, { opacity: { value: 1 } }]), vertexShader: en.meshnormal_vert, fragmentShader: en.meshnormal_frag }, sprite: { uniforms: br([$e.sprite, $e.fog]), vertexShader: en.sprite_vert, fragmentShader: en.sprite_frag }, background: { uniforms: { uvTransform: { value: new xi() }, t2D: { value: null } }, vertexShader: en.background_vert, fragmentShader: en.background_frag }, cube: { uniforms: br([$e.envmap, { opacity: { value: 1 } }]), vertexShader: en.cube_vert, fragmentShader: en.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: en.equirect_vert, fragmentShader: en.equirect_frag }, distanceRGBA: { uniforms: br([$e.common, $e.displacementmap, { referencePosition: { value: new L() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: en.distanceRGBA_vert, fragmentShader: en.distanceRGBA_frag }, shadow: { uniforms: br([$e.lights, $e.fog, { color: { value: new Ye(0) }, opacity: { value: 1 } }]), vertexShader: en.shadow_vert, fragmentShader: en.shadow_frag } };
  as.physical = { uniforms: br([as.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new Me(1, 1) }, clearcoatNormalMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Ye(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 0 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new Me() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Ye(0) }, specularIntensity: { value: 0 }, specularIntensityMap: { value: null }, specularColor: { value: new Ye(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: en.meshphysical_vert, fragmentShader: en.meshphysical_frag };
  function Cne(i59, t, e, n, r) {
    let o = new Ye(0), s = 0, a, l, c = null, d = 0, u = null;
    function h(f, m) {
      let v = false, _ = m.isScene === true ? m.background : null;
      _ && _.isTexture && (_ = t.get(_));
      let g = i59.xr, y = g.getSession && g.getSession();
      y && y.environmentBlendMode === "additive" && (_ = null), _ === null ? p(o, s) : _ && _.isColor && (p(_, 1), v = true), (i59.autoClear || v) && i59.clear(i59.autoClearColor, i59.autoClearDepth, i59.autoClearStencil), _ && (_.isCubeTexture || _.mapping === sp) ? (l === void 0 && (l = new li(new Il(1, 1, 1), new cs({ name: "BackgroundCubeMaterial", uniforms: Vh(as.cube.uniforms), vertexShader: as.cube.vertexShader, fragmentShader: as.cube.fragmentShader, side: bi, depthTest: false, depthWrite: false, fog: false })), l.geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function(w, E, P) {
        this.matrixWorld.copyPosition(P.matrixWorld);
      }, Object.defineProperty(l.material, "envMap", { get: function() {
        return this.uniforms.envMap.value;
      } }), n.update(l)), l.material.uniforms.envMap.value = _, l.material.uniforms.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === false ? -1 : 1, (c !== _ || d !== _.version || u !== i59.toneMapping) && (l.material.needsUpdate = true, c = _, d = _.version, u = i59.toneMapping), f.unshift(l, l.geometry, l.material, 0, 0, null)) : _ && _.isTexture && (a === void 0 && (a = new li(new Gh(2, 2), new cs({ name: "BackgroundMaterial", uniforms: Vh(as.background.uniforms), vertexShader: as.background.vertexShader, fragmentShader: as.background.fragmentShader, side: yd, depthTest: false, depthWrite: false, fog: false })), a.geometry.deleteAttribute("normal"), Object.defineProperty(a.material, "map", { get: function() {
        return this.uniforms.t2D.value;
      } }), n.update(a)), a.material.uniforms.t2D.value = _, _.matrixAutoUpdate === true && _.updateMatrix(), a.material.uniforms.uvTransform.value.copy(_.matrix), (c !== _ || d !== _.version || u !== i59.toneMapping) && (a.material.needsUpdate = true, c = _, d = _.version, u = i59.toneMapping), f.unshift(a, a.geometry, a.material, 0, 0, null));
    }
    function p(f, m) {
      e.buffers.color.setClear(f.r, f.g, f.b, m, r);
    }
    return { getClearColor: function() {
      return o;
    }, setClearColor: function(f, m = 1) {
      o.set(f), s = m, p(o, s);
    }, getClearAlpha: function() {
      return s;
    }, setClearAlpha: function(f) {
      s = f, p(o, s);
    }, render: h };
  }
  function Sne(i59, t, e, n) {
    let r = i59.getParameter(34921), o = n.isWebGL2 ? null : t.get("OES_vertex_array_object"), s = n.isWebGL2 || o !== null, a = {}, l = m(null), c = l;
    function d(F, j, $, k, z) {
      let R = false;
      if (s) {
        let V = f(k, $, j);
        c !== V && (c = V, h(c.object)), R = v(k, z), R && _(k, z);
      } else {
        let V = j.wireframe === true;
        (c.geometry !== k.id || c.program !== $.id || c.wireframe !== V) && (c.geometry = k.id, c.program = $.id, c.wireframe = V, R = true);
      }
      F.isInstancedMesh === true && (R = true), z !== null && e.update(z, 34963), R && (S(F, j, $, k), z !== null && i59.bindBuffer(34963, e.get(z).buffer));
    }
    function u() {
      return n.isWebGL2 ? i59.createVertexArray() : o.createVertexArrayOES();
    }
    function h(F) {
      return n.isWebGL2 ? i59.bindVertexArray(F) : o.bindVertexArrayOES(F);
    }
    function p(F) {
      return n.isWebGL2 ? i59.deleteVertexArray(F) : o.deleteVertexArrayOES(F);
    }
    function f(F, j, $) {
      let k = $.wireframe === true, z = a[F.id];
      z === void 0 && (z = {}, a[F.id] = z);
      let R = z[j.id];
      R === void 0 && (R = {}, z[j.id] = R);
      let V = R[k];
      return V === void 0 && (V = m(u()), R[k] = V), V;
    }
    function m(F) {
      let j = [], $ = [], k = [];
      for (let z = 0; z < r; z++) j[z] = 0, $[z] = 0, k[z] = 0;
      return { geometry: null, program: null, wireframe: false, newAttributes: j, enabledAttributes: $, attributeDivisors: k, object: F, attributes: {}, index: null };
    }
    function v(F, j) {
      let $ = c.attributes, k = F.attributes, z = 0;
      for (let R in k) {
        let V = $[R], ie = k[R];
        if (V === void 0 || V.attribute !== ie || V.data !== ie.data) return true;
        z++;
      }
      return c.attributesNum !== z || c.index !== j;
    }
    function _(F, j) {
      let $ = {}, k = F.attributes, z = 0;
      for (let R in k) {
        let V = k[R], ie = {};
        ie.attribute = V, V.data && (ie.data = V.data), $[R] = ie, z++;
      }
      c.attributes = $, c.attributesNum = z, c.index = j;
    }
    function g() {
      let F = c.newAttributes;
      for (let j = 0, $ = F.length; j < $; j++) F[j] = 0;
    }
    function y(F) {
      w(F, 0);
    }
    function w(F, j) {
      let $ = c.newAttributes, k = c.enabledAttributes, z = c.attributeDivisors;
      $[F] = 1, k[F] === 0 && (i59.enableVertexAttribArray(F), k[F] = 1), z[F] !== j && ((n.isWebGL2 ? i59 : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](F, j), z[F] = j);
    }
    function E() {
      let F = c.newAttributes, j = c.enabledAttributes;
      for (let $ = 0, k = j.length; $ < k; $++) j[$] !== F[$] && (i59.disableVertexAttribArray($), j[$] = 0);
    }
    function P(F, j, $, k, z, R) {
      n.isWebGL2 === true && ($ === 5124 || $ === 5125) ? i59.vertexAttribIPointer(F, j, $, z, R) : i59.vertexAttribPointer(F, j, $, k, z, R);
    }
    function S(F, j, $, k) {
      if (n.isWebGL2 === false && (F.isInstancedMesh || k.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null) return;
      g();
      let z = k.attributes, R = $.getAttributes(), V = j.defaultAttributeValues;
      for (let ie in R) {
        let re = R[ie];
        if (re.location >= 0) {
          let Re = z[ie];
          if (Re === void 0 && (ie === "instanceMatrix" && F.instanceMatrix && (Re = F.instanceMatrix), ie === "instanceColor" && F.instanceColor && (Re = F.instanceColor)), Re !== void 0) {
            let ne = Re.normalized, oe = Re.itemSize, Be = e.get(Re);
            if (Be === void 0) continue;
            let me = Be.buffer, Ve = Be.type, ue = Be.bytesPerElement;
            if (Re.isInterleavedBufferAttribute) {
              let ee = Re.data, Q = ee.stride, _e = Re.offset;
              if (ee && ee.isInstancedInterleavedBuffer) {
                for (let te = 0; te < re.locationSize; te++) w(re.location + te, ee.meshPerAttribute);
                F.isInstancedMesh !== true && k._maxInstanceCount === void 0 && (k._maxInstanceCount = ee.meshPerAttribute * ee.count);
              } else for (let te = 0; te < re.locationSize; te++) y(re.location + te);
              i59.bindBuffer(34962, me);
              for (let te = 0; te < re.locationSize; te++) P(re.location + te, oe / re.locationSize, Ve, ne, Q * ue, (_e + oe / re.locationSize * te) * ue);
            } else {
              if (Re.isInstancedBufferAttribute) {
                for (let ee = 0; ee < re.locationSize; ee++) w(re.location + ee, Re.meshPerAttribute);
                F.isInstancedMesh !== true && k._maxInstanceCount === void 0 && (k._maxInstanceCount = Re.meshPerAttribute * Re.count);
              } else for (let ee = 0; ee < re.locationSize; ee++) y(re.location + ee);
              i59.bindBuffer(34962, me);
              for (let ee = 0; ee < re.locationSize; ee++) P(re.location + ee, oe / re.locationSize, Ve, ne, oe * ue, oe / re.locationSize * ee * ue);
            }
          } else if (V !== void 0) {
            let ne = V[ie];
            if (ne !== void 0) switch (ne.length) {
              case 2:
                i59.vertexAttrib2fv(re.location, ne);
                break;
              case 3:
                i59.vertexAttrib3fv(re.location, ne);
                break;
              case 4:
                i59.vertexAttrib4fv(re.location, ne);
                break;
              default:
                i59.vertexAttrib1fv(re.location, ne);
            }
          }
        }
      }
      E();
    }
    function A() {
      O();
      for (let F in a) {
        let j = a[F];
        for (let $ in j) {
          let k = j[$];
          for (let z in k) p(k[z].object), delete k[z];
          delete j[$];
        }
        delete a[F];
      }
    }
    function W(F) {
      if (a[F.id] === void 0) return;
      let j = a[F.id];
      for (let $ in j) {
        let k = j[$];
        for (let z in k) p(k[z].object), delete k[z];
        delete j[$];
      }
      delete a[F.id];
    }
    function H(F) {
      for (let j in a) {
        let $ = a[j];
        if ($[F.id] === void 0) continue;
        let k = $[F.id];
        for (let z in k) p(k[z].object), delete k[z];
        delete $[F.id];
      }
    }
    function O() {
      I(), c !== l && (c = l, h(c.object));
    }
    function I() {
      l.geometry = null, l.program = null, l.wireframe = false;
    }
    return { setup: d, reset: O, resetDefaultState: I, dispose: A, releaseStatesOfGeometry: W, releaseStatesOfProgram: H, initAttributes: g, enableAttribute: y, disableUnusedAttributes: E };
  }
  function Mne(i59, t, e, n) {
    let r = n.isWebGL2, o;
    function s(c) {
      o = c;
    }
    function a(c, d) {
      i59.drawArrays(o, c, d), e.update(d, o, 1);
    }
    function l(c, d, u) {
      if (u === 0) return;
      let h, p;
      if (r) h = i59, p = "drawArraysInstanced";
      else if (h = t.get("ANGLE_instanced_arrays"), p = "drawArraysInstancedANGLE", h === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      h[p](o, c, d, u), e.update(d, o, u);
    }
    this.setMode = s, this.render = a, this.renderInstances = l;
  }
  function Ene(i59, t, e) {
    let n;
    function r() {
      if (n !== void 0) return n;
      if (t.has("EXT_texture_filter_anisotropic") === true) {
        let S = t.get("EXT_texture_filter_anisotropic");
        n = i59.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else n = 0;
      return n;
    }
    function o(S) {
      if (S === "highp") {
        if (i59.getShaderPrecisionFormat(35633, 36338).precision > 0 && i59.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
        S = "mediump";
      }
      return S === "mediump" && i59.getShaderPrecisionFormat(35633, 36337).precision > 0 && i59.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp";
    }
    let s = typeof WebGL2RenderingContext < "u" && i59 instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext < "u" && i59 instanceof WebGL2ComputeRenderingContext, a = e.precision !== void 0 ? e.precision : "highp", l = o(a);
    l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
    let c = s || t.has("WEBGL_draw_buffers"), d = e.logarithmicDepthBuffer === true, u = i59.getParameter(34930), h = i59.getParameter(35660), p = i59.getParameter(3379), f = i59.getParameter(34076), m = i59.getParameter(34921), v = i59.getParameter(36347), _ = i59.getParameter(36348), g = i59.getParameter(36349), y = h > 0, w = s || t.has("OES_texture_float"), E = y && w, P = s ? i59.getParameter(36183) : 0;
    return { isWebGL2: s, drawBuffers: c, getMaxAnisotropy: r, getMaxPrecision: o, precision: a, logarithmicDepthBuffer: d, maxTextures: u, maxVertexTextures: h, maxTextureSize: p, maxCubemapSize: f, maxAttributes: m, maxVertexUniforms: v, maxVaryings: _, maxFragmentUniforms: g, vertexTextures: y, floatFragmentTextures: w, floatVertexTextures: E, maxSamples: P };
  }
  function Tne(i59) {
    let t = this, e = null, n = 0, r = false, o = false, s = new No(), a = new xi(), l = { value: null, needsUpdate: false };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(u, h, p) {
      let f = u.length !== 0 || h || n !== 0 || r;
      return r = h, e = d(u, p, 0), n = u.length, f;
    }, this.beginShadows = function() {
      o = true, d(null);
    }, this.endShadows = function() {
      o = false, c();
    }, this.setState = function(u, h, p) {
      let f = u.clippingPlanes, m = u.clipIntersection, v = u.clipShadows, _ = i59.get(u);
      if (!r || f === null || f.length === 0 || o && !v) o ? d(null) : c();
      else {
        let g = o ? 0 : n, y = g * 4, w = _.clippingState || null;
        l.value = w, w = d(f, h, y, p);
        for (let E = 0; E !== y; ++E) w[E] = e[E];
        _.clippingState = w, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += g;
      }
    };
    function c() {
      l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0;
    }
    function d(u, h, p, f) {
      let m = u !== null ? u.length : 0, v = null;
      if (m !== 0) {
        if (v = l.value, f !== true || v === null) {
          let _ = p + m * 4, g = h.matrixWorldInverse;
          a.getNormalMatrix(g), (v === null || v.length < _) && (v = new Float32Array(_));
          for (let y = 0, w = p; y !== m; ++y, w += 4) s.copy(u[y]).applyMatrix4(g, a), s.normal.toArray(v, w), v[w + 3] = s.constant;
        }
        l.value = v, l.needsUpdate = true;
      }
      return t.numPlanes = m, t.numIntersection = 0, v;
    }
  }
  function Ine(i59) {
    let t = /* @__PURE__ */ new WeakMap();
    function e(s, a) {
      return a === Om ? s.mapping = Ld : a === Am && (s.mapping = Fd), s;
    }
    function n(s) {
      if (s && s.isTexture && s.isRenderTargetTexture === false) {
        let a = s.mapping;
        if (a === Om || a === Am) if (t.has(s)) {
          let l = t.get(s).texture;
          return e(l, s.mapping);
        } else {
          let l = s.image;
          if (l && l.height > 0) {
            let c = i59.getRenderTarget(), d = new Uh(l.height / 2);
            return d.fromEquirectangularTexture(i59, s), t.set(s, d), i59.setRenderTarget(c), s.addEventListener("dispose", r), e(d.texture, s.mapping);
          } else return null;
        }
      }
      return s;
    }
    function r(s) {
      let a = s.target;
      a.removeEventListener("dispose", r);
      let l = t.get(a);
      l !== void 0 && (t.delete(a), l.dispose());
    }
    function o() {
      t = /* @__PURE__ */ new WeakMap();
    }
    return { get: n, dispose: o };
  }
  var Sd = class extends wd {
    constructor(t = -1, e = 1, n = 1, r = -1, o = 0.1, s = 2e3) {
      super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = o, this.far = s, this.updateProjectionMatrix();
    }
    copy(t, e) {
      return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this;
    }
    setViewOffset(t, e, n, r, o, s) {
      this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = s, this.updateProjectionMatrix();
    }
    clearViewOffset() {
      this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      let t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, o = n - t, s = n + t, a = r + e, l = r - e;
      if (this.view !== null && this.view.enabled) {
        let c = (this.right - this.left) / this.view.fullWidth / this.zoom, d = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        o += c * this.view.offsetX, s = o + c * this.view.width, a -= d * this.view.offsetY, l = a - d * this.view.height;
      }
      this.projectionMatrix.makeOrthographic(o, s, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e;
    }
  };
  Sd.prototype.isOrthographicCamera = true;
  var Pl = class extends cs {
    constructor(t) {
      super(t), this.type = "RawShaderMaterial";
    }
  };
  Pl.prototype.isRawShaderMaterial = true;
  var Ah = 4;
  var El = 8;
  var Ls = Math.pow(2, El);
  var nU = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
  var iU = El - Ah + 1 + nU.length;
  var wh = 20;
  var Rl = { [or]: 0, [Ll]: 1, [zx]: 2, [nD]: 3, [iD]: 4, [rD]: 5, [Vx]: 6 };
  var WI = new Sd();
  var { _lodPlanes: bm, _sizeLods: dB, _sigmas: v0 } = Pne();
  var uB = new Ye();
  var $I = null;
  var ud = (1 + Math.sqrt(5)) / 2;
  var Ch = 1 / ud;
  var hB = [new L(1, 1, 1), new L(-1, 1, 1), new L(1, 1, -1), new L(-1, 1, -1), new L(0, ud, Ch), new L(0, ud, -Ch), new L(Ch, 0, ud), new L(-Ch, 0, ud), new L(ud, Ch, 0), new L(-ud, Ch, 0)];
  var ex = class {
    constructor(t) {
      this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = Rne(wh), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial);
    }
    fromScene(t, e = 0, n = 0.1, r = 100) {
      $I = this._renderer.getRenderTarget();
      let o = this._allocateTargets();
      return this._sceneToCubeUV(t, n, r, o), e > 0 && this._blur(o, 0, 0, e), this._applyPMREM(o), this._cleanup(o), o;
    }
    fromEquirectangular(t) {
      return this._fromTexture(t);
    }
    fromCubemap(t) {
      return this._fromTexture(t);
    }
    compileCubemapShader() {
      this._cubemapShader === null && (this._cubemapShader = mB(), this._compileMaterial(this._cubemapShader));
    }
    compileEquirectangularShader() {
      this._equirectShader === null && (this._equirectShader = fB(), this._compileMaterial(this._equirectShader));
    }
    dispose() {
      this._blurMaterial.dispose(), this._cubemapShader !== null && this._cubemapShader.dispose(), this._equirectShader !== null && this._equirectShader.dispose();
      for (let t = 0; t < bm.length; t++) bm[t].dispose();
    }
    _cleanup(t) {
      this._pingPongRenderTarget.dispose(), this._renderer.setRenderTarget($I), t.scissorTest = false, y0(t, 0, 0, t.width, t.height);
    }
    _fromTexture(t) {
      $I = this._renderer.getRenderTarget();
      let e = this._allocateTargets(t);
      return this._textureToCubeUV(t, e), this._applyPMREM(e), this._cleanup(e), e;
    }
    _allocateTargets(t) {
      let e = { magFilter: Si, minFilter: Si, generateMipmaps: false, type: Oa, format: oz, encoding: Dne(t) ? t.encoding : zx, depthBuffer: false }, n = pB(e);
      return n.depthBuffer = !t, this._pingPongRenderTarget = pB(e), n;
    }
    _compileMaterial(t) {
      let e = new li(bm[0], t);
      this._renderer.compile(e, WI);
    }
    _sceneToCubeUV(t, e, n, r) {
      let a = new Ci(90, 1, e, n), l = [1, -1, 1, 1, 1, 1], c = [1, 1, 1, -1, -1, -1], d = this._renderer, u = d.autoClear, h = d.outputEncoding, p = d.toneMapping;
      d.getClearColor(uB), d.toneMapping = Ml, d.outputEncoding = or, d.autoClear = false;
      let f = new ls({ name: "PMREM.Background", side: bi, depthWrite: false, depthTest: false }), m = new li(new Il(), f), v = false, _ = t.background;
      _ ? _.isColor && (f.color.copy(_), t.background = null, v = true) : (f.color.copy(uB), v = true);
      for (let g = 0; g < 6; g++) {
        let y = g % 3;
        y == 0 ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0)) : y == 1 ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0)) : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g])), y0(r, y * Ls, g > 2 ? Ls : 0, Ls, Ls), d.setRenderTarget(r), v && d.render(m, a), d.render(t, a);
      }
      m.geometry.dispose(), m.material.dispose(), d.toneMapping = p, d.outputEncoding = h, d.autoClear = u, t.background = _;
    }
    _setEncoding(t, e) {
      this._renderer.capabilities.isWebGL2 === true && e.format === ir && e.type === Oa && e.encoding === Ll ? t.value = Rl[or] : t.value = Rl[e.encoding];
    }
    _textureToCubeUV(t, e) {
      let n = this._renderer, r = t.mapping === Ld || t.mapping === Fd;
      r ? this._cubemapShader == null && (this._cubemapShader = mB()) : this._equirectShader == null && (this._equirectShader = fB());
      let o = r ? this._cubemapShader : this._equirectShader, s = new li(bm[0], o), a = o.uniforms;
      a.envMap.value = t, r || a.texelSize.value.set(1 / t.image.width, 1 / t.image.height), this._setEncoding(a.inputEncoding, t), this._setEncoding(a.outputEncoding, e.texture), y0(e, 0, 0, 3 * Ls, 2 * Ls), n.setRenderTarget(e), n.render(s, WI);
    }
    _applyPMREM(t) {
      let e = this._renderer, n = e.autoClear;
      e.autoClear = false;
      for (let r = 1; r < iU; r++) {
        let o = Math.sqrt(v0[r] * v0[r] - v0[r - 1] * v0[r - 1]), s = hB[(r - 1) % hB.length];
        this._blur(t, r - 1, r, o, s);
      }
      e.autoClear = n;
    }
    _blur(t, e, n, r, o) {
      let s = this._pingPongRenderTarget;
      this._halfBlur(t, s, e, n, r, "latitudinal", o), this._halfBlur(s, t, n, n, r, "longitudinal", o);
    }
    _halfBlur(t, e, n, r, o, s, a) {
      let l = this._renderer, c = this._blurMaterial;
      s !== "latitudinal" && s !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      let d = 3, u = new li(bm[r], c), h = c.uniforms, p = dB[n] - 1, f = isFinite(o) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * wh - 1), m = o / f, v = isFinite(o) ? 1 + Math.floor(d * m) : wh;
      v > wh && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${wh}`);
      let _ = [], g = 0;
      for (let P = 0; P < wh; ++P) {
        let S = P / m, A = Math.exp(-S * S / 2);
        _.push(A), P == 0 ? g += A : P < v && (g += 2 * A);
      }
      for (let P = 0; P < _.length; P++) _[P] = _[P] / g;
      h.envMap.value = t.texture, h.samples.value = v, h.weights.value = _, h.latitudinal.value = s === "latitudinal", a && (h.poleAxis.value = a), h.dTheta.value = f, h.mipInt.value = El - n, this._setEncoding(h.inputEncoding, t.texture), this._setEncoding(h.outputEncoding, t.texture);
      let y = dB[r], w = 3 * Math.max(0, Ls - 2 * y), E = (r === 0 ? 0 : 2 * Ls) + 2 * y * (r > El - Ah ? r - El + Ah : 0);
      y0(e, w, E, 3 * y, 2 * y), l.setRenderTarget(e), l.render(u, WI);
    }
  };
  function Dne(i59) {
    return i59 === void 0 || i59.type !== Oa ? false : i59.encoding === or || i59.encoding === Ll || i59.encoding === Vx;
  }
  function Pne() {
    let i59 = [], t = [], e = [], n = El;
    for (let r = 0; r < iU; r++) {
      let o = Math.pow(2, n);
      t.push(o);
      let s = 1 / o;
      r > El - Ah ? s = nU[r - El + Ah - 1] : r == 0 && (s = 0), e.push(s);
      let a = 1 / (o - 1), l = -a / 2, c = 1 + a / 2, d = [l, l, c, l, c, c, l, l, c, c, l, c], u = 6, h = 6, p = 3, f = 2, m = 1, v = new Float32Array(p * h * u), _ = new Float32Array(f * h * u), g = new Float32Array(m * h * u);
      for (let w = 0; w < u; w++) {
        let E = w % 3 * 2 / 3 - 1, P = w > 2 ? 0 : -1, S = [E, P, 0, E + 2 / 3, P, 0, E + 2 / 3, P + 1, 0, E, P, 0, E + 2 / 3, P + 1, 0, E, P + 1, 0];
        v.set(S, p * h * w), _.set(d, f * h * w);
        let A = [w, w, w, w, w, w];
        g.set(A, m * h * w);
      }
      let y = new Ct();
      y.setAttribute("position", new an(v, p)), y.setAttribute("uv", new an(_, f)), y.setAttribute("faceIndex", new an(g, m)), i59.push(y), n > Ah && n--;
    }
    return { _lodPlanes: i59, _sizeLods: t, _sigmas: e };
  }
  function pB(i59) {
    let t = new po(3 * Ls, 3 * Ls, i59);
    return t.texture.mapping = sp, t.texture.name = "PMREM.cubeUv", t.scissorTest = true, t;
  }
  function y0(i59, t, e, n, r) {
    i59.viewport.set(t, e, n, r), i59.scissor.set(t, e, n, r);
  }
  function Rne(i59) {
    let t = new Float32Array(i59), e = new L(0, 1, 0);
    return new Pl({ name: "SphericalGaussianBlur", defines: { n: i59 }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: t }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: e }, inputEncoding: { value: Rl[or] }, outputEncoding: { value: Rl[or] } }, vertexShader: sD(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${aD()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: Pa, depthTest: false, depthWrite: false });
  }
  function fB() {
    let i59 = new Me(1, 1);
    return new Pl({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null }, texelSize: { value: i59 }, inputEncoding: { value: Rl[or] }, outputEncoding: { value: Rl[or] } }, vertexShader: sD(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${aD()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: Pa, depthTest: false, depthWrite: false });
  }
  function mB() {
    return new Pl({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, inputEncoding: { value: Rl[or] }, outputEncoding: { value: Rl[or] } }, vertexShader: sD(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${aD()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`, blending: Pa, depthTest: false, depthWrite: false });
  }
  function sD() {
    return `

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
  }
  function aD() {
    return `

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;
  }
  function One(i59) {
    let t = /* @__PURE__ */ new WeakMap(), e = null;
    function n(a) {
      if (a && a.isTexture && a.isRenderTargetTexture === false) {
        let l = a.mapping, c = l === Om || l === Am, d = l === Ld || l === Fd;
        if (c || d) {
          if (t.has(a)) return t.get(a).texture;
          {
            let u = a.image;
            if (c && u && u.height > 0 || d && u && r(u)) {
              let h = i59.getRenderTarget();
              e === null && (e = new ex(i59));
              let p = c ? e.fromEquirectangular(a) : e.fromCubemap(a);
              return t.set(a, p), i59.setRenderTarget(h), a.addEventListener("dispose", o), p.texture;
            } else return null;
          }
        }
      }
      return a;
    }
    function r(a) {
      let l = 0, c = 6;
      for (let d = 0; d < c; d++) a[d] !== void 0 && l++;
      return l === c;
    }
    function o(a) {
      let l = a.target;
      l.removeEventListener("dispose", o);
      let c = t.get(l);
      c !== void 0 && (t.delete(l), c.dispose());
    }
    function s() {
      t = /* @__PURE__ */ new WeakMap(), e !== null && (e.dispose(), e = null);
    }
    return { get: n, dispose: s };
  }
  function Ane(i59) {
    let t = {};
    function e(n) {
      if (t[n] !== void 0) return t[n];
      let r;
      switch (n) {
        case "WEBGL_depth_texture":
          r = i59.getExtension("WEBGL_depth_texture") || i59.getExtension("MOZ_WEBGL_depth_texture") || i59.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          r = i59.getExtension("EXT_texture_filter_anisotropic") || i59.getExtension("MOZ_EXT_texture_filter_anisotropic") || i59.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          r = i59.getExtension("WEBGL_compressed_texture_s3tc") || i59.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i59.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          r = i59.getExtension("WEBGL_compressed_texture_pvrtc") || i59.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          r = i59.getExtension(n);
      }
      return t[n] = r, r;
    }
    return { has: function(n) {
      return e(n) !== null;
    }, init: function(n) {
      n.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float");
    }, get: function(n) {
      let r = e(n);
      return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r;
    } };
  }
  function Nne(i59, t, e, n) {
    let r = {}, o = /* @__PURE__ */ new WeakMap();
    function s(u) {
      let h = u.target;
      h.index !== null && t.remove(h.index);
      for (let f in h.attributes) t.remove(h.attributes[f]);
      h.removeEventListener("dispose", s), delete r[h.id];
      let p = o.get(h);
      p && (t.remove(p), o.delete(h)), n.releaseStatesOfGeometry(h), h.isInstancedBufferGeometry === true && delete h._maxInstanceCount, e.memory.geometries--;
    }
    function a(u, h) {
      return r[h.id] === true || (h.addEventListener("dispose", s), r[h.id] = true, e.memory.geometries++), h;
    }
    function l(u) {
      let h = u.attributes;
      for (let f in h) t.update(h[f], 34962);
      let p = u.morphAttributes;
      for (let f in p) {
        let m = p[f];
        for (let v = 0, _ = m.length; v < _; v++) t.update(m[v], 34962);
      }
    }
    function c(u) {
      let h = [], p = u.index, f = u.attributes.position, m = 0;
      if (p !== null) {
        let g = p.array;
        m = p.version;
        for (let y = 0, w = g.length; y < w; y += 3) {
          let E = g[y + 0], P = g[y + 1], S = g[y + 2];
          h.push(E, P, P, S, S, E);
        }
      } else {
        let g = f.array;
        m = f.version;
        for (let y = 0, w = g.length / 3 - 1; y < w; y += 3) {
          let E = y + 0, P = y + 1, S = y + 2;
          h.push(E, P, P, S, S, E);
        }
      }
      let v = new (Jz(h) > 65535 ? Bh : Fh)(h, 1);
      v.version = m;
      let _ = o.get(u);
      _ && t.remove(_), o.set(u, v);
    }
    function d(u) {
      let h = o.get(u);
      if (h) {
        let p = u.index;
        p !== null && h.version < p.version && c(u);
      } else c(u);
      return o.get(u);
    }
    return { get: a, update: l, getWireframeAttribute: d };
  }
  function kne(i59, t, e, n) {
    let r = n.isWebGL2, o;
    function s(h) {
      o = h;
    }
    let a, l;
    function c(h) {
      a = h.type, l = h.bytesPerElement;
    }
    function d(h, p) {
      i59.drawElements(o, p, a, h * l), e.update(p, o, 1);
    }
    function u(h, p, f) {
      if (f === 0) return;
      let m, v;
      if (r) m = i59, v = "drawElementsInstanced";
      else if (m = t.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", m === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
      m[v](o, p, a, h * l, f), e.update(p, o, f);
    }
    this.setMode = s, this.setIndex = c, this.render = d, this.renderInstances = u;
  }
  function Lne(i59) {
    let t = { geometries: 0, textures: 0 }, e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    function n(o, s, a) {
      switch (e.calls++, s) {
        case 4:
          e.triangles += a * (o / 3);
          break;
        case 1:
          e.lines += a * (o / 2);
          break;
        case 3:
          e.lines += a * (o - 1);
          break;
        case 2:
          e.lines += a * o;
          break;
        case 0:
          e.points += a * o;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", s);
          break;
      }
    }
    function r() {
      e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0;
    }
    return { memory: t, render: e, programs: null, autoReset: true, reset: r, update: n };
  }
  var Hh = class extends zi {
    constructor(t = null, e = 1, n = 1, r = 1) {
      super(null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Si, this.minFilter = Si, this.wrapR = nr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  };
  Hh.prototype.isDataTexture2DArray = true;
  function Fne(i59, t) {
    return i59[0] - t[0];
  }
  function Bne(i59, t) {
    return Math.abs(t[1]) - Math.abs(i59[1]);
  }
  function gB(i59, t) {
    let e = 1, n = t.isInterleavedBufferAttribute ? t.data.array : t.array;
    n instanceof Int8Array ? e = 127 : n instanceof Int16Array ? e = 32767 : n instanceof Int32Array ? e = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", n), i59.divideScalar(e);
  }
  function Vne(i59, t, e) {
    let n = {}, r = new Float32Array(8), o = /* @__PURE__ */ new WeakMap(), s = new L(), a = [];
    for (let c = 0; c < 8; c++) a[c] = [c, 0];
    function l(c, d, u, h) {
      let p = c.morphTargetInfluences;
      if (t.isWebGL2 === true) {
        let f = d.morphAttributes.position.length, m = o.get(d);
        if (m === void 0 || m.count !== f) {
          m !== void 0 && m.texture.dispose();
          let g = d.morphAttributes.normal !== void 0, y = d.morphAttributes.position, w = d.morphAttributes.normal || [], E = d.attributes.position.count, P = g === true ? 2 : 1, S = E * P, A = 1;
          S > t.maxTextureSize && (A = Math.ceil(S / t.maxTextureSize), S = t.maxTextureSize);
          let W = new Float32Array(S * A * 4 * f), H = new Hh(W, S, A, f);
          H.format = ir, H.type = Fs;
          let O = P * 4;
          for (let I = 0; I < f; I++) {
            let F = y[I], j = w[I], $ = S * A * 4 * I;
            for (let k = 0; k < F.count; k++) {
              s.fromBufferAttribute(F, k), F.normalized === true && gB(s, F);
              let z = k * O;
              W[$ + z + 0] = s.x, W[$ + z + 1] = s.y, W[$ + z + 2] = s.z, W[$ + z + 3] = 0, g === true && (s.fromBufferAttribute(j, k), j.normalized === true && gB(s, j), W[$ + z + 4] = s.x, W[$ + z + 5] = s.y, W[$ + z + 6] = s.z, W[$ + z + 7] = 0);
            }
          }
          m = { count: f, texture: H, size: new Me(S, A) }, o.set(d, m);
        }
        let v = 0;
        for (let g = 0; g < p.length; g++) v += p[g];
        let _ = d.morphTargetsRelative ? 1 : 1 - v;
        h.getUniforms().setValue(i59, "morphTargetBaseInfluence", _), h.getUniforms().setValue(i59, "morphTargetInfluences", p), h.getUniforms().setValue(i59, "morphTargetsTexture", m.texture, e), h.getUniforms().setValue(i59, "morphTargetsTextureSize", m.size);
      } else {
        let f = p === void 0 ? 0 : p.length, m = n[d.id];
        if (m === void 0 || m.length !== f) {
          m = [];
          for (let w = 0; w < f; w++) m[w] = [w, 0];
          n[d.id] = m;
        }
        for (let w = 0; w < f; w++) {
          let E = m[w];
          E[0] = w, E[1] = p[w];
        }
        m.sort(Bne);
        for (let w = 0; w < 8; w++) w < f && m[w][1] ? (a[w][0] = m[w][0], a[w][1] = m[w][1]) : (a[w][0] = Number.MAX_SAFE_INTEGER, a[w][1] = 0);
        a.sort(Fne);
        let v = d.morphAttributes.position, _ = d.morphAttributes.normal, g = 0;
        for (let w = 0; w < 8; w++) {
          let E = a[w], P = E[0], S = E[1];
          P !== Number.MAX_SAFE_INTEGER && S ? (v && d.getAttribute("morphTarget" + w) !== v[P] && d.setAttribute("morphTarget" + w, v[P]), _ && d.getAttribute("morphNormal" + w) !== _[P] && d.setAttribute("morphNormal" + w, _[P]), r[w] = S, g += S) : (v && d.hasAttribute("morphTarget" + w) === true && d.deleteAttribute("morphTarget" + w), _ && d.hasAttribute("morphNormal" + w) === true && d.deleteAttribute("morphNormal" + w), r[w] = 0);
        }
        let y = d.morphTargetsRelative ? 1 : 1 - g;
        h.getUniforms().setValue(i59, "morphTargetBaseInfluence", y), h.getUniforms().setValue(i59, "morphTargetInfluences", r);
      }
    }
    return { update: l };
  }
  function zne(i59, t, e, n) {
    let r = /* @__PURE__ */ new WeakMap();
    function o(l) {
      let c = n.render.frame, d = l.geometry, u = t.get(l, d);
      return r.get(u) !== c && (t.update(u), r.set(u, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), e.update(l.instanceMatrix, 34962), l.instanceColor !== null && e.update(l.instanceColor, 34962)), u;
    }
    function s() {
      r = /* @__PURE__ */ new WeakMap();
    }
    function a(l) {
      let c = l.target;
      c.removeEventListener("dispose", a), e.remove(c.instanceMatrix), c.instanceColor !== null && e.remove(c.instanceColor);
    }
    return { update: o, dispose: s };
  }
  var Hm = class extends zi {
    constructor(t = null, e = 1, n = 1, r = 1) {
      super(null), this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Si, this.minFilter = Si, this.wrapR = nr, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  };
  Hm.prototype.isDataTexture3D = true;
  var rU = new zi();
  var Une = new Hh();
  var Gne = new Hm();
  var oU = new Dl();
  var _B = [];
  var vB = [];
  var yB = new Float32Array(16);
  var bB = new Float32Array(9);
  var xB = new Float32Array(4);
  function ap(i59, t, e) {
    let n = i59[0];
    if (n <= 0 || n > 0) return i59;
    let r = t * e, o = _B[r];
    if (o === void 0 && (o = new Float32Array(r), _B[r] = o), t !== 0) {
      n.toArray(o, 0);
      for (let s = 1, a = 0; s !== t; ++s) a += e, i59[s].toArray(o, a);
    }
    return o;
  }
  function Fr(i59, t) {
    if (i59.length !== t.length) return false;
    for (let e = 0, n = i59.length; e < n; e++) if (i59[e] !== t[e]) return false;
    return true;
  }
  function xr(i59, t) {
    for (let e = 0, n = t.length; e < n; e++) i59[e] = t[e];
  }
  function sU(i59, t) {
    let e = vB[t];
    e === void 0 && (e = new Int32Array(t), vB[t] = e);
    for (let n = 0; n !== t; ++n) e[n] = i59.allocateTextureUnit();
    return e;
  }
  function Hne(i59, t) {
    let e = this.cache;
    e[0] !== t && (i59.uniform1f(this.addr, t), e[0] = t);
  }
  function jne(i59, t) {
    let e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i59.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y);
    else {
      if (Fr(e, t)) return;
      i59.uniform2fv(this.addr, t), xr(e, t);
    }
  }
  function Wne(i59, t) {
    let e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i59.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z);
    else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (i59.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b);
    else {
      if (Fr(e, t)) return;
      i59.uniform3fv(this.addr, t), xr(e, t);
    }
  }
  function $ne(i59, t) {
    let e = this.cache;
    if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i59.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w);
    else {
      if (Fr(e, t)) return;
      i59.uniform4fv(this.addr, t), xr(e, t);
    }
  }
  function qne(i59, t) {
    let e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Fr(e, t)) return;
      i59.uniformMatrix2fv(this.addr, false, t), xr(e, t);
    } else {
      if (Fr(e, n)) return;
      xB.set(n), i59.uniformMatrix2fv(this.addr, false, xB), xr(e, n);
    }
  }
  function Yne(i59, t) {
    let e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Fr(e, t)) return;
      i59.uniformMatrix3fv(this.addr, false, t), xr(e, t);
    } else {
      if (Fr(e, n)) return;
      bB.set(n), i59.uniformMatrix3fv(this.addr, false, bB), xr(e, n);
    }
  }
  function Xne(i59, t) {
    let e = this.cache, n = t.elements;
    if (n === void 0) {
      if (Fr(e, t)) return;
      i59.uniformMatrix4fv(this.addr, false, t), xr(e, t);
    } else {
      if (Fr(e, n)) return;
      yB.set(n), i59.uniformMatrix4fv(this.addr, false, yB), xr(e, n);
    }
  }
  function Zne(i59, t) {
    let e = this.cache;
    e[0] !== t && (i59.uniform1i(this.addr, t), e[0] = t);
  }
  function Qne(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform2iv(this.addr, t), xr(e, t));
  }
  function Kne(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform3iv(this.addr, t), xr(e, t));
  }
  function Jne(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform4iv(this.addr, t), xr(e, t));
  }
  function eie(i59, t) {
    let e = this.cache;
    e[0] !== t && (i59.uniform1ui(this.addr, t), e[0] = t);
  }
  function tie(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform2uiv(this.addr, t), xr(e, t));
  }
  function nie(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform3uiv(this.addr, t), xr(e, t));
  }
  function iie(i59, t) {
    let e = this.cache;
    Fr(e, t) || (i59.uniform4uiv(this.addr, t), xr(e, t));
  }
  function rie(i59, t, e) {
    let n = this.cache, r = e.allocateTextureUnit();
    n[0] !== r && (i59.uniform1i(this.addr, r), n[0] = r), e.safeSetTexture2D(t || rU, r);
  }
  function oie(i59, t, e) {
    let n = this.cache, r = e.allocateTextureUnit();
    n[0] !== r && (i59.uniform1i(this.addr, r), n[0] = r), e.setTexture3D(t || Gne, r);
  }
  function sie(i59, t, e) {
    let n = this.cache, r = e.allocateTextureUnit();
    n[0] !== r && (i59.uniform1i(this.addr, r), n[0] = r), e.safeSetTextureCube(t || oU, r);
  }
  function aie(i59, t, e) {
    let n = this.cache, r = e.allocateTextureUnit();
    n[0] !== r && (i59.uniform1i(this.addr, r), n[0] = r), e.setTexture2DArray(t || Une, r);
  }
  function lie(i59) {
    switch (i59) {
      case 5126:
        return Hne;
      case 35664:
        return jne;
      case 35665:
        return Wne;
      case 35666:
        return $ne;
      case 35674:
        return qne;
      case 35675:
        return Yne;
      case 35676:
        return Xne;
      case 5124:
      case 35670:
        return Zne;
      case 35667:
      case 35671:
        return Qne;
      case 35668:
      case 35672:
        return Kne;
      case 35669:
      case 35673:
        return Jne;
      case 5125:
        return eie;
      case 36294:
        return tie;
      case 36295:
        return nie;
      case 36296:
        return iie;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return rie;
      case 35679:
      case 36299:
      case 36307:
        return oie;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return sie;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
        return aie;
    }
  }
  function cie(i59, t) {
    i59.uniform1fv(this.addr, t);
  }
  function die(i59, t) {
    let e = ap(t, this.size, 2);
    i59.uniform2fv(this.addr, e);
  }
  function uie(i59, t) {
    let e = ap(t, this.size, 3);
    i59.uniform3fv(this.addr, e);
  }
  function hie(i59, t) {
    let e = ap(t, this.size, 4);
    i59.uniform4fv(this.addr, e);
  }
  function pie(i59, t) {
    let e = ap(t, this.size, 4);
    i59.uniformMatrix2fv(this.addr, false, e);
  }
  function fie(i59, t) {
    let e = ap(t, this.size, 9);
    i59.uniformMatrix3fv(this.addr, false, e);
  }
  function mie(i59, t) {
    let e = ap(t, this.size, 16);
    i59.uniformMatrix4fv(this.addr, false, e);
  }
  function gie(i59, t) {
    i59.uniform1iv(this.addr, t);
  }
  function _ie(i59, t) {
    i59.uniform2iv(this.addr, t);
  }
  function vie(i59, t) {
    i59.uniform3iv(this.addr, t);
  }
  function yie(i59, t) {
    i59.uniform4iv(this.addr, t);
  }
  function bie(i59, t) {
    i59.uniform1uiv(this.addr, t);
  }
  function xie(i59, t) {
    i59.uniform2uiv(this.addr, t);
  }
  function wie(i59, t) {
    i59.uniform3uiv(this.addr, t);
  }
  function Cie(i59, t) {
    i59.uniform4uiv(this.addr, t);
  }
  function Sie(i59, t, e) {
    let n = t.length, r = sU(e, n);
    i59.uniform1iv(this.addr, r);
    for (let o = 0; o !== n; ++o) e.safeSetTexture2D(t[o] || rU, r[o]);
  }
  function Mie(i59, t, e) {
    let n = t.length, r = sU(e, n);
    i59.uniform1iv(this.addr, r);
    for (let o = 0; o !== n; ++o) e.safeSetTextureCube(t[o] || oU, r[o]);
  }
  function Eie(i59) {
    switch (i59) {
      case 5126:
        return cie;
      case 35664:
        return die;
      case 35665:
        return uie;
      case 35666:
        return hie;
      case 35674:
        return pie;
      case 35675:
        return fie;
      case 35676:
        return mie;
      case 5124:
      case 35670:
        return gie;
      case 35667:
      case 35671:
        return _ie;
      case 35668:
      case 35672:
        return vie;
      case 35669:
      case 35673:
        return yie;
      case 5125:
        return bie;
      case 36294:
        return xie;
      case 36295:
        return wie;
      case 36296:
        return Cie;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
        return Sie;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
        return Mie;
    }
  }
  function Tie(i59, t, e) {
    this.id = i59, this.addr = e, this.cache = [], this.setValue = lie(t.type);
  }
  function aU(i59, t, e) {
    this.id = i59, this.addr = e, this.cache = [], this.size = t.size, this.setValue = Eie(t.type);
  }
  aU.prototype.updateCache = function(i59) {
    let t = this.cache;
    i59 instanceof Float32Array && t.length !== i59.length && (this.cache = new Float32Array(i59.length)), xr(t, i59);
  };
  function lU(i59) {
    this.id = i59, this.seq = [], this.map = {};
  }
  lU.prototype.setValue = function(i59, t, e) {
    let n = this.seq;
    for (let r = 0, o = n.length; r !== o; ++r) {
      let s = n[r];
      s.setValue(i59, t[s.id], e);
    }
  };
  var qI = /(\w+)(\])?(\[|\.)?/g;
  function wB(i59, t) {
    i59.seq.push(t), i59.map[t.id] = t;
  }
  function Iie(i59, t, e) {
    let n = i59.name, r = n.length;
    for (qI.lastIndex = 0; ; ) {
      let o = qI.exec(n), s = qI.lastIndex, a = o[1], l = o[2] === "]", c = o[3];
      if (l && (a = a | 0), c === void 0 || c === "[" && s + 2 === r) {
        wB(e, c === void 0 ? new Tie(a, i59, t) : new aU(a, i59, t));
        break;
      } else {
        let u = e.map[a];
        u === void 0 && (u = new lU(a), wB(e, u)), e = u;
      }
    }
  }
  function Tl(i59, t) {
    this.seq = [], this.map = {};
    let e = i59.getProgramParameter(t, 35718);
    for (let n = 0; n < e; ++n) {
      let r = i59.getActiveUniform(t, n), o = i59.getUniformLocation(t, r.name);
      Iie(r, o, this);
    }
  }
  Tl.prototype.setValue = function(i59, t, e, n) {
    let r = this.map[t];
    r !== void 0 && r.setValue(i59, e, n);
  };
  Tl.prototype.setOptional = function(i59, t, e) {
    let n = t[e];
    n !== void 0 && this.setValue(i59, e, n);
  };
  Tl.upload = function(i59, t, e, n) {
    for (let r = 0, o = t.length; r !== o; ++r) {
      let s = t[r], a = e[s.id];
      a.needsUpdate !== false && s.setValue(i59, a.value, n);
    }
  };
  Tl.seqWithValue = function(i59, t) {
    let e = [];
    for (let n = 0, r = i59.length; n !== r; ++n) {
      let o = i59[n];
      o.id in t && e.push(o);
    }
    return e;
  };
  function CB(i59, t, e) {
    let n = i59.createShader(t);
    return i59.shaderSource(n, e), i59.compileShader(n), n;
  }
  var Die = 0;
  function Pie(i59) {
    let t = i59.split(`
`);
    for (let e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
    return t.join(`
`);
  }
  function cU(i59) {
    switch (i59) {
      case or:
        return ["Linear", "( value )"];
      case Ll:
        return ["sRGB", "( value )"];
      case zx:
        return ["RGBE", "( value )"];
      case nD:
        return ["RGBM", "( value, 7.0 )"];
      case iD:
        return ["RGBM", "( value, 16.0 )"];
      case rD:
        return ["RGBD", "( value, 256.0 )"];
      case Vx:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      case $z:
        return ["LogLuv", "( value )"];
      default:
        return console.warn("THREE.WebGLProgram: Unsupported encoding:", i59), ["Linear", "( value )"];
    }
  }
  function SB(i59, t, e) {
    let n = i59.getShaderParameter(t, 35713), r = i59.getShaderInfoLog(t).trim();
    return n && r === "" ? "" : e.toUpperCase() + `

` + r + `

` + Pie(i59.getShaderSource(t));
  }
  function sd(i59, t) {
    let e = cU(t);
    return "vec4 " + i59 + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }";
  }
  function Rie(i59, t) {
    let e = cU(t);
    return "vec4 " + i59 + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }";
  }
  function Oie(i59, t) {
    let e;
    switch (t) {
      case WV:
        e = "Linear";
        break;
      case $V:
        e = "Reinhard";
        break;
      case qV:
        e = "OptimizedCineon";
        break;
      case YV:
        e = "ACESFilmic";
        break;
      case XV:
        e = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear";
    }
    return "vec3 " + i59 + "( vec3 color ) { return " + e + "ToneMapping( color ); }";
  }
  function Aie(i59) {
    return [i59.extensionDerivatives || i59.envMapCubeUV || i59.bumpMap || i59.tangentSpaceNormalMap || i59.clearcoatNormalMap || i59.flatShading || i59.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i59.extensionFragDepth || i59.logarithmicDepthBuffer) && i59.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i59.extensionDrawBuffers && i59.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i59.extensionShaderTextureLOD || i59.envMap || i59.transmission) && i59.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Em).join(`
`);
  }
  function Nie(i59) {
    let t = [];
    for (let e in i59) {
      let n = i59[e];
      n !== false && t.push("#define " + e + " " + n);
    }
    return t.join(`
`);
  }
  function kie(i59, t) {
    let e = {}, n = i59.getProgramParameter(t, 35721);
    for (let r = 0; r < n; r++) {
      let o = i59.getActiveAttrib(t, r), s = o.name, a = 1;
      o.type === 35674 && (a = 2), o.type === 35675 && (a = 3), o.type === 35676 && (a = 4), e[s] = { type: o.type, location: i59.getAttribLocation(t, s), locationSize: a };
    }
    return e;
  }
  function Em(i59) {
    return i59 !== "";
  }
  function MB(i59, t) {
    return i59.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
  }
  function EB(i59, t) {
    return i59.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection);
  }
  var Lie = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function x1(i59) {
    return i59.replace(Lie, Fie);
  }
  function Fie(i59, t) {
    let e = en[t];
    if (e === void 0) throw new Error("Can not resolve #include <" + t + ">");
    return x1(e);
  }
  var Bie = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
  var Vie = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function TB(i59) {
    return i59.replace(Vie, dU).replace(Bie, zie);
  }
  function zie(i59, t, e, n) {
    return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), dU(i59, t, e, n);
  }
  function dU(i59, t, e, n) {
    let r = "";
    for (let o = parseInt(t); o < parseInt(e); o++) r += n.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
    return r;
  }
  function IB(i59) {
    let t = "precision " + i59.precision + ` float;
precision ` + i59.precision + " int;";
    return i59.precision === "highp" ? t += `
#define HIGH_PRECISION` : i59.precision === "mediump" ? t += `
#define MEDIUM_PRECISION` : i59.precision === "lowp" && (t += `
#define LOW_PRECISION`), t;
  }
  function Uie(i59) {
    let t = "SHADOWMAP_TYPE_BASIC";
    return i59.shadowMapType === Z1 ? t = "SHADOWMAP_TYPE_PCF" : i59.shadowMapType === CV ? t = "SHADOWMAP_TYPE_PCF_SOFT" : i59.shadowMapType === Ih && (t = "SHADOWMAP_TYPE_VSM"), t;
  }
  function Gie(i59) {
    let t = "ENVMAP_TYPE_CUBE";
    if (i59.envMap) switch (i59.envMapMode) {
      case Ld:
      case Fd:
        t = "ENVMAP_TYPE_CUBE";
        break;
      case sp:
      case Lg:
        t = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
    return t;
  }
  function Hie(i59) {
    let t = "ENVMAP_MODE_REFLECTION";
    if (i59.envMap) switch (i59.envMapMode) {
      case Fd:
      case Lg:
        t = "ENVMAP_MODE_REFRACTION";
        break;
    }
    return t;
  }
  function jie(i59) {
    let t = "ENVMAP_BLENDING_NONE";
    if (i59.envMap) switch (i59.combine) {
      case kg:
        t = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case HV:
        t = "ENVMAP_BLENDING_MIX";
        break;
      case jV:
        t = "ENVMAP_BLENDING_ADD";
        break;
    }
    return t;
  }
  function Wie(i59, t, e, n) {
    let r = i59.getContext(), o = e.defines, s = e.vertexShader, a = e.fragmentShader, l = Uie(e), c = Gie(e), d = Hie(e), u = jie(e), h = i59.gammaFactor > 0 ? i59.gammaFactor : 1, p = e.isWebGL2 ? "" : Aie(e), f = Nie(o), m = r.createProgram(), v, _, g = e.glslVersion ? "#version " + e.glslVersion + `
` : "";
    e.isRawShaderMaterial ? (v = [f].filter(Em).join(`
`), v.length > 0 && (v += `
`), _ = [p, f].filter(Em).join(`
`), _.length > 0 && (_ += `
`)) : (v = [IB(e), "#define SHADER_NAME " + e.shaderName, f, e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + h, "#define MAX_BONES " + e.maxBones, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + d : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.displacementMap && e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === false ? "#define USE_MORPHNORMALS" : "", e.morphTargets && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", e.morphTargets && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Em).join(`
`), _ = [p, IB(e), "#define SHADER_NAME " + e.shaderName, f, "#define GAMMA_FACTOR " + h, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + d : "", e.envMap ? "#define " + u : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== Ml ? "#define TONE_MAPPING" : "", e.toneMapping !== Ml ? en.tonemapping_pars_fragment : "", e.toneMapping !== Ml ? Oie("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.format === gd ? "#define OPAQUE" : "", en.encodings_pars_fragment, e.map ? sd("mapTexelToLinear", e.mapEncoding) : "", e.matcap ? sd("matcapTexelToLinear", e.matcapEncoding) : "", e.envMap ? sd("envMapTexelToLinear", e.envMapEncoding) : "", e.emissiveMap ? sd("emissiveMapTexelToLinear", e.emissiveMapEncoding) : "", e.specularColorMap ? sd("specularColorMapTexelToLinear", e.specularColorMapEncoding) : "", e.sheenColorMap ? sd("sheenColorMapTexelToLinear", e.sheenColorMapEncoding) : "", e.lightMap ? sd("lightMapTexelToLinear", e.lightMapEncoding) : "", Rie("linearToOutputTexel", e.outputEncoding), e.depthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`].filter(Em).join(`
`)), s = x1(s), s = MB(s, e), s = EB(s, e), a = x1(a), a = MB(a, e), a = EB(a, e), s = TB(s), a = TB(a), e.isWebGL2 && e.isRawShaderMaterial !== true && (g = `#version 300 es
`, v = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v, _ = ["#define varying in", e.glslVersion === y1 ? "" : "out highp vec4 pc_fragColor;", e.glslVersion === y1 ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
    let y = g + v + s, w = g + _ + a, E = CB(r, 35633, y), P = CB(r, 35632, w);
    if (r.attachShader(m, E), r.attachShader(m, P), e.index0AttributeName !== void 0 ? r.bindAttribLocation(m, 0, e.index0AttributeName) : e.morphTargets === true && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), i59.debug.checkShaderErrors) {
      let W = r.getProgramInfoLog(m).trim(), H = r.getShaderInfoLog(E).trim(), O = r.getShaderInfoLog(P).trim(), I = true, F = true;
      if (r.getProgramParameter(m, 35714) === false) {
        I = false;
        let j = SB(r, E, "vertex"), $ = SB(r, P, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + `

Program Info Log: ` + W + `
` + j + `
` + $);
      } else W !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", W) : (H === "" || O === "") && (F = false);
      F && (this.diagnostics = { runnable: I, programLog: W, vertexShader: { log: H, prefix: v }, fragmentShader: { log: O, prefix: _ } });
    }
    r.deleteShader(E), r.deleteShader(P);
    let S;
    this.getUniforms = function() {
      return S === void 0 && (S = new Tl(r, m)), S;
    };
    let A;
    return this.getAttributes = function() {
      return A === void 0 && (A = kie(r, m)), A;
    }, this.destroy = function() {
      n.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0;
    }, this.name = e.shaderName, this.id = Die++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = E, this.fragmentShader = P, this;
  }
  function $ie(i59, t, e, n, r, o, s) {
    let a = [], l = r.isWebGL2, c = r.logarithmicDepthBuffer, d = r.floatVertexTextures, u = r.maxVertexUniforms, h = r.vertexTextures, p = r.precision, f = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, m = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoat", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", , "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "alphaTest", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "morphTargetsCount", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "format", "specularIntensityMap", "specularColorMap", "specularColorMapEncoding", "transmission", "transmissionMap", "thicknessMap", "sheen", "sheenColorMap", "sheenColorMapEncoding", "sheenRoughnessMap"];
    function v(S) {
      let W = S.skeleton.bones;
      if (d) return 1024;
      {
        let O = Math.floor((u - 20) / 4), I = Math.min(O, W.length);
        return I < W.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + W.length + " bones. This GPU supports " + I + "."), 0) : I;
      }
    }
    function _(S) {
      let A;
      return S && S.isTexture ? A = S.encoding : S && S.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), A = S.texture.encoding) : A = or, l && S && S.isTexture && S.format === ir && S.type === Oa && S.encoding === Ll && (A = or), A;
    }
    function g(S, A, W, H, O) {
      let I = H.fog, F = S.isMeshStandardMaterial ? H.environment : null, j = (S.isMeshStandardMaterial ? e : t).get(S.envMap || F), $ = f[S.type], k = O.isSkinnedMesh ? v(O) : 0;
      S.precision !== null && (p = r.getMaxPrecision(S.precision), p !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", p, "instead."));
      let z, R;
      if ($) {
        let ne = as[$];
        z = ne.vertexShader, R = ne.fragmentShader;
      } else z = S.vertexShader, R = S.fragmentShader;
      let V = i59.getRenderTarget(), ie = S.alphaTest > 0, re = S.clearcoat > 0;
      return { isWebGL2: l, shaderID: $, shaderName: S.type, vertexShader: z, fragmentShader: R, defines: S.defines, isRawShaderMaterial: S.isRawShaderMaterial === true, glslVersion: S.glslVersion, precision: p, instancing: O.isInstancedMesh === true, instancingColor: O.isInstancedMesh === true && O.instanceColor !== null, supportsVertexTextures: h, outputEncoding: V !== null ? _(V.texture) : i59.outputEncoding, map: !!S.map, mapEncoding: _(S.map), matcap: !!S.matcap, matcapEncoding: _(S.matcap), envMap: !!j, envMapMode: j && j.mapping, envMapEncoding: _(j), envMapCubeUV: !!j && (j.mapping === sp || j.mapping === Lg), lightMap: !!S.lightMap, lightMapEncoding: _(S.lightMap), aoMap: !!S.aoMap, emissiveMap: !!S.emissiveMap, emissiveMapEncoding: _(S.emissiveMap), bumpMap: !!S.bumpMap, normalMap: !!S.normalMap, objectSpaceNormalMap: S.normalMapType === Xz, tangentSpaceNormalMap: S.normalMapType === Vd, clearcoat: re, clearcoatMap: re && !!S.clearcoatMap, clearcoatRoughnessMap: re && !!S.clearcoatRoughnessMap, clearcoatNormalMap: re && !!S.clearcoatNormalMap, displacementMap: !!S.displacementMap, roughnessMap: !!S.roughnessMap, metalnessMap: !!S.metalnessMap, specularMap: !!S.specularMap, specularIntensityMap: !!S.specularIntensityMap, specularColorMap: !!S.specularColorMap, specularColorMapEncoding: _(S.specularColorMap), alphaMap: !!S.alphaMap, alphaTest: ie, gradientMap: !!S.gradientMap, sheen: S.sheen > 0, sheenColorMap: !!S.sheenColorMap, sheenColorMapEncoding: _(S.sheenColorMap), sheenRoughnessMap: !!S.sheenRoughnessMap, transmission: S.transmission > 0, transmissionMap: !!S.transmissionMap, thicknessMap: !!S.thicknessMap, combine: S.combine, vertexTangents: !!S.normalMap && !!O.geometry && !!O.geometry.attributes.tangent, vertexColors: S.vertexColors, vertexAlphas: S.vertexColors === true && !!O.geometry && !!O.geometry.attributes.color && O.geometry.attributes.color.itemSize === 4, vertexUvs: !!S.map || !!S.bumpMap || !!S.normalMap || !!S.specularMap || !!S.alphaMap || !!S.emissiveMap || !!S.roughnessMap || !!S.metalnessMap || !!S.clearcoatMap || !!S.clearcoatRoughnessMap || !!S.clearcoatNormalMap || !!S.displacementMap || !!S.transmissionMap || !!S.thicknessMap || !!S.specularIntensityMap || !!S.specularColorMap || !!S.sheenColorMap || S.sheenRoughnessMap, uvsVertexOnly: !(S.map || S.bumpMap || S.normalMap || S.specularMap || S.alphaMap || S.emissiveMap || S.roughnessMap || S.metalnessMap || S.clearcoatNormalMap || S.transmission > 0 || S.transmissionMap || S.thicknessMap || S.specularIntensityMap || S.specularColorMap || !!S.sheen > 0 || S.sheenColorMap || S.sheenRoughnessMap) && !!S.displacementMap, fog: !!I, useFog: S.fog, fogExp2: I && I.isFogExp2, flatShading: !!S.flatShading, sizeAttenuation: S.sizeAttenuation, logarithmicDepthBuffer: c, skinning: O.isSkinnedMesh === true && k > 0, maxBones: k, useVertexTexture: d, morphTargets: !!O.geometry && !!O.geometry.morphAttributes.position, morphNormals: !!O.geometry && !!O.geometry.morphAttributes.normal, morphTargetsCount: O.geometry && O.geometry.morphAttributes.position ? O.geometry.morphAttributes.position.length : 0, numDirLights: A.directional.length, numPointLights: A.point.length, numSpotLights: A.spot.length, numRectAreaLights: A.rectArea.length, numHemiLights: A.hemi.length, numDirLightShadows: A.directionalShadowMap.length, numPointLightShadows: A.pointShadowMap.length, numSpotLightShadows: A.spotShadowMap.length, numClippingPlanes: s.numPlanes, numClipIntersection: s.numIntersection, format: S.format, dithering: S.dithering, shadowMapEnabled: i59.shadowMap.enabled && W.length > 0, shadowMapType: i59.shadowMap.type, toneMapping: S.toneMapped ? i59.toneMapping : Ml, physicallyCorrectLights: i59.physicallyCorrectLights, premultipliedAlpha: S.premultipliedAlpha, doubleSided: S.side === bd, flipSided: S.side === bi, depthPacking: S.depthPacking !== void 0 ? S.depthPacking : false, index0AttributeName: S.index0AttributeName, extensionDerivatives: S.extensions && S.extensions.derivatives, extensionFragDepth: S.extensions && S.extensions.fragDepth, extensionDrawBuffers: S.extensions && S.extensions.drawBuffers, extensionShaderTextureLOD: S.extensions && S.extensions.shaderTextureLOD, rendererExtensionFragDepth: l || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: l || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: l || n.has("EXT_shader_texture_lod"), customProgramCacheKey: S.customProgramCacheKey() };
    }
    function y(S) {
      let A = [];
      if (S.shaderID ? A.push(S.shaderID) : (A.push(Q3(S.fragmentShader)), A.push(Q3(S.vertexShader))), S.defines !== void 0) for (let W in S.defines) A.push(W), A.push(S.defines[W]);
      if (S.isRawShaderMaterial === false) {
        for (let W = 0; W < m.length; W++) A.push(S[m[W]]);
        A.push(i59.outputEncoding), A.push(i59.gammaFactor);
      }
      return A.push(S.customProgramCacheKey), A.join();
    }
    function w(S) {
      let A = f[S.type], W;
      if (A) {
        let H = as[A];
        W = eU.clone(H.uniforms);
      } else W = S.uniforms;
      return W;
    }
    function E(S, A) {
      let W;
      for (let H = 0, O = a.length; H < O; H++) {
        let I = a[H];
        if (I.cacheKey === A) {
          W = I, ++W.usedTimes;
          break;
        }
      }
      return W === void 0 && (W = new Wie(i59, A, S, o), a.push(W)), W;
    }
    function P(S) {
      if (--S.usedTimes === 0) {
        let A = a.indexOf(S);
        a[A] = a[a.length - 1], a.pop(), S.destroy();
      }
    }
    return { getParameters: g, getProgramCacheKey: y, getUniforms: w, acquireProgram: E, releaseProgram: P, programs: a };
  }
  function qie() {
    let i59 = /* @__PURE__ */ new WeakMap();
    function t(o) {
      let s = i59.get(o);
      return s === void 0 && (s = {}, i59.set(o, s)), s;
    }
    function e(o) {
      i59.delete(o);
    }
    function n(o, s, a) {
      i59.get(o)[s] = a;
    }
    function r() {
      i59 = /* @__PURE__ */ new WeakMap();
    }
    return { get: t, remove: e, update: n, dispose: r };
  }
  function Yie(i59, t) {
    return i59.groupOrder !== t.groupOrder ? i59.groupOrder - t.groupOrder : i59.renderOrder !== t.renderOrder ? i59.renderOrder - t.renderOrder : i59.program !== t.program ? i59.program.id - t.program.id : i59.material.id !== t.material.id ? i59.material.id - t.material.id : i59.z !== t.z ? i59.z - t.z : i59.id - t.id;
  }
  function DB(i59, t) {
    return i59.groupOrder !== t.groupOrder ? i59.groupOrder - t.groupOrder : i59.renderOrder !== t.renderOrder ? i59.renderOrder - t.renderOrder : i59.z !== t.z ? t.z - i59.z : i59.id - t.id;
  }
  function PB(i59) {
    let t = [], e = 0, n = [], r = [], o = [], s = { id: -1 };
    function a() {
      e = 0, n.length = 0, r.length = 0, o.length = 0;
    }
    function l(p, f, m, v, _, g) {
      let y = t[e], w = i59.get(m);
      return y === void 0 ? (y = { id: p.id, object: p, geometry: f, material: m, program: w.program || s, groupOrder: v, renderOrder: p.renderOrder, z: _, group: g }, t[e] = y) : (y.id = p.id, y.object = p, y.geometry = f, y.material = m, y.program = w.program || s, y.groupOrder = v, y.renderOrder = p.renderOrder, y.z = _, y.group = g), e++, y;
    }
    function c(p, f, m, v, _, g) {
      let y = l(p, f, m, v, _, g);
      m.transmission > 0 ? r.push(y) : m.transparent === true ? o.push(y) : n.push(y);
    }
    function d(p, f, m, v, _, g) {
      let y = l(p, f, m, v, _, g);
      m.transmission > 0 ? r.unshift(y) : m.transparent === true ? o.unshift(y) : n.unshift(y);
    }
    function u(p, f) {
      n.length > 1 && n.sort(p || Yie), r.length > 1 && r.sort(f || DB), o.length > 1 && o.sort(f || DB);
    }
    function h() {
      for (let p = e, f = t.length; p < f; p++) {
        let m = t[p];
        if (m.id === null) break;
        m.id = null, m.object = null, m.geometry = null, m.material = null, m.program = null, m.group = null;
      }
    }
    return { opaque: n, transmissive: r, transparent: o, init: a, push: c, unshift: d, finish: h, sort: u };
  }
  function Xie(i59) {
    let t = /* @__PURE__ */ new WeakMap();
    function e(r, o) {
      let s;
      return t.has(r) === false ? (s = new PB(i59), t.set(r, [s])) : o >= t.get(r).length ? (s = new PB(i59), t.get(r).push(s)) : s = t.get(r)[o], s;
    }
    function n() {
      t = /* @__PURE__ */ new WeakMap();
    }
    return { get: e, dispose: n };
  }
  function Zie() {
    let i59 = {};
    return { get: function(t) {
      if (i59[t.id] !== void 0) return i59[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = { direction: new L(), color: new Ye() };
          break;
        case "SpotLight":
          e = { position: new L(), direction: new L(), color: new Ye(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
          break;
        case "PointLight":
          e = { position: new L(), color: new Ye(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          e = { direction: new L(), skyColor: new Ye(), groundColor: new Ye() };
          break;
        case "RectAreaLight":
          e = { color: new Ye(), position: new L(), halfWidth: new L(), halfHeight: new L() };
          break;
      }
      return i59[t.id] = e, e;
    } };
  }
  function Qie() {
    let i59 = {};
    return { get: function(t) {
      if (i59[t.id] !== void 0) return i59[t.id];
      let e;
      switch (t.type) {
        case "DirectionalLight":
          e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Me() };
          break;
        case "SpotLight":
          e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Me() };
          break;
        case "PointLight":
          e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new Me(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
          break;
      }
      return i59[t.id] = e, e;
    } };
  }
  var Kie = 0;
  function Jie(i59, t) {
    return (t.castShadow ? 1 : 0) - (i59.castShadow ? 1 : 0);
  }
  function ere(i59, t) {
    let e = new Zie(), n = Qie(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadow: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] };
    for (let d = 0; d < 9; d++) r.probe.push(new L());
    let o = new L(), s = new ut(), a = new ut();
    function l(d, u) {
      let h = 0, p = 0, f = 0;
      for (let W = 0; W < 9; W++) r.probe[W].set(0, 0, 0);
      let m = 0, v = 0, _ = 0, g = 0, y = 0, w = 0, E = 0, P = 0;
      d.sort(Jie);
      let S = u !== true ? Math.PI : 1;
      for (let W = 0, H = d.length; W < H; W++) {
        let O = d[W], I = O.color, F = O.intensity, j = O.distance, $ = O.shadow && O.shadow.map ? O.shadow.map.texture : null;
        if (O.isAmbientLight) h += I.r * F * S, p += I.g * F * S, f += I.b * F * S;
        else if (O.isLightProbe) for (let k = 0; k < 9; k++) r.probe[k].addScaledVector(O.sh.coefficients[k], F);
        else if (O.isDirectionalLight) {
          let k = e.get(O);
          if (k.color.copy(O.color).multiplyScalar(O.intensity * S), O.castShadow) {
            let z = O.shadow, R = n.get(O);
            R.shadowBias = z.bias, R.shadowNormalBias = z.normalBias, R.shadowRadius = z.radius, R.shadowMapSize = z.mapSize, r.directionalShadow[m] = R, r.directionalShadowMap[m] = $, r.directionalShadowMatrix[m] = O.shadow.matrix, w++;
          }
          r.directional[m] = k, m++;
        } else if (O.isSpotLight) {
          let k = e.get(O);
          if (k.position.setFromMatrixPosition(O.matrixWorld), k.color.copy(I).multiplyScalar(F * S), k.distance = j, k.coneCos = Math.cos(O.angle), k.penumbraCos = Math.cos(O.angle * (1 - O.penumbra)), k.decay = O.decay, O.castShadow) {
            let z = O.shadow, R = n.get(O);
            R.shadowBias = z.bias, R.shadowNormalBias = z.normalBias, R.shadowRadius = z.radius, R.shadowMapSize = z.mapSize, r.spotShadow[_] = R, r.spotShadowMap[_] = $, r.spotShadowMatrix[_] = O.shadow.matrix, P++;
          }
          r.spot[_] = k, _++;
        } else if (O.isRectAreaLight) {
          let k = e.get(O);
          k.color.copy(I).multiplyScalar(F), k.halfWidth.set(O.width * 0.5, 0, 0), k.halfHeight.set(0, O.height * 0.5, 0), r.rectArea[g] = k, g++;
        } else if (O.isPointLight) {
          let k = e.get(O);
          if (k.color.copy(O.color).multiplyScalar(O.intensity * S), k.distance = O.distance, k.decay = O.decay, O.castShadow) {
            let z = O.shadow, R = n.get(O);
            R.shadowBias = z.bias, R.shadowNormalBias = z.normalBias, R.shadowRadius = z.radius, R.shadowMapSize = z.mapSize, R.shadowCameraNear = z.camera.near, R.shadowCameraFar = z.camera.far, r.pointShadow[v] = R, r.pointShadowMap[v] = $, r.pointShadowMatrix[v] = O.shadow.matrix, E++;
          }
          r.point[v] = k, v++;
        } else if (O.isHemisphereLight) {
          let k = e.get(O);
          k.skyColor.copy(O.color).multiplyScalar(F * S), k.groundColor.copy(O.groundColor).multiplyScalar(F * S), r.hemi[y] = k, y++;
        }
      }
      g > 0 && (t.isWebGL2 || i59.has("OES_texture_float_linear") === true ? (r.rectAreaLTC1 = $e.LTC_FLOAT_1, r.rectAreaLTC2 = $e.LTC_FLOAT_2) : i59.has("OES_texture_half_float_linear") === true ? (r.rectAreaLTC1 = $e.LTC_HALF_1, r.rectAreaLTC2 = $e.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = h, r.ambient[1] = p, r.ambient[2] = f;
      let A = r.hash;
      (A.directionalLength !== m || A.pointLength !== v || A.spotLength !== _ || A.rectAreaLength !== g || A.hemiLength !== y || A.numDirectionalShadows !== w || A.numPointShadows !== E || A.numSpotShadows !== P) && (r.directional.length = m, r.spot.length = _, r.rectArea.length = g, r.point.length = v, r.hemi.length = y, r.directionalShadow.length = w, r.directionalShadowMap.length = w, r.pointShadow.length = E, r.pointShadowMap.length = E, r.spotShadow.length = P, r.spotShadowMap.length = P, r.directionalShadowMatrix.length = w, r.pointShadowMatrix.length = E, r.spotShadowMatrix.length = P, A.directionalLength = m, A.pointLength = v, A.spotLength = _, A.rectAreaLength = g, A.hemiLength = y, A.numDirectionalShadows = w, A.numPointShadows = E, A.numSpotShadows = P, r.version = Kie++);
    }
    function c(d, u) {
      let h = 0, p = 0, f = 0, m = 0, v = 0, _ = u.matrixWorldInverse;
      for (let g = 0, y = d.length; g < y; g++) {
        let w = d[g];
        if (w.isDirectionalLight) {
          let E = r.directional[h];
          E.direction.setFromMatrixPosition(w.matrixWorld), o.setFromMatrixPosition(w.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(_), h++;
        } else if (w.isSpotLight) {
          let E = r.spot[f];
          E.position.setFromMatrixPosition(w.matrixWorld), E.position.applyMatrix4(_), E.direction.setFromMatrixPosition(w.matrixWorld), o.setFromMatrixPosition(w.target.matrixWorld), E.direction.sub(o), E.direction.transformDirection(_), f++;
        } else if (w.isRectAreaLight) {
          let E = r.rectArea[m];
          E.position.setFromMatrixPosition(w.matrixWorld), E.position.applyMatrix4(_), a.identity(), s.copy(w.matrixWorld), s.premultiply(_), a.extractRotation(s), E.halfWidth.set(w.width * 0.5, 0, 0), E.halfHeight.set(0, w.height * 0.5, 0), E.halfWidth.applyMatrix4(a), E.halfHeight.applyMatrix4(a), m++;
        } else if (w.isPointLight) {
          let E = r.point[p];
          E.position.setFromMatrixPosition(w.matrixWorld), E.position.applyMatrix4(_), p++;
        } else if (w.isHemisphereLight) {
          let E = r.hemi[v];
          E.direction.setFromMatrixPosition(w.matrixWorld), E.direction.transformDirection(_), E.direction.normalize(), v++;
        }
      }
    }
    return { setup: l, setupView: c, state: r };
  }
  function RB(i59, t) {
    let e = new ere(i59, t), n = [], r = [];
    function o() {
      n.length = 0, r.length = 0;
    }
    function s(u) {
      n.push(u);
    }
    function a(u) {
      r.push(u);
    }
    function l(u) {
      e.setup(n, u);
    }
    function c(u) {
      e.setupView(n, u);
    }
    return { init: o, state: { lightsArray: n, shadowsArray: r, lights: e }, setupLights: l, setupLightsView: c, pushLight: s, pushShadow: a };
  }
  function tre(i59, t) {
    let e = /* @__PURE__ */ new WeakMap();
    function n(o, s = 0) {
      let a;
      return e.has(o) === false ? (a = new RB(i59, t), e.set(o, [a])) : s >= e.get(o).length ? (a = new RB(i59, t), e.get(o).push(a)) : a = e.get(o)[s], a;
    }
    function r() {
      e = /* @__PURE__ */ new WeakMap();
    }
    return { get: n, dispose: r };
  }
  var jh = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshDepthMaterial", this.depthPacking = qz, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this;
    }
  };
  jh.prototype.isMeshDepthMaterial = true;
  var Wh = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshDistanceMaterial", this.referencePosition = new L(), this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this;
    }
  };
  Wh.prototype.isMeshDistanceMaterial = true;
  var nre = `void main() {
	gl_Position = vec4( position, 1.0 );
}`;
  var ire = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
  function uU(i59, t, e) {
    let n = new Cd(), r = new Me(), o = new Me(), s = new bn(), a = new jh({ depthPacking: Yz }), l = new Wh(), c = {}, d = e.maxTextureSize, u = { 0: bi, 1: yd, 2: bd }, h = new cs({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new Me() }, radius: { value: 4 } }, vertexShader: nre, fragmentShader: ire }), p = h.clone();
    p.defines.HORIZONTAL_PASS = 1;
    let f = new Ct();
    f.setAttribute("position", new an(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
    let m = new li(f, h), v = this;
    this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Z1, this.render = function(w, E, P) {
      if (v.enabled === false || v.autoUpdate === false && v.needsUpdate === false || w.length === 0) return;
      let S = i59.getRenderTarget(), A = i59.getActiveCubeFace(), W = i59.getActiveMipmapLevel(), H = i59.state;
      H.setBlending(Pa), H.buffers.color.setClear(1, 1, 1, 1), H.buffers.depth.setTest(true), H.setScissorTest(false);
      for (let O = 0, I = w.length; O < I; O++) {
        let F = w[O], j = F.shadow;
        if (j === void 0) {
          console.warn("THREE.WebGLShadowMap:", F, "has no shadow.");
          continue;
        }
        if (j.autoUpdate === false && j.needsUpdate === false) continue;
        r.copy(j.mapSize);
        let $ = j.getFrameExtents();
        if (r.multiply($), o.copy(j.mapSize), (r.x > d || r.y > d) && (r.x > d && (o.x = Math.floor(d / $.x), r.x = o.x * $.x, j.mapSize.x = o.x), r.y > d && (o.y = Math.floor(d / $.y), r.y = o.y * $.y, j.mapSize.y = o.y)), j.map === null && !j.isPointLightShadow && this.type === Ih) {
          let z = { minFilter: Ri, magFilter: Ri, format: ir };
          j.map = new po(r.x, r.y, z), j.map.texture.name = F.name + ".shadowMap", j.mapPass = new po(r.x, r.y, z), j.camera.updateProjectionMatrix();
        }
        if (j.map === null) {
          let z = { minFilter: Si, magFilter: Si, format: ir };
          j.map = new po(r.x, r.y, z), j.map.texture.name = F.name + ".shadowMap", j.camera.updateProjectionMatrix();
        }
        i59.setRenderTarget(j.map), i59.clear();
        let k = j.getViewportCount();
        for (let z = 0; z < k; z++) {
          let R = j.getViewport(z);
          s.set(o.x * R.x, o.y * R.y, o.x * R.z, o.y * R.w), H.viewport(s), j.updateMatrices(F, z), n = j.getFrustum(), y(E, P, j.camera, F, this.type);
        }
        !j.isPointLightShadow && this.type === Ih && _(j, P), j.needsUpdate = false;
      }
      v.needsUpdate = false, i59.setRenderTarget(S, A, W);
    };
    function _(w, E) {
      let P = t.update(m);
      h.defines.VSM_SAMPLES !== w.blurSamples && (h.defines.VSM_SAMPLES = w.blurSamples, p.defines.VSM_SAMPLES = w.blurSamples, h.needsUpdate = true, p.needsUpdate = true), h.uniforms.shadow_pass.value = w.map.texture, h.uniforms.resolution.value = w.mapSize, h.uniforms.radius.value = w.radius, i59.setRenderTarget(w.mapPass), i59.clear(), i59.renderBufferDirect(E, null, P, h, m, null), p.uniforms.shadow_pass.value = w.mapPass.texture, p.uniforms.resolution.value = w.mapSize, p.uniforms.radius.value = w.radius, i59.setRenderTarget(w.map), i59.clear(), i59.renderBufferDirect(E, null, P, p, m, null);
    }
    function g(w, E, P, S, A, W, H) {
      let O = null, I = S.isPointLight === true ? w.customDistanceMaterial : w.customDepthMaterial;
      if (I !== void 0 ? O = I : O = S.isPointLight === true ? l : a, i59.localClippingEnabled && P.clipShadows === true && P.clippingPlanes.length !== 0 || P.displacementMap && P.displacementScale !== 0 || P.alphaMap && P.alphaTest > 0) {
        let F = O.uuid, j = P.uuid, $ = c[F];
        $ === void 0 && ($ = {}, c[F] = $);
        let k = $[j];
        k === void 0 && (k = O.clone(), $[j] = k), O = k;
      }
      return O.visible = P.visible, O.wireframe = P.wireframe, H === Ih ? O.side = P.shadowSide !== null ? P.shadowSide : P.side : O.side = P.shadowSide !== null ? P.shadowSide : u[P.side], O.alphaMap = P.alphaMap, O.alphaTest = P.alphaTest, O.clipShadows = P.clipShadows, O.clippingPlanes = P.clippingPlanes, O.clipIntersection = P.clipIntersection, O.displacementMap = P.displacementMap, O.displacementScale = P.displacementScale, O.displacementBias = P.displacementBias, O.wireframeLinewidth = P.wireframeLinewidth, O.linewidth = P.linewidth, S.isPointLight === true && O.isMeshDistanceMaterial === true && (O.referencePosition.setFromMatrixPosition(S.matrixWorld), O.nearDistance = A, O.farDistance = W), O;
    }
    function y(w, E, P, S, A) {
      if (w.visible === false) return;
      if (w.layers.test(E.layers) && (w.isMesh || w.isLine || w.isPoints) && (w.castShadow || w.receiveShadow && A === Ih) && (!w.frustumCulled || n.intersectsObject(w))) {
        w.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, w.matrixWorld);
        let O = t.update(w), I = w.material;
        if (Array.isArray(I)) {
          let F = O.groups;
          for (let j = 0, $ = F.length; j < $; j++) {
            let k = F[j], z = I[k.materialIndex];
            if (z && z.visible) {
              let R = g(w, O, z, S, P.near, P.far, A);
              i59.renderBufferDirect(P, null, O, R, w, k);
            }
          }
        } else if (I.visible) {
          let F = g(w, O, I, S, P.near, P.far, A);
          i59.renderBufferDirect(P, null, O, F, w, null);
        }
      }
      let H = w.children;
      for (let O = 0, I = H.length; O < I; O++) y(H[O], E, P, S, A);
    }
  }
  function rre(i59, t, e) {
    let n = e.isWebGL2;
    function r() {
      let J = false, je = new bn(), Te = null, rt = new bn(0, 0, 0, 0);
      return { setMask: function(ot) {
        Te !== ot && !J && (i59.colorMask(ot, ot, ot, ot), Te = ot);
      }, setLocked: function(ot) {
        J = ot;
      }, setClear: function(ot, Xt, Zn, Mn, Ti) {
        Ti === true && (ot *= Mn, Xt *= Mn, Zn *= Mn), je.set(ot, Xt, Zn, Mn), rt.equals(je) === false && (i59.clearColor(ot, Xt, Zn, Mn), rt.copy(je));
      }, reset: function() {
        J = false, Te = null, rt.set(-1, 0, 0, 0);
      } };
    }
    function o() {
      let J = false, je = null, Te = null, rt = null;
      return { setTest: function(ot) {
        ot ? oe(2929) : Be(2929);
      }, setMask: function(ot) {
        je !== ot && !J && (i59.depthMask(ot), je = ot);
      }, setFunc: function(ot) {
        if (Te !== ot) {
          if (ot) switch (ot) {
            case LV:
              i59.depthFunc(512);
              break;
            case FV:
              i59.depthFunc(519);
              break;
            case BV:
              i59.depthFunc(513);
              break;
            case H0:
              i59.depthFunc(515);
              break;
            case VV:
              i59.depthFunc(514);
              break;
            case zV:
              i59.depthFunc(518);
              break;
            case UV:
              i59.depthFunc(516);
              break;
            case GV:
              i59.depthFunc(517);
              break;
            default:
              i59.depthFunc(515);
          }
          else i59.depthFunc(515);
          Te = ot;
        }
      }, setLocked: function(ot) {
        J = ot;
      }, setClear: function(ot) {
        rt !== ot && (i59.clearDepth(ot), rt = ot);
      }, reset: function() {
        J = false, je = null, Te = null, rt = null;
      } };
    }
    function s() {
      let J = false, je = null, Te = null, rt = null, ot = null, Xt = null, Zn = null, Mn = null, Ti = null;
      return { setTest: function(ui) {
        J || (ui ? oe(2960) : Be(2960));
      }, setMask: function(ui) {
        je !== ui && !J && (i59.stencilMask(ui), je = ui);
      }, setFunc: function(ui, Qs, Go) {
        (Te !== ui || rt !== Qs || ot !== Go) && (i59.stencilFunc(ui, Qs, Go), Te = ui, rt = Qs, ot = Go);
      }, setOp: function(ui, Qs, Go) {
        (Xt !== ui || Zn !== Qs || Mn !== Go) && (i59.stencilOp(ui, Qs, Go), Xt = ui, Zn = Qs, Mn = Go);
      }, setLocked: function(ui) {
        J = ui;
      }, setClear: function(ui) {
        Ti !== ui && (i59.clearStencil(ui), Ti = ui);
      }, reset: function() {
        J = false, je = null, Te = null, rt = null, ot = null, Xt = null, Zn = null, Mn = null, Ti = null;
      } };
    }
    let a = new r(), l = new o(), c = new s(), d = {}, u = null, h = {}, p = null, f = false, m = null, v = null, _ = null, g = null, y = null, w = null, E = null, P = false, S = null, A = null, W = null, H = null, O = null, I = i59.getParameter(35661), F = false, j = 0, $ = i59.getParameter(7938);
    $.indexOf("WebGL") !== -1 ? (j = parseFloat(/^WebGL (\d)/.exec($)[1]), F = j >= 1) : $.indexOf("OpenGL ES") !== -1 && (j = parseFloat(/^OpenGL ES (\d)/.exec($)[1]), F = j >= 2);
    let k = null, z = {}, R = i59.getParameter(3088), V = i59.getParameter(2978), ie = new bn().fromArray(R), re = new bn().fromArray(V);
    function Re(J, je, Te) {
      let rt = new Uint8Array(4), ot = i59.createTexture();
      i59.bindTexture(J, ot), i59.texParameteri(J, 10241, 9728), i59.texParameteri(J, 10240, 9728);
      for (let Xt = 0; Xt < Te; Xt++) i59.texImage2D(je + Xt, 0, 6408, 1, 1, 0, 6408, 5121, rt);
      return ot;
    }
    let ne = {};
    ne[3553] = Re(3553, 3553, 1), ne[34067] = Re(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), c.setClear(0), oe(2929), l.setFunc(H0), fe(false), ge(i1), oe(2884), _e(Pa);
    function oe(J) {
      d[J] !== true && (i59.enable(J), d[J] = true);
    }
    function Be(J) {
      d[J] !== false && (i59.disable(J), d[J] = false);
    }
    function me(J) {
      J !== u && (i59.bindFramebuffer(36160, J), u = J);
    }
    function Ve(J, je) {
      return je === null && u !== null && (je = u), h[J] !== je ? (i59.bindFramebuffer(J, je), h[J] = je, n && (J === 36009 && (h[36160] = je), J === 36160 && (h[36009] = je)), true) : false;
    }
    function ue(J) {
      return p !== J ? (i59.useProgram(J), p = J, true) : false;
    }
    let ee = { [hd]: 32774, [MV]: 32778, [EV]: 32779 };
    if (n) ee[a1] = 32775, ee[l1] = 32776;
    else {
      let J = t.get("EXT_blend_minmax");
      J !== null && (ee[a1] = J.MIN_EXT, ee[l1] = J.MAX_EXT);
    }
    let Q = { [TV]: 0, [IV]: 1, [DV]: 768, [K1]: 770, [kV]: 776, [AV]: 774, [RV]: 772, [PV]: 769, [J1]: 771, [NV]: 775, [OV]: 773 };
    function _e(J, je, Te, rt, ot, Xt, Zn, Mn) {
      if (J === Pa) {
        f === true && (Be(3042), f = false);
        return;
      }
      if (f === false && (oe(3042), f = true), J !== SV) {
        if (J !== m || Mn !== P) {
          if ((v !== hd || y !== hd) && (i59.blendEquation(32774), v = hd, y = hd), Mn) switch (J) {
            case Rh:
              i59.blendFuncSeparate(1, 771, 1, 771);
              break;
            case r1:
              i59.blendFunc(1, 1);
              break;
            case o1:
              i59.blendFuncSeparate(0, 0, 769, 771);
              break;
            case s1:
              i59.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
          else switch (J) {
            case Rh:
              i59.blendFuncSeparate(770, 771, 1, 771);
              break;
            case r1:
              i59.blendFunc(770, 1);
              break;
            case o1:
              i59.blendFunc(0, 769);
              break;
            case s1:
              i59.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", J);
              break;
          }
          _ = null, g = null, w = null, E = null, m = J, P = Mn;
        }
        return;
      }
      ot = ot || je, Xt = Xt || Te, Zn = Zn || rt, (je !== v || ot !== y) && (i59.blendEquationSeparate(ee[je], ee[ot]), v = je, y = ot), (Te !== _ || rt !== g || Xt !== w || Zn !== E) && (i59.blendFuncSeparate(Q[Te], Q[rt], Q[Xt], Q[Zn]), _ = Te, g = rt, w = Xt, E = Zn), m = J, P = null;
    }
    function te(J, je) {
      J.side === bd ? Be(2884) : oe(2884);
      let Te = J.side === bi;
      je && (Te = !Te), fe(Te), J.blending === Rh && J.transparent === false ? _e(Pa) : _e(J.blending, J.blendEquation, J.blendSrc, J.blendDst, J.blendEquationAlpha, J.blendSrcAlpha, J.blendDstAlpha, J.premultipliedAlpha), l.setFunc(J.depthFunc), l.setTest(J.depthTest), l.setMask(J.depthWrite), a.setMask(J.colorWrite);
      let rt = J.stencilWrite;
      c.setTest(rt), rt && (c.setMask(J.stencilWriteMask), c.setFunc(J.stencilFunc, J.stencilRef, J.stencilFuncMask), c.setOp(J.stencilFail, J.stencilZFail, J.stencilZPass)), Se(J.polygonOffset, J.polygonOffsetFactor, J.polygonOffsetUnits), J.alphaToCoverage === true ? oe(32926) : Be(32926);
    }
    function fe(J) {
      S !== J && (J ? i59.frontFace(2304) : i59.frontFace(2305), S = J);
    }
    function ge(J) {
      J !== xV ? (oe(2884), J !== A && (J === i1 ? i59.cullFace(1029) : J === wV ? i59.cullFace(1028) : i59.cullFace(1032))) : Be(2884), A = J;
    }
    function Ne(J) {
      J !== W && (F && i59.lineWidth(J), W = J);
    }
    function Se(J, je, Te) {
      J ? (oe(32823), (H !== je || O !== Te) && (i59.polygonOffset(je, Te), H = je, O = Te)) : Be(32823);
    }
    function B(J) {
      J ? oe(3089) : Be(3089);
    }
    function N(J) {
      J === void 0 && (J = 33984 + I - 1), k !== J && (i59.activeTexture(J), k = J);
    }
    function se(J, je) {
      k === null && N();
      let Te = z[k];
      Te === void 0 && (Te = { type: void 0, texture: void 0 }, z[k] = Te), (Te.type !== J || Te.texture !== je) && (i59.bindTexture(J, je || ne[J]), Te.type = J, Te.texture = je);
    }
    function Le() {
      let J = z[k];
      J !== void 0 && J.type !== void 0 && (i59.bindTexture(J.type, null), J.type = void 0, J.texture = void 0);
    }
    function ke() {
      try {
        i59.compressedTexImage2D.apply(i59, arguments);
      } catch (J) {
        console.error("THREE.WebGLState:", J);
      }
    }
    function Xe() {
      try {
        i59.texImage2D.apply(i59, arguments);
      } catch (J) {
        console.error("THREE.WebGLState:", J);
      }
    }
    function bt() {
      try {
        i59.texImage3D.apply(i59, arguments);
      } catch (J) {
        console.error("THREE.WebGLState:", J);
      }
    }
    function ft(J) {
      ie.equals(J) === false && (i59.scissor(J.x, J.y, J.z, J.w), ie.copy(J));
    }
    function Dt(J) {
      re.equals(J) === false && (i59.viewport(J.x, J.y, J.z, J.w), re.copy(J));
    }
    function st() {
      i59.disable(3042), i59.disable(2884), i59.disable(2929), i59.disable(32823), i59.disable(3089), i59.disable(2960), i59.disable(32926), i59.blendEquation(32774), i59.blendFunc(1, 0), i59.blendFuncSeparate(1, 0, 1, 0), i59.colorMask(true, true, true, true), i59.clearColor(0, 0, 0, 0), i59.depthMask(true), i59.depthFunc(513), i59.clearDepth(1), i59.stencilMask(4294967295), i59.stencilFunc(519, 0, 4294967295), i59.stencilOp(7680, 7680, 7680), i59.clearStencil(0), i59.cullFace(1029), i59.frontFace(2305), i59.polygonOffset(0, 0), i59.activeTexture(33984), i59.bindFramebuffer(36160, null), n === true && (i59.bindFramebuffer(36009, null), i59.bindFramebuffer(36008, null)), i59.useProgram(null), i59.lineWidth(1), i59.scissor(0, 0, i59.canvas.width, i59.canvas.height), i59.viewport(0, 0, i59.canvas.width, i59.canvas.height), d = {}, k = null, z = {}, u = null, h = {}, p = null, f = false, m = null, v = null, _ = null, g = null, y = null, w = null, E = null, P = false, S = null, A = null, W = null, H = null, O = null, ie.set(0, 0, i59.canvas.width, i59.canvas.height), re.set(0, 0, i59.canvas.width, i59.canvas.height), a.reset(), l.reset(), c.reset();
    }
    return { buffers: { color: a, depth: l, stencil: c }, enable: oe, disable: Be, bindFramebuffer: Ve, bindXRFramebuffer: me, useProgram: ue, setBlending: _e, setMaterial: te, setFlipSided: fe, setCullFace: ge, setLineWidth: Ne, setPolygonOffset: Se, setScissorTest: B, activeTexture: N, bindTexture: se, unbindTexture: Le, compressedTexImage2D: ke, texImage2D: Xe, texImage3D: bt, scissor: ft, viewport: Dt, reset: st };
  }
  function ore(i59, t, e, n, r, o, s) {
    let a = r.isWebGL2, l = r.maxTextures, c = r.maxCubemapSize, d = r.maxTextureSize, u = r.maxSamples, h = /* @__PURE__ */ new WeakMap(), p, f = false;
    try {
      f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
    } catch {
    }
    function m(B, N) {
      return f ? new OffscreenCanvas(B, N) : Ux("canvas");
    }
    function v(B, N, se, Le) {
      let ke = 1;
      if ((B.width > Le || B.height > Le) && (ke = Le / Math.max(B.width, B.height)), ke < 1 || N === true) if (typeof HTMLImageElement < "u" && B instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && B instanceof ImageBitmap) {
        let Xe = N ? Kz : Math.floor, bt = Xe(ke * B.width), ft = Xe(ke * B.height);
        p === void 0 && (p = m(bt, ft));
        let Dt = se ? m(bt, ft) : p;
        return Dt.width = bt, Dt.height = ft, Dt.getContext("2d").drawImage(B, 0, 0, bt, ft), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + B.width + "x" + B.height + ") to (" + bt + "x" + ft + ")."), Dt;
      } else return "data" in B && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + B.width + "x" + B.height + ")."), B;
      return B;
    }
    function _(B) {
      return b1(B.width) && b1(B.height);
    }
    function g(B) {
      return a ? false : B.wrapS !== nr || B.wrapT !== nr || B.minFilter !== Si && B.minFilter !== Ri;
    }
    function y(B, N) {
      return B.generateMipmaps && N && B.minFilter !== Si && B.minFilter !== Ri;
    }
    function w(B, N, se, Le, ke = 1) {
      i59.generateMipmap(B);
      let Xe = n.get(N);
      Xe.__maxMipLevel = Math.log2(Math.max(se, Le, ke));
    }
    function E(B, N, se, Le) {
      if (a === false) return N;
      if (B !== null) {
        if (i59[B] !== void 0) return i59[B];
        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'");
      }
      let ke = N;
      return N === 6403 && (se === 5126 && (ke = 33326), se === 5131 && (ke = 33325), se === 5121 && (ke = 33321)), N === 6407 && (se === 5126 && (ke = 34837), se === 5131 && (ke = 34843), se === 5121 && (ke = 32849)), N === 6408 && (se === 5126 && (ke = 34836), se === 5131 && (ke = 34842), se === 5121 && (ke = Le === Ll ? 35907 : 32856)), (ke === 33325 || ke === 33326 || ke === 34842 || ke === 34836) && t.get("EXT_color_buffer_float"), ke;
    }
    function P(B) {
      return B === Si || B === j0 || B === W0 ? 9728 : 9729;
    }
    function S(B) {
      let N = B.target;
      N.removeEventListener("dispose", S), W(N), N.isVideoTexture && h.delete(N), s.memory.textures--;
    }
    function A(B) {
      let N = B.target;
      N.removeEventListener("dispose", A), H(N);
    }
    function W(B) {
      let N = n.get(B);
      N.__webglInit !== void 0 && (i59.deleteTexture(N.__webglTexture), n.remove(B));
    }
    function H(B) {
      let N = B.texture, se = n.get(B), Le = n.get(N);
      if (B) {
        if (Le.__webglTexture !== void 0 && (i59.deleteTexture(Le.__webglTexture), s.memory.textures--), B.depthTexture && B.depthTexture.dispose(), B.isWebGLCubeRenderTarget) for (let ke = 0; ke < 6; ke++) i59.deleteFramebuffer(se.__webglFramebuffer[ke]), se.__webglDepthbuffer && i59.deleteRenderbuffer(se.__webglDepthbuffer[ke]);
        else i59.deleteFramebuffer(se.__webglFramebuffer), se.__webglDepthbuffer && i59.deleteRenderbuffer(se.__webglDepthbuffer), se.__webglMultisampledFramebuffer && i59.deleteFramebuffer(se.__webglMultisampledFramebuffer), se.__webglColorRenderbuffer && i59.deleteRenderbuffer(se.__webglColorRenderbuffer), se.__webglDepthRenderbuffer && i59.deleteRenderbuffer(se.__webglDepthRenderbuffer);
        if (B.isWebGLMultipleRenderTargets) for (let ke = 0, Xe = N.length; ke < Xe; ke++) {
          let bt = n.get(N[ke]);
          bt.__webglTexture && (i59.deleteTexture(bt.__webglTexture), s.memory.textures--), n.remove(N[ke]);
        }
        n.remove(N), n.remove(B);
      }
    }
    let O = 0;
    function I() {
      O = 0;
    }
    function F() {
      let B = O;
      return B >= l && console.warn("THREE.WebGLTextures: Trying to use " + B + " texture units while this GPU supports only " + l), O += 1, B;
    }
    function j(B, N) {
      let se = n.get(B);
      if (B.isVideoTexture && te(B), B.version > 0 && se.__version !== B.version) {
        let Le = B.image;
        if (Le === void 0) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        else if (Le.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        else {
          Re(se, B, N);
          return;
        }
      }
      e.activeTexture(33984 + N), e.bindTexture(3553, se.__webglTexture);
    }
    function $(B, N) {
      let se = n.get(B);
      if (B.version > 0 && se.__version !== B.version) {
        Re(se, B, N);
        return;
      }
      e.activeTexture(33984 + N), e.bindTexture(35866, se.__webglTexture);
    }
    function k(B, N) {
      let se = n.get(B);
      if (B.version > 0 && se.__version !== B.version) {
        Re(se, B, N);
        return;
      }
      e.activeTexture(33984 + N), e.bindTexture(32879, se.__webglTexture);
    }
    function z(B, N) {
      let se = n.get(B);
      if (B.version > 0 && se.__version !== B.version) {
        ne(se, B, N);
        return;
      }
      e.activeTexture(33984 + N), e.bindTexture(34067, se.__webglTexture);
    }
    let R = { [Nm]: 10497, [nr]: 33071, [km]: 33648 }, V = { [Si]: 9728, [j0]: 9984, [W0]: 9986, [Ri]: 9729, [eD]: 9985, [Bd]: 9987 };
    function ie(B, N, se) {
      if (se ? (i59.texParameteri(B, 10242, R[N.wrapS]), i59.texParameteri(B, 10243, R[N.wrapT]), (B === 32879 || B === 35866) && i59.texParameteri(B, 32882, R[N.wrapR]), i59.texParameteri(B, 10240, V[N.magFilter]), i59.texParameteri(B, 10241, V[N.minFilter])) : (i59.texParameteri(B, 10242, 33071), i59.texParameteri(B, 10243, 33071), (B === 32879 || B === 35866) && i59.texParameteri(B, 32882, 33071), (N.wrapS !== nr || N.wrapT !== nr) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i59.texParameteri(B, 10240, P(N.magFilter)), i59.texParameteri(B, 10241, P(N.minFilter)), N.minFilter !== Si && N.minFilter !== Ri && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), t.has("EXT_texture_filter_anisotropic") === true) {
        let Le = t.get("EXT_texture_filter_anisotropic");
        if (N.type === Fs && t.has("OES_texture_float_linear") === false || a === false && N.type === md && t.has("OES_texture_half_float_linear") === false) return;
        (N.anisotropy > 1 || n.get(N).__currentAnisotropy) && (i59.texParameterf(B, Le.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())), n.get(N).__currentAnisotropy = N.anisotropy);
      }
    }
    function re(B, N) {
      B.__webglInit === void 0 && (B.__webglInit = true, N.addEventListener("dispose", S), B.__webglTexture = i59.createTexture(), s.memory.textures++);
    }
    function Re(B, N, se) {
      let Le = 3553;
      N.isDataTexture2DArray && (Le = 35866), N.isDataTexture3D && (Le = 32879), re(B, N), e.activeTexture(33984 + se), e.bindTexture(Le, B.__webglTexture), i59.pixelStorei(37440, N.flipY), i59.pixelStorei(37441, N.premultiplyAlpha), i59.pixelStorei(3317, N.unpackAlignment), i59.pixelStorei(37443, 0);
      let ke = g(N) && _(N.image) === false, Xe = v(N.image, ke, false, d), bt = _(Xe) || a, ft = o.convert(N.format), Dt = o.convert(N.type), st = E(N.internalFormat, ft, Dt, N.encoding);
      ie(Le, N, bt);
      let J, je = N.mipmaps;
      if (N.isDepthTexture) st = 6402, a ? N.type === Fs ? st = 36012 : N.type === Tm ? st = 33190 : N.type === Oh ? st = 35056 : st = 33189 : N.type === Fs && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), N.format === _d && st === 6402 && N.type !== Lm && N.type !== Tm && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), N.type = Lm, Dt = o.convert(N.type)), N.format === Nh && st === 6402 && (st = 34041, N.type !== Oh && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), N.type = Oh, Dt = o.convert(N.type))), e.texImage2D(3553, 0, st, Xe.width, Xe.height, 0, ft, Dt, null);
      else if (N.isDataTexture) if (je.length > 0 && bt) {
        for (let Te = 0, rt = je.length; Te < rt; Te++) J = je[Te], e.texImage2D(3553, Te, st, J.width, J.height, 0, ft, Dt, J.data);
        N.generateMipmaps = false, B.__maxMipLevel = je.length - 1;
      } else e.texImage2D(3553, 0, st, Xe.width, Xe.height, 0, ft, Dt, Xe.data), B.__maxMipLevel = 0;
      else if (N.isCompressedTexture) {
        for (let Te = 0, rt = je.length; Te < rt; Te++) J = je[Te], N.format !== ir && N.format !== gd ? ft !== null ? e.compressedTexImage2D(3553, Te, st, J.width, J.height, 0, J.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : e.texImage2D(3553, Te, st, J.width, J.height, 0, ft, Dt, J.data);
        B.__maxMipLevel = je.length - 1;
      } else if (N.isDataTexture2DArray) e.texImage3D(35866, 0, st, Xe.width, Xe.height, Xe.depth, 0, ft, Dt, Xe.data), B.__maxMipLevel = 0;
      else if (N.isDataTexture3D) e.texImage3D(32879, 0, st, Xe.width, Xe.height, Xe.depth, 0, ft, Dt, Xe.data), B.__maxMipLevel = 0;
      else if (je.length > 0 && bt) {
        for (let Te = 0, rt = je.length; Te < rt; Te++) J = je[Te], e.texImage2D(3553, Te, st, ft, Dt, J);
        N.generateMipmaps = false, B.__maxMipLevel = je.length - 1;
      } else e.texImage2D(3553, 0, st, ft, Dt, Xe), B.__maxMipLevel = 0;
      y(N, bt) && w(Le, N, Xe.width, Xe.height), B.__version = N.version, N.onUpdate && N.onUpdate(N);
    }
    function ne(B, N, se) {
      if (N.image.length !== 6) return;
      re(B, N), e.activeTexture(33984 + se), e.bindTexture(34067, B.__webglTexture), i59.pixelStorei(37440, N.flipY), i59.pixelStorei(37441, N.premultiplyAlpha), i59.pixelStorei(3317, N.unpackAlignment), i59.pixelStorei(37443, 0);
      let Le = N && (N.isCompressedTexture || N.image[0].isCompressedTexture), ke = N.image[0] && N.image[0].isDataTexture, Xe = [];
      for (let Te = 0; Te < 6; Te++) !Le && !ke ? Xe[Te] = v(N.image[Te], false, true, c) : Xe[Te] = ke ? N.image[Te].image : N.image[Te];
      let bt = Xe[0], ft = _(bt) || a, Dt = o.convert(N.format), st = o.convert(N.type), J = E(N.internalFormat, Dt, st, N.encoding);
      ie(34067, N, ft);
      let je;
      if (Le) {
        for (let Te = 0; Te < 6; Te++) {
          je = Xe[Te].mipmaps;
          for (let rt = 0; rt < je.length; rt++) {
            let ot = je[rt];
            N.format !== ir && N.format !== gd ? Dt !== null ? e.compressedTexImage2D(34069 + Te, rt, J, ot.width, ot.height, 0, ot.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : e.texImage2D(34069 + Te, rt, J, ot.width, ot.height, 0, Dt, st, ot.data);
          }
        }
        B.__maxMipLevel = je.length - 1;
      } else {
        je = N.mipmaps;
        for (let Te = 0; Te < 6; Te++) if (ke) {
          e.texImage2D(34069 + Te, 0, J, Xe[Te].width, Xe[Te].height, 0, Dt, st, Xe[Te].data);
          for (let rt = 0; rt < je.length; rt++) {
            let Xt = je[rt].image[Te].image;
            e.texImage2D(34069 + Te, rt + 1, J, Xt.width, Xt.height, 0, Dt, st, Xt.data);
          }
        } else {
          e.texImage2D(34069 + Te, 0, J, Dt, st, Xe[Te]);
          for (let rt = 0; rt < je.length; rt++) {
            let ot = je[rt];
            e.texImage2D(34069 + Te, rt + 1, J, Dt, st, ot.image[Te]);
          }
        }
        B.__maxMipLevel = je.length;
      }
      y(N, ft) && w(34067, N, bt.width, bt.height), B.__version = N.version, N.onUpdate && N.onUpdate(N);
    }
    function oe(B, N, se, Le, ke) {
      let Xe = o.convert(se.format), bt = o.convert(se.type), ft = E(se.internalFormat, Xe, bt, se.encoding);
      ke === 32879 || ke === 35866 ? e.texImage3D(ke, 0, ft, N.width, N.height, N.depth, 0, Xe, bt, null) : e.texImage2D(ke, 0, ft, N.width, N.height, 0, Xe, bt, null), e.bindFramebuffer(36160, B), i59.framebufferTexture2D(36160, Le, ke, n.get(se).__webglTexture, 0), e.bindFramebuffer(36160, null);
    }
    function Be(B, N, se) {
      if (i59.bindRenderbuffer(36161, B), N.depthBuffer && !N.stencilBuffer) {
        let Le = 33189;
        if (se) {
          let ke = N.depthTexture;
          ke && ke.isDepthTexture && (ke.type === Fs ? Le = 36012 : ke.type === Tm && (Le = 33190));
          let Xe = _e(N);
          i59.renderbufferStorageMultisample(36161, Xe, Le, N.width, N.height);
        } else i59.renderbufferStorage(36161, Le, N.width, N.height);
        i59.framebufferRenderbuffer(36160, 36096, 36161, B);
      } else if (N.depthBuffer && N.stencilBuffer) {
        if (se) {
          let Le = _e(N);
          i59.renderbufferStorageMultisample(36161, Le, 35056, N.width, N.height);
        } else i59.renderbufferStorage(36161, 34041, N.width, N.height);
        i59.framebufferRenderbuffer(36160, 33306, 36161, B);
      } else {
        let Le = N.isWebGLMultipleRenderTargets === true ? N.texture[0] : N.texture, ke = o.convert(Le.format), Xe = o.convert(Le.type), bt = E(Le.internalFormat, ke, Xe, Le.encoding);
        if (se) {
          let ft = _e(N);
          i59.renderbufferStorageMultisample(36161, ft, bt, N.width, N.height);
        } else i59.renderbufferStorage(36161, bt, N.width, N.height);
      }
      i59.bindRenderbuffer(36161, null);
    }
    function me(B, N) {
      if (N && N.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (e.bindFramebuffer(36160, B), !(N.depthTexture && N.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      (!n.get(N.depthTexture).__webglTexture || N.depthTexture.image.width !== N.width || N.depthTexture.image.height !== N.height) && (N.depthTexture.image.width = N.width, N.depthTexture.image.height = N.height, N.depthTexture.needsUpdate = true), j(N.depthTexture, 0);
      let Le = n.get(N.depthTexture).__webglTexture;
      if (N.depthTexture.format === _d) i59.framebufferTexture2D(36160, 36096, 3553, Le, 0);
      else if (N.depthTexture.format === Nh) i59.framebufferTexture2D(36160, 33306, 3553, Le, 0);
      else throw new Error("Unknown depthTexture format");
    }
    function Ve(B) {
      let N = n.get(B), se = B.isWebGLCubeRenderTarget === true;
      if (B.depthTexture) {
        if (se) throw new Error("target.depthTexture not supported in Cube render targets");
        me(N.__webglFramebuffer, B);
      } else if (se) {
        N.__webglDepthbuffer = [];
        for (let Le = 0; Le < 6; Le++) e.bindFramebuffer(36160, N.__webglFramebuffer[Le]), N.__webglDepthbuffer[Le] = i59.createRenderbuffer(), Be(N.__webglDepthbuffer[Le], B, false);
      } else e.bindFramebuffer(36160, N.__webglFramebuffer), N.__webglDepthbuffer = i59.createRenderbuffer(), Be(N.__webglDepthbuffer, B, false);
      e.bindFramebuffer(36160, null);
    }
    function ue(B) {
      let N = B.texture, se = n.get(B), Le = n.get(N);
      B.addEventListener("dispose", A), B.isWebGLMultipleRenderTargets !== true && (Le.__webglTexture = i59.createTexture(), Le.__version = N.version, s.memory.textures++);
      let ke = B.isWebGLCubeRenderTarget === true, Xe = B.isWebGLMultipleRenderTargets === true, bt = B.isWebGLMultisampleRenderTarget === true, ft = N.isDataTexture3D || N.isDataTexture2DArray, Dt = _(B) || a;
      if (a && N.format === gd && (N.type === Fs || N.type === md) && (N.format = ir, console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")), ke) {
        se.__webglFramebuffer = [];
        for (let st = 0; st < 6; st++) se.__webglFramebuffer[st] = i59.createFramebuffer();
      } else if (se.__webglFramebuffer = i59.createFramebuffer(), Xe) if (r.drawBuffers) {
        let st = B.texture;
        for (let J = 0, je = st.length; J < je; J++) {
          let Te = n.get(st[J]);
          Te.__webglTexture === void 0 && (Te.__webglTexture = i59.createTexture(), s.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      else if (bt) if (a) {
        se.__webglMultisampledFramebuffer = i59.createFramebuffer(), se.__webglColorRenderbuffer = i59.createRenderbuffer(), i59.bindRenderbuffer(36161, se.__webglColorRenderbuffer);
        let st = o.convert(N.format), J = o.convert(N.type), je = E(N.internalFormat, st, J, N.encoding), Te = _e(B);
        i59.renderbufferStorageMultisample(36161, Te, je, B.width, B.height), e.bindFramebuffer(36160, se.__webglMultisampledFramebuffer), i59.framebufferRenderbuffer(36160, 36064, 36161, se.__webglColorRenderbuffer), i59.bindRenderbuffer(36161, null), B.depthBuffer && (se.__webglDepthRenderbuffer = i59.createRenderbuffer(), Be(se.__webglDepthRenderbuffer, B, true)), e.bindFramebuffer(36160, null);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
      if (ke) {
        e.bindTexture(34067, Le.__webglTexture), ie(34067, N, Dt);
        for (let st = 0; st < 6; st++) oe(se.__webglFramebuffer[st], B, N, 36064, 34069 + st);
        y(N, Dt) && w(34067, N, B.width, B.height), e.unbindTexture();
      } else if (Xe) {
        let st = B.texture;
        for (let J = 0, je = st.length; J < je; J++) {
          let Te = st[J], rt = n.get(Te);
          e.bindTexture(3553, rt.__webglTexture), ie(3553, Te, Dt), oe(se.__webglFramebuffer, B, Te, 36064 + J, 3553), y(Te, Dt) && w(3553, Te, B.width, B.height);
        }
        e.unbindTexture();
      } else {
        let st = 3553;
        ft && (a ? st = N.isDataTexture3D ? 32879 : 35866 : console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")), e.bindTexture(st, Le.__webglTexture), ie(st, N, Dt), oe(se.__webglFramebuffer, B, N, 36064, st), y(N, Dt) && w(st, N, B.width, B.height, B.depth), e.unbindTexture();
      }
      B.depthBuffer && Ve(B);
    }
    function ee(B) {
      let N = _(B) || a, se = B.isWebGLMultipleRenderTargets === true ? B.texture : [B.texture];
      for (let Le = 0, ke = se.length; Le < ke; Le++) {
        let Xe = se[Le];
        if (y(Xe, N)) {
          let bt = B.isWebGLCubeRenderTarget ? 34067 : 3553, ft = n.get(Xe).__webglTexture;
          e.bindTexture(bt, ft), w(bt, Xe, B.width, B.height), e.unbindTexture();
        }
      }
    }
    function Q(B) {
      if (B.isWebGLMultisampleRenderTarget) if (a) {
        let N = B.width, se = B.height, Le = 16384;
        B.depthBuffer && (Le |= 256), B.stencilBuffer && (Le |= 1024);
        let ke = n.get(B);
        e.bindFramebuffer(36008, ke.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, ke.__webglFramebuffer), i59.blitFramebuffer(0, 0, N, se, 0, 0, N, se, Le, 9728), e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, ke.__webglMultisampledFramebuffer);
      } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
    }
    function _e(B) {
      return a && B.isWebGLMultisampleRenderTarget ? Math.min(u, B.samples) : 0;
    }
    function te(B) {
      let N = s.render.frame;
      h.get(B) !== N && (h.set(B, N), B.update());
    }
    let fe = false, ge = false;
    function Ne(B, N) {
      B && B.isWebGLRenderTarget && (fe === false && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), fe = true), B = B.texture), j(B, N);
    }
    function Se(B, N) {
      B && B.isWebGLCubeRenderTarget && (ge === false && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), ge = true), B = B.texture), z(B, N);
    }
    this.allocateTextureUnit = F, this.resetTextureUnits = I, this.setTexture2D = j, this.setTexture2DArray = $, this.setTexture3D = k, this.setTextureCube = z, this.setupRenderTarget = ue, this.updateRenderTargetMipmap = ee, this.updateMultisampleRenderTarget = Q, this.safeSetTexture2D = Ne, this.safeSetTextureCube = Se;
  }
  function hU(i59, t, e) {
    let n = e.isWebGL2;
    function r(o) {
      let s;
      if (o === Oa) return 5121;
      if (o === JV) return 32819;
      if (o === ez) return 32820;
      if (o === tz) return 33635;
      if (o === ZV) return 5120;
      if (o === QV) return 5122;
      if (o === Lm) return 5123;
      if (o === KV) return 5124;
      if (o === Tm) return 5125;
      if (o === Fs) return 5126;
      if (o === md) return n ? 5131 : (s = t.get("OES_texture_half_float"), s !== null ? s.HALF_FLOAT_OES : null);
      if (o === nz) return 6406;
      if (o === gd) return 6407;
      if (o === ir) return 6408;
      if (o === iz) return 6409;
      if (o === rz) return 6410;
      if (o === _d) return 6402;
      if (o === Nh) return 34041;
      if (o === sz) return 6403;
      if (o === az) return 36244;
      if (o === lz) return 33319;
      if (o === cz) return 33320;
      if (o === dz) return 36248;
      if (o === uz) return 36249;
      if (o === c1 || o === d1 || o === u1 || o === h1) if (s = t.get("WEBGL_compressed_texture_s3tc"), s !== null) {
        if (o === c1) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (o === d1) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (o === u1) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (o === h1) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
      if (o === p1 || o === f1 || o === m1 || o === g1) if (s = t.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
        if (o === p1) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (o === f1) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (o === m1) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (o === g1) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
      if (o === hz) return s = t.get("WEBGL_compressed_texture_etc1"), s !== null ? s.COMPRESSED_RGB_ETC1_WEBGL : null;
      if ((o === _1 || o === v1) && (s = t.get("WEBGL_compressed_texture_etc"), s !== null)) {
        if (o === _1) return s.COMPRESSED_RGB8_ETC2;
        if (o === v1) return s.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (o === pz || o === fz || o === mz || o === gz || o === _z || o === vz || o === yz || o === bz || o === xz || o === wz || o === Cz || o === Sz || o === Mz || o === Ez || o === Iz || o === Dz || o === Pz || o === Rz || o === Oz || o === Az || o === Nz || o === kz || o === Lz || o === Fz || o === Bz || o === Vz || o === zz || o === Uz) return s = t.get("WEBGL_compressed_texture_astc"), s !== null ? o : null;
      if (o === Tz) return s = t.get("EXT_texture_compression_bptc"), s !== null ? o : null;
      if (o === Oh) return n ? 34042 : (s = t.get("WEBGL_depth_texture"), s !== null ? s.UNSIGNED_INT_24_8_WEBGL : null);
    }
    return { convert: r };
  }
  var jm = class extends Ci {
    constructor(t = []) {
      super(), this.cameras = t;
    }
  };
  jm.prototype.isArrayCamera = true;
  var Da = class extends ln {
    constructor() {
      super(), this.type = "Group";
    }
  };
  Da.prototype.isGroup = true;
  var sre = { type: "move" };
  var Dm = class {
    constructor() {
      this._targetRay = null, this._grip = null, this._hand = null;
    }
    getHandSpace() {
      return this._hand === null && (this._hand = new Da(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
    }
    getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new Da(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new L(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new L()), this._targetRay;
    }
    getGripSpace() {
      return this._grip === null && (this._grip = new Da(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new L(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new L()), this._grip;
    }
    dispatchEvent(t) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this;
    }
    disconnect(t) {
      return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
    }
    update(t, e, n) {
      let r = null, o = null, s = null, a = this._targetRay, l = this._grip, c = this._hand;
      if (t && e.session.visibilityState !== "visible-blurred") if (a !== null && (r = e.getPose(t.targetRaySpace, n), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = false, r.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(sre))), c && t.hand) {
        s = true;
        for (let m of t.hand.values()) {
          let v = e.getJointPose(m, n);
          if (c.joints[m.jointName] === void 0) {
            let g = new Da();
            g.matrixAutoUpdate = false, g.visible = false, c.joints[m.jointName] = g, c.add(g);
          }
          let _ = c.joints[m.jointName];
          v !== null && (_.matrix.fromArray(v.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.jointRadius = v.radius), _.visible = v !== null;
        }
        let d = c.joints["index-finger-tip"], u = c.joints["thumb-tip"], h = d.position.distanceTo(u.position), p = 0.02, f = 5e-3;
        c.inputState.pinching && h > p + f ? (c.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !c.inputState.pinching && h <= p - f && (c.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this }));
      } else l !== null && t.gripSpace && (o = e.getPose(t.gripSpace, n), o !== null && (l.matrix.fromArray(o.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), o.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(o.linearVelocity)) : l.hasLinearVelocity = false, o.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(o.angularVelocity)) : l.hasAngularVelocity = false));
      return a !== null && (a.visible = r !== null), l !== null && (l.visible = o !== null), c !== null && (c.visible = s !== null), this;
    }
  };
  var w1 = class extends Vs {
    constructor(t, e) {
      super();
      let n = this, r = t.state, o = null, s = 1, a = null, l = "local-floor", c = null, d = null, u = null, h = null, p = null, f = false, m = null, v = null, _ = null, g = null, y = null, w = null, E = [], P = /* @__PURE__ */ new Map(), S = new Ci();
      S.layers.enable(1), S.viewport = new bn();
      let A = new Ci();
      A.layers.enable(2), A.viewport = new bn();
      let W = [S, A], H = new jm();
      H.layers.enable(1), H.layers.enable(2);
      let O = null, I = null;
      this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(ne) {
        let oe = E[ne];
        return oe === void 0 && (oe = new Dm(), E[ne] = oe), oe.getTargetRaySpace();
      }, this.getControllerGrip = function(ne) {
        let oe = E[ne];
        return oe === void 0 && (oe = new Dm(), E[ne] = oe), oe.getGripSpace();
      }, this.getHand = function(ne) {
        let oe = E[ne];
        return oe === void 0 && (oe = new Dm(), E[ne] = oe), oe.getHandSpace();
      };
      function F(ne) {
        let oe = P.get(ne.inputSource);
        oe && oe.dispatchEvent({ type: ne.type, data: ne.inputSource });
      }
      function j() {
        P.forEach(function(ne, oe) {
          ne.disconnect(oe);
        }), P.clear(), O = null, I = null, r.bindXRFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), u && e.deleteFramebuffer(u), m && e.deleteFramebuffer(m), v && e.deleteRenderbuffer(v), _ && e.deleteRenderbuffer(_), u = null, m = null, v = null, _ = null, p = null, h = null, d = null, o = null, Re.stop(), n.isPresenting = false, n.dispatchEvent({ type: "sessionend" });
      }
      this.setFramebufferScaleFactor = function(ne) {
        s = ne, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }, this.setReferenceSpaceType = function(ne) {
        l = ne, n.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }, this.getReferenceSpace = function() {
        return a;
      }, this.getBaseLayer = function() {
        return h !== null ? h : p;
      }, this.getBinding = function() {
        return d;
      }, this.getFrame = function() {
        return g;
      }, this.getSession = function() {
        return o;
      }, this.setSession = function(ne) {
        return $t(this, null, function* () {
          if (o = ne, o !== null) {
            o.addEventListener("select", F), o.addEventListener("selectstart", F), o.addEventListener("selectend", F), o.addEventListener("squeeze", F), o.addEventListener("squeezestart", F), o.addEventListener("squeezeend", F), o.addEventListener("end", j), o.addEventListener("inputsourceschange", $);
            let oe = e.getContextAttributes();
            if (oe.xrCompatible !== true && (yield e.makeXRCompatible()), o.renderState.layers === void 0) {
              let Be = { antialias: oe.antialias, alpha: oe.alpha, depth: oe.depth, stencil: oe.stencil, framebufferScaleFactor: s };
              p = new XRWebGLLayer(o, e, Be), o.updateRenderState({ baseLayer: p });
            } else if (e instanceof WebGLRenderingContext) {
              let Be = { antialias: true, alpha: oe.alpha, depth: oe.depth, stencil: oe.stencil, framebufferScaleFactor: s };
              p = new XRWebGLLayer(o, e, Be), o.updateRenderState({ layers: [p] });
            } else {
              f = oe.antialias;
              let Be = null;
              oe.depth && (w = 256, oe.stencil && (w |= 1024), y = oe.stencil ? 33306 : 36096, Be = oe.stencil ? 35056 : 33190);
              let me = { colorFormat: oe.alpha ? 32856 : 32849, depthFormat: Be, scaleFactor: s };
              d = new XRWebGLBinding(o, e), h = d.createProjectionLayer(me), u = e.createFramebuffer(), o.updateRenderState({ layers: [h] }), f && (m = e.createFramebuffer(), v = e.createRenderbuffer(), e.bindRenderbuffer(36161, v), e.renderbufferStorageMultisample(36161, 4, 32856, h.textureWidth, h.textureHeight), r.bindFramebuffer(36160, m), e.framebufferRenderbuffer(36160, 36064, 36161, v), e.bindRenderbuffer(36161, null), Be !== null && (_ = e.createRenderbuffer(), e.bindRenderbuffer(36161, _), e.renderbufferStorageMultisample(36161, 4, Be, h.textureWidth, h.textureHeight), e.framebufferRenderbuffer(36160, y, 36161, _), e.bindRenderbuffer(36161, null)), r.bindFramebuffer(36160, null));
            }
            a = yield o.requestReferenceSpace(l), Re.setContext(o), Re.start(), n.isPresenting = true, n.dispatchEvent({ type: "sessionstart" });
          }
        });
      };
      function $(ne) {
        let oe = o.inputSources;
        for (let Be = 0; Be < E.length; Be++) P.set(oe[Be], E[Be]);
        for (let Be = 0; Be < ne.removed.length; Be++) {
          let me = ne.removed[Be], Ve = P.get(me);
          Ve && (Ve.dispatchEvent({ type: "disconnected", data: me }), P.delete(me));
        }
        for (let Be = 0; Be < ne.added.length; Be++) {
          let me = ne.added[Be], Ve = P.get(me);
          Ve && Ve.dispatchEvent({ type: "connected", data: me });
        }
      }
      let k = new L(), z = new L();
      function R(ne, oe, Be) {
        k.setFromMatrixPosition(oe.matrixWorld), z.setFromMatrixPosition(Be.matrixWorld);
        let me = k.distanceTo(z), Ve = oe.projectionMatrix.elements, ue = Be.projectionMatrix.elements, ee = Ve[14] / (Ve[10] - 1), Q = Ve[14] / (Ve[10] + 1), _e = (Ve[9] + 1) / Ve[5], te = (Ve[9] - 1) / Ve[5], fe = (Ve[8] - 1) / Ve[0], ge = (ue[8] + 1) / ue[0], Ne = ee * fe, Se = ee * ge, B = me / (-fe + ge), N = B * -fe;
        oe.matrixWorld.decompose(ne.position, ne.quaternion, ne.scale), ne.translateX(N), ne.translateZ(B), ne.matrixWorld.compose(ne.position, ne.quaternion, ne.scale), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
        let se = ee + B, Le = Q + B, ke = Ne - N, Xe = Se + (me - N), bt = _e * Q / Le * se, ft = te * Q / Le * se;
        ne.projectionMatrix.makePerspective(ke, Xe, bt, ft, se, Le);
      }
      function V(ne, oe) {
        oe === null ? ne.matrixWorld.copy(ne.matrix) : ne.matrixWorld.multiplyMatrices(oe.matrixWorld, ne.matrix), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
      }
      this.updateCamera = function(ne) {
        if (o === null) return;
        H.near = A.near = S.near = ne.near, H.far = A.far = S.far = ne.far, (O !== H.near || I !== H.far) && (o.updateRenderState({ depthNear: H.near, depthFar: H.far }), O = H.near, I = H.far);
        let oe = ne.parent, Be = H.cameras;
        V(H, oe);
        for (let Ve = 0; Ve < Be.length; Ve++) V(Be[Ve], oe);
        H.matrixWorld.decompose(H.position, H.quaternion, H.scale), ne.position.copy(H.position), ne.quaternion.copy(H.quaternion), ne.scale.copy(H.scale), ne.matrix.copy(H.matrix), ne.matrixWorld.copy(H.matrixWorld);
        let me = ne.children;
        for (let Ve = 0, ue = me.length; Ve < ue; Ve++) me[Ve].updateMatrixWorld(true);
        Be.length === 2 ? R(H, S, A) : H.projectionMatrix.copy(S.projectionMatrix);
      }, this.getCamera = function() {
        return H;
      }, this.getFoveation = function() {
        if (h !== null) return h.fixedFoveation;
        if (p !== null) return p.fixedFoveation;
      }, this.setFoveation = function(ne) {
        h !== null && (h.fixedFoveation = ne), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = ne);
      };
      let ie = null;
      function re(ne, oe) {
        if (c = oe.getViewerPose(a), g = oe, c !== null) {
          let me = c.views;
          p !== null && r.bindXRFramebuffer(p.framebuffer);
          let Ve = false;
          me.length !== H.cameras.length && (H.cameras.length = 0, Ve = true);
          for (let ue = 0; ue < me.length; ue++) {
            let ee = me[ue], Q = null;
            if (p !== null) Q = p.getViewport(ee);
            else {
              let te = d.getViewSubImage(h, ee);
              r.bindXRFramebuffer(u), te.depthStencilTexture !== void 0 && e.framebufferTexture2D(36160, y, 3553, te.depthStencilTexture, 0), e.framebufferTexture2D(36160, 36064, 3553, te.colorTexture, 0), Q = te.viewport;
            }
            let _e = W[ue];
            _e.matrix.fromArray(ee.transform.matrix), _e.projectionMatrix.fromArray(ee.projectionMatrix), _e.viewport.set(Q.x, Q.y, Q.width, Q.height), ue === 0 && H.matrix.copy(_e.matrix), Ve === true && H.cameras.push(_e);
          }
          f && (r.bindXRFramebuffer(m), w !== null && e.clear(w));
        }
        let Be = o.inputSources;
        for (let me = 0; me < E.length; me++) {
          let Ve = E[me], ue = Be[me];
          Ve.update(ue, oe, a);
        }
        if (ie && ie(ne, oe), f) {
          let me = h.textureWidth, Ve = h.textureHeight;
          r.bindFramebuffer(36008, m), r.bindFramebuffer(36009, u), e.invalidateFramebuffer(36008, [y]), e.invalidateFramebuffer(36009, [y]), e.blitFramebuffer(0, 0, me, Ve, 0, 0, me, Ve, 16384, 9728), e.invalidateFramebuffer(36008, [36064]), r.bindFramebuffer(36008, null), r.bindFramebuffer(36009, null), r.bindFramebuffer(36160, m);
        }
        g = null;
      }
      let Re = new tU();
      Re.setAnimationLoop(re), this.setAnimationLoop = function(ne) {
        ie = ne;
      }, this.dispose = function() {
      };
    }
  };
  function are(i59) {
    function t(_, g) {
      _.fogColor.value.copy(g.color), g.isFog ? (_.fogNear.value = g.near, _.fogFar.value = g.far) : g.isFogExp2 && (_.fogDensity.value = g.density);
    }
    function e(_, g, y, w, E) {
      g.isMeshBasicMaterial ? n(_, g) : g.isMeshLambertMaterial ? (n(_, g), l(_, g)) : g.isMeshToonMaterial ? (n(_, g), d(_, g)) : g.isMeshPhongMaterial ? (n(_, g), c(_, g)) : g.isMeshStandardMaterial ? (n(_, g), g.isMeshPhysicalMaterial ? h(_, g, E) : u(_, g)) : g.isMeshMatcapMaterial ? (n(_, g), p(_, g)) : g.isMeshDepthMaterial ? (n(_, g), f(_, g)) : g.isMeshDistanceMaterial ? (n(_, g), m(_, g)) : g.isMeshNormalMaterial ? (n(_, g), v(_, g)) : g.isLineBasicMaterial ? (r(_, g), g.isLineDashedMaterial && o(_, g)) : g.isPointsMaterial ? s(_, g, y, w) : g.isSpriteMaterial ? a(_, g) : g.isShadowMaterial ? (_.color.value.copy(g.color), _.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = false);
    }
    function n(_, g) {
      _.opacity.value = g.opacity, g.color && _.diffuse.value.copy(g.color), g.emissive && _.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (_.map.value = g.map), g.alphaMap && (_.alphaMap.value = g.alphaMap), g.specularMap && (_.specularMap.value = g.specularMap), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
      let y = i59.get(g).envMap;
      if (y) {
        _.envMap.value = y, _.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === false ? -1 : 1, _.reflectivity.value = g.reflectivity, _.ior.value = g.ior, _.refractionRatio.value = g.refractionRatio;
        let P = i59.get(y).__maxMipLevel;
        P !== void 0 && (_.maxMipLevel.value = P);
      }
      g.lightMap && (_.lightMap.value = g.lightMap, _.lightMapIntensity.value = g.lightMapIntensity), g.aoMap && (_.aoMap.value = g.aoMap, _.aoMapIntensity.value = g.aoMapIntensity);
      let w;
      g.map ? w = g.map : g.specularMap ? w = g.specularMap : g.displacementMap ? w = g.displacementMap : g.normalMap ? w = g.normalMap : g.bumpMap ? w = g.bumpMap : g.roughnessMap ? w = g.roughnessMap : g.metalnessMap ? w = g.metalnessMap : g.alphaMap ? w = g.alphaMap : g.emissiveMap ? w = g.emissiveMap : g.clearcoatMap ? w = g.clearcoatMap : g.clearcoatNormalMap ? w = g.clearcoatNormalMap : g.clearcoatRoughnessMap ? w = g.clearcoatRoughnessMap : g.specularIntensityMap ? w = g.specularIntensityMap : g.specularColorMap ? w = g.specularColorMap : g.transmissionMap ? w = g.transmissionMap : g.thicknessMap ? w = g.thicknessMap : g.sheenColorMap ? w = g.sheenColorMap : g.sheenRoughnessMap && (w = g.sheenRoughnessMap), w !== void 0 && (w.isWebGLRenderTarget && (w = w.texture), w.matrixAutoUpdate === true && w.updateMatrix(), _.uvTransform.value.copy(w.matrix));
      let E;
      g.aoMap ? E = g.aoMap : g.lightMap && (E = g.lightMap), E !== void 0 && (E.isWebGLRenderTarget && (E = E.texture), E.matrixAutoUpdate === true && E.updateMatrix(), _.uv2Transform.value.copy(E.matrix));
    }
    function r(_, g) {
      _.diffuse.value.copy(g.color), _.opacity.value = g.opacity;
    }
    function o(_, g) {
      _.dashSize.value = g.dashSize, _.totalSize.value = g.dashSize + g.gapSize, _.scale.value = g.scale;
    }
    function s(_, g, y, w) {
      _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.size.value = g.size * y, _.scale.value = w * 0.5, g.map && (_.map.value = g.map), g.alphaMap && (_.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
      let E;
      g.map ? E = g.map : g.alphaMap && (E = g.alphaMap), E !== void 0 && (E.matrixAutoUpdate === true && E.updateMatrix(), _.uvTransform.value.copy(E.matrix));
    }
    function a(_, g) {
      _.diffuse.value.copy(g.color), _.opacity.value = g.opacity, _.rotation.value = g.rotation, g.map && (_.map.value = g.map), g.alphaMap && (_.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (_.alphaTest.value = g.alphaTest);
      let y;
      g.map ? y = g.map : g.alphaMap && (y = g.alphaMap), y !== void 0 && (y.matrixAutoUpdate === true && y.updateMatrix(), _.uvTransform.value.copy(y.matrix));
    }
    function l(_, g) {
      g.emissiveMap && (_.emissiveMap.value = g.emissiveMap);
    }
    function c(_, g) {
      _.specular.value.copy(g.specular), _.shininess.value = Math.max(g.shininess, 1e-4), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap), g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === bi && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === bi && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias);
    }
    function d(_, g) {
      g.gradientMap && (_.gradientMap.value = g.gradientMap), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap), g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === bi && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === bi && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias);
    }
    function u(_, g) {
      _.roughness.value = g.roughness, _.metalness.value = g.metalness, g.roughnessMap && (_.roughnessMap.value = g.roughnessMap), g.metalnessMap && (_.metalnessMap.value = g.metalnessMap), g.emissiveMap && (_.emissiveMap.value = g.emissiveMap), g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === bi && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === bi && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias), i59.get(g).envMap && (_.envMapIntensity.value = g.envMapIntensity);
    }
    function h(_, g, y) {
      u(_, g), _.ior.value = g.ior, g.sheen > 0 && (_.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), _.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (_.sheenColorMap.value = g.sheenColorMap), g.sheenRoughnessMap && (_.sheenRoughnessMap.value = g.sheenRoughnessMap)), g.clearcoat > 0 && (_.clearcoat.value = g.clearcoat, _.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (_.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (_.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (_.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), _.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === bi && _.clearcoatNormalScale.value.negate())), g.transmission > 0 && (_.transmission.value = g.transmission, _.transmissionSamplerMap.value = y.texture, _.transmissionSamplerSize.value.set(y.width, y.height), g.transmissionMap && (_.transmissionMap.value = g.transmissionMap), _.thickness.value = g.thickness, g.thicknessMap && (_.thicknessMap.value = g.thicknessMap), _.attenuationDistance.value = g.attenuationDistance, _.attenuationColor.value.copy(g.attenuationColor)), _.specularIntensity.value = g.specularIntensity, _.specularColor.value.copy(g.specularColor), g.specularIntensityMap && (_.specularIntensityMap.value = g.specularIntensityMap), g.specularColorMap && (_.specularColorMap.value = g.specularColorMap);
    }
    function p(_, g) {
      g.matcap && (_.matcap.value = g.matcap), g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === bi && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === bi && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias);
    }
    function f(_, g) {
      g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias);
    }
    function m(_, g) {
      g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias), _.referencePosition.value.copy(g.referencePosition), _.nearDistance.value = g.nearDistance, _.farDistance.value = g.farDistance;
    }
    function v(_, g) {
      g.bumpMap && (_.bumpMap.value = g.bumpMap, _.bumpScale.value = g.bumpScale, g.side === bi && (_.bumpScale.value *= -1)), g.normalMap && (_.normalMap.value = g.normalMap, _.normalScale.value.copy(g.normalScale), g.side === bi && _.normalScale.value.negate()), g.displacementMap && (_.displacementMap.value = g.displacementMap, _.displacementScale.value = g.displacementScale, _.displacementBias.value = g.displacementBias);
    }
    return { refreshFogUniforms: t, refreshMaterialUniforms: e };
  }
  function lre() {
    let i59 = Ux("canvas");
    return i59.style.display = "block", i59;
  }
  function Sn(i59 = {}) {
    let t = i59.canvas !== void 0 ? i59.canvas : lre(), e = i59.context !== void 0 ? i59.context : null, n = i59.alpha !== void 0 ? i59.alpha : false, r = i59.depth !== void 0 ? i59.depth : true, o = i59.stencil !== void 0 ? i59.stencil : true, s = i59.antialias !== void 0 ? i59.antialias : false, a = i59.premultipliedAlpha !== void 0 ? i59.premultipliedAlpha : true, l = i59.preserveDrawingBuffer !== void 0 ? i59.preserveDrawingBuffer : false, c = i59.powerPreference !== void 0 ? i59.powerPreference : "default", d = i59.failIfMajorPerformanceCaveat !== void 0 ? i59.failIfMajorPerformanceCaveat : false, u = null, h = null, p = [], f = [];
    this.domElement = t, this.debug = { checkShaderErrors: true }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this.gammaFactor = 2, this.outputEncoding = or, this.physicallyCorrectLights = false, this.toneMapping = Ml, this.toneMappingExposure = 1;
    let m = this, v = false, _ = 0, g = 0, y = null, w = -1, E = null, P = new bn(), S = new bn(), A = null, W = t.width, H = t.height, O = 1, I = null, F = null, j = new bn(0, 0, W, H), $ = new bn(0, 0, W, H), k = false, z = [], R = new Cd(), V = false, ie = false, re = null, Re = new ut(), ne = new L(), oe = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function Be() {
      return y === null ? O : 1;
    }
    let me = e;
    function Ve(G, ce) {
      for (let be = 0; be < G.length; be++) {
        let ve = G[be], Pe = t.getContext(ve, ce);
        if (Pe !== null) return Pe;
      }
      return null;
    }
    try {
      let G = { alpha: n, depth: r, stencil: o, antialias: s, premultipliedAlpha: a, preserveDrawingBuffer: l, powerPreference: c, failIfMajorPerformanceCaveat: d };
      if (t.addEventListener("webglcontextlost", Zn, false), t.addEventListener("webglcontextrestored", Mn, false), me === null) {
        let ce = ["webgl2", "webgl", "experimental-webgl"];
        if (m.isWebGL1Renderer === true && ce.shift(), me = Ve(ce, G), me === null) throw Ve(ce) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      me.getShaderPrecisionFormat === void 0 && (me.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (G) {
      throw console.error("THREE.WebGLRenderer: " + G.message), G;
    }
    let ue, ee, Q, _e, te, fe, ge, Ne, Se, B, N, se, Le, ke, Xe, bt, ft, Dt, st, J, je, Te, rt;
    function ot() {
      ue = new Ane(me), ee = new Ene(me, ue, i59), ue.init(ee), Te = new hU(me, ue, ee), Q = new rre(me, ue, ee), z[0] = 1029, _e = new Lne(me), te = new qie(), fe = new ore(me, ue, Q, te, ee, Te, _e), ge = new Ine(m), Ne = new One(m), Se = new ZJ(me, ee), rt = new Sne(me, ue, Se, ee), B = new Nne(me, Se, _e, rt), N = new zne(me, B, Se, _e), st = new Vne(me, ee, fe), bt = new Tne(te), se = new $ie(m, ge, Ne, ue, ee, rt, bt), Le = new are(te), ke = new Xie(te), Xe = new tre(ue, ee), Dt = new Cne(m, ge, Q, N, a), ft = new uU(m, N, ee), J = new Mne(me, ue, _e, ee), je = new kne(me, ue, _e, ee), _e.programs = se.programs, m.capabilities = ee, m.extensions = ue, m.properties = te, m.renderLists = ke, m.shadowMap = ft, m.state = Q, m.info = _e;
    }
    ot();
    let Xt = new w1(m, me);
    this.xr = Xt, this.getContext = function() {
      return me;
    }, this.getContextAttributes = function() {
      return me.getContextAttributes();
    }, this.forceContextLoss = function() {
      let G = ue.get("WEBGL_lose_context");
      G && G.loseContext();
    }, this.forceContextRestore = function() {
      let G = ue.get("WEBGL_lose_context");
      G && G.restoreContext();
    }, this.getPixelRatio = function() {
      return O;
    }, this.setPixelRatio = function(G) {
      G !== void 0 && (O = G, this.setSize(W, H, false));
    }, this.getSize = function(G) {
      return G.set(W, H);
    }, this.setSize = function(G, ce, be) {
      if (Xt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      W = G, H = ce, t.width = Math.floor(G * O), t.height = Math.floor(ce * O), be !== false && (t.style.width = G + "px", t.style.height = ce + "px"), this.setViewport(0, 0, G, ce);
    }, this.getDrawingBufferSize = function(G) {
      return G.set(W * O, H * O).floor();
    }, this.setDrawingBufferSize = function(G, ce, be) {
      W = G, H = ce, O = be, t.width = Math.floor(G * be), t.height = Math.floor(ce * be), this.setViewport(0, 0, G, ce);
    }, this.getCurrentViewport = function(G) {
      return G.copy(P);
    }, this.getViewport = function(G) {
      return G.copy(j);
    }, this.setViewport = function(G, ce, be, ve) {
      G.isVector4 ? j.set(G.x, G.y, G.z, G.w) : j.set(G, ce, be, ve), Q.viewport(P.copy(j).multiplyScalar(O).floor());
    }, this.getScissor = function(G) {
      return G.copy($);
    }, this.setScissor = function(G, ce, be, ve) {
      G.isVector4 ? $.set(G.x, G.y, G.z, G.w) : $.set(G, ce, be, ve), Q.scissor(S.copy($).multiplyScalar(O).floor());
    }, this.getScissorTest = function() {
      return k;
    }, this.setScissorTest = function(G) {
      Q.setScissorTest(k = G);
    }, this.setOpaqueSort = function(G) {
      I = G;
    }, this.setTransparentSort = function(G) {
      F = G;
    }, this.getClearColor = function(G) {
      return G.copy(Dt.getClearColor());
    }, this.setClearColor = function() {
      Dt.setClearColor.apply(Dt, arguments);
    }, this.getClearAlpha = function() {
      return Dt.getClearAlpha();
    }, this.setClearAlpha = function() {
      Dt.setClearAlpha.apply(Dt, arguments);
    }, this.clear = function(G, ce, be) {
      let ve = 0;
      (G === void 0 || G) && (ve |= 16384), (ce === void 0 || ce) && (ve |= 256), (be === void 0 || be) && (ve |= 1024), me.clear(ve);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Zn, false), t.removeEventListener("webglcontextrestored", Mn, false), ke.dispose(), Xe.dispose(), te.dispose(), ge.dispose(), Ne.dispose(), N.dispose(), rt.dispose(), Xt.dispose(), Xt.removeEventListener("sessionstart", dP), Xt.removeEventListener("sessionend", uP), re && (re.dispose(), re = null), jl.stop();
    };
    function Zn(G) {
      G.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), v = true;
    }
    function Mn() {
      console.log("THREE.WebGLRenderer: Context Restored."), v = false;
      let G = _e.autoReset, ce = ft.enabled, be = ft.autoUpdate, ve = ft.needsUpdate, Pe = ft.type;
      ot(), _e.autoReset = G, ft.enabled = ce, ft.autoUpdate = be, ft.needsUpdate = ve, ft.type = Pe;
    }
    function Ti(G) {
      let ce = G.target;
      ce.removeEventListener("dispose", Ti), ui(ce);
    }
    function ui(G) {
      Qs(G), te.remove(G);
    }
    function Qs(G) {
      let ce = te.get(G).programs;
      ce !== void 0 && ce.forEach(function(be) {
        se.releaseProgram(be);
      });
    }
    this.renderBufferDirect = function(G, ce, be, ve, Pe, Nt) {
      ce === null && (ce = oe);
      let Pt = Pe.isMesh && Pe.matrixWorld.determinant() < 0, Mt = S4(G, ce, be, ve, Pe);
      Q.setMaterial(ve, Pt);
      let nn = be.index, wn = be.attributes.position;
      if (nn === null) {
        if (wn === void 0 || wn.count === 0) return;
      } else if (nn.count === 0) return;
      let cn = 1;
      ve.wireframe === true && (nn = B.getWireframeAttribute(be), cn = 2), rt.setup(Pe, ve, Mt, be, nn);
      let gn, Qn = J;
      nn !== null && (gn = Se.get(nn), Qn = je, Qn.setIndex(gn));
      let Wl = nn !== null ? nn.count : wn.count, vn = be.drawRange.start * cn, bp = be.drawRange.count * cn, Vn = Nt !== null ? Nt.start * cn : 0, $l = Nt !== null ? Nt.count * cn : 1 / 0, ql = Math.max(vn, Vn), Yl = Math.min(Wl, vn + bp, Vn + $l) - 1, Wa = Math.max(0, Yl - ql + 1);
      if (Wa !== 0) {
        if (Pe.isMesh) ve.wireframe === true ? (Q.setLineWidth(ve.wireframeLinewidth * Be()), Qn.setMode(1)) : Qn.setMode(4);
        else if (Pe.isLine) {
          let Kn = ve.linewidth;
          Kn === void 0 && (Kn = 1), Q.setLineWidth(Kn * Be()), Pe.isLineSegments ? Qn.setMode(1) : Pe.isLineLoop ? Qn.setMode(2) : Qn.setMode(3);
        } else Pe.isPoints ? Qn.setMode(0) : Pe.isSprite && Qn.setMode(4);
        if (Pe.isInstancedMesh) Qn.renderInstances(ql, Wa, Pe.count);
        else if (be.isInstancedBufferGeometry) {
          let Kn = Math.min(be.instanceCount, be._maxInstanceCount);
          Qn.renderInstances(ql, Wa, Kn);
        } else Qn.render(ql, Wa);
      }
    }, this.compile = function(G, ce) {
      h = Xe.get(G), h.init(), f.push(h), G.traverseVisible(function(be) {
        be.isLight && be.layers.test(ce.layers) && (h.pushLight(be), be.castShadow && h.pushShadow(be));
      }), h.setupLights(m.physicallyCorrectLights), G.traverse(function(be) {
        let ve = be.material;
        if (ve) if (Array.isArray(ve)) for (let Pe = 0; Pe < ve.length; Pe++) {
          let Nt = ve[Pe];
          Gw(Nt, G, be);
        }
        else Gw(ve, G, be);
      }), f.pop(), h = null;
    };
    let Go = null;
    function x4(G) {
      Go && Go(G);
    }
    function dP() {
      jl.stop();
    }
    function uP() {
      jl.start();
    }
    let jl = new tU();
    jl.setAnimationLoop(x4), typeof window < "u" && jl.setContext(window), this.setAnimationLoop = function(G) {
      Go = G, Xt.setAnimationLoop(G), G === null ? jl.stop() : jl.start();
    }, Xt.addEventListener("sessionstart", dP), Xt.addEventListener("sessionend", uP), this.render = function(G, ce) {
      if (ce !== void 0 && ce.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (v === true) return;
      G.autoUpdate === true && G.updateMatrixWorld(), ce.parent === null && ce.updateMatrixWorld(), Xt.enabled === true && Xt.isPresenting === true && (Xt.cameraAutoUpdate === true && Xt.updateCamera(ce), ce = Xt.getCamera()), G.isScene === true && G.onBeforeRender(m, G, ce, y), h = Xe.get(G, f.length), h.init(), f.push(h), Re.multiplyMatrices(ce.projectionMatrix, ce.matrixWorldInverse), R.setFromProjectionMatrix(Re), ie = this.localClippingEnabled, V = bt.init(this.clippingPlanes, ie, ce), u = ke.get(G, p.length), u.init(), p.push(u), hP(G, ce, 0, m.sortObjects), u.finish(), m.sortObjects === true && u.sort(I, F), V === true && bt.beginShadows();
      let be = h.state.shadowsArray;
      if (ft.render(be, G, ce), V === true && bt.endShadows(), this.info.autoReset === true && this.info.reset(), Dt.render(u, G), h.setupLights(m.physicallyCorrectLights), ce.isArrayCamera) {
        let ve = ce.cameras;
        for (let Pe = 0, Nt = ve.length; Pe < Nt; Pe++) {
          let Pt = ve[Pe];
          pP(u, G, Pt, Pt.viewport);
        }
      } else pP(u, G, ce);
      y !== null && (fe.updateMultisampleRenderTarget(y), fe.updateRenderTargetMipmap(y)), G.isScene === true && G.onAfterRender(m, G, ce), Q.buffers.depth.setTest(true), Q.buffers.depth.setMask(true), Q.buffers.color.setMask(true), Q.setPolygonOffset(false), rt.resetDefaultState(), w = -1, E = null, f.pop(), f.length > 0 ? h = f[f.length - 1] : h = null, p.pop(), p.length > 0 ? u = p[p.length - 1] : u = null;
    };
    function hP(G, ce, be, ve) {
      if (G.visible === false) return;
      if (G.layers.test(ce.layers)) {
        if (G.isGroup) be = G.renderOrder;
        else if (G.isLOD) G.autoUpdate === true && G.update(ce);
        else if (G.isLight) h.pushLight(G), G.castShadow && h.pushShadow(G);
        else if (G.isSprite) {
          if (!G.frustumCulled || R.intersectsSprite(G)) {
            ve && ne.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Re);
            let Pt = N.update(G), Mt = G.material;
            Mt.visible && u.push(G, Pt, Mt, be, ne.z, null);
          }
        } else if ((G.isMesh || G.isLine || G.isPoints) && (G.isSkinnedMesh && G.skeleton.frame !== _e.render.frame && (G.skeleton.update(), G.skeleton.frame = _e.render.frame), !G.frustumCulled || R.intersectsObject(G))) {
          ve && ne.setFromMatrixPosition(G.matrixWorld).applyMatrix4(Re);
          let Pt = N.update(G), Mt = G.material;
          if (Array.isArray(Mt)) {
            let nn = Pt.groups;
            for (let wn = 0, cn = nn.length; wn < cn; wn++) {
              let gn = nn[wn], Qn = Mt[gn.materialIndex];
              Qn && Qn.visible && u.push(G, Pt, Qn, be, ne.z, gn);
            }
          } else Mt.visible && u.push(G, Pt, Mt, be, ne.z, null);
        }
      }
      let Nt = G.children;
      for (let Pt = 0, Mt = Nt.length; Pt < Mt; Pt++) hP(Nt[Pt], ce, be, ve);
    }
    function pP(G, ce, be, ve) {
      let Pe = G.opaque, Nt = G.transmissive, Pt = G.transparent;
      h.setupLightsView(be), Nt.length > 0 && w4(Pe, ce, be), ve && Q.viewport(P.copy(ve)), Pe.length > 0 && Qg(Pe, ce, be), Nt.length > 0 && Qg(Nt, ce, be), Pt.length > 0 && Qg(Pt, ce, be);
    }
    function w4(G, ce, be) {
      if (re === null) {
        let Pt = s === true && ee.isWebGL2 === true ? Um : po;
        re = new Pt(1024, 1024, { generateMipmaps: true, type: Te.convert(md) !== null ? md : Oa, minFilter: Bd, magFilter: Si, wrapS: nr, wrapT: nr });
      }
      let ve = m.getRenderTarget();
      m.setRenderTarget(re), m.clear();
      let Pe = m.toneMapping;
      m.toneMapping = Ml, Qg(G, ce, be), m.toneMapping = Pe, fe.updateMultisampleRenderTarget(re), fe.updateRenderTargetMipmap(re), m.setRenderTarget(ve);
    }
    function Qg(G, ce, be) {
      let ve = ce.isScene === true ? ce.overrideMaterial : null;
      for (let Pe = 0, Nt = G.length; Pe < Nt; Pe++) {
        let Pt = G[Pe], Mt = Pt.object, nn = Pt.geometry, wn = ve === null ? Pt.material : ve, cn = Pt.group;
        Mt.layers.test(be.layers) && C4(Mt, ce, be, nn, wn, cn);
      }
    }
    function C4(G, ce, be, ve, Pe, Nt) {
      G.onBeforeRender(m, ce, be, ve, Pe, Nt), G.modelViewMatrix.multiplyMatrices(be.matrixWorldInverse, G.matrixWorld), G.normalMatrix.getNormalMatrix(G.modelViewMatrix), Pe.onBeforeRender(m, ce, be, ve, G, Nt), Pe.transparent === true && Pe.side === bd ? (Pe.side = bi, Pe.needsUpdate = true, m.renderBufferDirect(be, ce, ve, Pe, G, Nt), Pe.side = yd, Pe.needsUpdate = true, m.renderBufferDirect(be, ce, ve, Pe, G, Nt), Pe.side = bd) : m.renderBufferDirect(be, ce, ve, Pe, G, Nt), G.onAfterRender(m, ce, be, ve, Pe, Nt);
    }
    function Gw(G, ce, be) {
      ce.isScene !== true && (ce = oe);
      let ve = te.get(G), Pe = h.state.lights, Nt = h.state.shadowsArray, Pt = Pe.state.version, Mt = se.getParameters(G, Pe.state, Nt, ce, be), nn = se.getProgramCacheKey(Mt), wn = ve.programs;
      ve.environment = G.isMeshStandardMaterial ? ce.environment : null, ve.fog = ce.fog, ve.envMap = (G.isMeshStandardMaterial ? Ne : ge).get(G.envMap || ve.environment), wn === void 0 && (G.addEventListener("dispose", Ti), wn = /* @__PURE__ */ new Map(), ve.programs = wn);
      let cn = wn.get(nn);
      if (cn !== void 0) {
        if (ve.currentProgram === cn && ve.lightsStateVersion === Pt) return fP(G, Mt), cn;
      } else Mt.uniforms = se.getUniforms(G), G.onBuild(be, Mt, m), G.onBeforeCompile(Mt, m), cn = se.acquireProgram(Mt, nn), wn.set(nn, cn), ve.uniforms = Mt.uniforms;
      let gn = ve.uniforms;
      (!G.isShaderMaterial && !G.isRawShaderMaterial || G.clipping === true) && (gn.clippingPlanes = bt.uniform), fP(G, Mt), ve.needsLights = E4(G), ve.lightsStateVersion = Pt, ve.needsLights && (gn.ambientLightColor.value = Pe.state.ambient, gn.lightProbe.value = Pe.state.probe, gn.directionalLights.value = Pe.state.directional, gn.directionalLightShadows.value = Pe.state.directionalShadow, gn.spotLights.value = Pe.state.spot, gn.spotLightShadows.value = Pe.state.spotShadow, gn.rectAreaLights.value = Pe.state.rectArea, gn.ltc_1.value = Pe.state.rectAreaLTC1, gn.ltc_2.value = Pe.state.rectAreaLTC2, gn.pointLights.value = Pe.state.point, gn.pointLightShadows.value = Pe.state.pointShadow, gn.hemisphereLights.value = Pe.state.hemi, gn.directionalShadowMap.value = Pe.state.directionalShadowMap, gn.directionalShadowMatrix.value = Pe.state.directionalShadowMatrix, gn.spotShadowMap.value = Pe.state.spotShadowMap, gn.spotShadowMatrix.value = Pe.state.spotShadowMatrix, gn.pointShadowMap.value = Pe.state.pointShadowMap, gn.pointShadowMatrix.value = Pe.state.pointShadowMatrix);
      let Qn = cn.getUniforms(), Wl = Tl.seqWithValue(Qn.seq, gn);
      return ve.currentProgram = cn, ve.uniformsList = Wl, cn;
    }
    function fP(G, ce) {
      let be = te.get(G);
      be.outputEncoding = ce.outputEncoding, be.instancing = ce.instancing, be.skinning = ce.skinning, be.morphTargets = ce.morphTargets, be.morphNormals = ce.morphNormals, be.morphTargetsCount = ce.morphTargetsCount, be.numClippingPlanes = ce.numClippingPlanes, be.numIntersection = ce.numClipIntersection, be.vertexAlphas = ce.vertexAlphas, be.vertexTangents = ce.vertexTangents;
    }
    function S4(G, ce, be, ve, Pe) {
      ce.isScene !== true && (ce = oe), fe.resetTextureUnits();
      let Nt = ce.fog, Pt = ve.isMeshStandardMaterial ? ce.environment : null, Mt = y === null ? m.outputEncoding : y.texture.encoding, nn = (ve.isMeshStandardMaterial ? Ne : ge).get(ve.envMap || Pt), wn = ve.vertexColors === true && !!be.attributes.color && be.attributes.color.itemSize === 4, cn = !!ve.normalMap && !!be.attributes.tangent, gn = !!be.morphAttributes.position, Qn = !!be.morphAttributes.normal, Wl = be.morphAttributes.position ? be.morphAttributes.position.length : 0, vn = te.get(ve), bp = h.state.lights;
      if (V === true && (ie === true || G !== E)) {
        let Ho = G === E && ve.id === w;
        bt.setState(ve, G, Ho);
      }
      let Vn = false;
      ve.version === vn.__version ? (vn.needsLights && vn.lightsStateVersion !== bp.state.version || vn.outputEncoding !== Mt || Pe.isInstancedMesh && vn.instancing === false || !Pe.isInstancedMesh && vn.instancing === true || Pe.isSkinnedMesh && vn.skinning === false || !Pe.isSkinnedMesh && vn.skinning === true || vn.envMap !== nn || ve.fog && vn.fog !== Nt || vn.numClippingPlanes !== void 0 && (vn.numClippingPlanes !== bt.numPlanes || vn.numIntersection !== bt.numIntersection) || vn.vertexAlphas !== wn || vn.vertexTangents !== cn || vn.morphTargets !== gn || vn.morphNormals !== Qn || ee.isWebGL2 === true && vn.morphTargetsCount !== Wl) && (Vn = true) : (Vn = true, vn.__version = ve.version);
      let $l = vn.currentProgram;
      Vn === true && ($l = Gw(ve, ce, Pe));
      let ql = false, Yl = false, Wa = false, Kn = $l.getUniforms(), xp = vn.uniforms;
      if (Q.useProgram($l.program) && (ql = true, Yl = true, Wa = true), ve.id !== w && (w = ve.id, Yl = true), ql || E !== G) {
        if (Kn.setValue(me, "projectionMatrix", G.projectionMatrix), ee.logarithmicDepthBuffer && Kn.setValue(me, "logDepthBufFC", 2 / (Math.log(G.far + 1) / Math.LN2)), E !== G && (E = G, Yl = true, Wa = true), ve.isShaderMaterial || ve.isMeshPhongMaterial || ve.isMeshToonMaterial || ve.isMeshStandardMaterial || ve.envMap) {
          let Ho = Kn.map.cameraPosition;
          Ho !== void 0 && Ho.setValue(me, ne.setFromMatrixPosition(G.matrixWorld));
        }
        (ve.isMeshPhongMaterial || ve.isMeshToonMaterial || ve.isMeshLambertMaterial || ve.isMeshBasicMaterial || ve.isMeshStandardMaterial || ve.isShaderMaterial) && Kn.setValue(me, "isOrthographic", G.isOrthographicCamera === true), (ve.isMeshPhongMaterial || ve.isMeshToonMaterial || ve.isMeshLambertMaterial || ve.isMeshBasicMaterial || ve.isMeshStandardMaterial || ve.isShaderMaterial || ve.isShadowMaterial || Pe.isSkinnedMesh) && Kn.setValue(me, "viewMatrix", G.matrixWorldInverse);
      }
      if (Pe.isSkinnedMesh) {
        Kn.setOptional(me, Pe, "bindMatrix"), Kn.setOptional(me, Pe, "bindMatrixInverse");
        let Ho = Pe.skeleton;
        Ho && (ee.floatVertexTextures ? (Ho.boneTexture === null && Ho.computeBoneTexture(), Kn.setValue(me, "boneTexture", Ho.boneTexture, fe), Kn.setValue(me, "boneTextureSize", Ho.boneTextureSize)) : Kn.setOptional(me, Ho, "boneMatrices"));
      }
      return be && (be.morphAttributes.position !== void 0 || be.morphAttributes.normal !== void 0) && st.update(Pe, be, ve, $l), (Yl || vn.receiveShadow !== Pe.receiveShadow) && (vn.receiveShadow = Pe.receiveShadow, Kn.setValue(me, "receiveShadow", Pe.receiveShadow)), Yl && (Kn.setValue(me, "toneMappingExposure", m.toneMappingExposure), vn.needsLights && M4(xp, Wa), Nt && ve.fog && Le.refreshFogUniforms(xp, Nt), Le.refreshMaterialUniforms(xp, ve, O, H, re), Tl.upload(me, vn.uniformsList, xp, fe)), ve.isShaderMaterial && ve.uniformsNeedUpdate === true && (Tl.upload(me, vn.uniformsList, xp, fe), ve.uniformsNeedUpdate = false), ve.isSpriteMaterial && Kn.setValue(me, "center", Pe.center), Kn.setValue(me, "modelViewMatrix", Pe.modelViewMatrix), Kn.setValue(me, "normalMatrix", Pe.normalMatrix), Kn.setValue(me, "modelMatrix", Pe.matrixWorld), $l;
    }
    function M4(G, ce) {
      G.ambientLightColor.needsUpdate = ce, G.lightProbe.needsUpdate = ce, G.directionalLights.needsUpdate = ce, G.directionalLightShadows.needsUpdate = ce, G.pointLights.needsUpdate = ce, G.pointLightShadows.needsUpdate = ce, G.spotLights.needsUpdate = ce, G.spotLightShadows.needsUpdate = ce, G.rectAreaLights.needsUpdate = ce, G.hemisphereLights.needsUpdate = ce;
    }
    function E4(G) {
      return G.isMeshLambertMaterial || G.isMeshToonMaterial || G.isMeshPhongMaterial || G.isMeshStandardMaterial || G.isShadowMaterial || G.isShaderMaterial && G.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _;
    }, this.getActiveMipmapLevel = function() {
      return g;
    }, this.getRenderTarget = function() {
      return y;
    }, this.setRenderTarget = function(G, ce = 0, be = 0) {
      y = G, _ = ce, g = be, G && te.get(G).__webglFramebuffer === void 0 && fe.setupRenderTarget(G);
      let ve = null, Pe = false, Nt = false;
      if (G) {
        let Mt = G.texture;
        (Mt.isDataTexture3D || Mt.isDataTexture2DArray) && (Nt = true);
        let nn = te.get(G).__webglFramebuffer;
        G.isWebGLCubeRenderTarget ? (ve = nn[ce], Pe = true) : G.isWebGLMultisampleRenderTarget ? ve = te.get(G).__webglMultisampledFramebuffer : ve = nn, P.copy(G.viewport), S.copy(G.scissor), A = G.scissorTest;
      } else P.copy(j).multiplyScalar(O).floor(), S.copy($).multiplyScalar(O).floor(), A = k;
      if (Q.bindFramebuffer(36160, ve) && ee.drawBuffers) {
        let Mt = false;
        if (G) if (G.isWebGLMultipleRenderTargets) {
          let nn = G.texture;
          if (z.length !== nn.length || z[0] !== 36064) {
            for (let wn = 0, cn = nn.length; wn < cn; wn++) z[wn] = 36064 + wn;
            z.length = nn.length, Mt = true;
          }
        } else (z.length !== 1 || z[0] !== 36064) && (z[0] = 36064, z.length = 1, Mt = true);
        else (z.length !== 1 || z[0] !== 1029) && (z[0] = 1029, z.length = 1, Mt = true);
        Mt && (ee.isWebGL2 ? me.drawBuffers(z) : ue.get("WEBGL_draw_buffers").drawBuffersWEBGL(z));
      }
      if (Q.viewport(P), Q.scissor(S), Q.setScissorTest(A), Pe) {
        let Mt = te.get(G.texture);
        me.framebufferTexture2D(36160, 36064, 34069 + ce, Mt.__webglTexture, be);
      } else if (Nt) {
        let Mt = te.get(G.texture), nn = ce || 0;
        me.framebufferTextureLayer(36160, 36064, Mt.__webglTexture, be || 0, nn);
      }
      w = -1;
    }, this.readRenderTargetPixels = function(G, ce, be, ve, Pe, Nt, Pt) {
      if (!(G && G.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let Mt = te.get(G).__webglFramebuffer;
      if (G.isWebGLCubeRenderTarget && Pt !== void 0 && (Mt = Mt[Pt]), Mt) {
        Q.bindFramebuffer(36160, Mt);
        try {
          let nn = G.texture, wn = nn.format, cn = nn.type;
          if (wn !== ir && Te.convert(wn) !== me.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          let gn = cn === md && (ue.has("EXT_color_buffer_half_float") || ee.isWebGL2 && ue.has("EXT_color_buffer_float"));
          if (cn !== Oa && Te.convert(cn) !== me.getParameter(35738) && !(cn === Fs && (ee.isWebGL2 || ue.has("OES_texture_float") || ue.has("WEBGL_color_buffer_float"))) && !gn) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          me.checkFramebufferStatus(36160) === 36053 ? ce >= 0 && ce <= G.width - ve && be >= 0 && be <= G.height - Pe && me.readPixels(ce, be, ve, Pe, Te.convert(wn), Te.convert(cn), Nt) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
        } finally {
          let nn = y !== null ? te.get(y).__webglFramebuffer : null;
          Q.bindFramebuffer(36160, nn);
        }
      }
    }, this.copyFramebufferToTexture = function(G, ce, be = 0) {
      let ve = Math.pow(2, -be), Pe = Math.floor(ce.image.width * ve), Nt = Math.floor(ce.image.height * ve), Pt = Te.convert(ce.format);
      ee.isWebGL2 && (Pt === 6407 && (Pt = 32849), Pt === 6408 && (Pt = 32856)), fe.setTexture2D(ce, 0), me.copyTexImage2D(3553, be, Pt, G.x, G.y, Pe, Nt, 0), Q.unbindTexture();
    }, this.copyTextureToTexture = function(G, ce, be, ve = 0) {
      let Pe = ce.image.width, Nt = ce.image.height, Pt = Te.convert(be.format), Mt = Te.convert(be.type);
      fe.setTexture2D(be, 0), me.pixelStorei(37440, be.flipY), me.pixelStorei(37441, be.premultiplyAlpha), me.pixelStorei(3317, be.unpackAlignment), ce.isDataTexture ? me.texSubImage2D(3553, ve, G.x, G.y, Pe, Nt, Pt, Mt, ce.image.data) : ce.isCompressedTexture ? me.compressedTexSubImage2D(3553, ve, G.x, G.y, ce.mipmaps[0].width, ce.mipmaps[0].height, Pt, ce.mipmaps[0].data) : me.texSubImage2D(3553, ve, G.x, G.y, Pt, Mt, ce.image), ve === 0 && be.generateMipmaps && me.generateMipmap(3553), Q.unbindTexture();
    }, this.copyTextureToTexture3D = function(G, ce, be, ve, Pe = 0) {
      if (m.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      let Nt = G.max.x - G.min.x + 1, Pt = G.max.y - G.min.y + 1, Mt = G.max.z - G.min.z + 1, nn = Te.convert(ve.format), wn = Te.convert(ve.type), cn;
      if (ve.isDataTexture3D) fe.setTexture3D(ve, 0), cn = 32879;
      else if (ve.isDataTexture2DArray) fe.setTexture2DArray(ve, 0), cn = 35866;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      me.pixelStorei(37440, ve.flipY), me.pixelStorei(37441, ve.premultiplyAlpha), me.pixelStorei(3317, ve.unpackAlignment);
      let gn = me.getParameter(3314), Qn = me.getParameter(32878), Wl = me.getParameter(3316), vn = me.getParameter(3315), bp = me.getParameter(32877), Vn = be.isCompressedTexture ? be.mipmaps[0] : be.image;
      me.pixelStorei(3314, Vn.width), me.pixelStorei(32878, Vn.height), me.pixelStorei(3316, G.min.x), me.pixelStorei(3315, G.min.y), me.pixelStorei(32877, G.min.z), be.isDataTexture || be.isDataTexture3D ? me.texSubImage3D(cn, Pe, ce.x, ce.y, ce.z, Nt, Pt, Mt, nn, wn, Vn.data) : be.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), me.compressedTexSubImage3D(cn, Pe, ce.x, ce.y, ce.z, Nt, Pt, Mt, nn, Vn.data)) : me.texSubImage3D(cn, Pe, ce.x, ce.y, ce.z, Nt, Pt, Mt, nn, wn, Vn), me.pixelStorei(3314, gn), me.pixelStorei(32878, Qn), me.pixelStorei(3316, Wl), me.pixelStorei(3315, vn), me.pixelStorei(32877, bp), Pe === 0 && ve.generateMipmaps && me.generateMipmap(cn), Q.unbindTexture();
    }, this.initTexture = function(G) {
      fe.setTexture2D(G, 0), Q.unbindTexture();
    }, this.resetState = function() {
      _ = 0, g = 0, y = null, Q.reset(), rt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  Sn.prototype.isWebGLRenderer = true;
  var tx = class extends Sn {
  };
  tx.prototype.isWebGL1Renderer = true;
  var Wm = class i37 {
    constructor(t, e = 25e-5) {
      this.name = "", this.color = new Ye(t), this.density = e;
    }
    clone() {
      return new i37(this.color, this.density);
    }
    toJSON() {
      return { type: "FogExp2", color: this.color.getHex(), density: this.density };
    }
  };
  Wm.prototype.isFogExp2 = true;
  var $m = class i38 {
    constructor(t, e = 1, n = 1e3) {
      this.name = "", this.color = new Ye(t), this.near = e, this.far = n;
    }
    clone() {
      return new i38(this.color, this.near, this.far);
    }
    toJSON() {
      return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far };
    }
  };
  $m.prototype.isFog = true;
  var $h = class extends ln {
    constructor() {
      super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = true, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
    copy(t, e) {
      return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return this.fog !== null && (e.object.fog = this.fog.toJSON()), e;
    }
  };
  $h.prototype.isScene = true;
  var Na = class {
    constructor(t, e) {
      this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = kh, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = ho();
    }
    onUploadCallback() {
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    setUsage(t) {
      return this.usage = t, this;
    }
    copy(t) {
      return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this;
    }
    copyAt(t, e, n) {
      t *= this.stride, n *= e.stride;
      for (let r = 0, o = this.stride; r < o; r++) this.array[t + r] = e.array[n + r];
      return this;
    }
    set(t, e = 0) {
      return this.array.set(t, e), this;
    }
    clone(t) {
      t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ho()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      let e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride);
      return n.setUsage(this.usage), n;
    }
    onUpload(t) {
      return this.onUploadCallback = t, this;
    }
    toJSON(t) {
      return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ho()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
    }
  };
  Na.prototype.isInterleavedBuffer = true;
  var vi = new L();
  var Ol = class i39 {
    constructor(t, e, n, r = false) {
      this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r === true;
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(t) {
      this.data.needsUpdate = t;
    }
    applyMatrix4(t) {
      for (let e = 0, n = this.data.count; e < n; e++) vi.x = this.getX(e), vi.y = this.getY(e), vi.z = this.getZ(e), vi.applyMatrix4(t), this.setXYZ(e, vi.x, vi.y, vi.z);
      return this;
    }
    applyNormalMatrix(t) {
      for (let e = 0, n = this.count; e < n; e++) vi.x = this.getX(e), vi.y = this.getY(e), vi.z = this.getZ(e), vi.applyNormalMatrix(t), this.setXYZ(e, vi.x, vi.y, vi.z);
      return this;
    }
    transformDirection(t) {
      for (let e = 0, n = this.count; e < n; e++) vi.x = this.getX(e), vi.y = this.getY(e), vi.z = this.getZ(e), vi.transformDirection(t), this.setXYZ(e, vi.x, vi.y, vi.z);
      return this;
    }
    setX(t, e) {
      return this.data.array[t * this.data.stride + this.offset] = e, this;
    }
    setY(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 1] = e, this;
    }
    setZ(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 2] = e, this;
    }
    setW(t, e) {
      return this.data.array[t * this.data.stride + this.offset + 3] = e, this;
    }
    getX(t) {
      return this.data.array[t * this.data.stride + this.offset];
    }
    getY(t) {
      return this.data.array[t * this.data.stride + this.offset + 1];
    }
    getZ(t) {
      return this.data.array[t * this.data.stride + this.offset + 2];
    }
    getW(t) {
      return this.data.array[t * this.data.stride + this.offset + 3];
    }
    setXY(t, e, n) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this;
    }
    setXYZ(t, e, n, r) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this;
    }
    setXYZW(t, e, n, r, o) {
      return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = o, this;
    }
    clone(t) {
      if (t === void 0) {
        console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
        let e = [];
        for (let n = 0; n < this.count; n++) {
          let r = n * this.data.stride + this.offset;
          for (let o = 0; o < this.itemSize; o++) e.push(this.data.array[r + o]);
        }
        return new an(new this.array.constructor(e), this.itemSize, this.normalized);
      } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new i39(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
    toJSON(t) {
      if (t === void 0) {
        console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
        let e = [];
        for (let n = 0; n < this.count; n++) {
          let r = n * this.data.stride + this.offset;
          for (let o = 0; o < this.itemSize; o++) e.push(this.data.array[r + o]);
        }
        return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized };
      } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
    }
  };
  Ol.prototype.isInterleavedBufferAttribute = true;
  var qh = class extends Mi {
    constructor(t) {
      super(), this.type = "SpriteMaterial", this.color = new Ye(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this;
    }
  };
  qh.prototype.isSpriteMaterial = true;
  var Sh;
  var xm = new L();
  var Mh = new L();
  var Eh = new L();
  var Th = new Me();
  var wm = new Me();
  var pU = new ut();
  var b0 = new L();
  var Cm = new L();
  var x0 = new L();
  var OB = new Me();
  var YI = new Me();
  var AB = new Me();
  var Yh = class extends ln {
    constructor(t) {
      if (super(), this.type = "Sprite", Sh === void 0) {
        Sh = new Ct();
        let e = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), n = new Na(e, 5);
        Sh.setIndex([0, 1, 2, 0, 2, 3]), Sh.setAttribute("position", new Ol(n, 3, 0, false)), Sh.setAttribute("uv", new Ol(n, 2, 3, false));
      }
      this.geometry = Sh, this.material = t !== void 0 ? t : new qh(), this.center = new Me(0.5, 0.5);
    }
    raycast(t, e) {
      t.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Mh.setFromMatrixScale(this.matrixWorld), pU.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Eh.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && Mh.multiplyScalar(-Eh.z);
      let n = this.material.rotation, r, o;
      n !== 0 && (o = Math.cos(n), r = Math.sin(n));
      let s = this.center;
      w0(b0.set(-0.5, -0.5, 0), Eh, s, Mh, r, o), w0(Cm.set(0.5, -0.5, 0), Eh, s, Mh, r, o), w0(x0.set(0.5, 0.5, 0), Eh, s, Mh, r, o), OB.set(0, 0), YI.set(1, 0), AB.set(1, 1);
      let a = t.ray.intersectTriangle(b0, Cm, x0, false, xm);
      if (a === null && (w0(Cm.set(-0.5, 0.5, 0), Eh, s, Mh, r, o), YI.set(0, 1), a = t.ray.intersectTriangle(b0, x0, Cm, false, xm), a === null)) return;
      let l = t.ray.origin.distanceTo(xm);
      l < t.near || l > t.far || e.push({ distance: l, point: xm.clone(), uv: rr.getUV(xm, b0, Cm, x0, OB, YI, AB, new Me()), face: null, object: this });
    }
    copy(t) {
      return super.copy(t), t.center !== void 0 && this.center.copy(t.center), this.material = t.material, this;
    }
  };
  Yh.prototype.isSprite = true;
  function w0(i59, t, e, n, r, o) {
    Th.subVectors(i59, e).addScalar(0.5).multiply(n), r !== void 0 ? (wm.x = o * Th.x - r * Th.y, wm.y = r * Th.x + o * Th.y) : wm.copy(Th), i59.copy(t), i59.x += wm.x, i59.y += wm.y, i59.applyMatrix4(pU);
  }
  var C0 = new L();
  var NB = new L();
  var nx = class extends ln {
    constructor() {
      super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
    }
    copy(t) {
      super.copy(t, false);
      let e = t.levels;
      for (let n = 0, r = e.length; n < r; n++) {
        let o = e[n];
        this.addLevel(o.object.clone(), o.distance);
      }
      return this.autoUpdate = t.autoUpdate, this;
    }
    addLevel(t, e = 0) {
      e = Math.abs(e);
      let n = this.levels, r;
      for (r = 0; r < n.length && !(e < n[r].distance); r++) ;
      return n.splice(r, 0, { distance: e, object: t }), this.add(t), this;
    }
    getCurrentLevel() {
      return this._currentLevel;
    }
    getObjectForDistance(t) {
      let e = this.levels;
      if (e.length > 0) {
        let n, r;
        for (n = 1, r = e.length; n < r && !(t < e[n].distance); n++) ;
        return e[n - 1].object;
      }
      return null;
    }
    raycast(t, e) {
      if (this.levels.length > 0) {
        C0.setFromMatrixPosition(this.matrixWorld);
        let r = t.ray.origin.distanceTo(C0);
        this.getObjectForDistance(r).raycast(t, e);
      }
    }
    update(t) {
      let e = this.levels;
      if (e.length > 1) {
        C0.setFromMatrixPosition(t.matrixWorld), NB.setFromMatrixPosition(this.matrixWorld);
        let n = C0.distanceTo(NB) / t.zoom;
        e[0].object.visible = true;
        let r, o;
        for (r = 1, o = e.length; r < o && n >= e[r].distance; r++) e[r - 1].object.visible = false, e[r].object.visible = true;
        for (this._currentLevel = r - 1; r < o; r++) e[r].object.visible = false;
      }
    }
    toJSON(t) {
      let e = super.toJSON(t);
      this.autoUpdate === false && (e.object.autoUpdate = false), e.object.levels = [];
      let n = this.levels;
      for (let r = 0, o = n.length; r < o; r++) {
        let s = n[r];
        e.object.levels.push({ object: s.object.uuid, distance: s.distance });
      }
      return e;
    }
  };
  var kB = new L();
  var LB = new bn();
  var FB = new bn();
  var cre = new L();
  var BB = new ut();
  var Xh = class extends li {
    constructor(t, e) {
      super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new ut(), this.bindMatrixInverse = new ut();
    }
    copy(t) {
      return super.copy(t), this.bindMode = t.bindMode, this.bindMatrix.copy(t.bindMatrix), this.bindMatrixInverse.copy(t.bindMatrixInverse), this.skeleton = t.skeleton, this;
    }
    bind(t, e) {
      this.skeleton = t, e === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      let t = new bn(), e = this.geometry.attributes.skinWeight;
      for (let n = 0, r = e.count; n < r; n++) {
        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
        let o = 1 / t.manhattanLength();
        o !== 1 / 0 ? t.multiplyScalar(o) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w);
      }
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
    boneTransform(t, e) {
      let n = this.skeleton, r = this.geometry;
      LB.fromBufferAttribute(r.attributes.skinIndex, t), FB.fromBufferAttribute(r.attributes.skinWeight, t), kB.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
      for (let o = 0; o < 4; o++) {
        let s = FB.getComponent(o);
        if (s !== 0) {
          let a = LB.getComponent(o);
          BB.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), e.addScaledVector(cre.copy(kB).applyMatrix4(BB), s);
        }
      }
      return e.applyMatrix4(this.bindMatrixInverse);
    }
  };
  Xh.prototype.isSkinnedMesh = true;
  var Zh = class extends ln {
    constructor() {
      super(), this.type = "Bone";
    }
  };
  Zh.prototype.isBone = true;
  var Ra = class extends zi {
    constructor(t = null, e = 1, n = 1, r, o, s, a, l, c = Si, d = Si, u, h) {
      super(null, s, a, l, c, d, r, o, u, h), this.image = { data: t, width: e, height: n }, this.magFilter = c, this.minFilter = d, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.needsUpdate = true;
    }
  };
  Ra.prototype.isDataTexture = true;
  var VB = new ut();
  var dre = new ut();
  var ix = class i40 {
    constructor(t = [], e = []) {
      this.uuid = ho(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init();
    }
    init() {
      let t = this.bones, e = this.boneInverses;
      if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses();
      else if (t.length !== e.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
        for (let n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new ut());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let t = 0, e = this.bones.length; t < e; t++) {
        let n = new ut();
        this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n);
      }
    }
    pose() {
      for (let t = 0, e = this.bones.length; t < e; t++) {
        let n = this.bones[t];
        n && n.matrixWorld.copy(this.boneInverses[t]).invert();
      }
      for (let t = 0, e = this.bones.length; t < e; t++) {
        let n = this.bones[t];
        n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale));
      }
    }
    update() {
      let t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture;
      for (let o = 0, s = t.length; o < s; o++) {
        let a = t[o] ? t[o].matrixWorld : dre;
        VB.multiplyMatrices(a, e[o]), VB.toArray(n, o * 16);
      }
      r !== null && (r.needsUpdate = true);
    }
    clone() {
      return new i40(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let t = Math.sqrt(this.bones.length * 4);
      t = Qz(t), t = Math.max(t, 4);
      let e = new Float32Array(t * t * 4);
      e.set(this.boneMatrices);
      let n = new Ra(e, t, t, ir, Fs);
      return this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this;
    }
    getBoneByName(t) {
      for (let e = 0, n = this.bones.length; e < n; e++) {
        let r = this.bones[e];
        if (r.name === t) return r;
      }
    }
    dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
    }
    fromJSON(t, e) {
      this.uuid = t.uuid;
      for (let n = 0, r = t.bones.length; n < r; n++) {
        let o = t.bones[n], s = e[o];
        s === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", o), s = new Zh()), this.bones.push(s), this.boneInverses.push(new ut().fromArray(t.boneInverses[n]));
      }
      return this.init(), this;
    }
    toJSON() {
      let t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
      t.uuid = this.uuid;
      let e = this.bones, n = this.boneInverses;
      for (let r = 0, o = e.length; r < o; r++) {
        let s = e[r];
        t.bones.push(s.uuid);
        let a = n[r];
        t.boneInverses.push(a.toArray());
      }
      return t;
    }
  };
  var ka = class extends an {
    constructor(t, e, n, r = 1) {
      typeof n == "number" && (r = n, n = false, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r;
    }
    copy(t) {
      return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = true, t;
    }
  };
  ka.prototype.isInstancedBufferAttribute = true;
  var zB = new ut();
  var UB = new ut();
  var S0 = [];
  var Sm = new li();
  var qm = class extends li {
    constructor(t, e, n) {
      super(t, e), this.instanceMatrix = new ka(new Float32Array(n * 16), 16), this.instanceColor = null, this.count = n, this.frustumCulled = false;
    }
    copy(t) {
      return super.copy(t), this.instanceMatrix.copy(t.instanceMatrix), t.instanceColor !== null && (this.instanceColor = t.instanceColor.clone()), this.count = t.count, this;
    }
    getColorAt(t, e) {
      e.fromArray(this.instanceColor.array, t * 3);
    }
    getMatrixAt(t, e) {
      e.fromArray(this.instanceMatrix.array, t * 16);
    }
    raycast(t, e) {
      let n = this.matrixWorld, r = this.count;
      if (Sm.geometry = this.geometry, Sm.material = this.material, Sm.material !== void 0) for (let o = 0; o < r; o++) {
        this.getMatrixAt(o, zB), UB.multiplyMatrices(n, zB), Sm.matrixWorld = UB, Sm.raycast(t, S0);
        for (let s = 0, a = S0.length; s < a; s++) {
          let l = S0[s];
          l.instanceId = o, l.object = this, e.push(l);
        }
        S0.length = 0;
      }
    }
    setColorAt(t, e) {
      this.instanceColor === null && (this.instanceColor = new ka(new Float32Array(this.instanceMatrix.count * 3), 3)), e.toArray(this.instanceColor.array, t * 3);
    }
    setMatrixAt(t, e) {
      e.toArray(this.instanceMatrix.array, t * 16);
    }
    updateMorphTargets() {
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  };
  qm.prototype.isInstancedMesh = true;
  var Ei = class extends Mi {
    constructor(t) {
      super(), this.type = "LineBasicMaterial", this.color = new Ye(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this;
    }
  };
  Ei.prototype.isLineBasicMaterial = true;
  var GB = new L();
  var HB = new L();
  var jB = new ut();
  var XI = new Us();
  var M0 = new zs();
  var ds = class extends ln {
    constructor(t = new Ct(), e = new Ei()) {
      super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t) {
      return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
    }
    computeLineDistances() {
      let t = this.geometry;
      if (t.isBufferGeometry) if (t.index === null) {
        let e = t.attributes.position, n = [0];
        for (let r = 1, o = e.count; r < o; r++) GB.fromBufferAttribute(e, r - 1), HB.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += GB.distanceTo(HB);
        t.setAttribute("lineDistance", new it(n, 1));
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
    raycast(t, e) {
      let n = this.geometry, r = this.matrixWorld, o = t.params.Line.threshold, s = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), M0.copy(n.boundingSphere), M0.applyMatrix4(r), M0.radius += o, t.ray.intersectsSphere(M0) === false) return;
      jB.copy(r).invert(), XI.copy(t.ray).applyMatrix4(jB);
      let a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, c = new L(), d = new L(), u = new L(), h = new L(), p = this.isLineSegments ? 2 : 1;
      if (n.isBufferGeometry) {
        let f = n.index, v = n.attributes.position;
        if (f !== null) {
          let _ = Math.max(0, s.start), g = Math.min(f.count, s.start + s.count);
          for (let y = _, w = g - 1; y < w; y += p) {
            let E = f.getX(y), P = f.getX(y + 1);
            if (c.fromBufferAttribute(v, E), d.fromBufferAttribute(v, P), XI.distanceSqToSegment(c, d, h, u) > l) continue;
            h.applyMatrix4(this.matrixWorld);
            let A = t.ray.origin.distanceTo(h);
            A < t.near || A > t.far || e.push({ distance: A, point: u.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this });
          }
        } else {
          let _ = Math.max(0, s.start), g = Math.min(v.count, s.start + s.count);
          for (let y = _, w = g - 1; y < w; y += p) {
            if (c.fromBufferAttribute(v, y), d.fromBufferAttribute(v, y + 1), XI.distanceSqToSegment(c, d, h, u) > l) continue;
            h.applyMatrix4(this.matrixWorld);
            let P = t.ray.origin.distanceTo(h);
            P < t.near || P > t.far || e.push({ distance: P, point: u.clone().applyMatrix4(this.matrixWorld), index: y, face: null, faceIndex: null, object: this });
          }
        }
      } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      let t = this.geometry;
      if (t.isBufferGeometry) {
        let e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          let r = e[n[0]];
          if (r !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let o = 0, s = r.length; o < s; o++) {
              let a = r[o].name || String(o);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o;
            }
          }
        }
      } else {
        let e = t.morphTargets;
        e !== void 0 && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  ds.prototype.isLine = true;
  var WB = new L();
  var $B = new L();
  var wr = class extends ds {
    constructor(t, e) {
      super(t, e), this.type = "LineSegments";
    }
    computeLineDistances() {
      let t = this.geometry;
      if (t.isBufferGeometry) if (t.index === null) {
        let e = t.attributes.position, n = [];
        for (let r = 0, o = e.count; r < o; r += 2) WB.fromBufferAttribute(e, r), $B.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + WB.distanceTo($B);
        t.setAttribute("lineDistance", new it(n, 1));
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
      return this;
    }
  };
  wr.prototype.isLineSegments = true;
  var Ym = class extends ds {
    constructor(t, e) {
      super(t, e), this.type = "LineLoop";
    }
  };
  Ym.prototype.isLineLoop = true;
  var La = class extends Mi {
    constructor(t) {
      super(), this.type = "PointsMaterial", this.color = new Ye(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.alphaMap = t.alphaMap, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this;
    }
  };
  La.prototype.isPointsMaterial = true;
  var qB = new ut();
  var C1 = new Us();
  var E0 = new zs();
  var T0 = new L();
  var Md = class extends ln {
    constructor(t = new Ct(), e = new La()) {
      super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets();
    }
    copy(t) {
      return super.copy(t), this.material = t.material, this.geometry = t.geometry, this;
    }
    raycast(t, e) {
      let n = this.geometry, r = this.matrixWorld, o = t.params.Points.threshold, s = n.drawRange;
      if (n.boundingSphere === null && n.computeBoundingSphere(), E0.copy(n.boundingSphere), E0.applyMatrix4(r), E0.radius += o, t.ray.intersectsSphere(E0) === false) return;
      qB.copy(r).invert(), C1.copy(t.ray).applyMatrix4(qB);
      let a = o / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a;
      if (n.isBufferGeometry) {
        let c = n.index, u = n.attributes.position;
        if (c !== null) {
          let h = Math.max(0, s.start), p = Math.min(c.count, s.start + s.count);
          for (let f = h, m = p; f < m; f++) {
            let v = c.getX(f);
            T0.fromBufferAttribute(u, v), YB(T0, v, l, r, t, e, this);
          }
        } else {
          let h = Math.max(0, s.start), p = Math.min(u.count, s.start + s.count);
          for (let f = h, m = p; f < m; f++) T0.fromBufferAttribute(u, f), YB(T0, f, l, r, t, e, this);
        }
      } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    updateMorphTargets() {
      let t = this.geometry;
      if (t.isBufferGeometry) {
        let e = t.morphAttributes, n = Object.keys(e);
        if (n.length > 0) {
          let r = e[n[0]];
          if (r !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let o = 0, s = r.length; o < s; o++) {
              let a = r[o].name || String(o);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = o;
            }
          }
        }
      } else {
        let e = t.morphTargets;
        e !== void 0 && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
      }
    }
  };
  Md.prototype.isPoints = true;
  function YB(i59, t, e, n, r, o, s) {
    let a = C1.distanceSqToPoint(i59);
    if (a < e) {
      let l = new L();
      C1.closestPointToPoint(i59, l), l.applyMatrix4(n);
      let c = r.ray.origin.distanceTo(l);
      if (c < r.near || c > r.far) return;
      o.push({ distance: c, distanceToRay: Math.sqrt(a), point: l, index: t, face: null, object: s });
    }
  }
  var rx = class extends zi {
    constructor(t, e, n, r, o, s, a, l, c) {
      super(t, e, n, r, o, s, a, l, c), this.format = a !== void 0 ? a : gd, this.minFilter = s !== void 0 ? s : Ri, this.magFilter = o !== void 0 ? o : Ri, this.generateMipmaps = false;
      let d = this;
      function u() {
        d.needsUpdate = true, t.requestVideoFrameCallback(u);
      }
      "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(u);
    }
    clone() {
      return new this.constructor(this.image).copy(this);
    }
    update() {
      let t = this.image;
      "requestVideoFrameCallback" in t === false && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = true);
    }
  };
  rx.prototype.isVideoTexture = true;
  var Xm = class extends zi {
    constructor(t, e, n, r, o, s, a, l, c, d, u, h) {
      super(null, s, a, l, c, d, r, o, u, h), this.image = { width: e, height: n }, this.mipmaps = t, this.flipY = false, this.generateMipmaps = false;
    }
  };
  Xm.prototype.isCompressedTexture = true;
  var ox = class extends zi {
    constructor(t, e, n, r, o, s, a, l, c) {
      super(t, e, n, r, o, s, a, l, c), this.needsUpdate = true;
    }
  };
  ox.prototype.isCanvasTexture = true;
  var sx = class extends zi {
    constructor(t, e, n, r, o, s, a, l, c, d) {
      if (d = d !== void 0 ? d : _d, d !== _d && d !== Nh) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      n === void 0 && d === _d && (n = Lm), n === void 0 && d === Nh && (n = Oh), super(null, r, o, s, a, l, d, n, c), this.image = { width: t, height: e }, this.magFilter = a !== void 0 ? a : Si, this.minFilter = l !== void 0 ? l : Si, this.flipY = false, this.generateMipmaps = false;
    }
  };
  sx.prototype.isDepthTexture = true;
  var Zm = class i41 extends Ct {
    constructor(t = 1, e = 8, n = 0, r = Math.PI * 2) {
      super(), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: r }, e = Math.max(3, e);
      let o = [], s = [], a = [], l = [], c = new L(), d = new Me();
      s.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
      for (let u = 0, h = 3; u <= e; u++, h += 3) {
        let p = n + u / e * r;
        c.x = t * Math.cos(p), c.y = t * Math.sin(p), s.push(c.x, c.y, c.z), a.push(0, 0, 1), d.x = (s[h] / t + 1) / 2, d.y = (s[h + 1] / t + 1) / 2, l.push(d.x, d.y);
      }
      for (let u = 1; u <= e; u++) o.push(u, u + 1, 0);
      this.setIndex(o), this.setAttribute("position", new it(s, 3)), this.setAttribute("normal", new it(a, 3)), this.setAttribute("uv", new it(l, 2));
    }
    static fromJSON(t) {
      return new i41(t.radius, t.segments, t.thetaStart, t.thetaLength);
    }
  };
  var Ed = class i42 extends Ct {
    constructor(t = 1, e = 1, n = 1, r = 8, o = 1, s = false, a = 0, l = Math.PI * 2) {
      super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: r, heightSegments: o, openEnded: s, thetaStart: a, thetaLength: l };
      let c = this;
      r = Math.floor(r), o = Math.floor(o);
      let d = [], u = [], h = [], p = [], f = 0, m = [], v = n / 2, _ = 0;
      g(), s === false && (t > 0 && y(true), e > 0 && y(false)), this.setIndex(d), this.setAttribute("position", new it(u, 3)), this.setAttribute("normal", new it(h, 3)), this.setAttribute("uv", new it(p, 2));
      function g() {
        let w = new L(), E = new L(), P = 0, S = (e - t) / n;
        for (let A = 0; A <= o; A++) {
          let W = [], H = A / o, O = H * (e - t) + t;
          for (let I = 0; I <= r; I++) {
            let F = I / r, j = F * l + a, $ = Math.sin(j), k = Math.cos(j);
            E.x = O * $, E.y = -H * n + v, E.z = O * k, u.push(E.x, E.y, E.z), w.set($, S, k).normalize(), h.push(w.x, w.y, w.z), p.push(F, 1 - H), W.push(f++);
          }
          m.push(W);
        }
        for (let A = 0; A < r; A++) for (let W = 0; W < o; W++) {
          let H = m[W][A], O = m[W + 1][A], I = m[W + 1][A + 1], F = m[W][A + 1];
          d.push(H, O, F), d.push(O, I, F), P += 6;
        }
        c.addGroup(_, P, 0), _ += P;
      }
      function y(w) {
        let E = f, P = new Me(), S = new L(), A = 0, W = w === true ? t : e, H = w === true ? 1 : -1;
        for (let I = 1; I <= r; I++) u.push(0, v * H, 0), h.push(0, H, 0), p.push(0.5, 0.5), f++;
        let O = f;
        for (let I = 0; I <= r; I++) {
          let j = I / r * l + a, $ = Math.cos(j), k = Math.sin(j);
          S.x = W * k, S.y = v * H, S.z = W * $, u.push(S.x, S.y, S.z), h.push(0, H, 0), P.x = $ * 0.5 + 0.5, P.y = k * 0.5 * H + 0.5, p.push(P.x, P.y), f++;
        }
        for (let I = 0; I < r; I++) {
          let F = E + I, j = O + I;
          w === true ? d.push(j, j + 1, F) : d.push(j + 1, j, F), A += 3;
        }
        c.addGroup(_, A, w === true ? 1 : 2), _ += A;
      }
    }
    static fromJSON(t) {
      return new i42(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
    }
  };
  var Qm = class i43 extends Ed {
    constructor(t = 1, e = 1, n = 8, r = 1, o = false, s = 0, a = Math.PI * 2) {
      super(0, t, e, n, r, o, s, a), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: r, openEnded: o, thetaStart: s, thetaLength: a };
    }
    static fromJSON(t) {
      return new i43(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength);
    }
  };
  var Fa = class i44 extends Ct {
    constructor(t = [], e = [], n = 1, r = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: r };
      let o = [], s = [];
      a(r), c(n), d(), this.setAttribute("position", new it(o, 3)), this.setAttribute("normal", new it(o.slice(), 3)), this.setAttribute("uv", new it(s, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
      function a(g) {
        let y = new L(), w = new L(), E = new L();
        for (let P = 0; P < e.length; P += 3) p(e[P + 0], y), p(e[P + 1], w), p(e[P + 2], E), l(y, w, E, g);
      }
      function l(g, y, w, E) {
        let P = E + 1, S = [];
        for (let A = 0; A <= P; A++) {
          S[A] = [];
          let W = g.clone().lerp(w, A / P), H = y.clone().lerp(w, A / P), O = P - A;
          for (let I = 0; I <= O; I++) I === 0 && A === P ? S[A][I] = W : S[A][I] = W.clone().lerp(H, I / O);
        }
        for (let A = 0; A < P; A++) for (let W = 0; W < 2 * (P - A) - 1; W++) {
          let H = Math.floor(W / 2);
          W % 2 === 0 ? (h(S[A][H + 1]), h(S[A + 1][H]), h(S[A][H])) : (h(S[A][H + 1]), h(S[A + 1][H + 1]), h(S[A + 1][H]));
        }
      }
      function c(g) {
        let y = new L();
        for (let w = 0; w < o.length; w += 3) y.x = o[w + 0], y.y = o[w + 1], y.z = o[w + 2], y.normalize().multiplyScalar(g), o[w + 0] = y.x, o[w + 1] = y.y, o[w + 2] = y.z;
      }
      function d() {
        let g = new L();
        for (let y = 0; y < o.length; y += 3) {
          g.x = o[y + 0], g.y = o[y + 1], g.z = o[y + 2];
          let w = v(g) / 2 / Math.PI + 0.5, E = _(g) / Math.PI + 0.5;
          s.push(w, 1 - E);
        }
        f(), u();
      }
      function u() {
        for (let g = 0; g < s.length; g += 6) {
          let y = s[g + 0], w = s[g + 2], E = s[g + 4], P = Math.max(y, w, E), S = Math.min(y, w, E);
          P > 0.9 && S < 0.1 && (y < 0.2 && (s[g + 0] += 1), w < 0.2 && (s[g + 2] += 1), E < 0.2 && (s[g + 4] += 1));
        }
      }
      function h(g) {
        o.push(g.x, g.y, g.z);
      }
      function p(g, y) {
        let w = g * 3;
        y.x = t[w + 0], y.y = t[w + 1], y.z = t[w + 2];
      }
      function f() {
        let g = new L(), y = new L(), w = new L(), E = new L(), P = new Me(), S = new Me(), A = new Me();
        for (let W = 0, H = 0; W < o.length; W += 9, H += 6) {
          g.set(o[W + 0], o[W + 1], o[W + 2]), y.set(o[W + 3], o[W + 4], o[W + 5]), w.set(o[W + 6], o[W + 7], o[W + 8]), P.set(s[H + 0], s[H + 1]), S.set(s[H + 2], s[H + 3]), A.set(s[H + 4], s[H + 5]), E.copy(g).add(y).add(w).divideScalar(3);
          let O = v(E);
          m(P, H + 0, g, O), m(S, H + 2, y, O), m(A, H + 4, w, O);
        }
      }
      function m(g, y, w, E) {
        E < 0 && g.x === 1 && (s[y] = g.x - 1), w.x === 0 && w.z === 0 && (s[y] = E / 2 / Math.PI + 0.5);
      }
      function v(g) {
        return Math.atan2(g.z, -g.x);
      }
      function _(g) {
        return Math.atan2(-g.y, Math.sqrt(g.x * g.x + g.z * g.z));
      }
    }
    static fromJSON(t) {
      return new i44(t.vertices, t.indices, t.radius, t.details);
    }
  };
  var Km = class i45 extends Fa {
    constructor(t = 1, e = 0) {
      let n = (1 + Math.sqrt(5)) / 2, r = 1 / n, o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], s = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      super(o, s, t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e };
    }
    static fromJSON(t) {
      return new i45(t.radius, t.detail);
    }
  };
  var I0 = new L();
  var D0 = new L();
  var ZI = new L();
  var P0 = new rr();
  var Jm = class extends Ct {
    constructor(t = null, e = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: t, thresholdAngle: e }, t !== null) {
        let r = Math.pow(10, 4), o = Math.cos(vd * e), s = t.getIndex(), a = t.getAttribute("position"), l = s ? s.count : a.count, c = [0, 0, 0], d = ["a", "b", "c"], u = new Array(3), h = {}, p = [];
        for (let f = 0; f < l; f += 3) {
          s ? (c[0] = s.getX(f), c[1] = s.getX(f + 1), c[2] = s.getX(f + 2)) : (c[0] = f, c[1] = f + 1, c[2] = f + 2);
          let { a: m, b: v, c: _ } = P0;
          if (m.fromBufferAttribute(a, c[0]), v.fromBufferAttribute(a, c[1]), _.fromBufferAttribute(a, c[2]), P0.getNormal(ZI), u[0] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, u[1] = `${Math.round(v.x * r)},${Math.round(v.y * r)},${Math.round(v.z * r)}`, u[2] = `${Math.round(_.x * r)},${Math.round(_.y * r)},${Math.round(_.z * r)}`, !(u[0] === u[1] || u[1] === u[2] || u[2] === u[0])) for (let g = 0; g < 3; g++) {
            let y = (g + 1) % 3, w = u[g], E = u[y], P = P0[d[g]], S = P0[d[y]], A = `${w}_${E}`, W = `${E}_${w}`;
            W in h && h[W] ? (ZI.dot(h[W].normal) <= o && (p.push(P.x, P.y, P.z), p.push(S.x, S.y, S.z)), h[W] = null) : A in h || (h[A] = { index0: c[g], index1: c[y], normal: ZI.clone() });
          }
        }
        for (let f in h) if (h[f]) {
          let { index0: m, index1: v } = h[f];
          I0.fromBufferAttribute(a, m), D0.fromBufferAttribute(a, v), p.push(I0.x, I0.y, I0.z), p.push(D0.x, D0.y, D0.z);
        }
        this.setAttribute("position", new it(p, 3));
      }
    }
  };
  var Br = class {
    constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200;
    }
    getPoint() {
      return console.warn("THREE.Curve: .getPoint() not implemented."), null;
    }
    getPointAt(t, e) {
      let n = this.getUtoTmapping(t);
      return this.getPoint(n, e);
    }
    getPoints(t = 5) {
      let e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return e;
    }
    getSpacedPoints(t = 5) {
      let e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
      return e;
    }
    getLength() {
      let t = this.getLengths();
      return t[t.length - 1];
    }
    getLengths(t = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = false;
      let e = [], n, r = this.getPoint(0), o = 0;
      e.push(0);
      for (let s = 1; s <= t; s++) n = this.getPoint(s / t), o += n.distanceTo(r), e.push(o), r = n;
      return this.cacheArcLengths = e, e;
    }
    updateArcLengths() {
      this.needsUpdate = true, this.getLengths();
    }
    getUtoTmapping(t, e) {
      let n = this.getLengths(), r = 0, o = n.length, s;
      e ? s = e : s = t * n[o - 1];
      let a = 0, l = o - 1, c;
      for (; a <= l; ) if (r = Math.floor(a + (l - a) / 2), c = n[r] - s, c < 0) a = r + 1;
      else if (c > 0) l = r - 1;
      else {
        l = r;
        break;
      }
      if (r = l, n[r] === s) return r / (o - 1);
      let d = n[r], h = n[r + 1] - d, p = (s - d) / h;
      return (r + p) / (o - 1);
    }
    getTangent(t, e) {
      let r = t - 1e-4, o = t + 1e-4;
      r < 0 && (r = 0), o > 1 && (o = 1);
      let s = this.getPoint(r), a = this.getPoint(o), l = e || (s.isVector2 ? new Me() : new L());
      return l.copy(a).sub(s).normalize(), l;
    }
    getTangentAt(t, e) {
      let n = this.getUtoTmapping(t);
      return this.getTangent(n, e);
    }
    computeFrenetFrames(t, e) {
      let n = new L(), r = [], o = [], s = [], a = new L(), l = new ut();
      for (let p = 0; p <= t; p++) {
        let f = p / t;
        r[p] = this.getTangentAt(f, new L());
      }
      o[0] = new L(), s[0] = new L();
      let c = Number.MAX_VALUE, d = Math.abs(r[0].x), u = Math.abs(r[0].y), h = Math.abs(r[0].z);
      d <= c && (c = d, n.set(1, 0, 0)), u <= c && (c = u, n.set(0, 1, 0)), h <= c && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), o[0].crossVectors(r[0], a), s[0].crossVectors(r[0], o[0]);
      for (let p = 1; p <= t; p++) {
        if (o[p] = o[p - 1].clone(), s[p] = s[p - 1].clone(), a.crossVectors(r[p - 1], r[p]), a.length() > Number.EPSILON) {
          a.normalize();
          let f = Math.acos(tr(r[p - 1].dot(r[p]), -1, 1));
          o[p].applyMatrix4(l.makeRotationAxis(a, f));
        }
        s[p].crossVectors(r[p], o[p]);
      }
      if (e === true) {
        let p = Math.acos(tr(o[0].dot(o[t]), -1, 1));
        p /= t, r[0].dot(a.crossVectors(o[0], o[t])) > 0 && (p = -p);
        for (let f = 1; f <= t; f++) o[f].applyMatrix4(l.makeRotationAxis(r[f], p * f)), s[f].crossVectors(r[f], o[f]);
      }
      return { tangents: r, normals: o, binormals: s };
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
    toJSON() {
      let t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } };
      return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t;
    }
    fromJSON(t) {
      return this.arcLengthDivisions = t.arcLengthDivisions, this;
    }
  };
  var Td = class extends Br {
    constructor(t = 0, e = 0, n = 1, r = 1, o = 0, s = Math.PI * 2, a = false, l = 0) {
      super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = s, this.aClockwise = a, this.aRotation = l;
    }
    getPoint(t, e) {
      let n = e || new Me(), r = Math.PI * 2, o = this.aEndAngle - this.aStartAngle, s = Math.abs(o) < Number.EPSILON;
      for (; o < 0; ) o += r;
      for (; o > r; ) o -= r;
      o < Number.EPSILON && (s ? o = 0 : o = r), this.aClockwise === true && !s && (o === r ? o = -r : o = o - r);
      let a = this.aStartAngle + t * o, l = this.aX + this.xRadius * Math.cos(a), c = this.aY + this.yRadius * Math.sin(a);
      if (this.aRotation !== 0) {
        let d = Math.cos(this.aRotation), u = Math.sin(this.aRotation), h = l - this.aX, p = c - this.aY;
        l = h * d - p * u + this.aX, c = h * u + p * d + this.aY;
      }
      return n.set(l, c);
    }
    copy(t) {
      return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this;
    }
  };
  Td.prototype.isEllipseCurve = true;
  var eg = class extends Td {
    constructor(t, e, n, r, o, s) {
      super(t, e, n, n, r, o, s), this.type = "ArcCurve";
    }
  };
  eg.prototype.isArcCurve = true;
  function lD() {
    let i59 = 0, t = 0, e = 0, n = 0;
    function r(o, s, a, l) {
      i59 = o, t = a, e = -3 * o + 3 * s - 2 * a - l, n = 2 * o - 2 * s + a + l;
    }
    return { initCatmullRom: function(o, s, a, l, c) {
      r(s, a, c * (a - o), c * (l - s));
    }, initNonuniformCatmullRom: function(o, s, a, l, c, d, u) {
      let h = (s - o) / c - (a - o) / (c + d) + (a - s) / d, p = (a - s) / d - (l - s) / (d + u) + (l - a) / u;
      h *= d, p *= d, r(s, a, h, p);
    }, calc: function(o) {
      let s = o * o, a = s * o;
      return i59 + t * o + e * s + n * a;
    } };
  }
  var R0 = new L();
  var QI = new lD();
  var KI = new lD();
  var JI = new lD();
  var tg = class extends Br {
    constructor(t = [], e = false, n = "centripetal", r = 0.5) {
      super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r;
    }
    getPoint(t, e = new L()) {
      let n = e, r = this.points, o = r.length, s = (o - (this.closed ? 0 : 1)) * t, a = Math.floor(s), l = s - a;
      this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / o) + 1) * o : l === 0 && a === o - 1 && (a = o - 2, l = 1);
      let c, d;
      this.closed || a > 0 ? c = r[(a - 1) % o] : (R0.subVectors(r[0], r[1]).add(r[0]), c = R0);
      let u = r[a % o], h = r[(a + 1) % o];
      if (this.closed || a + 2 < o ? d = r[(a + 2) % o] : (R0.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), d = R0), this.curveType === "centripetal" || this.curveType === "chordal") {
        let p = this.curveType === "chordal" ? 0.5 : 0.25, f = Math.pow(c.distanceToSquared(u), p), m = Math.pow(u.distanceToSquared(h), p), v = Math.pow(h.distanceToSquared(d), p);
        m < 1e-4 && (m = 1), f < 1e-4 && (f = m), v < 1e-4 && (v = m), QI.initNonuniformCatmullRom(c.x, u.x, h.x, d.x, f, m, v), KI.initNonuniformCatmullRom(c.y, u.y, h.y, d.y, f, m, v), JI.initNonuniformCatmullRom(c.z, u.z, h.z, d.z, f, m, v);
      } else this.curveType === "catmullrom" && (QI.initCatmullRom(c.x, u.x, h.x, d.x, this.tension), KI.initCatmullRom(c.y, u.y, h.y, d.y, this.tension), JI.initCatmullRom(c.z, u.z, h.z, d.z, this.tension));
      return n.set(QI.calc(l), KI.calc(l), JI.calc(l)), n;
    }
    copy(t) {
      super.copy(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        let r = t.points[e];
        this.points.push(r.clone());
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
    toJSON() {
      let t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        let r = this.points[e];
        t.points.push(r.toArray());
      }
      return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t;
    }
    fromJSON(t) {
      super.fromJSON(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        let r = t.points[e];
        this.points.push(new L().fromArray(r));
      }
      return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this;
    }
  };
  tg.prototype.isCatmullRomCurve3 = true;
  function XB(i59, t, e, n, r) {
    let o = (n - t) * 0.5, s = (r - e) * 0.5, a = i59 * i59, l = i59 * a;
    return (2 * e - 2 * n + o + s) * l + (-3 * e + 3 * n - 2 * o - s) * a + o * i59 + e;
  }
  function ure(i59, t) {
    let e = 1 - i59;
    return e * e * t;
  }
  function hre(i59, t) {
    return 2 * (1 - i59) * i59 * t;
  }
  function pre(i59, t) {
    return i59 * i59 * t;
  }
  function Pm(i59, t, e, n) {
    return ure(i59, t) + hre(i59, e) + pre(i59, n);
  }
  function fre(i59, t) {
    let e = 1 - i59;
    return e * e * e * t;
  }
  function mre(i59, t) {
    let e = 1 - i59;
    return 3 * e * e * i59 * t;
  }
  function gre(i59, t) {
    return 3 * (1 - i59) * i59 * i59 * t;
  }
  function _re(i59, t) {
    return i59 * i59 * i59 * t;
  }
  function Rm(i59, t, e, n, r) {
    return fre(i59, t) + mre(i59, e) + gre(i59, n) + _re(i59, r);
  }
  var Qh = class extends Br {
    constructor(t = new Me(), e = new Me(), n = new Me(), r = new Me()) {
      super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
    }
    getPoint(t, e = new Me()) {
      let n = e, r = this.v0, o = this.v1, s = this.v2, a = this.v3;
      return n.set(Rm(t, r.x, o.x, s.x, a.x), Rm(t, r.y, o.y, s.y, a.y)), n;
    }
    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
  };
  Qh.prototype.isCubicBezierCurve = true;
  var ng = class extends Br {
    constructor(t = new L(), e = new L(), n = new L(), r = new L()) {
      super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r;
    }
    getPoint(t, e = new L()) {
      let n = e, r = this.v0, o = this.v1, s = this.v2, a = this.v3;
      return n.set(Rm(t, r.x, o.x, s.x, a.x), Rm(t, r.y, o.y, s.y, a.y), Rm(t, r.z, o.z, s.z, a.z)), n;
    }
    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this;
    }
  };
  ng.prototype.isCubicBezierCurve3 = true;
  var Id = class extends Br {
    constructor(t = new Me(), e = new Me()) {
      super(), this.type = "LineCurve", this.v1 = t, this.v2 = e;
    }
    getPoint(t, e = new Me()) {
      let n = e;
      return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
    }
    getPointAt(t, e) {
      return this.getPoint(t, e);
    }
    getTangent(t, e) {
      let n = e || new Me();
      return n.copy(this.v2).sub(this.v1).normalize(), n;
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  };
  Id.prototype.isLineCurve = true;
  var ax = class extends Br {
    constructor(t = new L(), e = new L()) {
      super(), this.type = "LineCurve3", this.isLineCurve3 = true, this.v1 = t, this.v2 = e;
    }
    getPoint(t, e = new L()) {
      let n = e;
      return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n;
    }
    getPointAt(t, e) {
      return this.getPoint(t, e);
    }
    copy(t) {
      return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  };
  var Kh = class extends Br {
    constructor(t = new Me(), e = new Me(), n = new Me()) {
      super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n;
    }
    getPoint(t, e = new Me()) {
      let n = e, r = this.v0, o = this.v1, s = this.v2;
      return n.set(Pm(t, r.x, o.x, s.x), Pm(t, r.y, o.y, s.y)), n;
    }
    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  };
  Kh.prototype.isQuadraticBezierCurve = true;
  var Jh = class extends Br {
    constructor(t = new L(), e = new L(), n = new L()) {
      super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n;
    }
    getPoint(t, e = new L()) {
      let n = e, r = this.v0, o = this.v1, s = this.v2;
      return n.set(Pm(t, r.x, o.x, s.x), Pm(t, r.y, o.y, s.y), Pm(t, r.z, o.z, s.z)), n;
    }
    copy(t) {
      return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this;
    }
  };
  Jh.prototype.isQuadraticBezierCurve3 = true;
  var ep = class extends Br {
    constructor(t = []) {
      super(), this.type = "SplineCurve", this.points = t;
    }
    getPoint(t, e = new Me()) {
      let n = e, r = this.points, o = (r.length - 1) * t, s = Math.floor(o), a = o - s, l = r[s === 0 ? s : s - 1], c = r[s], d = r[s > r.length - 2 ? r.length - 1 : s + 1], u = r[s > r.length - 3 ? r.length - 1 : s + 2];
      return n.set(XB(a, l.x, c.x, d.x, u.x), XB(a, l.y, c.y, d.y, u.y)), n;
    }
    copy(t) {
      super.copy(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        let r = t.points[e];
        this.points.push(r.clone());
      }
      return this;
    }
    toJSON() {
      let t = super.toJSON();
      t.points = [];
      for (let e = 0, n = this.points.length; e < n; e++) {
        let r = this.points[e];
        t.points.push(r.toArray());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), this.points = [];
      for (let e = 0, n = t.points.length; e < n; e++) {
        let r = t.points[e];
        this.points.push(new Me().fromArray(r));
      }
      return this;
    }
  };
  ep.prototype.isSplineCurve = true;
  var cD = Object.freeze({ __proto__: null, ArcCurve: eg, CatmullRomCurve3: tg, CubicBezierCurve: Qh, CubicBezierCurve3: ng, EllipseCurve: Td, LineCurve: Id, LineCurve3: ax, QuadraticBezierCurve: Kh, QuadraticBezierCurve3: Jh, SplineCurve: ep });
  var lx = class extends Br {
    constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
    }
    add(t) {
      this.curves.push(t);
    }
    closePath() {
      let t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Id(e, t));
    }
    getPoint(t, e) {
      let n = t * this.getLength(), r = this.getCurveLengths(), o = 0;
      for (; o < r.length; ) {
        if (r[o] >= n) {
          let s = r[o] - n, a = this.curves[o], l = a.getLength(), c = l === 0 ? 0 : 1 - s / l;
          return a.getPointAt(c, e);
        }
        o++;
      }
      return null;
    }
    getLength() {
      let t = this.getCurveLengths();
      return t[t.length - 1];
    }
    updateArcLengths() {
      this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
    }
    getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      let t = [], e = 0;
      for (let n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
      return this.cacheLengths = t, t;
    }
    getSpacedPoints(t = 40) {
      let e = [];
      for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
      return this.autoClose && e.push(e[0]), e;
    }
    getPoints(t = 12) {
      let e = [], n;
      for (let r = 0, o = this.curves; r < o.length; r++) {
        let s = o[r], a = s && s.isEllipseCurve ? t * 2 : s && (s.isLineCurve || s.isLineCurve3) ? 1 : s && s.isSplineCurve ? t * s.points.length : t, l = s.getPoints(a);
        for (let c = 0; c < l.length; c++) {
          let d = l[c];
          n && n.equals(d) || (e.push(d), n = d);
        }
      }
      return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e;
    }
    copy(t) {
      super.copy(t), this.curves = [];
      for (let e = 0, n = t.curves.length; e < n; e++) {
        let r = t.curves[e];
        this.curves.push(r.clone());
      }
      return this.autoClose = t.autoClose, this;
    }
    toJSON() {
      let t = super.toJSON();
      t.autoClose = this.autoClose, t.curves = [];
      for (let e = 0, n = this.curves.length; e < n; e++) {
        let r = this.curves[e];
        t.curves.push(r.toJSON());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
      for (let e = 0, n = t.curves.length; e < n; e++) {
        let r = t.curves[e];
        this.curves.push(new cD[r.type]().fromJSON(r));
      }
      return this;
    }
  };
  var Dd = class extends lx {
    constructor(t) {
      super(), this.type = "Path", this.currentPoint = new Me(), t && this.setFromPoints(t);
    }
    setFromPoints(t) {
      this.moveTo(t[0].x, t[0].y);
      for (let e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y);
      return this;
    }
    moveTo(t, e) {
      return this.currentPoint.set(t, e), this;
    }
    lineTo(t, e) {
      let n = new Id(this.currentPoint.clone(), new Me(t, e));
      return this.curves.push(n), this.currentPoint.set(t, e), this;
    }
    quadraticCurveTo(t, e, n, r) {
      let o = new Kh(this.currentPoint.clone(), new Me(t, e), new Me(n, r));
      return this.curves.push(o), this.currentPoint.set(n, r), this;
    }
    bezierCurveTo(t, e, n, r, o, s) {
      let a = new Qh(this.currentPoint.clone(), new Me(t, e), new Me(n, r), new Me(o, s));
      return this.curves.push(a), this.currentPoint.set(o, s), this;
    }
    splineThru(t) {
      let e = [this.currentPoint.clone()].concat(t), n = new ep(e);
      return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this;
    }
    arc(t, e, n, r, o, s) {
      let a = this.currentPoint.x, l = this.currentPoint.y;
      return this.absarc(t + a, e + l, n, r, o, s), this;
    }
    absarc(t, e, n, r, o, s) {
      return this.absellipse(t, e, n, n, r, o, s), this;
    }
    ellipse(t, e, n, r, o, s, a, l) {
      let c = this.currentPoint.x, d = this.currentPoint.y;
      return this.absellipse(t + c, e + d, n, r, o, s, a, l), this;
    }
    absellipse(t, e, n, r, o, s, a, l) {
      let c = new Td(t, e, n, r, o, s, a, l);
      if (this.curves.length > 0) {
        let u = c.getPoint(0);
        u.equals(this.currentPoint) || this.lineTo(u.x, u.y);
      }
      this.curves.push(c);
      let d = c.getPoint(1);
      return this.currentPoint.copy(d), this;
    }
    copy(t) {
      return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
    }
    toJSON() {
      let t = super.toJSON();
      return t.currentPoint = this.currentPoint.toArray(), t;
    }
    fromJSON(t) {
      return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this;
    }
  };
  var ko = class extends Dd {
    constructor(t) {
      super(t), this.uuid = ho(), this.type = "Shape", this.holes = [];
    }
    getPointsHoles(t) {
      let e = [];
      for (let n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
      return e;
    }
    extractPoints(t) {
      return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
    }
    copy(t) {
      super.copy(t), this.holes = [];
      for (let e = 0, n = t.holes.length; e < n; e++) {
        let r = t.holes[e];
        this.holes.push(r.clone());
      }
      return this;
    }
    toJSON() {
      let t = super.toJSON();
      t.uuid = this.uuid, t.holes = [];
      for (let e = 0, n = this.holes.length; e < n; e++) {
        let r = this.holes[e];
        t.holes.push(r.toJSON());
      }
      return t;
    }
    fromJSON(t) {
      super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
      for (let e = 0, n = t.holes.length; e < n; e++) {
        let r = t.holes[e];
        this.holes.push(new Dd().fromJSON(r));
      }
      return this;
    }
  };
  var vre = { triangulate: function(i59, t, e = 2) {
    let n = t && t.length, r = n ? t[0] * e : i59.length, o = fU(i59, 0, r, e, true), s = [];
    if (!o || o.next === o.prev) return s;
    let a, l, c, d, u, h, p;
    if (n && (o = Cre(i59, t, o, e)), i59.length > 80 * e) {
      a = c = i59[0], l = d = i59[1];
      for (let f = e; f < r; f += e) u = i59[f], h = i59[f + 1], u < a && (a = u), h < l && (l = h), u > c && (c = u), h > d && (d = h);
      p = Math.max(c - a, d - l), p = p !== 0 ? 1 / p : 0;
    }
    return ig(o, s, e, a, l, p), s;
  } };
  function fU(i59, t, e, n, r) {
    let o, s;
    if (r === Nre(i59, t, e, n) > 0) for (o = t; o < e; o += n) s = ZB(o, i59[o], i59[o + 1], s);
    else for (o = e - n; o >= t; o -= n) s = ZB(o, i59[o], i59[o + 1], s);
    return s && Gx(s, s.next) && (og(s), s = s.next), s;
  }
  function Al(i59, t) {
    if (!i59) return i59;
    t || (t = i59);
    let e = i59, n;
    do
      if (n = false, !e.steiner && (Gx(e, e.next) || Xn(e.prev, e, e.next) === 0)) {
        if (og(e), e = t = e.prev, e === e.next) break;
        n = true;
      } else e = e.next;
    while (n || e !== t);
    return t;
  }
  function ig(i59, t, e, n, r, o, s) {
    if (!i59) return;
    !s && o && Ire(i59, n, r, o);
    let a = i59, l, c;
    for (; i59.prev !== i59.next; ) {
      if (l = i59.prev, c = i59.next, o ? bre(i59, n, r, o) : yre(i59)) {
        t.push(l.i / e), t.push(i59.i / e), t.push(c.i / e), og(i59), i59 = c.next, a = c.next;
        continue;
      }
      if (i59 = c, i59 === a) {
        s ? s === 1 ? (i59 = xre(Al(i59), t, e), ig(i59, t, e, n, r, o, 2)) : s === 2 && wre(i59, t, e, n, r, o) : ig(Al(i59), t, e, n, r, o, 1);
        break;
      }
    }
  }
  function yre(i59) {
    let t = i59.prev, e = i59, n = i59.next;
    if (Xn(t, e, n) >= 0) return false;
    let r = i59.next.next;
    for (; r !== i59.prev; ) {
      if (Ph(t.x, t.y, e.x, e.y, n.x, n.y, r.x, r.y) && Xn(r.prev, r, r.next) >= 0) return false;
      r = r.next;
    }
    return true;
  }
  function bre(i59, t, e, n) {
    let r = i59.prev, o = i59, s = i59.next;
    if (Xn(r, o, s) >= 0) return false;
    let a = r.x < o.x ? r.x < s.x ? r.x : s.x : o.x < s.x ? o.x : s.x, l = r.y < o.y ? r.y < s.y ? r.y : s.y : o.y < s.y ? o.y : s.y, c = r.x > o.x ? r.x > s.x ? r.x : s.x : o.x > s.x ? o.x : s.x, d = r.y > o.y ? r.y > s.y ? r.y : s.y : o.y > s.y ? o.y : s.y, u = S1(a, l, t, e, n), h = S1(c, d, t, e, n), p = i59.prevZ, f = i59.nextZ;
    for (; p && p.z >= u && f && f.z <= h; ) {
      if (p !== i59.prev && p !== i59.next && Ph(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && Xn(p.prev, p, p.next) >= 0 || (p = p.prevZ, f !== i59.prev && f !== i59.next && Ph(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Xn(f.prev, f, f.next) >= 0)) return false;
      f = f.nextZ;
    }
    for (; p && p.z >= u; ) {
      if (p !== i59.prev && p !== i59.next && Ph(r.x, r.y, o.x, o.y, s.x, s.y, p.x, p.y) && Xn(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }
    for (; f && f.z <= h; ) {
      if (f !== i59.prev && f !== i59.next && Ph(r.x, r.y, o.x, o.y, s.x, s.y, f.x, f.y) && Xn(f.prev, f, f.next) >= 0) return false;
      f = f.nextZ;
    }
    return true;
  }
  function xre(i59, t, e) {
    let n = i59;
    do {
      let r = n.prev, o = n.next.next;
      !Gx(r, o) && mU(r, n, n.next, o) && rg(r, o) && rg(o, r) && (t.push(r.i / e), t.push(n.i / e), t.push(o.i / e), og(n), og(n.next), n = i59 = o), n = n.next;
    } while (n !== i59);
    return Al(n);
  }
  function wre(i59, t, e, n, r, o) {
    let s = i59;
    do {
      let a = s.next.next;
      for (; a !== s.prev; ) {
        if (s.i !== a.i && Rre(s, a)) {
          let l = gU(s, a);
          s = Al(s, s.next), l = Al(l, l.next), ig(s, t, e, n, r, o), ig(l, t, e, n, r, o);
          return;
        }
        a = a.next;
      }
      s = s.next;
    } while (s !== i59);
  }
  function Cre(i59, t, e, n) {
    let r = [], o, s, a, l, c;
    for (o = 0, s = t.length; o < s; o++) a = t[o] * n, l = o < s - 1 ? t[o + 1] * n : i59.length, c = fU(i59, a, l, n, false), c === c.next && (c.steiner = true), r.push(Pre(c));
    for (r.sort(Sre), o = 0; o < r.length; o++) Mre(r[o], e), e = Al(e, e.next);
    return e;
  }
  function Sre(i59, t) {
    return i59.x - t.x;
  }
  function Mre(i59, t) {
    if (t = Ere(i59, t), t) {
      let e = gU(t, i59);
      Al(t, t.next), Al(e, e.next);
    }
  }
  function Ere(i59, t) {
    let e = t, n = i59.x, r = i59.y, o = -1 / 0, s;
    do {
      if (r <= e.y && r >= e.next.y && e.next.y !== e.y) {
        let h = e.x + (r - e.y) * (e.next.x - e.x) / (e.next.y - e.y);
        if (h <= n && h > o) {
          if (o = h, h === n) {
            if (r === e.y) return e;
            if (r === e.next.y) return e.next;
          }
          s = e.x < e.next.x ? e : e.next;
        }
      }
      e = e.next;
    } while (e !== t);
    if (!s) return null;
    if (n === o) return s;
    let a = s, l = s.x, c = s.y, d = 1 / 0, u;
    e = s;
    do
      n >= e.x && e.x >= l && n !== e.x && Ph(r < c ? n : o, r, l, c, r < c ? o : n, r, e.x, e.y) && (u = Math.abs(r - e.y) / (n - e.x), rg(e, i59) && (u < d || u === d && (e.x > s.x || e.x === s.x && Tre(s, e))) && (s = e, d = u)), e = e.next;
    while (e !== a);
    return s;
  }
  function Tre(i59, t) {
    return Xn(i59.prev, i59, t.prev) < 0 && Xn(t.next, i59, i59.next) < 0;
  }
  function Ire(i59, t, e, n) {
    let r = i59;
    do
      r.z === null && (r.z = S1(r.x, r.y, t, e, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
    while (r !== i59);
    r.prevZ.nextZ = null, r.prevZ = null, Dre(r);
  }
  function Dre(i59) {
    let t, e, n, r, o, s, a, l, c = 1;
    do {
      for (e = i59, i59 = null, o = null, s = 0; e; ) {
        for (s++, n = e, a = 0, t = 0; t < c && (a++, n = n.nextZ, !!n); t++) ;
        for (l = c; a > 0 || l > 0 && n; ) a !== 0 && (l === 0 || !n || e.z <= n.z) ? (r = e, e = e.nextZ, a--) : (r = n, n = n.nextZ, l--), o ? o.nextZ = r : i59 = r, r.prevZ = o, o = r;
        e = n;
      }
      o.nextZ = null, c *= 2;
    } while (s > 1);
    return i59;
  }
  function S1(i59, t, e, n, r) {
    return i59 = 32767 * (i59 - e) * r, t = 32767 * (t - n) * r, i59 = (i59 | i59 << 8) & 16711935, i59 = (i59 | i59 << 4) & 252645135, i59 = (i59 | i59 << 2) & 858993459, i59 = (i59 | i59 << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i59 | t << 1;
  }
  function Pre(i59) {
    let t = i59, e = i59;
    do
      (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next;
    while (t !== i59);
    return e;
  }
  function Ph(i59, t, e, n, r, o, s, a) {
    return (r - s) * (t - a) - (i59 - s) * (o - a) >= 0 && (i59 - s) * (n - a) - (e - s) * (t - a) >= 0 && (e - s) * (o - a) - (r - s) * (n - a) >= 0;
  }
  function Rre(i59, t) {
    return i59.next.i !== t.i && i59.prev.i !== t.i && !Ore(i59, t) && (rg(i59, t) && rg(t, i59) && Are(i59, t) && (Xn(i59.prev, i59, t.prev) || Xn(i59, t.prev, t)) || Gx(i59, t) && Xn(i59.prev, i59, i59.next) > 0 && Xn(t.prev, t, t.next) > 0);
  }
  function Xn(i59, t, e) {
    return (t.y - i59.y) * (e.x - t.x) - (t.x - i59.x) * (e.y - t.y);
  }
  function Gx(i59, t) {
    return i59.x === t.x && i59.y === t.y;
  }
  function mU(i59, t, e, n) {
    let r = A0(Xn(i59, t, e)), o = A0(Xn(i59, t, n)), s = A0(Xn(e, n, i59)), a = A0(Xn(e, n, t));
    return !!(r !== o && s !== a || r === 0 && O0(i59, e, t) || o === 0 && O0(i59, n, t) || s === 0 && O0(e, i59, n) || a === 0 && O0(e, t, n));
  }
  function O0(i59, t, e) {
    return t.x <= Math.max(i59.x, e.x) && t.x >= Math.min(i59.x, e.x) && t.y <= Math.max(i59.y, e.y) && t.y >= Math.min(i59.y, e.y);
  }
  function A0(i59) {
    return i59 > 0 ? 1 : i59 < 0 ? -1 : 0;
  }
  function Ore(i59, t) {
    let e = i59;
    do {
      if (e.i !== i59.i && e.next.i !== i59.i && e.i !== t.i && e.next.i !== t.i && mU(e, e.next, i59, t)) return true;
      e = e.next;
    } while (e !== i59);
    return false;
  }
  function rg(i59, t) {
    return Xn(i59.prev, i59, i59.next) < 0 ? Xn(i59, t, i59.next) >= 0 && Xn(i59, i59.prev, t) >= 0 : Xn(i59, t, i59.prev) < 0 || Xn(i59, i59.next, t) < 0;
  }
  function Are(i59, t) {
    let e = i59, n = false, r = (i59.x + t.x) / 2, o = (i59.y + t.y) / 2;
    do
      e.y > o != e.next.y > o && e.next.y !== e.y && r < (e.next.x - e.x) * (o - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next;
    while (e !== i59);
    return n;
  }
  function gU(i59, t) {
    let e = new M1(i59.i, i59.x, i59.y), n = new M1(t.i, t.x, t.y), r = i59.next, o = t.prev;
    return i59.next = t, t.prev = i59, e.next = r, r.prev = e, n.next = e, e.prev = n, o.next = n, n.prev = o, n;
  }
  function ZB(i59, t, e, n) {
    let r = new M1(i59, t, e);
    return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r;
  }
  function og(i59) {
    i59.next.prev = i59.prev, i59.prev.next = i59.next, i59.prevZ && (i59.prevZ.nextZ = i59.nextZ), i59.nextZ && (i59.nextZ.prevZ = i59.prevZ);
  }
  function M1(i59, t, e) {
    this.i = i59, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  function Nre(i59, t, e, n) {
    let r = 0;
    for (let o = t, s = e - n; o < e; o += n) r += (i59[s] - i59[o]) * (i59[o + 1] + i59[s + 1]), s = o;
    return r;
  }
  var Bs = class i46 {
    static area(t) {
      let e = t.length, n = 0;
      for (let r = e - 1, o = 0; o < e; r = o++) n += t[r].x * t[o].y - t[o].x * t[r].y;
      return n * 0.5;
    }
    static isClockWise(t) {
      return i46.area(t) < 0;
    }
    static triangulateShape(t, e) {
      let n = [], r = [], o = [];
      QB(t), KB(n, t);
      let s = t.length;
      e.forEach(QB);
      for (let l = 0; l < e.length; l++) r.push(s), s += e[l].length, KB(n, e[l]);
      let a = vre.triangulate(n, r);
      for (let l = 0; l < a.length; l += 3) o.push(a.slice(l, l + 3));
      return o;
    }
  };
  function QB(i59) {
    let t = i59.length;
    t > 2 && i59[t - 1].equals(i59[0]) && i59.pop();
  }
  function KB(i59, t) {
    for (let e = 0; e < t.length; e++) i59.push(t[e].x), i59.push(t[e].y);
  }
  var Ba = class i47 extends Ct {
    constructor(t = new ko([new Me(0.5, 0.5), new Me(-0.5, 0.5), new Me(-0.5, -0.5), new Me(0.5, -0.5)]), e = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t];
      let n = this, r = [], o = [];
      for (let a = 0, l = t.length; a < l; a++) {
        let c = t[a];
        s(c);
      }
      this.setAttribute("position", new it(r, 3)), this.setAttribute("uv", new it(o, 2)), this.computeVertexNormals();
      function s(a) {
        let l = [], c = e.curveSegments !== void 0 ? e.curveSegments : 12, d = e.steps !== void 0 ? e.steps : 1, u = e.depth !== void 0 ? e.depth : 1, h = e.bevelEnabled !== void 0 ? e.bevelEnabled : true, p = e.bevelThickness !== void 0 ? e.bevelThickness : 0.2, f = e.bevelSize !== void 0 ? e.bevelSize : p - 0.1, m = e.bevelOffset !== void 0 ? e.bevelOffset : 0, v = e.bevelSegments !== void 0 ? e.bevelSegments : 3, _ = e.extrudePath, g = e.UVGenerator !== void 0 ? e.UVGenerator : kre;
        e.amount !== void 0 && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), u = e.amount);
        let y, w = false, E, P, S, A;
        _ && (y = _.getSpacedPoints(d), w = true, h = false, E = _.computeFrenetFrames(d, false), P = new L(), S = new L(), A = new L()), h || (v = 0, p = 0, f = 0, m = 0);
        let W = a.extractPoints(c), H = W.shape, O = W.holes;
        if (!Bs.isClockWise(H)) {
          H = H.reverse();
          for (let te = 0, fe = O.length; te < fe; te++) {
            let ge = O[te];
            Bs.isClockWise(ge) && (O[te] = ge.reverse());
          }
        }
        let F = Bs.triangulateShape(H, O), j = H;
        for (let te = 0, fe = O.length; te < fe; te++) {
          let ge = O[te];
          H = H.concat(ge);
        }
        function $(te, fe, ge) {
          return fe || console.error("THREE.ExtrudeGeometry: vec does not exist"), fe.clone().multiplyScalar(ge).add(te);
        }
        let k = H.length, z = F.length;
        function R(te, fe, ge) {
          let Ne, Se, B, N = te.x - fe.x, se = te.y - fe.y, Le = ge.x - te.x, ke = ge.y - te.y, Xe = N * N + se * se, bt = N * ke - se * Le;
          if (Math.abs(bt) > Number.EPSILON) {
            let ft = Math.sqrt(Xe), Dt = Math.sqrt(Le * Le + ke * ke), st = fe.x - se / ft, J = fe.y + N / ft, je = ge.x - ke / Dt, Te = ge.y + Le / Dt, rt = ((je - st) * ke - (Te - J) * Le) / (N * ke - se * Le);
            Ne = st + N * rt - te.x, Se = J + se * rt - te.y;
            let ot = Ne * Ne + Se * Se;
            if (ot <= 2) return new Me(Ne, Se);
            B = Math.sqrt(ot / 2);
          } else {
            let ft = false;
            N > Number.EPSILON ? Le > Number.EPSILON && (ft = true) : N < -Number.EPSILON ? Le < -Number.EPSILON && (ft = true) : Math.sign(se) === Math.sign(ke) && (ft = true), ft ? (Ne = -se, Se = N, B = Math.sqrt(Xe)) : (Ne = N, Se = se, B = Math.sqrt(Xe / 2));
          }
          return new Me(Ne / B, Se / B);
        }
        let V = [];
        for (let te = 0, fe = j.length, ge = fe - 1, Ne = te + 1; te < fe; te++, ge++, Ne++) ge === fe && (ge = 0), Ne === fe && (Ne = 0), V[te] = R(j[te], j[ge], j[Ne]);
        let ie = [], re, Re = V.concat();
        for (let te = 0, fe = O.length; te < fe; te++) {
          let ge = O[te];
          re = [];
          for (let Ne = 0, Se = ge.length, B = Se - 1, N = Ne + 1; Ne < Se; Ne++, B++, N++) B === Se && (B = 0), N === Se && (N = 0), re[Ne] = R(ge[Ne], ge[B], ge[N]);
          ie.push(re), Re = Re.concat(re);
        }
        for (let te = 0; te < v; te++) {
          let fe = te / v, ge = p * Math.cos(fe * Math.PI / 2), Ne = f * Math.sin(fe * Math.PI / 2) + m;
          for (let Se = 0, B = j.length; Se < B; Se++) {
            let N = $(j[Se], V[Se], Ne);
            Ve(N.x, N.y, -ge);
          }
          for (let Se = 0, B = O.length; Se < B; Se++) {
            let N = O[Se];
            re = ie[Se];
            for (let se = 0, Le = N.length; se < Le; se++) {
              let ke = $(N[se], re[se], Ne);
              Ve(ke.x, ke.y, -ge);
            }
          }
        }
        let ne = f + m;
        for (let te = 0; te < k; te++) {
          let fe = h ? $(H[te], Re[te], ne) : H[te];
          w ? (S.copy(E.normals[0]).multiplyScalar(fe.x), P.copy(E.binormals[0]).multiplyScalar(fe.y), A.copy(y[0]).add(S).add(P), Ve(A.x, A.y, A.z)) : Ve(fe.x, fe.y, 0);
        }
        for (let te = 1; te <= d; te++) for (let fe = 0; fe < k; fe++) {
          let ge = h ? $(H[fe], Re[fe], ne) : H[fe];
          w ? (S.copy(E.normals[te]).multiplyScalar(ge.x), P.copy(E.binormals[te]).multiplyScalar(ge.y), A.copy(y[te]).add(S).add(P), Ve(A.x, A.y, A.z)) : Ve(ge.x, ge.y, u / d * te);
        }
        for (let te = v - 1; te >= 0; te--) {
          let fe = te / v, ge = p * Math.cos(fe * Math.PI / 2), Ne = f * Math.sin(fe * Math.PI / 2) + m;
          for (let Se = 0, B = j.length; Se < B; Se++) {
            let N = $(j[Se], V[Se], Ne);
            Ve(N.x, N.y, u + ge);
          }
          for (let Se = 0, B = O.length; Se < B; Se++) {
            let N = O[Se];
            re = ie[Se];
            for (let se = 0, Le = N.length; se < Le; se++) {
              let ke = $(N[se], re[se], Ne);
              w ? Ve(ke.x, ke.y + y[d - 1].y, y[d - 1].x + ge) : Ve(ke.x, ke.y, u + ge);
            }
          }
        }
        oe(), Be();
        function oe() {
          let te = r.length / 3;
          if (h) {
            let fe = 0, ge = k * fe;
            for (let Ne = 0; Ne < z; Ne++) {
              let Se = F[Ne];
              ue(Se[2] + ge, Se[1] + ge, Se[0] + ge);
            }
            fe = d + v * 2, ge = k * fe;
            for (let Ne = 0; Ne < z; Ne++) {
              let Se = F[Ne];
              ue(Se[0] + ge, Se[1] + ge, Se[2] + ge);
            }
          } else {
            for (let fe = 0; fe < z; fe++) {
              let ge = F[fe];
              ue(ge[2], ge[1], ge[0]);
            }
            for (let fe = 0; fe < z; fe++) {
              let ge = F[fe];
              ue(ge[0] + k * d, ge[1] + k * d, ge[2] + k * d);
            }
          }
          n.addGroup(te, r.length / 3 - te, 0);
        }
        function Be() {
          let te = r.length / 3, fe = 0;
          me(j, fe), fe += j.length;
          for (let ge = 0, Ne = O.length; ge < Ne; ge++) {
            let Se = O[ge];
            me(Se, fe), fe += Se.length;
          }
          n.addGroup(te, r.length / 3 - te, 1);
        }
        function me(te, fe) {
          let ge = te.length;
          for (; --ge >= 0; ) {
            let Ne = ge, Se = ge - 1;
            Se < 0 && (Se = te.length - 1);
            for (let B = 0, N = d + v * 2; B < N; B++) {
              let se = k * B, Le = k * (B + 1), ke = fe + Ne + se, Xe = fe + Se + se, bt = fe + Se + Le, ft = fe + Ne + Le;
              ee(ke, Xe, bt, ft);
            }
          }
        }
        function Ve(te, fe, ge) {
          l.push(te), l.push(fe), l.push(ge);
        }
        function ue(te, fe, ge) {
          Q(te), Q(fe), Q(ge);
          let Ne = r.length / 3, Se = g.generateTopUV(n, r, Ne - 3, Ne - 2, Ne - 1);
          _e(Se[0]), _e(Se[1]), _e(Se[2]);
        }
        function ee(te, fe, ge, Ne) {
          Q(te), Q(fe), Q(Ne), Q(fe), Q(ge), Q(Ne);
          let Se = r.length / 3, B = g.generateSideWallUV(n, r, Se - 6, Se - 3, Se - 2, Se - 1);
          _e(B[0]), _e(B[1]), _e(B[3]), _e(B[1]), _e(B[2]), _e(B[3]);
        }
        function Q(te) {
          r.push(l[te * 3 + 0]), r.push(l[te * 3 + 1]), r.push(l[te * 3 + 2]);
        }
        function _e(te) {
          o.push(te.x), o.push(te.y);
        }
      }
    }
    toJSON() {
      let t = super.toJSON(), e = this.parameters.shapes, n = this.parameters.options;
      return Lre(e, n, t);
    }
    static fromJSON(t, e) {
      let n = [];
      for (let o = 0, s = t.shapes.length; o < s; o++) {
        let a = e[t.shapes[o]];
        n.push(a);
      }
      let r = t.options.extrudePath;
      return r !== void 0 && (t.options.extrudePath = new cD[r.type]().fromJSON(r)), new i47(n, t.options);
    }
  };
  var kre = { generateTopUV: function(i59, t, e, n, r) {
    let o = t[e * 3], s = t[e * 3 + 1], a = t[n * 3], l = t[n * 3 + 1], c = t[r * 3], d = t[r * 3 + 1];
    return [new Me(o, s), new Me(a, l), new Me(c, d)];
  }, generateSideWallUV: function(i59, t, e, n, r, o) {
    let s = t[e * 3], a = t[e * 3 + 1], l = t[e * 3 + 2], c = t[n * 3], d = t[n * 3 + 1], u = t[n * 3 + 2], h = t[r * 3], p = t[r * 3 + 1], f = t[r * 3 + 2], m = t[o * 3], v = t[o * 3 + 1], _ = t[o * 3 + 2];
    return Math.abs(a - d) < Math.abs(s - c) ? [new Me(s, 1 - l), new Me(c, 1 - u), new Me(h, 1 - f), new Me(m, 1 - _)] : [new Me(a, 1 - l), new Me(d, 1 - u), new Me(p, 1 - f), new Me(v, 1 - _)];
  } };
  function Lre(i59, t, e) {
    if (e.shapes = [], Array.isArray(i59)) for (let n = 0, r = i59.length; n < r; n++) {
      let o = i59[n];
      e.shapes.push(o.uuid);
    }
    else e.shapes.push(i59.uuid);
    return t.extrudePath !== void 0 && (e.options.extrudePath = t.extrudePath.toJSON()), e;
  }
  var sg = class i48 extends Fa {
    constructor(t = 1, e = 0) {
      let n = (1 + Math.sqrt(5)) / 2, r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      super(r, o, t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e };
    }
    static fromJSON(t) {
      return new i48(t.radius, t.detail);
    }
  };
  var ag = class i49 extends Ct {
    constructor(t = [new Me(0, 0.5), new Me(0.5, 0), new Me(0, -0.5)], e = 12, n = 0, r = Math.PI * 2) {
      super(), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }, e = Math.floor(e), r = tr(r, 0, Math.PI * 2);
      let o = [], s = [], a = [], l = 1 / e, c = new L(), d = new Me();
      for (let u = 0; u <= e; u++) {
        let h = n + u * l * r, p = Math.sin(h), f = Math.cos(h);
        for (let m = 0; m <= t.length - 1; m++) c.x = t[m].x * p, c.y = t[m].y, c.z = t[m].x * f, s.push(c.x, c.y, c.z), d.x = u / e, d.y = m / (t.length - 1), a.push(d.x, d.y);
      }
      for (let u = 0; u < e; u++) for (let h = 0; h < t.length - 1; h++) {
        let p = h + u * t.length, f = p, m = p + t.length, v = p + t.length + 1, _ = p + 1;
        o.push(f, m, _), o.push(m, v, _);
      }
      if (this.setIndex(o), this.setAttribute("position", new it(s, 3)), this.setAttribute("uv", new it(a, 2)), this.computeVertexNormals(), r === Math.PI * 2) {
        let u = this.attributes.normal.array, h = new L(), p = new L(), f = new L(), m = e * t.length * 3;
        for (let v = 0, _ = 0; v < t.length; v++, _ += 3) h.x = u[_ + 0], h.y = u[_ + 1], h.z = u[_ + 2], p.x = u[m + _ + 0], p.y = u[m + _ + 1], p.z = u[m + _ + 2], f.addVectors(h, p).normalize(), u[_ + 0] = u[m + _ + 0] = f.x, u[_ + 1] = u[m + _ + 1] = f.y, u[_ + 2] = u[m + _ + 2] = f.z;
      }
    }
    static fromJSON(t) {
      return new i49(t.points, t.segments, t.phiStart, t.phiLength);
    }
  };
  var tp = class i50 extends Fa {
    constructor(t = 1, e = 0) {
      let n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      super(n, r, t, e), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e };
    }
    static fromJSON(t) {
      return new i50(t.radius, t.detail);
    }
  };
  var lg = class i51 extends Ct {
    constructor(t = 0.5, e = 1, n = 8, r = 1, o = 0, s = Math.PI * 2) {
      super(), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: r, thetaStart: o, thetaLength: s }, n = Math.max(3, n), r = Math.max(1, r);
      let a = [], l = [], c = [], d = [], u = t, h = (e - t) / r, p = new L(), f = new Me();
      for (let m = 0; m <= r; m++) {
        for (let v = 0; v <= n; v++) {
          let _ = o + v / n * s;
          p.x = u * Math.cos(_), p.y = u * Math.sin(_), l.push(p.x, p.y, p.z), c.push(0, 0, 1), f.x = (p.x / e + 1) / 2, f.y = (p.y / e + 1) / 2, d.push(f.x, f.y);
        }
        u += h;
      }
      for (let m = 0; m < r; m++) {
        let v = m * (n + 1);
        for (let _ = 0; _ < n; _++) {
          let g = _ + v, y = g, w = g + n + 1, E = g + n + 2, P = g + 1;
          a.push(y, w, P), a.push(w, E, P);
        }
      }
      this.setIndex(a), this.setAttribute("position", new it(l, 3)), this.setAttribute("normal", new it(c, 3)), this.setAttribute("uv", new it(d, 2));
    }
    static fromJSON(t) {
      return new i51(t.innerRadius, t.outerRadius, t.thetaSegments, t.phiSegments, t.thetaStart, t.thetaLength);
    }
  };
  var np = class i52 extends Ct {
    constructor(t = new ko([new Me(0, 0.5), new Me(-0.5, -0.5), new Me(0.5, -0.5)]), e = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = { shapes: t, curveSegments: e };
      let n = [], r = [], o = [], s = [], a = 0, l = 0;
      if (Array.isArray(t) === false) c(t);
      else for (let d = 0; d < t.length; d++) c(t[d]), this.addGroup(a, l, d), a += l, l = 0;
      this.setIndex(n), this.setAttribute("position", new it(r, 3)), this.setAttribute("normal", new it(o, 3)), this.setAttribute("uv", new it(s, 2));
      function c(d) {
        let u = r.length / 3, h = d.extractPoints(e), p = h.shape, f = h.holes;
        Bs.isClockWise(p) === false && (p = p.reverse());
        for (let v = 0, _ = f.length; v < _; v++) {
          let g = f[v];
          Bs.isClockWise(g) === true && (f[v] = g.reverse());
        }
        let m = Bs.triangulateShape(p, f);
        for (let v = 0, _ = f.length; v < _; v++) {
          let g = f[v];
          p = p.concat(g);
        }
        for (let v = 0, _ = p.length; v < _; v++) {
          let g = p[v];
          r.push(g.x, g.y, 0), o.push(0, 0, 1), s.push(g.x, g.y);
        }
        for (let v = 0, _ = m.length; v < _; v++) {
          let g = m[v], y = g[0] + u, w = g[1] + u, E = g[2] + u;
          n.push(y, w, E), l += 3;
        }
      }
    }
    toJSON() {
      let t = super.toJSON(), e = this.parameters.shapes;
      return Fre(e, t);
    }
    static fromJSON(t, e) {
      let n = [];
      for (let r = 0, o = t.shapes.length; r < o; r++) {
        let s = e[t.shapes[r]];
        n.push(s);
      }
      return new i52(n, t.curveSegments);
    }
  };
  function Fre(i59, t) {
    if (t.shapes = [], Array.isArray(i59)) for (let e = 0, n = i59.length; e < n; e++) {
      let r = i59[e];
      t.shapes.push(r.uuid);
    }
    else t.shapes.push(i59.uuid);
    return t;
  }
  var ip = class i53 extends Ct {
    constructor(t = 1, e = 32, n = 16, r = 0, o = Math.PI * 2, s = 0, a = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: o, thetaStart: s, thetaLength: a }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n));
      let l = Math.min(s + a, Math.PI), c = 0, d = [], u = new L(), h = new L(), p = [], f = [], m = [], v = [];
      for (let _ = 0; _ <= n; _++) {
        let g = [], y = _ / n, w = 0;
        _ == 0 && s == 0 ? w = 0.5 / e : _ == n && l == Math.PI && (w = -0.5 / e);
        for (let E = 0; E <= e; E++) {
          let P = E / e;
          u.x = -t * Math.cos(r + P * o) * Math.sin(s + y * a), u.y = t * Math.cos(s + y * a), u.z = t * Math.sin(r + P * o) * Math.sin(s + y * a), f.push(u.x, u.y, u.z), h.copy(u).normalize(), m.push(h.x, h.y, h.z), v.push(P + w, 1 - y), g.push(c++);
        }
        d.push(g);
      }
      for (let _ = 0; _ < n; _++) for (let g = 0; g < e; g++) {
        let y = d[_][g + 1], w = d[_][g], E = d[_ + 1][g], P = d[_ + 1][g + 1];
        (_ !== 0 || s > 0) && p.push(y, w, P), (_ !== n - 1 || l < Math.PI) && p.push(w, E, P);
      }
      this.setIndex(p), this.setAttribute("position", new it(f, 3)), this.setAttribute("normal", new it(m, 3)), this.setAttribute("uv", new it(v, 2));
    }
    static fromJSON(t) {
      return new i53(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength);
    }
  };
  var cg = class i54 extends Fa {
    constructor(t = 1, e = 0) {
      let n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      super(n, r, t, e), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e };
    }
    static fromJSON(t) {
      return new i54(t.radius, t.detail);
    }
  };
  var dg = class i55 extends Ct {
    constructor(t = 1, e = 0.4, n = 8, r = 6, o = Math.PI * 2) {
      super(), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: n, tubularSegments: r, arc: o }, n = Math.floor(n), r = Math.floor(r);
      let s = [], a = [], l = [], c = [], d = new L(), u = new L(), h = new L();
      for (let p = 0; p <= n; p++) for (let f = 0; f <= r; f++) {
        let m = f / r * o, v = p / n * Math.PI * 2;
        u.x = (t + e * Math.cos(v)) * Math.cos(m), u.y = (t + e * Math.cos(v)) * Math.sin(m), u.z = e * Math.sin(v), a.push(u.x, u.y, u.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), h.subVectors(u, d).normalize(), l.push(h.x, h.y, h.z), c.push(f / r), c.push(p / n);
      }
      for (let p = 1; p <= n; p++) for (let f = 1; f <= r; f++) {
        let m = (r + 1) * p + f - 1, v = (r + 1) * (p - 1) + f - 1, _ = (r + 1) * (p - 1) + f, g = (r + 1) * p + f;
        s.push(m, v, g), s.push(v, _, g);
      }
      this.setIndex(s), this.setAttribute("position", new it(a, 3)), this.setAttribute("normal", new it(l, 3)), this.setAttribute("uv", new it(c, 2));
    }
    static fromJSON(t) {
      return new i55(t.radius, t.tube, t.radialSegments, t.tubularSegments, t.arc);
    }
  };
  var ug = class i56 extends Ct {
    constructor(t = 1, e = 0.4, n = 64, r = 8, o = 2, s = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: r, p: o, q: s }, n = Math.floor(n), r = Math.floor(r);
      let a = [], l = [], c = [], d = [], u = new L(), h = new L(), p = new L(), f = new L(), m = new L(), v = new L(), _ = new L();
      for (let y = 0; y <= n; ++y) {
        let w = y / n * o * Math.PI * 2;
        g(w, o, s, t, p), g(w + 0.01, o, s, t, f), v.subVectors(f, p), _.addVectors(f, p), m.crossVectors(v, _), _.crossVectors(m, v), m.normalize(), _.normalize();
        for (let E = 0; E <= r; ++E) {
          let P = E / r * Math.PI * 2, S = -e * Math.cos(P), A = e * Math.sin(P);
          u.x = p.x + (S * _.x + A * m.x), u.y = p.y + (S * _.y + A * m.y), u.z = p.z + (S * _.z + A * m.z), l.push(u.x, u.y, u.z), h.subVectors(u, p).normalize(), c.push(h.x, h.y, h.z), d.push(y / n), d.push(E / r);
        }
      }
      for (let y = 1; y <= n; y++) for (let w = 1; w <= r; w++) {
        let E = (r + 1) * (y - 1) + (w - 1), P = (r + 1) * y + (w - 1), S = (r + 1) * y + w, A = (r + 1) * (y - 1) + w;
        a.push(E, P, A), a.push(P, S, A);
      }
      this.setIndex(a), this.setAttribute("position", new it(l, 3)), this.setAttribute("normal", new it(c, 3)), this.setAttribute("uv", new it(d, 2));
      function g(y, w, E, P, S) {
        let A = Math.cos(y), W = Math.sin(y), H = E / w * y, O = Math.cos(H);
        S.x = P * (2 + O) * 0.5 * A, S.y = P * (2 + O) * W * 0.5, S.z = P * Math.sin(H) * 0.5;
      }
    }
    static fromJSON(t) {
      return new i56(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q);
    }
  };
  var hg = class i57 extends Ct {
    constructor(t = new Jh(new L(-1, -1, 0), new L(-1, 1, 0), new L(1, 1, 0)), e = 64, n = 1, r = 8, o = false) {
      super(), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: r, closed: o };
      let s = t.computeFrenetFrames(e, o);
      this.tangents = s.tangents, this.normals = s.normals, this.binormals = s.binormals;
      let a = new L(), l = new L(), c = new Me(), d = new L(), u = [], h = [], p = [], f = [];
      m(), this.setIndex(f), this.setAttribute("position", new it(u, 3)), this.setAttribute("normal", new it(h, 3)), this.setAttribute("uv", new it(p, 2));
      function m() {
        for (let y = 0; y < e; y++) v(y);
        v(o === false ? e : 0), g(), _();
      }
      function v(y) {
        d = t.getPointAt(y / e, d);
        let w = s.normals[y], E = s.binormals[y];
        for (let P = 0; P <= r; P++) {
          let S = P / r * Math.PI * 2, A = Math.sin(S), W = -Math.cos(S);
          l.x = W * w.x + A * E.x, l.y = W * w.y + A * E.y, l.z = W * w.z + A * E.z, l.normalize(), h.push(l.x, l.y, l.z), a.x = d.x + n * l.x, a.y = d.y + n * l.y, a.z = d.z + n * l.z, u.push(a.x, a.y, a.z);
        }
      }
      function _() {
        for (let y = 1; y <= e; y++) for (let w = 1; w <= r; w++) {
          let E = (r + 1) * (y - 1) + (w - 1), P = (r + 1) * y + (w - 1), S = (r + 1) * y + w, A = (r + 1) * (y - 1) + w;
          f.push(E, P, A), f.push(P, S, A);
        }
      }
      function g() {
        for (let y = 0; y <= e; y++) for (let w = 0; w <= r; w++) c.x = y / e, c.y = w / r, p.push(c.x, c.y);
      }
    }
    toJSON() {
      let t = super.toJSON();
      return t.path = this.parameters.path.toJSON(), t;
    }
    static fromJSON(t) {
      return new i57(new cD[t.path.type]().fromJSON(t.path), t.tubularSegments, t.radius, t.radialSegments, t.closed);
    }
  };
  var pg = class extends Ct {
    constructor(t = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: t }, t !== null) {
        let e = [], n = /* @__PURE__ */ new Set(), r = new L(), o = new L();
        if (t.index !== null) {
          let s = t.attributes.position, a = t.index, l = t.groups;
          l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
          for (let c = 0, d = l.length; c < d; ++c) {
            let u = l[c], h = u.start, p = u.count;
            for (let f = h, m = h + p; f < m; f += 3) for (let v = 0; v < 3; v++) {
              let _ = a.getX(f + v), g = a.getX(f + (v + 1) % 3);
              r.fromBufferAttribute(s, _), o.fromBufferAttribute(s, g), JB(r, o, n) === true && (e.push(r.x, r.y, r.z), e.push(o.x, o.y, o.z));
            }
          }
        } else {
          let s = t.attributes.position;
          for (let a = 0, l = s.count / 3; a < l; a++) for (let c = 0; c < 3; c++) {
            let d = 3 * a + c, u = 3 * a + (c + 1) % 3;
            r.fromBufferAttribute(s, d), o.fromBufferAttribute(s, u), JB(r, o, n) === true && (e.push(r.x, r.y, r.z), e.push(o.x, o.y, o.z));
          }
        }
        this.setAttribute("position", new it(e, 3));
      }
    }
  };
  function JB(i59, t, e) {
    let n = `${i59.x},${i59.y},${i59.z}-${t.x},${t.y},${t.z}`, r = `${t.x},${t.y},${t.z}-${i59.x},${i59.y},${i59.z}`;
    return e.has(n) === true || e.has(r) === true ? false : (e.add(n, r), true);
  }
  var eV = Object.freeze({ __proto__: null, BoxGeometry: Il, BoxBufferGeometry: Il, CircleGeometry: Zm, CircleBufferGeometry: Zm, ConeGeometry: Qm, ConeBufferGeometry: Qm, CylinderGeometry: Ed, CylinderBufferGeometry: Ed, DodecahedronGeometry: Km, DodecahedronBufferGeometry: Km, EdgesGeometry: Jm, ExtrudeGeometry: Ba, ExtrudeBufferGeometry: Ba, IcosahedronGeometry: sg, IcosahedronBufferGeometry: sg, LatheGeometry: ag, LatheBufferGeometry: ag, OctahedronGeometry: tp, OctahedronBufferGeometry: tp, PlaneGeometry: Gh, PlaneBufferGeometry: Gh, PolyhedronGeometry: Fa, PolyhedronBufferGeometry: Fa, RingGeometry: lg, RingBufferGeometry: lg, ShapeGeometry: np, ShapeBufferGeometry: np, SphereGeometry: ip, SphereBufferGeometry: ip, TetrahedronGeometry: cg, TetrahedronBufferGeometry: cg, TorusGeometry: dg, TorusBufferGeometry: dg, TorusKnotGeometry: ug, TorusKnotBufferGeometry: ug, TubeGeometry: hg, TubeBufferGeometry: hg, WireframeGeometry: pg });
  var fg = class extends Mi {
    constructor(t) {
      super(), this.type = "ShadowMaterial", this.color = new Ye(0), this.transparent = true, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this;
    }
  };
  fg.prototype.isShadowMaterial = true;
  var rp = class extends Mi {
    constructor(t) {
      super(), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ye(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vd, this.normalScale = new Me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
    }
  };
  rp.prototype.isMeshStandardMaterial = true;
  var mg = class extends rp {
    constructor(t) {
      super(), this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Me(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
        return tr(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      }, set: function(e) {
        this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
      } }), this.sheenColor = new Ye(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0.01, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Ye(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ye(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(t) {
      this._sheen > 0 != t > 0 && this.version++, this._sheen = t;
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(t) {
      this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t;
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(t) {
      this._transmission > 0 != t > 0 && this.version++, this._transmission = t;
    }
    copy(t) {
      return super.copy(t), this.defines = { STANDARD: "", PHYSICAL: "" }, this.clearcoat = t.clearcoat, this.clearcoatMap = t.clearcoatMap, this.clearcoatRoughness = t.clearcoatRoughness, this.clearcoatRoughnessMap = t.clearcoatRoughnessMap, this.clearcoatNormalMap = t.clearcoatNormalMap, this.clearcoatNormalScale.copy(t.clearcoatNormalScale), this.ior = t.ior, this.sheen = t.sheen, this.sheenColor.copy(t.sheenColor), this.sheenColorMap = t.sheenColorMap, this.sheenRoughness = t.sheenRoughness, this.sheenRoughnessMap = t.sheenRoughnessMap, this.transmission = t.transmission, this.transmissionMap = t.transmissionMap, this.thickness = t.thickness, this.thicknessMap = t.thicknessMap, this.attenuationDistance = t.attenuationDistance, this.attenuationColor.copy(t.attenuationColor), this.specularIntensity = t.specularIntensity, this.specularIntensityMap = t.specularIntensityMap, this.specularColor.copy(t.specularColor), this.specularColorMap = t.specularColorMap, this;
    }
  };
  mg.prototype.isMeshPhysicalMaterial = true;
  var gg = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshPhongMaterial", this.color = new Ye(16777215), this.specular = new Ye(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vd, this.normalScale = new Me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this;
    }
  };
  gg.prototype.isMeshPhongMaterial = true;
  var _g = class extends Mi {
    constructor(t) {
      super(), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ye(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vd, this.normalScale = new Me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.gradientMap = t.gradientMap, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
  };
  _g.prototype.isMeshToonMaterial = true;
  var vg = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vd, this.normalScale = new Me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.flatShading = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.flatShading = t.flatShading, this;
    }
  };
  vg.prototype.isMeshNormalMaterial = true;
  var yg = class extends Mi {
    constructor(t) {
      super(), this.type = "MeshLambertMaterial", this.color = new Ye(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ye(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = kg, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this;
    }
  };
  yg.prototype.isMeshLambertMaterial = true;
  var bg = class extends Mi {
    constructor(t) {
      super(), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ye(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Vd, this.normalScale = new Me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.flatShading = t.flatShading, this;
    }
  };
  bg.prototype.isMeshMatcapMaterial = true;
  var xg = class extends Ei {
    constructor(t) {
      super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t);
    }
    copy(t) {
      return super.copy(t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this;
    }
  };
  xg.prototype.isLineDashedMaterial = true;
  var Bre = Object.freeze({ __proto__: null, ShadowMaterial: fg, SpriteMaterial: qh, RawShaderMaterial: Pl, ShaderMaterial: cs, PointsMaterial: La, MeshPhysicalMaterial: mg, MeshStandardMaterial: rp, MeshPhongMaterial: gg, MeshToonMaterial: _g, MeshNormalMaterial: vg, MeshLambertMaterial: yg, MeshDepthMaterial: jh, MeshDistanceMaterial: Wh, MeshBasicMaterial: ls, MeshMatcapMaterial: bg, LineDashedMaterial: xg, LineBasicMaterial: Ei, Material: Mi });
  var jn = { arraySlice: function(i59, t, e) {
    return jn.isTypedArray(i59) ? new i59.constructor(i59.subarray(t, e !== void 0 ? e : i59.length)) : i59.slice(t, e);
  }, convertArray: function(i59, t, e) {
    return !i59 || !e && i59.constructor === t ? i59 : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i59) : Array.prototype.slice.call(i59);
  }, isTypedArray: function(i59) {
    return ArrayBuffer.isView(i59) && !(i59 instanceof DataView);
  }, getKeyframeOrder: function(i59) {
    function t(r, o) {
      return i59[r] - i59[o];
    }
    let e = i59.length, n = new Array(e);
    for (let r = 0; r !== e; ++r) n[r] = r;
    return n.sort(t), n;
  }, sortedArray: function(i59, t, e) {
    let n = i59.length, r = new i59.constructor(n);
    for (let o = 0, s = 0; s !== n; ++o) {
      let a = e[o] * t;
      for (let l = 0; l !== t; ++l) r[s++] = i59[a + l];
    }
    return r;
  }, flattenJSON: function(i59, t, e, n) {
    let r = 1, o = i59[0];
    for (; o !== void 0 && o[n] === void 0; ) o = i59[r++];
    if (o === void 0) return;
    let s = o[n];
    if (s !== void 0) if (Array.isArray(s)) do
      s = o[n], s !== void 0 && (t.push(o.time), e.push.apply(e, s)), o = i59[r++];
    while (o !== void 0);
    else if (s.toArray !== void 0) do
      s = o[n], s !== void 0 && (t.push(o.time), s.toArray(e, e.length)), o = i59[r++];
    while (o !== void 0);
    else do
      s = o[n], s !== void 0 && (t.push(o.time), e.push(s)), o = i59[r++];
    while (o !== void 0);
  }, subclip: function(i59, t, e, n, r = 30) {
    let o = i59.clone();
    o.name = t;
    let s = [];
    for (let l = 0; l < o.tracks.length; ++l) {
      let c = o.tracks[l], d = c.getValueSize(), u = [], h = [];
      for (let p = 0; p < c.times.length; ++p) {
        let f = c.times[p] * r;
        if (!(f < e || f >= n)) {
          u.push(c.times[p]);
          for (let m = 0; m < d; ++m) h.push(c.values[p * d + m]);
        }
      }
      u.length !== 0 && (c.times = jn.convertArray(u, c.times.constructor), c.values = jn.convertArray(h, c.values.constructor), s.push(c));
    }
    o.tracks = s;
    let a = 1 / 0;
    for (let l = 0; l < o.tracks.length; ++l) a > o.tracks[l].times[0] && (a = o.tracks[l].times[0]);
    for (let l = 0; l < o.tracks.length; ++l) o.tracks[l].shift(-1 * a);
    return o.resetDuration(), o;
  }, makeClipAdditive: function(i59, t = 0, e = i59, n = 30) {
    n <= 0 && (n = 30);
    let r = e.tracks.length, o = t / n;
    for (let s = 0; s < r; ++s) {
      let a = e.tracks[s], l = a.ValueTypeName;
      if (l === "bool" || l === "string") continue;
      let c = i59.tracks.find(function(_) {
        return _.name === a.name && _.ValueTypeName === l;
      });
      if (c === void 0) continue;
      let d = 0, u = a.getValueSize();
      a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = u / 3);
      let h = 0, p = c.getValueSize();
      c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = p / 3);
      let f = a.times.length - 1, m;
      if (o <= a.times[0]) {
        let _ = d, g = u - d;
        m = jn.arraySlice(a.values, _, g);
      } else if (o >= a.times[f]) {
        let _ = f * u + d, g = _ + u - d;
        m = jn.arraySlice(a.values, _, g);
      } else {
        let _ = a.createInterpolant(), g = d, y = u - d;
        _.evaluate(o), m = jn.arraySlice(_.resultBuffer, g, y);
      }
      l === "quaternion" && new Oi().fromArray(m).normalize().conjugate().toArray(m);
      let v = c.times.length;
      for (let _ = 0; _ < v; ++_) {
        let g = _ * p + h;
        if (l === "quaternion") Oi.multiplyQuaternionsFlat(c.values, g, m, 0, c.values, g);
        else {
          let y = p - h * 2;
          for (let w = 0; w < y; ++w) c.values[g + w] -= m[w];
        }
      }
    }
    return i59.blendMode = tD, i59;
  } };
  var us = class {
    constructor(t, e, n, r) {
      this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {};
    }
    evaluate(t) {
      let e = this.parameterPositions, n = this._cachedIndex, r = e[n], o = e[n - 1];
      e: {
        t: {
          let s;
          n: {
            i: if (!(t < r)) {
              for (let a = n + 2; ; ) {
                if (r === void 0) {
                  if (t < o) break i;
                  return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, o);
                }
                if (n === a) break;
                if (o = r, r = e[++n], t < r) break t;
              }
              s = e.length;
              break n;
            }
            if (!(t >= o)) {
              let a = e[1];
              t < a && (n = 2, o = a);
              for (let l = n - 2; ; ) {
                if (o === void 0) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                if (n === l) break;
                if (r = o, o = e[--n - 1], t >= o) break t;
              }
              s = n, n = 0;
              break n;
            }
            break e;
          }
          for (; n < s; ) {
            let a = n + s >>> 1;
            t < e[a] ? s = a : n = a + 1;
          }
          if (r = e[n], o = e[n - 1], o === void 0) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
          if (r === void 0) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, o, t);
        }
        this._cachedIndex = n, this.intervalChanged_(n, o, r);
      }
      return this.interpolate_(n, o, t, r);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(t) {
      let e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, o = t * r;
      for (let s = 0; s !== r; ++s) e[s] = n[o + s];
      return e;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {
    }
  };
  us.prototype.beforeStart_ = us.prototype.copySampleValue_;
  us.prototype.afterEnd_ = us.prototype.copySampleValue_;
  var cx = class extends us {
    constructor(t, e, n, r) {
      super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: pd, endingEnd: pd };
    }
    intervalChanged_(t, e, n) {
      let r = this.parameterPositions, o = t - 2, s = t + 1, a = r[o], l = r[s];
      if (a === void 0) switch (this.getSettings_().endingStart) {
        case fd:
          o = t, a = 2 * e - n;
          break;
        case Vm:
          o = r.length - 2, a = e + r[o] - r[o + 1];
          break;
        default:
          o = t, a = n;
      }
      if (l === void 0) switch (this.getSettings_().endingEnd) {
        case fd:
          s = t, l = 2 * n - e;
          break;
        case Vm:
          s = 1, l = n + r[1] - r[0];
          break;
        default:
          s = t - 1, l = e;
      }
      let c = (n - e) * 0.5, d = this.valueSize;
      this._weightPrev = c / (e - a), this._weightNext = c / (l - n), this._offsetPrev = o * d, this._offsetNext = s * d;
    }
    interpolate_(t, e, n, r) {
      let o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, d = this._offsetPrev, u = this._offsetNext, h = this._weightPrev, p = this._weightNext, f = (n - e) / (r - e), m = f * f, v = m * f, _ = -h * v + 2 * h * m - h * f, g = (1 + h) * v + (-1.5 - 2 * h) * m + (-0.5 + h) * f + 1, y = (-1 - p) * v + (1.5 + p) * m + 0.5 * f, w = p * v - p * m;
      for (let E = 0; E !== a; ++E) o[E] = _ * s[d + E] + g * s[c + E] + y * s[l + E] + w * s[u + E];
      return o;
    }
  };
  var wg = class extends us {
    constructor(t, e, n, r) {
      super(t, e, n, r);
    }
    interpolate_(t, e, n, r) {
      let o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = t * a, c = l - a, d = (n - e) / (r - e), u = 1 - d;
      for (let h = 0; h !== a; ++h) o[h] = s[c + h] * u + s[l + h] * d;
      return o;
    }
  };
  var dx = class extends us {
    constructor(t, e, n, r) {
      super(t, e, n, r);
    }
    interpolate_(t) {
      return this.copySampleValue_(t - 1);
    }
  };
  var fo = class {
    constructor(t, e, n, r) {
      if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
      this.name = t, this.times = jn.convertArray(e, this.TimeBufferType), this.values = jn.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
    }
    static toJSON(t) {
      let e = t.constructor, n;
      if (e.toJSON !== this.toJSON) n = e.toJSON(t);
      else {
        n = { name: t.name, times: jn.convertArray(t.times, Array), values: jn.convertArray(t.values, Array) };
        let r = t.getInterpolation();
        r !== t.DefaultInterpolation && (n.interpolation = r);
      }
      return n.type = t.ValueTypeName, n;
    }
    InterpolantFactoryMethodDiscrete(t) {
      return new dx(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodLinear(t) {
      return new wg(this.times, this.values, this.getValueSize(), t);
    }
    InterpolantFactoryMethodSmooth(t) {
      return new cx(this.times, this.values, this.getValueSize(), t);
    }
    setInterpolation(t) {
      let e;
      switch (t) {
        case Fm:
          e = this.InterpolantFactoryMethodDiscrete;
          break;
        case Bm:
          e = this.InterpolantFactoryMethodLinear;
          break;
        case U0:
          e = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (e === void 0) {
        let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
        return console.warn("THREE.KeyframeTrack:", n), this;
      }
      return this.createInterpolant = e, this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return Fm;
        case this.InterpolantFactoryMethodLinear:
          return Bm;
        case this.InterpolantFactoryMethodSmooth:
          return U0;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(t) {
      if (t !== 0) {
        let e = this.times;
        for (let n = 0, r = e.length; n !== r; ++n) e[n] += t;
      }
      return this;
    }
    scale(t) {
      if (t !== 1) {
        let e = this.times;
        for (let n = 0, r = e.length; n !== r; ++n) e[n] *= t;
      }
      return this;
    }
    trim(t, e) {
      let n = this.times, r = n.length, o = 0, s = r - 1;
      for (; o !== r && n[o] < t; ) ++o;
      for (; s !== -1 && n[s] > e; ) --s;
      if (++s, o !== 0 || s !== r) {
        o >= s && (s = Math.max(s, 1), o = s - 1);
        let a = this.getValueSize();
        this.times = jn.arraySlice(n, o, s), this.values = jn.arraySlice(this.values, o * a, s * a);
      }
      return this;
    }
    validate() {
      let t = true, e = this.getValueSize();
      e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = false);
      let n = this.times, r = this.values, o = n.length;
      o === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = false);
      let s = null;
      for (let a = 0; a !== o; a++) {
        let l = n[a];
        if (typeof l == "number" && isNaN(l)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), t = false;
          break;
        }
        if (s !== null && s > l) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, s), t = false;
          break;
        }
        s = l;
      }
      if (r !== void 0 && jn.isTypedArray(r)) for (let a = 0, l = r.length; a !== l; ++a) {
        let c = r[a];
        if (isNaN(c)) {
          console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), t = false;
          break;
        }
      }
      return t;
    }
    optimize() {
      let t = jn.arraySlice(this.times), e = jn.arraySlice(this.values), n = this.getValueSize(), r = this.getInterpolation() === U0, o = t.length - 1, s = 1;
      for (let a = 1; a < o; ++a) {
        let l = false, c = t[a], d = t[a + 1];
        if (c !== d && (a !== 1 || c !== t[0])) if (r) l = true;
        else {
          let u = a * n, h = u - n, p = u + n;
          for (let f = 0; f !== n; ++f) {
            let m = e[u + f];
            if (m !== e[h + f] || m !== e[p + f]) {
              l = true;
              break;
            }
          }
        }
        if (l) {
          if (a !== s) {
            t[s] = t[a];
            let u = a * n, h = s * n;
            for (let p = 0; p !== n; ++p) e[h + p] = e[u + p];
          }
          ++s;
        }
      }
      if (o > 0) {
        t[s] = t[o];
        for (let a = o * n, l = s * n, c = 0; c !== n; ++c) e[l + c] = e[a + c];
        ++s;
      }
      return s !== t.length ? (this.times = jn.arraySlice(t, 0, s), this.values = jn.arraySlice(e, 0, s * n)) : (this.times = t, this.values = e), this;
    }
    clone() {
      let t = jn.arraySlice(this.times, 0), e = jn.arraySlice(this.values, 0), n = this.constructor, r = new n(this.name, t, e);
      return r.createInterpolant = this.createInterpolant, r;
    }
  };
  fo.prototype.TimeBufferType = Float32Array;
  fo.prototype.ValueBufferType = Float32Array;
  fo.prototype.DefaultInterpolation = Bm;
  var Va = class extends fo {
  };
  Va.prototype.ValueTypeName = "bool";
  Va.prototype.ValueBufferType = Array;
  Va.prototype.DefaultInterpolation = Fm;
  Va.prototype.InterpolantFactoryMethodLinear = void 0;
  Va.prototype.InterpolantFactoryMethodSmooth = void 0;
  var Cg = class extends fo {
  };
  Cg.prototype.ValueTypeName = "color";
  var Pd = class extends fo {
  };
  Pd.prototype.ValueTypeName = "number";
  var ux = class extends us {
    constructor(t, e, n, r) {
      super(t, e, n, r);
    }
    interpolate_(t, e, n, r) {
      let o = this.resultBuffer, s = this.sampleValues, a = this.valueSize, l = (n - e) / (r - e), c = t * a;
      for (let d = c + a; c !== d; c += 4) Oi.slerpFlat(o, 0, s, c - a, s, c, l);
      return o;
    }
  };
  var Nl = class extends fo {
    InterpolantFactoryMethodLinear(t) {
      return new ux(this.times, this.values, this.getValueSize(), t);
    }
  };
  Nl.prototype.ValueTypeName = "quaternion";
  Nl.prototype.DefaultInterpolation = Bm;
  Nl.prototype.InterpolantFactoryMethodSmooth = void 0;
  var za = class extends fo {
  };
  za.prototype.ValueTypeName = "string";
  za.prototype.ValueBufferType = Array;
  za.prototype.DefaultInterpolation = Fm;
  za.prototype.InterpolantFactoryMethodLinear = void 0;
  za.prototype.InterpolantFactoryMethodSmooth = void 0;
  var Rd = class extends fo {
  };
  Rd.prototype.ValueTypeName = "vector";
  var Od = class {
    constructor(t, e = -1, n, r = Bx) {
      this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = ho(), this.duration < 0 && this.resetDuration();
    }
    static parse(t) {
      let e = [], n = t.tracks, r = 1 / (t.fps || 1);
      for (let s = 0, a = n.length; s !== a; ++s) e.push(zre(n[s]).scale(r));
      let o = new this(t.name, t.duration, e, t.blendMode);
      return o.uuid = t.uuid, o;
    }
    static toJSON(t) {
      let e = [], n = t.tracks, r = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode };
      for (let o = 0, s = n.length; o !== s; ++o) e.push(fo.toJSON(n[o]));
      return r;
    }
    static CreateFromMorphTargetSequence(t, e, n, r) {
      let o = e.length, s = [];
      for (let a = 0; a < o; a++) {
        let l = [], c = [];
        l.push((a + o - 1) % o, a, (a + 1) % o), c.push(0, 1, 0);
        let d = jn.getKeyframeOrder(l);
        l = jn.sortedArray(l, 1, d), c = jn.sortedArray(c, 1, d), !r && l[0] === 0 && (l.push(o), c.push(c[0])), s.push(new Pd(".morphTargetInfluences[" + e[a].name + "]", l, c).scale(1 / n));
      }
      return new this(t, -1, s);
    }
    static findByName(t, e) {
      let n = t;
      if (!Array.isArray(t)) {
        let r = t;
        n = r.geometry && r.geometry.animations || r.animations;
      }
      for (let r = 0; r < n.length; r++) if (n[r].name === e) return n[r];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(t, e, n) {
      let r = {}, o = /^([\w-]*?)([\d]+)$/;
      for (let a = 0, l = t.length; a < l; a++) {
        let c = t[a], d = c.name.match(o);
        if (d && d.length > 1) {
          let u = d[1], h = r[u];
          h || (r[u] = h = []), h.push(c);
        }
      }
      let s = [];
      for (let a in r) s.push(this.CreateFromMorphTargetSequence(a, r[a], e, n));
      return s;
    }
    static parseAnimation(t, e) {
      if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      let n = function(u, h, p, f, m) {
        if (p.length !== 0) {
          let v = [], _ = [];
          jn.flattenJSON(p, v, _, f), v.length !== 0 && m.push(new u(h, v, _));
        }
      }, r = [], o = t.name || "default", s = t.fps || 30, a = t.blendMode, l = t.length || -1, c = t.hierarchy || [];
      for (let u = 0; u < c.length; u++) {
        let h = c[u].keys;
        if (!(!h || h.length === 0)) if (h[0].morphTargets) {
          let p = {}, f;
          for (f = 0; f < h.length; f++) if (h[f].morphTargets) for (let m = 0; m < h[f].morphTargets.length; m++) p[h[f].morphTargets[m]] = -1;
          for (let m in p) {
            let v = [], _ = [];
            for (let g = 0; g !== h[f].morphTargets.length; ++g) {
              let y = h[f];
              v.push(y.time), _.push(y.morphTarget === m ? 1 : 0);
            }
            r.push(new Pd(".morphTargetInfluence[" + m + "]", v, _));
          }
          l = p.length * (s || 1);
        } else {
          let p = ".bones[" + e[u].name + "]";
          n(Rd, p + ".position", h, "pos", r), n(Nl, p + ".quaternion", h, "rot", r), n(Rd, p + ".scale", h, "scl", r);
        }
      }
      return r.length === 0 ? null : new this(o, l, r, a);
    }
    resetDuration() {
      let t = this.tracks, e = 0;
      for (let n = 0, r = t.length; n !== r; ++n) {
        let o = this.tracks[n];
        e = Math.max(e, o.times[o.times.length - 1]);
      }
      return this.duration = e, this;
    }
    trim() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
      return this;
    }
    validate() {
      let t = true;
      for (let e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
      return t;
    }
    optimize() {
      for (let t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
      return this;
    }
    clone() {
      let t = [];
      for (let e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
      return new this.constructor(this.name, this.duration, t, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  };
  function Vre(i59) {
    switch (i59.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return Pd;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return Rd;
      case "color":
        return Cg;
      case "quaternion":
        return Nl;
      case "bool":
      case "boolean":
        return Va;
      case "string":
        return za;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i59);
  }
  function zre(i59) {
    if (i59.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    let t = Vre(i59.type);
    if (i59.times === void 0) {
      let e = [], n = [];
      jn.flattenJSON(i59.keys, e, n, "value"), i59.times = e, i59.values = n;
    }
    return t.parse !== void 0 ? t.parse(i59) : new t(i59.name, i59.times, i59.values, i59.interpolation);
  }
  var Ad = { enabled: false, files: {}, add: function(i59, t) {
    this.enabled !== false && (this.files[i59] = t);
  }, get: function(i59) {
    if (this.enabled !== false) return this.files[i59];
  }, remove: function(i59) {
    delete this.files[i59];
  }, clear: function() {
    this.files = {};
  } };
  var Sg = class {
    constructor(t, e, n) {
      let r = this, o = false, s = 0, a = 0, l, c = [];
      this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(d) {
        a++, o === false && r.onStart !== void 0 && r.onStart(d, s, a), o = true;
      }, this.itemEnd = function(d) {
        s++, r.onProgress !== void 0 && r.onProgress(d, s, a), s === a && (o = false, r.onLoad !== void 0 && r.onLoad());
      }, this.itemError = function(d) {
        r.onError !== void 0 && r.onError(d);
      }, this.resolveURL = function(d) {
        return l ? l(d) : d;
      }, this.setURLModifier = function(d) {
        return l = d, this;
      }, this.addHandler = function(d, u) {
        return c.push(d, u), this;
      }, this.removeHandler = function(d) {
        let u = c.indexOf(d);
        return u !== -1 && c.splice(u, 2), this;
      }, this.getHandler = function(d) {
        for (let u = 0, h = c.length; u < h; u += 2) {
          let p = c[u], f = c[u + 1];
          if (p.global && (p.lastIndex = 0), p.test(d)) return f;
        }
        return null;
      };
    }
  };
  var _U = new Sg();
  var sr = class {
    constructor(t) {
      this.manager = t !== void 0 ? t : _U, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
    }
    load() {
    }
    loadAsync(t, e) {
      let n = this;
      return new Promise(function(r, o) {
        n.load(t, r, e, o);
      });
    }
    parse() {
    }
    setCrossOrigin(t) {
      return this.crossOrigin = t, this;
    }
    setWithCredentials(t) {
      return this.withCredentials = t, this;
    }
    setPath(t) {
      return this.path = t, this;
    }
    setResourcePath(t) {
      return this.resourcePath = t, this;
    }
    setRequestHeader(t) {
      return this.requestHeader = t, this;
    }
  };
  var Ia = {};
  var Lo = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      let o = Ad.get(t);
      if (o !== void 0) return this.manager.itemStart(t), setTimeout(() => {
        e && e(o), this.manager.itemEnd(t);
      }, 0), o;
      if (Ia[t] !== void 0) {
        Ia[t].push({ onLoad: e, onProgress: n, onError: r });
        return;
      }
      Ia[t] = [], Ia[t].push({ onLoad: e, onProgress: n, onError: r });
      let s = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" });
      fetch(s).then((a) => {
        if (a.status === 200 || a.status === 0) {
          a.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received.");
          let l = Ia[t], c = a.body.getReader(), d = a.headers.get("Content-Length"), u = d ? parseInt(d) : 0, h = u !== 0, p = 0;
          return new ReadableStream({ start(f) {
            m();
            function m() {
              c.read().then(({ done: v, value: _ }) => {
                if (v) f.close();
                else {
                  p += _.byteLength;
                  let g = new ProgressEvent("progress", { lengthComputable: h, loaded: p, total: u });
                  for (let y = 0, w = l.length; y < w; y++) {
                    let E = l[y];
                    E.onProgress && E.onProgress(g);
                  }
                  f.enqueue(_), m();
                }
              });
            }
          } });
        } else throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`);
      }).then((a) => {
        let l = new Response(a);
        switch (this.responseType) {
          case "arraybuffer":
            return l.arrayBuffer();
          case "blob":
            return l.blob();
          case "document":
            return l.text().then((c) => new DOMParser().parseFromString(c, this.mimeType));
          case "json":
            return l.json();
          default:
            return l.text();
        }
      }).then((a) => {
        Ad.add(t, a);
        let l = Ia[t];
        delete Ia[t];
        for (let c = 0, d = l.length; c < d; c++) {
          let u = l[c];
          u.onLoad && u.onLoad(a);
        }
        this.manager.itemEnd(t);
      }).catch((a) => {
        let l = Ia[t];
        delete Ia[t];
        for (let c = 0, d = l.length; c < d; c++) {
          let u = l[c];
          u.onError && u.onError(a);
        }
        this.manager.itemError(t), this.manager.itemEnd(t);
      }), this.manager.itemStart(t);
    }
    setResponseType(t) {
      return this.responseType = t, this;
    }
    setMimeType(t) {
      return this.mimeType = t, this;
    }
  };
  var E1 = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = new Lo(this.manager);
      s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function(a) {
        try {
          e(o.parse(JSON.parse(a)));
        } catch (l) {
          r ? r(l) : console.error(l), o.manager.itemError(t);
        }
      }, n, r);
    }
    parse(t) {
      let e = [];
      for (let n = 0; n < t.length; n++) {
        let r = Od.parse(t[n]);
        e.push(r);
      }
      return e;
    }
  };
  var T1 = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = [], a = new Xm(), l = new Lo(this.manager);
      l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(o.withCredentials);
      let c = 0;
      function d(u) {
        l.load(t[u], function(h) {
          let p = o.parse(h, true);
          s[u] = { width: p.width, height: p.height, format: p.format, mipmaps: p.mipmaps }, c += 1, c === 6 && (p.mipmapCount === 1 && (a.minFilter = Ri), a.image = s, a.format = p.format, a.needsUpdate = true, e && e(a));
        }, n, r);
      }
      if (Array.isArray(t)) for (let u = 0, h = t.length; u < h; ++u) d(u);
      else l.load(t, function(u) {
        let h = o.parse(u, true);
        if (h.isCubemap) {
          let p = h.mipmaps.length / h.mipmapCount;
          for (let f = 0; f < p; f++) {
            s[f] = { mipmaps: [] };
            for (let m = 0; m < h.mipmapCount; m++) s[f].mipmaps.push(h.mipmaps[f * h.mipmapCount + m]), s[f].format = h.format, s[f].width = h.width, s[f].height = h.height;
          }
          a.image = s;
        } else a.image.width = h.width, a.image.height = h.height, a.mipmaps = h.mipmaps;
        h.mipmapCount === 1 && (a.minFilter = Ri), a.format = h.format, a.needsUpdate = true, e && e(a);
      }, n, r);
      return a;
    }
  };
  var Nd = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      let o = this, s = Ad.get(t);
      if (s !== void 0) return o.manager.itemStart(t), setTimeout(function() {
        e && e(s), o.manager.itemEnd(t);
      }, 0), s;
      let a = Ux("img");
      function l() {
        d(), Ad.add(t, this), e && e(this), o.manager.itemEnd(t);
      }
      function c(u) {
        d(), r && r(u), o.manager.itemError(t), o.manager.itemEnd(t);
      }
      function d() {
        a.removeEventListener("load", l, false), a.removeEventListener("error", c, false);
      }
      return a.addEventListener("load", l, false), a.addEventListener("error", c, false), t.substr(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), o.manager.itemStart(t), a.src = t, a;
    }
  };
  var hx = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = new Dl(), s = new Nd(this.manager);
      s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
      let a = 0;
      function l(c) {
        s.load(t[c], function(d) {
          o.images[c] = d, a++, a === 6 && (o.needsUpdate = true, e && e(o));
        }, void 0, r);
      }
      for (let c = 0; c < t.length; ++c) l(c);
      return o;
    }
  };
  var px = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = new Ra(), a = new Lo(this.manager);
      return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(o.withCredentials), a.load(t, function(l) {
        let c = o.parse(l);
        c && (c.image !== void 0 ? s.image = c.image : c.data !== void 0 && (s.image.width = c.width, s.image.height = c.height, s.image.data = c.data), s.wrapS = c.wrapS !== void 0 ? c.wrapS : nr, s.wrapT = c.wrapT !== void 0 ? c.wrapT : nr, s.magFilter = c.magFilter !== void 0 ? c.magFilter : Ri, s.minFilter = c.minFilter !== void 0 ? c.minFilter : Ri, s.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.encoding !== void 0 && (s.encoding = c.encoding), c.flipY !== void 0 && (s.flipY = c.flipY), c.format !== void 0 && (s.format = c.format), c.type !== void 0 && (s.type = c.type), c.mipmaps !== void 0 && (s.mipmaps = c.mipmaps, s.minFilter = Bd), c.mipmapCount === 1 && (s.minFilter = Ri), c.generateMipmaps !== void 0 && (s.generateMipmaps = c.generateMipmaps), s.needsUpdate = true, e && e(s, c));
      }, n, r), s;
    }
  };
  var fx = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = new zi(), s = new Nd(this.manager);
      return s.setCrossOrigin(this.crossOrigin), s.setPath(this.path), s.load(t, function(a) {
        o.image = a, o.needsUpdate = true, e !== void 0 && e(o);
      }, n, r), o;
    }
  };
  var mo = class extends ln {
    constructor(t, e = 1) {
      super(), this.type = "Light", this.color = new Ye(t), this.intensity = e;
    }
    dispose() {
    }
    copy(t) {
      return super.copy(t), this.color.copy(t.color), this.intensity = t.intensity, this;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e;
    }
  };
  mo.prototype.isLight = true;
  var Mg = class extends mo {
    constructor(t, e, n) {
      super(t, n), this.type = "HemisphereLight", this.position.copy(ln.DefaultUp), this.updateMatrix(), this.groundColor = new Ye(e);
    }
    copy(t) {
      return mo.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this;
    }
  };
  Mg.prototype.isHemisphereLight = true;
  var tV = new ut();
  var nV = new L();
  var iV = new L();
  var Eg = class {
    constructor(t) {
      this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Me(512, 512), this.map = null, this.mapPass = null, this.matrix = new ut(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Cd(), this._frameExtents = new Me(1, 1), this._viewportCount = 1, this._viewports = [new bn(0, 0, 1, 1)];
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(t) {
      let e = this.camera, n = this.matrix;
      nV.setFromMatrixPosition(t.matrixWorld), e.position.copy(nV), iV.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(iV), e.updateMatrixWorld(), tV.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(tV), n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse);
    }
    getViewport(t) {
      return this._viewports[t];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(t) {
      return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      let t = {};
      return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(false).object, delete t.camera.matrix, t;
    }
  };
  var mx = class extends Eg {
    constructor() {
      super(new Ci(50, 1, 0.5, 500)), this.focus = 1;
    }
    updateMatrices(t) {
      let e = this.camera, n = zm * 2 * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, o = t.distance || e.far;
      (n !== e.fov || r !== e.aspect || o !== e.far) && (e.fov = n, e.aspect = r, e.far = o, e.updateProjectionMatrix()), super.updateMatrices(t);
    }
    copy(t) {
      return super.copy(t), this.focus = t.focus, this;
    }
  };
  mx.prototype.isSpotLightShadow = true;
  var Tg = class extends mo {
    constructor(t, e, n = 0, r = Math.PI / 3, o = 0, s = 1) {
      super(t, e), this.type = "SpotLight", this.position.copy(ln.DefaultUp), this.updateMatrix(), this.target = new ln(), this.distance = n, this.angle = r, this.penumbra = o, this.decay = s, this.shadow = new mx();
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(t) {
      this.intensity = t / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return super.copy(t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  };
  Tg.prototype.isSpotLight = true;
  var rV = new ut();
  var Mm = new L();
  var e1 = new L();
  var gx = class extends Eg {
    constructor() {
      super(new Ci(90, 1, 0.5, 500)), this._frameExtents = new Me(4, 2), this._viewportCount = 6, this._viewports = [new bn(2, 1, 1, 1), new bn(0, 1, 1, 1), new bn(3, 1, 1, 1), new bn(1, 1, 1, 1), new bn(3, 0, 1, 1), new bn(1, 0, 1, 1)], this._cubeDirections = [new L(1, 0, 0), new L(-1, 0, 0), new L(0, 0, 1), new L(0, 0, -1), new L(0, 1, 0), new L(0, -1, 0)], this._cubeUps = [new L(0, 1, 0), new L(0, 1, 0), new L(0, 1, 0), new L(0, 1, 0), new L(0, 0, 1), new L(0, 0, -1)];
    }
    updateMatrices(t, e = 0) {
      let n = this.camera, r = this.matrix, o = t.distance || n.far;
      o !== n.far && (n.far = o, n.updateProjectionMatrix()), Mm.setFromMatrixPosition(t.matrixWorld), n.position.copy(Mm), e1.copy(n.position), e1.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(e1), n.updateMatrixWorld(), r.makeTranslation(-Mm.x, -Mm.y, -Mm.z), rV.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(rV);
    }
  };
  gx.prototype.isPointLightShadow = true;
  var Ig = class extends mo {
    constructor(t, e, n = 0, r = 1) {
      super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new gx();
    }
    get power() {
      return this.intensity * 4 * Math.PI;
    }
    set power(t) {
      this.intensity = t / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return super.copy(t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this;
    }
  };
  Ig.prototype.isPointLight = true;
  var _x = class extends Eg {
    constructor() {
      super(new Sd(-5, 5, 5, -5, 0.5, 500));
    }
  };
  _x.prototype.isDirectionalLightShadow = true;
  var Dg = class extends mo {
    constructor(t, e) {
      super(t, e), this.type = "DirectionalLight", this.position.copy(ln.DefaultUp), this.updateMatrix(), this.target = new ln(), this.shadow = new _x();
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(t) {
      return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this;
    }
  };
  Dg.prototype.isDirectionalLight = true;
  var Pg = class extends mo {
    constructor(t, e) {
      super(t, e), this.type = "AmbientLight";
    }
  };
  Pg.prototype.isAmbientLight = true;
  var Rg = class extends mo {
    constructor(t, e, n = 10, r = 10) {
      super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r;
    }
    get power() {
      return this.intensity * this.width * this.height * Math.PI;
    }
    set power(t) {
      this.intensity = t / (this.width * this.height * Math.PI);
    }
    copy(t) {
      return super.copy(t), this.width = t.width, this.height = t.height, this;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.object.width = this.width, e.object.height = this.height, e;
    }
  };
  Rg.prototype.isRectAreaLight = true;
  var Og = class {
    constructor() {
      this.coefficients = [];
      for (let t = 0; t < 9; t++) this.coefficients.push(new L());
    }
    set(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
      return this;
    }
    zero() {
      for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
      return this;
    }
    getAt(t, e) {
      let n = t.x, r = t.y, o = t.z, s = this.coefficients;
      return e.copy(s[0]).multiplyScalar(0.282095), e.addScaledVector(s[1], 0.488603 * r), e.addScaledVector(s[2], 0.488603 * o), e.addScaledVector(s[3], 0.488603 * n), e.addScaledVector(s[4], 1.092548 * (n * r)), e.addScaledVector(s[5], 1.092548 * (r * o)), e.addScaledVector(s[6], 0.315392 * (3 * o * o - 1)), e.addScaledVector(s[7], 1.092548 * (n * o)), e.addScaledVector(s[8], 0.546274 * (n * n - r * r)), e;
    }
    getIrradianceAt(t, e) {
      let n = t.x, r = t.y, o = t.z, s = this.coefficients;
      return e.copy(s[0]).multiplyScalar(0.886227), e.addScaledVector(s[1], 2 * 0.511664 * r), e.addScaledVector(s[2], 2 * 0.511664 * o), e.addScaledVector(s[3], 2 * 0.511664 * n), e.addScaledVector(s[4], 2 * 0.429043 * n * r), e.addScaledVector(s[5], 2 * 0.429043 * r * o), e.addScaledVector(s[6], 0.743125 * o * o - 0.247708), e.addScaledVector(s[7], 2 * 0.429043 * n * o), e.addScaledVector(s[8], 0.429043 * (n * n - r * r)), e;
    }
    add(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
      return this;
    }
    addScaledSH(t, e) {
      for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(t.coefficients[n], e);
      return this;
    }
    scale(t) {
      for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
      return this;
    }
    lerp(t, e) {
      for (let n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
      return this;
    }
    equals(t) {
      for (let e = 0; e < 9; e++) if (!this.coefficients[e].equals(t.coefficients[e])) return false;
      return true;
    }
    copy(t) {
      return this.set(t.coefficients);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(t, e = 0) {
      let n = this.coefficients;
      for (let r = 0; r < 9; r++) n[r].fromArray(t, e + r * 3);
      return this;
    }
    toArray(t = [], e = 0) {
      let n = this.coefficients;
      for (let r = 0; r < 9; r++) n[r].toArray(t, e + r * 3);
      return t;
    }
    static getBasisAt(t, e) {
      let n = t.x, r = t.y, o = t.z;
      e[0] = 0.282095, e[1] = 0.488603 * r, e[2] = 0.488603 * o, e[3] = 0.488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * o, e[6] = 0.315392 * (3 * o * o - 1), e[7] = 1.092548 * n * o, e[8] = 0.546274 * (n * n - r * r);
    }
  };
  Og.prototype.isSphericalHarmonics3 = true;
  var kd = class extends mo {
    constructor(t = new Og(), e = 1) {
      super(void 0, e), this.sh = t;
    }
    copy(t) {
      return super.copy(t), this.sh.copy(t.sh), this;
    }
    fromJSON(t) {
      return this.intensity = t.intensity, this.sh.fromArray(t.sh), this;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.object.sh = this.sh.toArray(), e;
    }
  };
  kd.prototype.isLightProbe = true;
  var vx = class extends sr {
    constructor(t) {
      super(t), this.textures = {};
    }
    load(t, e, n, r) {
      let o = this, s = new Lo(o.manager);
      s.setPath(o.path), s.setRequestHeader(o.requestHeader), s.setWithCredentials(o.withCredentials), s.load(t, function(a) {
        try {
          e(o.parse(JSON.parse(a)));
        } catch (l) {
          r ? r(l) : console.error(l), o.manager.itemError(t);
        }
      }, n, r);
    }
    parse(t) {
      let e = this.textures;
      function n(o) {
        return e[o] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", o), e[o];
      }
      let r = new Bre[t.type]();
      if (t.uuid !== void 0 && (r.uuid = t.uuid), t.name !== void 0 && (r.name = t.name), t.color !== void 0 && r.color !== void 0 && r.color.setHex(t.color), t.roughness !== void 0 && (r.roughness = t.roughness), t.metalness !== void 0 && (r.metalness = t.metalness), t.sheen !== void 0 && (r.sheen = t.sheen), t.sheenColor !== void 0 && (r.sheenColor = new Ye().setHex(t.sheenColor)), t.sheenRoughness !== void 0 && (r.sheenRoughness = t.sheenRoughness), t.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(t.emissive), t.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(t.specular), t.specularIntensity !== void 0 && (r.specularIntensity = t.specularIntensity), t.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(t.specularColor), t.shininess !== void 0 && (r.shininess = t.shininess), t.clearcoat !== void 0 && (r.clearcoat = t.clearcoat), t.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = t.clearcoatRoughness), t.transmission !== void 0 && (r.transmission = t.transmission), t.thickness !== void 0 && (r.thickness = t.thickness), t.attenuationDistance !== void 0 && (r.attenuationDistance = t.attenuationDistance), t.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(t.attenuationColor), t.fog !== void 0 && (r.fog = t.fog), t.flatShading !== void 0 && (r.flatShading = t.flatShading), t.blending !== void 0 && (r.blending = t.blending), t.combine !== void 0 && (r.combine = t.combine), t.side !== void 0 && (r.side = t.side), t.shadowSide !== void 0 && (r.shadowSide = t.shadowSide), t.opacity !== void 0 && (r.opacity = t.opacity), t.format !== void 0 && (r.format = t.format), t.transparent !== void 0 && (r.transparent = t.transparent), t.alphaTest !== void 0 && (r.alphaTest = t.alphaTest), t.depthTest !== void 0 && (r.depthTest = t.depthTest), t.depthWrite !== void 0 && (r.depthWrite = t.depthWrite), t.colorWrite !== void 0 && (r.colorWrite = t.colorWrite), t.stencilWrite !== void 0 && (r.stencilWrite = t.stencilWrite), t.stencilWriteMask !== void 0 && (r.stencilWriteMask = t.stencilWriteMask), t.stencilFunc !== void 0 && (r.stencilFunc = t.stencilFunc), t.stencilRef !== void 0 && (r.stencilRef = t.stencilRef), t.stencilFuncMask !== void 0 && (r.stencilFuncMask = t.stencilFuncMask), t.stencilFail !== void 0 && (r.stencilFail = t.stencilFail), t.stencilZFail !== void 0 && (r.stencilZFail = t.stencilZFail), t.stencilZPass !== void 0 && (r.stencilZPass = t.stencilZPass), t.wireframe !== void 0 && (r.wireframe = t.wireframe), t.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = t.wireframeLinewidth), t.wireframeLinecap !== void 0 && (r.wireframeLinecap = t.wireframeLinecap), t.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = t.wireframeLinejoin), t.rotation !== void 0 && (r.rotation = t.rotation), t.linewidth !== 1 && (r.linewidth = t.linewidth), t.dashSize !== void 0 && (r.dashSize = t.dashSize), t.gapSize !== void 0 && (r.gapSize = t.gapSize), t.scale !== void 0 && (r.scale = t.scale), t.polygonOffset !== void 0 && (r.polygonOffset = t.polygonOffset), t.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = t.polygonOffsetFactor), t.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = t.polygonOffsetUnits), t.dithering !== void 0 && (r.dithering = t.dithering), t.alphaToCoverage !== void 0 && (r.alphaToCoverage = t.alphaToCoverage), t.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = t.premultipliedAlpha), t.visible !== void 0 && (r.visible = t.visible), t.toneMapped !== void 0 && (r.toneMapped = t.toneMapped), t.userData !== void 0 && (r.userData = t.userData), t.vertexColors !== void 0 && (typeof t.vertexColors == "number" ? r.vertexColors = t.vertexColors > 0 : r.vertexColors = t.vertexColors), t.uniforms !== void 0) for (let o in t.uniforms) {
        let s = t.uniforms[o];
        switch (r.uniforms[o] = {}, s.type) {
          case "t":
            r.uniforms[o].value = n(s.value);
            break;
          case "c":
            r.uniforms[o].value = new Ye().setHex(s.value);
            break;
          case "v2":
            r.uniforms[o].value = new Me().fromArray(s.value);
            break;
          case "v3":
            r.uniforms[o].value = new L().fromArray(s.value);
            break;
          case "v4":
            r.uniforms[o].value = new bn().fromArray(s.value);
            break;
          case "m3":
            r.uniforms[o].value = new xi().fromArray(s.value);
            break;
          case "m4":
            r.uniforms[o].value = new ut().fromArray(s.value);
            break;
          default:
            r.uniforms[o].value = s.value;
        }
      }
      if (t.defines !== void 0 && (r.defines = t.defines), t.vertexShader !== void 0 && (r.vertexShader = t.vertexShader), t.fragmentShader !== void 0 && (r.fragmentShader = t.fragmentShader), t.extensions !== void 0) for (let o in t.extensions) r.extensions[o] = t.extensions[o];
      if (t.shading !== void 0 && (r.flatShading = t.shading === 1), t.size !== void 0 && (r.size = t.size), t.sizeAttenuation !== void 0 && (r.sizeAttenuation = t.sizeAttenuation), t.map !== void 0 && (r.map = n(t.map)), t.matcap !== void 0 && (r.matcap = n(t.matcap)), t.alphaMap !== void 0 && (r.alphaMap = n(t.alphaMap)), t.bumpMap !== void 0 && (r.bumpMap = n(t.bumpMap)), t.bumpScale !== void 0 && (r.bumpScale = t.bumpScale), t.normalMap !== void 0 && (r.normalMap = n(t.normalMap)), t.normalMapType !== void 0 && (r.normalMapType = t.normalMapType), t.normalScale !== void 0) {
        let o = t.normalScale;
        Array.isArray(o) === false && (o = [o, o]), r.normalScale = new Me().fromArray(o);
      }
      return t.displacementMap !== void 0 && (r.displacementMap = n(t.displacementMap)), t.displacementScale !== void 0 && (r.displacementScale = t.displacementScale), t.displacementBias !== void 0 && (r.displacementBias = t.displacementBias), t.roughnessMap !== void 0 && (r.roughnessMap = n(t.roughnessMap)), t.metalnessMap !== void 0 && (r.metalnessMap = n(t.metalnessMap)), t.emissiveMap !== void 0 && (r.emissiveMap = n(t.emissiveMap)), t.emissiveIntensity !== void 0 && (r.emissiveIntensity = t.emissiveIntensity), t.specularMap !== void 0 && (r.specularMap = n(t.specularMap)), t.specularIntensityMap !== void 0 && (r.specularIntensityMap = n(t.specularIntensityMap)), t.specularColorMap !== void 0 && (r.specularColorMap = n(t.specularColorMap)), t.envMap !== void 0 && (r.envMap = n(t.envMap)), t.envMapIntensity !== void 0 && (r.envMapIntensity = t.envMapIntensity), t.reflectivity !== void 0 && (r.reflectivity = t.reflectivity), t.refractionRatio !== void 0 && (r.refractionRatio = t.refractionRatio), t.lightMap !== void 0 && (r.lightMap = n(t.lightMap)), t.lightMapIntensity !== void 0 && (r.lightMapIntensity = t.lightMapIntensity), t.aoMap !== void 0 && (r.aoMap = n(t.aoMap)), t.aoMapIntensity !== void 0 && (r.aoMapIntensity = t.aoMapIntensity), t.gradientMap !== void 0 && (r.gradientMap = n(t.gradientMap)), t.clearcoatMap !== void 0 && (r.clearcoatMap = n(t.clearcoatMap)), t.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)), t.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = n(t.clearcoatNormalMap)), t.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new Me().fromArray(t.clearcoatNormalScale)), t.transmissionMap !== void 0 && (r.transmissionMap = n(t.transmissionMap)), t.thicknessMap !== void 0 && (r.thicknessMap = n(t.thicknessMap)), t.sheenColorMap !== void 0 && (r.sheenColorMap = n(t.sheenColorMap)), t.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = n(t.sheenRoughnessMap)), r;
    }
    setTextures(t) {
      return this.textures = t, this;
    }
  };
  var op = class {
    static decodeText(t) {
      if (typeof TextDecoder < "u") return new TextDecoder().decode(t);
      let e = "";
      for (let n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
      try {
        return decodeURIComponent(escape(e));
      } catch {
        return e;
      }
    }
    static extractUrlBase(t) {
      let e = t.lastIndexOf("/");
      return e === -1 ? "./" : t.substr(0, e + 1);
    }
    static resolveURL(t, e) {
      return typeof t != "string" || t === "" ? "" : (/^https?:\/\//i.test(e) && /^\//.test(t) && (e = e.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : e + t);
    }
  };
  var Ag = class extends Ct {
    constructor() {
      super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
    }
    copy(t) {
      return super.copy(t), this.instanceCount = t.instanceCount, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      let t = super.toJSON(this);
      return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = true, t;
    }
  };
  Ag.prototype.isInstancedBufferGeometry = true;
  var yx = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = new Lo(o.manager);
      s.setPath(o.path), s.setRequestHeader(o.requestHeader), s.setWithCredentials(o.withCredentials), s.load(t, function(a) {
        try {
          e(o.parse(JSON.parse(a)));
        } catch (l) {
          r ? r(l) : console.error(l), o.manager.itemError(t);
        }
      }, n, r);
    }
    parse(t) {
      let e = {}, n = {};
      function r(p, f) {
        if (e[f] !== void 0) return e[f];
        let v = p.interleavedBuffers[f], _ = o(p, v.buffer), g = Dh(v.type, _), y = new Na(g, v.stride);
        return y.uuid = v.uuid, e[f] = y, y;
      }
      function o(p, f) {
        if (n[f] !== void 0) return n[f];
        let v = p.arrayBuffers[f], _ = new Uint32Array(v).buffer;
        return n[f] = _, _;
      }
      let s = t.isInstancedBufferGeometry ? new Ag() : new Ct(), a = t.data.index;
      if (a !== void 0) {
        let p = Dh(a.type, a.array);
        s.setIndex(new an(p, 1));
      }
      let l = t.data.attributes;
      for (let p in l) {
        let f = l[p], m;
        if (f.isInterleavedBufferAttribute) {
          let v = r(t.data, f.data);
          m = new Ol(v, f.itemSize, f.offset, f.normalized);
        } else {
          let v = Dh(f.type, f.array), _ = f.isInstancedBufferAttribute ? ka : an;
          m = new _(v, f.itemSize, f.normalized);
        }
        f.name !== void 0 && (m.name = f.name), f.usage !== void 0 && m.setUsage(f.usage), f.updateRange !== void 0 && (m.updateRange.offset = f.updateRange.offset, m.updateRange.count = f.updateRange.count), s.setAttribute(p, m);
      }
      let c = t.data.morphAttributes;
      if (c) for (let p in c) {
        let f = c[p], m = [];
        for (let v = 0, _ = f.length; v < _; v++) {
          let g = f[v], y;
          if (g.isInterleavedBufferAttribute) {
            let w = r(t.data, g.data);
            y = new Ol(w, g.itemSize, g.offset, g.normalized);
          } else {
            let w = Dh(g.type, g.array);
            y = new an(w, g.itemSize, g.normalized);
          }
          g.name !== void 0 && (y.name = g.name), m.push(y);
        }
        s.morphAttributes[p] = m;
      }
      t.data.morphTargetsRelative && (s.morphTargetsRelative = true);
      let u = t.data.groups || t.data.drawcalls || t.data.offsets;
      if (u !== void 0) for (let p = 0, f = u.length; p !== f; ++p) {
        let m = u[p];
        s.addGroup(m.start, m.count, m.materialIndex);
      }
      let h = t.data.boundingSphere;
      if (h !== void 0) {
        let p = new L();
        h.center !== void 0 && p.fromArray(h.center), s.boundingSphere = new zs(p, h.radius);
      }
      return t.name && (s.name = t.name), t.userData && (s.userData = t.userData), s;
    }
  };
  var I1 = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = this.path === "" ? op.extractUrlBase(t) : this.path;
      this.resourcePath = this.resourcePath || s;
      let a = new Lo(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(t, function(l) {
        let c = null;
        try {
          c = JSON.parse(l);
        } catch (u) {
          r !== void 0 && r(u), console.error("THREE:ObjectLoader: Can't parse " + t + ".", u.message);
          return;
        }
        let d = c.metadata;
        if (d === void 0 || d.type === void 0 || d.type.toLowerCase() === "geometry") {
          console.error("THREE.ObjectLoader: Can't load " + t);
          return;
        }
        o.parse(c, e);
      }, n, r);
    }
    loadAsync(t, e) {
      return $t(this, null, function* () {
        let n = this, r = this.path === "" ? op.extractUrlBase(t) : this.path;
        this.resourcePath = this.resourcePath || r;
        let o = new Lo(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials);
        let s = yield o.loadAsync(t, e), a = JSON.parse(s), l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + t);
        return yield n.parseAsync(a);
      });
    }
    parse(t, e) {
      let n = this.parseAnimations(t.animations), r = this.parseShapes(t.shapes), o = this.parseGeometries(t.geometries, r), s = this.parseImages(t.images, function() {
        e !== void 0 && e(c);
      }), a = this.parseTextures(t.textures, s), l = this.parseMaterials(t.materials, a), c = this.parseObject(t.object, o, l, a, n), d = this.parseSkeletons(t.skeletons, c);
      if (this.bindSkeletons(c, d), e !== void 0) {
        let u = false;
        for (let h in s) if (s[h] instanceof HTMLImageElement) {
          u = true;
          break;
        }
        u === false && e(c);
      }
      return c;
    }
    parseAsync(t) {
      return $t(this, null, function* () {
        let e = this.parseAnimations(t.animations), n = this.parseShapes(t.shapes), r = this.parseGeometries(t.geometries, n), o = yield this.parseImagesAsync(t.images), s = this.parseTextures(t.textures, o), a = this.parseMaterials(t.materials, s), l = this.parseObject(t.object, r, a, s, e), c = this.parseSkeletons(t.skeletons, l);
        return this.bindSkeletons(l, c), l;
      });
    }
    parseShapes(t) {
      let e = {};
      if (t !== void 0) for (let n = 0, r = t.length; n < r; n++) {
        let o = new ko().fromJSON(t[n]);
        e[o.uuid] = o;
      }
      return e;
    }
    parseSkeletons(t, e) {
      let n = {}, r = {};
      if (e.traverse(function(o) {
        o.isBone && (r[o.uuid] = o);
      }), t !== void 0) for (let o = 0, s = t.length; o < s; o++) {
        let a = new ix().fromJSON(t[o], r);
        n[a.uuid] = a;
      }
      return n;
    }
    parseGeometries(t, e) {
      let n = {};
      if (t !== void 0) {
        let r = new yx();
        for (let o = 0, s = t.length; o < s; o++) {
          let a, l = t[o];
          switch (l.type) {
            case "BufferGeometry":
            case "InstancedBufferGeometry":
              a = r.parse(l);
              break;
            case "Geometry":
              console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
              break;
            default:
              l.type in eV ? a = eV[l.type].fromJSON(l, e) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
          }
          a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), a.isBufferGeometry === true && l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a;
        }
      }
      return n;
    }
    parseMaterials(t, e) {
      let n = {}, r = {};
      if (t !== void 0) {
        let o = new vx();
        o.setTextures(e);
        for (let s = 0, a = t.length; s < a; s++) {
          let l = t[s];
          if (l.type === "MultiMaterial") {
            let c = [];
            for (let d = 0; d < l.materials.length; d++) {
              let u = l.materials[d];
              n[u.uuid] === void 0 && (n[u.uuid] = o.parse(u)), c.push(n[u.uuid]);
            }
            r[l.uuid] = c;
          } else n[l.uuid] === void 0 && (n[l.uuid] = o.parse(l)), r[l.uuid] = n[l.uuid];
        }
      }
      return r;
    }
    parseAnimations(t) {
      let e = {};
      if (t !== void 0) for (let n = 0; n < t.length; n++) {
        let r = t[n], o = Od.parse(r);
        e[o.uuid] = o;
      }
      return e;
    }
    parseImages(t, e) {
      let n = this, r = {}, o;
      function s(l) {
        return n.manager.itemStart(l), o.load(l, function() {
          n.manager.itemEnd(l);
        }, void 0, function() {
          n.manager.itemError(l), n.manager.itemEnd(l);
        });
      }
      function a(l) {
        if (typeof l == "string") {
          let c = l, d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
          return s(d);
        } else return l.data ? { data: Dh(l.type, l.data), width: l.width, height: l.height } : null;
      }
      if (t !== void 0 && t.length > 0) {
        let l = new Sg(e);
        o = new Nd(l), o.setCrossOrigin(this.crossOrigin);
        for (let c = 0, d = t.length; c < d; c++) {
          let u = t[c], h = u.url;
          if (Array.isArray(h)) {
            r[u.uuid] = [];
            for (let p = 0, f = h.length; p < f; p++) {
              let m = h[p], v = a(m);
              v !== null && (v instanceof HTMLImageElement ? r[u.uuid].push(v) : r[u.uuid].push(new Ra(v.data, v.width, v.height)));
            }
          } else {
            let p = a(u.url);
            p !== null && (r[u.uuid] = p);
          }
        }
      }
      return r;
    }
    parseImagesAsync(t) {
      return $t(this, null, function* () {
        let e = this, n = {}, r;
        function o(s) {
          return $t(this, null, function* () {
            if (typeof s == "string") {
              let a = s, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : e.resourcePath + a;
              return yield r.loadAsync(l);
            } else return s.data ? { data: Dh(s.type, s.data), width: s.width, height: s.height } : null;
          });
        }
        if (t !== void 0 && t.length > 0) {
          r = new Nd(this.manager), r.setCrossOrigin(this.crossOrigin);
          for (let s = 0, a = t.length; s < a; s++) {
            let l = t[s], c = l.url;
            if (Array.isArray(c)) {
              n[l.uuid] = [];
              for (let d = 0, u = c.length; d < u; d++) {
                let h = c[d], p = yield o(h);
                p !== null && (p instanceof HTMLImageElement ? n[l.uuid].push(p) : n[l.uuid].push(new Ra(p.data, p.width, p.height)));
              }
            } else {
              let d = yield o(l.url);
              d !== null && (n[l.uuid] = d);
            }
          }
        }
        return n;
      });
    }
    parseTextures(t, e) {
      function n(o, s) {
        return typeof o == "number" ? o : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", o), s[o]);
      }
      let r = {};
      if (t !== void 0) for (let o = 0, s = t.length; o < s; o++) {
        let a = t[o];
        a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), e[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
        let l, c = e[a.image];
        Array.isArray(c) ? (l = new Dl(c), c.length === 6 && (l.needsUpdate = true)) : (c && c.data ? l = new Ra(c.data, c.width, c.height) : l = new zi(c), c && (l.needsUpdate = true)), l.uuid = a.uuid, a.name !== void 0 && (l.name = a.name), a.mapping !== void 0 && (l.mapping = n(a.mapping, Ure)), a.offset !== void 0 && l.offset.fromArray(a.offset), a.repeat !== void 0 && l.repeat.fromArray(a.repeat), a.center !== void 0 && l.center.fromArray(a.center), a.rotation !== void 0 && (l.rotation = a.rotation), a.wrap !== void 0 && (l.wrapS = n(a.wrap[0], oV), l.wrapT = n(a.wrap[1], oV)), a.format !== void 0 && (l.format = a.format), a.type !== void 0 && (l.type = a.type), a.encoding !== void 0 && (l.encoding = a.encoding), a.minFilter !== void 0 && (l.minFilter = n(a.minFilter, sV)), a.magFilter !== void 0 && (l.magFilter = n(a.magFilter, sV)), a.anisotropy !== void 0 && (l.anisotropy = a.anisotropy), a.flipY !== void 0 && (l.flipY = a.flipY), a.premultiplyAlpha !== void 0 && (l.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (l.unpackAlignment = a.unpackAlignment), a.userData !== void 0 && (l.userData = a.userData), r[a.uuid] = l;
      }
      return r;
    }
    parseObject(t, e, n, r, o) {
      let s;
      function a(h) {
        return e[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", h), e[h];
      }
      function l(h) {
        if (h !== void 0) {
          if (Array.isArray(h)) {
            let p = [];
            for (let f = 0, m = h.length; f < m; f++) {
              let v = h[f];
              n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), p.push(n[v]);
            }
            return p;
          }
          return n[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", h), n[h];
        }
      }
      function c(h) {
        return r[h] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", h), r[h];
      }
      let d, u;
      switch (t.type) {
        case "Scene":
          s = new $h(), t.background !== void 0 && (Number.isInteger(t.background) ? s.background = new Ye(t.background) : s.background = c(t.background)), t.environment !== void 0 && (s.environment = c(t.environment)), t.fog !== void 0 && (t.fog.type === "Fog" ? s.fog = new $m(t.fog.color, t.fog.near, t.fog.far) : t.fog.type === "FogExp2" && (s.fog = new Wm(t.fog.color, t.fog.density)));
          break;
        case "PerspectiveCamera":
          s = new Ci(t.fov, t.aspect, t.near, t.far), t.focus !== void 0 && (s.focus = t.focus), t.zoom !== void 0 && (s.zoom = t.zoom), t.filmGauge !== void 0 && (s.filmGauge = t.filmGauge), t.filmOffset !== void 0 && (s.filmOffset = t.filmOffset), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "OrthographicCamera":
          s = new Sd(t.left, t.right, t.top, t.bottom, t.near, t.far), t.zoom !== void 0 && (s.zoom = t.zoom), t.view !== void 0 && (s.view = Object.assign({}, t.view));
          break;
        case "AmbientLight":
          s = new Pg(t.color, t.intensity);
          break;
        case "DirectionalLight":
          s = new Dg(t.color, t.intensity);
          break;
        case "PointLight":
          s = new Ig(t.color, t.intensity, t.distance, t.decay);
          break;
        case "RectAreaLight":
          s = new Rg(t.color, t.intensity, t.width, t.height);
          break;
        case "SpotLight":
          s = new Tg(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
          break;
        case "HemisphereLight":
          s = new Mg(t.color, t.groundColor, t.intensity);
          break;
        case "LightProbe":
          s = new kd().fromJSON(t);
          break;
        case "SkinnedMesh":
          d = a(t.geometry), u = l(t.material), s = new Xh(d, u), t.bindMode !== void 0 && (s.bindMode = t.bindMode), t.bindMatrix !== void 0 && s.bindMatrix.fromArray(t.bindMatrix), t.skeleton !== void 0 && (s.skeleton = t.skeleton);
          break;
        case "Mesh":
          d = a(t.geometry), u = l(t.material), s = new li(d, u);
          break;
        case "InstancedMesh":
          d = a(t.geometry), u = l(t.material);
          let h = t.count, p = t.instanceMatrix, f = t.instanceColor;
          s = new qm(d, u, h), s.instanceMatrix = new ka(new Float32Array(p.array), 16), f !== void 0 && (s.instanceColor = new ka(new Float32Array(f.array), f.itemSize));
          break;
        case "LOD":
          s = new nx();
          break;
        case "Line":
          s = new ds(a(t.geometry), l(t.material));
          break;
        case "LineLoop":
          s = new Ym(a(t.geometry), l(t.material));
          break;
        case "LineSegments":
          s = new wr(a(t.geometry), l(t.material));
          break;
        case "PointCloud":
        case "Points":
          s = new Md(a(t.geometry), l(t.material));
          break;
        case "Sprite":
          s = new Yh(l(t.material));
          break;
        case "Group":
          s = new Da();
          break;
        case "Bone":
          s = new Zh();
          break;
        default:
          s = new ln();
      }
      if (s.uuid = t.uuid, t.name !== void 0 && (s.name = t.name), t.matrix !== void 0 ? (s.matrix.fromArray(t.matrix), t.matrixAutoUpdate !== void 0 && (s.matrixAutoUpdate = t.matrixAutoUpdate), s.matrixAutoUpdate && s.matrix.decompose(s.position, s.quaternion, s.scale)) : (t.position !== void 0 && s.position.fromArray(t.position), t.rotation !== void 0 && s.rotation.fromArray(t.rotation), t.quaternion !== void 0 && s.quaternion.fromArray(t.quaternion), t.scale !== void 0 && s.scale.fromArray(t.scale)), t.castShadow !== void 0 && (s.castShadow = t.castShadow), t.receiveShadow !== void 0 && (s.receiveShadow = t.receiveShadow), t.shadow && (t.shadow.bias !== void 0 && (s.shadow.bias = t.shadow.bias), t.shadow.normalBias !== void 0 && (s.shadow.normalBias = t.shadow.normalBias), t.shadow.radius !== void 0 && (s.shadow.radius = t.shadow.radius), t.shadow.mapSize !== void 0 && s.shadow.mapSize.fromArray(t.shadow.mapSize), t.shadow.camera !== void 0 && (s.shadow.camera = this.parseObject(t.shadow.camera))), t.visible !== void 0 && (s.visible = t.visible), t.frustumCulled !== void 0 && (s.frustumCulled = t.frustumCulled), t.renderOrder !== void 0 && (s.renderOrder = t.renderOrder), t.userData !== void 0 && (s.userData = t.userData), t.layers !== void 0 && (s.layers.mask = t.layers), t.children !== void 0) {
        let h = t.children;
        for (let p = 0; p < h.length; p++) s.add(this.parseObject(h[p], e, n, r, o));
      }
      if (t.animations !== void 0) {
        let h = t.animations;
        for (let p = 0; p < h.length; p++) {
          let f = h[p];
          s.animations.push(o[f]);
        }
      }
      if (t.type === "LOD") {
        t.autoUpdate !== void 0 && (s.autoUpdate = t.autoUpdate);
        let h = t.levels;
        for (let p = 0; p < h.length; p++) {
          let f = h[p], m = s.getObjectByProperty("uuid", f.object);
          m !== void 0 && s.addLevel(m, f.distance);
        }
      }
      return s;
    }
    bindSkeletons(t, e) {
      Object.keys(e).length !== 0 && t.traverse(function(n) {
        if (n.isSkinnedMesh === true && n.skeleton !== void 0) {
          let r = e[n.skeleton];
          r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(r, n.bindMatrix);
        }
      });
    }
    setTexturePath(t) {
      return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t);
    }
  };
  var Ure = { UVMapping: Fx, CubeReflectionMapping: Ld, CubeRefractionMapping: Fd, EquirectangularReflectionMapping: Om, EquirectangularRefractionMapping: Am, CubeUVReflectionMapping: sp, CubeUVRefractionMapping: Lg };
  var oV = { RepeatWrapping: Nm, ClampToEdgeWrapping: nr, MirroredRepeatWrapping: km };
  var sV = { NearestFilter: Si, NearestMipmapNearestFilter: j0, NearestMipmapLinearFilter: W0, LinearFilter: Ri, LinearMipmapNearestFilter: eD, LinearMipmapLinearFilter: Bd };
  var bx = class extends sr {
    constructor(t) {
      super(t), typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
    }
    setOptions(t) {
      return this.options = t, this;
    }
    load(t, e, n, r) {
      t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
      let o = this, s = Ad.get(t);
      if (s !== void 0) return o.manager.itemStart(t), setTimeout(function() {
        e && e(s), o.manager.itemEnd(t);
      }, 0), s;
      let a = {};
      a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader, fetch(t, a).then(function(l) {
        return l.blob();
      }).then(function(l) {
        return createImageBitmap(l, Object.assign(o.options, { colorSpaceConversion: "none" }));
      }).then(function(l) {
        Ad.add(t, l), e && e(l), o.manager.itemEnd(t);
      }).catch(function(l) {
        r && r(l), o.manager.itemError(t), o.manager.itemEnd(t);
      }), o.manager.itemStart(t);
    }
  };
  bx.prototype.isImageBitmapLoader = true;
  var N0;
  var dD = { getContext: function() {
    return N0 === void 0 && (N0 = new (window.AudioContext || window.webkitAudioContext)()), N0;
  }, setContext: function(i59) {
    N0 = i59;
  } };
  var xx = class extends sr {
    constructor(t) {
      super(t);
    }
    load(t, e, n, r) {
      let o = this, s = new Lo(this.manager);
      s.setResponseType("arraybuffer"), s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, function(a) {
        try {
          let l = a.slice(0);
          dD.getContext().decodeAudioData(l, function(d) {
            e(d);
          });
        } catch (l) {
          r ? r(l) : console.error(l), o.manager.itemError(t);
        }
      }, n, r);
    }
  };
  var wx = class extends kd {
    constructor(t, e, n = 1) {
      super(void 0, n);
      let r = new Ye().set(t), o = new Ye().set(e), s = new L(r.r, r.g, r.b), a = new L(o.r, o.g, o.b), l = Math.sqrt(Math.PI), c = l * Math.sqrt(0.75);
      this.sh.coefficients[0].copy(s).add(a).multiplyScalar(l), this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(c);
    }
  };
  wx.prototype.isHemisphereLightProbe = true;
  var Cx = class extends kd {
    constructor(t, e = 1) {
      super(void 0, e);
      let n = new Ye().set(t);
      this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI));
    }
  };
  Cx.prototype.isAmbientLightProbe = true;
  var aV = new ut();
  var lV = new ut();
  var D1 = class {
    constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Ci(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Ci(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
    }
    update(t) {
      let e = this._cache;
      if (e.focus !== t.focus || e.fov !== t.fov || e.aspect !== t.aspect * this.aspect || e.near !== t.near || e.far !== t.far || e.zoom !== t.zoom || e.eyeSep !== this.eyeSep) {
        e.focus = t.focus, e.fov = t.fov, e.aspect = t.aspect * this.aspect, e.near = t.near, e.far = t.far, e.zoom = t.zoom, e.eyeSep = this.eyeSep;
        let r = t.projectionMatrix.clone(), o = e.eyeSep / 2, s = o * e.near / e.focus, a = e.near * Math.tan(vd * e.fov * 0.5) / e.zoom, l, c;
        lV.elements[12] = -o, aV.elements[12] = o, l = -a * e.aspect + s, c = a * e.aspect + s, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(r), l = -a * e.aspect - s, c = a * e.aspect - s, r.elements[0] = 2 * e.near / (c - l), r.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(r);
      }
      this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(lV), this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(aV);
    }
  };
  var Sx = class {
    constructor(t = true) {
      this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
    }
    start() {
      this.startTime = cV(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
    }
    stop() {
      this.getElapsedTime(), this.running = false, this.autoStart = false;
    }
    getElapsedTime() {
      return this.getDelta(), this.elapsedTime;
    }
    getDelta() {
      let t = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
        let e = cV();
        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t;
      }
      return t;
    }
  };
  function cV() {
    return (typeof performance > "u" ? Date : performance).now();
  }
  var ad = new L();
  var dV = new Oi();
  var Gre = new L();
  var ld = new L();
  var P1 = class extends ln {
    constructor() {
      super(), this.type = "AudioListener", this.context = dD.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Sx();
    }
    getInput() {
      return this.gain;
    }
    removeFilter() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
    }
    getFilter() {
      return this.filter;
    }
    setFilter(t) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
    }
    getMasterVolume() {
      return this.gain.gain.value;
    }
    setMasterVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
    updateMatrixWorld(t) {
      super.updateMatrixWorld(t);
      let e = this.context.listener, n = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ad, dV, Gre), ld.set(0, 0, -1).applyQuaternion(dV), e.positionX) {
        let r = this.context.currentTime + this.timeDelta;
        e.positionX.linearRampToValueAtTime(ad.x, r), e.positionY.linearRampToValueAtTime(ad.y, r), e.positionZ.linearRampToValueAtTime(ad.z, r), e.forwardX.linearRampToValueAtTime(ld.x, r), e.forwardY.linearRampToValueAtTime(ld.y, r), e.forwardZ.linearRampToValueAtTime(ld.z, r), e.upX.linearRampToValueAtTime(n.x, r), e.upY.linearRampToValueAtTime(n.y, r), e.upZ.linearRampToValueAtTime(n.z, r);
      } else e.setPosition(ad.x, ad.y, ad.z), e.setOrientation(ld.x, ld.y, ld.z, n.x, n.y, n.z);
    }
  };
  var Ng = class extends ln {
    constructor(t) {
      super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
    }
    getOutput() {
      return this.gain;
    }
    setNodeSource(t) {
      return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = t, this.connect(), this;
    }
    setMediaElementSource(t) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this;
    }
    setMediaStreamSource(t) {
      return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this;
    }
    setBuffer(t) {
      return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this;
    }
    play(t = 0) {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this._startedAt = this.context.currentTime + t;
      let e = this.context.createBufferSource();
      return e.buffer = this.buffer, e.loop = this.loop, e.loopStart = this.loopStart, e.loopEnd = this.loopEnd, e.onended = this.onEnded.bind(this), e.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = e, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
    }
    pause() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
    }
    stop() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = false, this;
    }
    connect() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else this.source.connect(this.getOutput());
      return this._connected = true, this;
    }
    disconnect() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
    getFilters() {
      return this.filters;
    }
    setFilters(t) {
      return t || (t = []), this._connected === true ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this;
    }
    setDetune(t) {
      if (this.detune = t, this.source.detune !== void 0) return this.isPlaying === true && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
    }
    getDetune() {
      return this.detune;
    }
    getFilter() {
      return this.getFilters()[0];
    }
    setFilter(t) {
      return this.setFilters(t ? [t] : []);
    }
    setPlaybackRate(t) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.playbackRate = t, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
    }
    getPlaybackRate() {
      return this.playbackRate;
    }
    onEnded() {
      this.isPlaying = false;
    }
    getLoop() {
      return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
    }
    setLoop(t) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      return this.loop = t, this.isPlaying === true && (this.source.loop = this.loop), this;
    }
    setLoopStart(t) {
      return this.loopStart = t, this;
    }
    setLoopEnd(t) {
      return this.loopEnd = t, this;
    }
    getVolume() {
      return this.gain.gain.value;
    }
    setVolume(t) {
      return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
    }
  };
  var cd = new L();
  var uV = new Oi();
  var Hre = new L();
  var dd = new L();
  var R1 = class extends Ng {
    constructor(t) {
      super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
    }
    getOutput() {
      return this.panner;
    }
    getRefDistance() {
      return this.panner.refDistance;
    }
    setRefDistance(t) {
      return this.panner.refDistance = t, this;
    }
    getRolloffFactor() {
      return this.panner.rolloffFactor;
    }
    setRolloffFactor(t) {
      return this.panner.rolloffFactor = t, this;
    }
    getDistanceModel() {
      return this.panner.distanceModel;
    }
    setDistanceModel(t) {
      return this.panner.distanceModel = t, this;
    }
    getMaxDistance() {
      return this.panner.maxDistance;
    }
    setMaxDistance(t) {
      return this.panner.maxDistance = t, this;
    }
    setDirectionalCone(t, e, n) {
      return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this;
    }
    updateMatrixWorld(t) {
      if (super.updateMatrixWorld(t), this.hasPlaybackControl === true && this.isPlaying === false) return;
      this.matrixWorld.decompose(cd, uV, Hre), dd.set(0, 0, 1).applyQuaternion(uV);
      let e = this.panner;
      if (e.positionX) {
        let n = this.context.currentTime + this.listener.timeDelta;
        e.positionX.linearRampToValueAtTime(cd.x, n), e.positionY.linearRampToValueAtTime(cd.y, n), e.positionZ.linearRampToValueAtTime(cd.z, n), e.orientationX.linearRampToValueAtTime(dd.x, n), e.orientationY.linearRampToValueAtTime(dd.y, n), e.orientationZ.linearRampToValueAtTime(dd.z, n);
      } else e.setPosition(cd.x, cd.y, cd.z), e.setOrientation(dd.x, dd.y, dd.z);
    }
  };
  var Mx = class {
    constructor(t, e = 2048) {
      this.analyser = t.context.createAnalyser(), this.analyser.fftSize = e, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser);
    }
    getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data;
    }
    getAverageFrequency() {
      let t = 0, e = this.getFrequencyData();
      for (let n = 0; n < e.length; n++) t += e[n];
      return t / e.length;
    }
  };
  var Ex = class {
    constructor(t, e, n) {
      this.binding = t, this.valueSize = n;
      let r, o, s;
      switch (e) {
        case "quaternion":
          r = this._slerp, o = this._slerpAdditive, s = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
          break;
        case "string":
        case "bool":
          r = this._select, o = this._select, s = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
          break;
        default:
          r = this._lerp, o = this._lerpAdditive, s = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5);
      }
      this._mixBufferRegion = r, this._mixBufferRegionAdditive = o, this._setIdentity = s, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
    }
    accumulate(t, e) {
      let n = this.buffer, r = this.valueSize, o = t * r + r, s = this.cumulativeWeight;
      if (s === 0) {
        for (let a = 0; a !== r; ++a) n[o + a] = n[a];
        s = e;
      } else {
        s += e;
        let a = e / s;
        this._mixBufferRegion(n, o, 0, a, r);
      }
      this.cumulativeWeight = s;
    }
    accumulateAdditive(t) {
      let e = this.buffer, n = this.valueSize, r = n * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t;
    }
    apply(t) {
      let e = this.valueSize, n = this.buffer, r = t * e + e, o = this.cumulativeWeight, s = this.cumulativeWeightAdditive, a = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
        let l = e * this._origIndex;
        this._mixBufferRegion(n, r, l, 1 - o, e);
      }
      s > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
      for (let l = e, c = e + e; l !== c; ++l) if (n[l] !== n[l + e]) {
        a.setValue(n, r);
        break;
      }
    }
    saveOriginalState() {
      let t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex;
      t.getValue(e, r);
      for (let o = n, s = r; o !== s; ++o) e[o] = e[r + o % n];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
    }
    restoreOriginalState() {
      let t = this.valueSize * 3;
      this.binding.setValue(this.buffer, t);
    }
    _setAdditiveIdentityNumeric() {
      let t = this._addIndex * this.valueSize, e = t + this.valueSize;
      for (let n = t; n < e; n++) this.buffer[n] = 0;
    }
    _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
    }
    _setAdditiveIdentityOther() {
      let t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize;
      for (let n = 0; n < this.valueSize; n++) this.buffer[e + n] = this.buffer[t + n];
    }
    _select(t, e, n, r, o) {
      if (r >= 0.5) for (let s = 0; s !== o; ++s) t[e + s] = t[n + s];
    }
    _slerp(t, e, n, r) {
      Oi.slerpFlat(t, e, t, e, t, n, r);
    }
    _slerpAdditive(t, e, n, r, o) {
      let s = this._workIndex * o;
      Oi.multiplyQuaternionsFlat(t, s, t, e, t, n), Oi.slerpFlat(t, e, t, e, t, s, r);
    }
    _lerp(t, e, n, r, o) {
      let s = 1 - r;
      for (let a = 0; a !== o; ++a) {
        let l = e + a;
        t[l] = t[l] * s + t[n + a] * r;
      }
    }
    _lerpAdditive(t, e, n, r, o) {
      for (let s = 0; s !== o; ++s) {
        let a = e + s;
        t[a] = t[a] + t[n + s] * r;
      }
    }
  };
  var uD = "\\[\\]\\.:\\/";
  var jre = new RegExp("[" + uD + "]", "g");
  var hD = "[^" + uD + "]";
  var Wre = "[^" + uD.replace("\\.", "") + "]";
  var $re = /((?:WC+[\/:])*)/.source.replace("WC", hD);
  var qre = /(WCOD+)?/.source.replace("WCOD", Wre);
  var Yre = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", hD);
  var Xre = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", hD);
  var Zre = new RegExp("^" + $re + qre + Yre + Xre + "$");
  var Qre = ["material", "materials", "bones"];
  var O1 = class {
    constructor(t, e, n) {
      let r = n || Fn.parseTrackName(e);
      this._targetGroup = t, this._bindings = t.subscribe_(e, r);
    }
    getValue(t, e) {
      this.bind();
      let n = this._targetGroup.nCachedObjects_, r = this._bindings[n];
      r !== void 0 && r.getValue(t, e);
    }
    setValue(t, e) {
      let n = this._bindings;
      for (let r = this._targetGroup.nCachedObjects_, o = n.length; r !== o; ++r) n[r].setValue(t, e);
    }
    bind() {
      let t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind();
    }
    unbind() {
      let t = this._bindings;
      for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind();
    }
  };
  var Fn = (() => {
    class i59 {
      constructor(e, n, r) {
        this.path = n, this.parsedPath = r || i59.parseTrackName(n), this.node = i59.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
      static create(e, n, r) {
        return e && e.isAnimationObjectGroup ? new i59.Composite(e, n, r) : new i59(e, n, r);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(jre, "");
      }
      static parseTrackName(e) {
        let n = Zre.exec(e);
        if (!n) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        let r = { nodeName: n[2], objectName: n[3], objectIndex: n[4], propertyName: n[5], propertyIndex: n[6] }, o = r.nodeName && r.nodeName.lastIndexOf(".");
        if (o !== void 0 && o !== -1) {
          let s = r.nodeName.substring(o + 1);
          Qre.indexOf(s) !== -1 && (r.nodeName = r.nodeName.substring(0, o), r.objectName = s);
        }
        if (r.propertyName === null || r.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return r;
      }
      static findNode(e, n) {
        if (!n || n === "" || n === "." || n === -1 || n === e.name || n === e.uuid) return e;
        if (e.skeleton) {
          let r = e.skeleton.getBoneByName(n);
          if (r !== void 0) return r;
        }
        if (e.children) {
          let r = function(s) {
            for (let a = 0; a < s.length; a++) {
              let l = s[a];
              if (l.name === n || l.uuid === n) return l;
              let c = r(l.children);
              if (c) return c;
            }
            return null;
          }, o = r(e.children);
          if (o) return o;
        }
        return null;
      }
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      _getValue_direct(e, n) {
        e[n] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, n) {
        let r = this.resolvedProperty;
        for (let o = 0, s = r.length; o !== s; ++o) e[n++] = r[o];
      }
      _getValue_arrayElement(e, n) {
        e[n] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, n) {
        this.resolvedProperty.toArray(e, n);
      }
      _setValue_direct(e, n) {
        this.targetObject[this.propertyName] = e[n];
      }
      _setValue_direct_setNeedsUpdate(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, n) {
        this.targetObject[this.propertyName] = e[n], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(e, n) {
        let r = this.resolvedProperty;
        for (let o = 0, s = r.length; o !== s; ++o) r[o] = e[n++];
      }
      _setValue_array_setNeedsUpdate(e, n) {
        let r = this.resolvedProperty;
        for (let o = 0, s = r.length; o !== s; ++o) r[o] = e[n++];
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, n) {
        let r = this.resolvedProperty;
        for (let o = 0, s = r.length; o !== s; ++o) r[o] = e[n++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n];
      }
      _setValue_arrayElement_setNeedsUpdate(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, n) {
        this.resolvedProperty[this.propertyIndex] = e[n], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(e, n) {
        this.resolvedProperty.fromArray(e, n);
      }
      _setValue_fromArray_setNeedsUpdate(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, n) {
        this.resolvedProperty.fromArray(e, n), this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(e, n) {
        this.bind(), this.getValue(e, n);
      }
      _setValue_unbound(e, n) {
        this.bind(), this.setValue(e, n);
      }
      bind() {
        let e = this.node, n = this.parsedPath, r = n.objectName, o = n.propertyName, s = n.propertyIndex;
        if (e || (e = i59.findNode(this.rootNode, n.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (r) {
          let d = n.objectIndex;
          switch (r) {
            case "materials":
              if (!e.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!e.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              e = e.skeleton.bones;
              for (let u = 0; u < e.length; u++) if (e[u].name === d) {
                d = u;
                break;
              }
              break;
            default:
              if (e[r] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              e = e[r];
          }
          if (d !== void 0) {
            if (e[d] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
              return;
            }
            e = e[d];
          }
        }
        let a = e[o];
        if (a === void 0) {
          let d = n.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + d + "." + o + " but it wasn't found.", e);
          return;
        }
        let l = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? l = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
        let c = this.BindingType.Direct;
        if (s !== void 0) {
          if (o === "morphTargetInfluences") {
            if (!e.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (e.geometry.isBufferGeometry) {
              if (!e.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
            } else {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              return;
            }
          }
          c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
        } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = o;
        this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l];
      }
      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
    }
    return i59.Composite = O1, i59;
  })();
  Fn.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
  Fn.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
  Fn.prototype.GetterByBindingType = [Fn.prototype._getValue_direct, Fn.prototype._getValue_array, Fn.prototype._getValue_arrayElement, Fn.prototype._getValue_toArray];
  Fn.prototype.SetterByBindingTypeAndVersioning = [[Fn.prototype._setValue_direct, Fn.prototype._setValue_direct_setNeedsUpdate, Fn.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Fn.prototype._setValue_array, Fn.prototype._setValue_array_setNeedsUpdate, Fn.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Fn.prototype._setValue_arrayElement, Fn.prototype._setValue_arrayElement_setNeedsUpdate, Fn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Fn.prototype._setValue_fromArray, Fn.prototype._setValue_fromArray_setNeedsUpdate, Fn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
  var Tx = class {
    constructor() {
      this.uuid = ho(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      let t = {};
      this._indicesByUUID = t;
      for (let n = 0, r = arguments.length; n !== r; ++n) t[arguments[n].uuid] = n;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      let e = this;
      this.stats = { objects: { get total() {
        return e._objects.length;
      }, get inUse() {
        return this.total - e.nCachedObjects_;
      } }, get bindingsPerObject() {
        return e._bindings.length;
      } };
    }
    add() {
      let t = this._objects, e = this._indicesByUUID, n = this._paths, r = this._parsedPaths, o = this._bindings, s = o.length, a, l = t.length, c = this.nCachedObjects_;
      for (let d = 0, u = arguments.length; d !== u; ++d) {
        let h = arguments[d], p = h.uuid, f = e[p];
        if (f === void 0) {
          f = l++, e[p] = f, t.push(h);
          for (let m = 0, v = s; m !== v; ++m) o[m].push(new Fn(h, n[m], r[m]));
        } else if (f < c) {
          a = t[f];
          let m = --c, v = t[m];
          e[v.uuid] = f, t[f] = v, e[p] = m, t[m] = h;
          for (let _ = 0, g = s; _ !== g; ++_) {
            let y = o[_], w = y[m], E = y[f];
            y[f] = w, E === void 0 && (E = new Fn(h, n[_], r[_])), y[m] = E;
          }
        } else t[f] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
      this.nCachedObjects_ = c;
    }
    remove() {
      let t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length, o = this.nCachedObjects_;
      for (let s = 0, a = arguments.length; s !== a; ++s) {
        let l = arguments[s], c = l.uuid, d = e[c];
        if (d !== void 0 && d >= o) {
          let u = o++, h = t[u];
          e[h.uuid] = d, t[d] = h, e[c] = u, t[u] = l;
          for (let p = 0, f = r; p !== f; ++p) {
            let m = n[p], v = m[u], _ = m[d];
            m[d] = v, m[u] = _;
          }
        }
      }
      this.nCachedObjects_ = o;
    }
    uncache() {
      let t = this._objects, e = this._indicesByUUID, n = this._bindings, r = n.length, o = this.nCachedObjects_, s = t.length;
      for (let a = 0, l = arguments.length; a !== l; ++a) {
        let c = arguments[a], d = c.uuid, u = e[d];
        if (u !== void 0) if (delete e[d], u < o) {
          let h = --o, p = t[h], f = --s, m = t[f];
          e[p.uuid] = u, t[u] = p, e[m.uuid] = h, t[h] = m, t.pop();
          for (let v = 0, _ = r; v !== _; ++v) {
            let g = n[v], y = g[h], w = g[f];
            g[u] = y, g[h] = w, g.pop();
          }
        } else {
          let h = --s, p = t[h];
          h > 0 && (e[p.uuid] = u), t[u] = p, t.pop();
          for (let f = 0, m = r; f !== m; ++f) {
            let v = n[f];
            v[u] = v[h], v.pop();
          }
        }
      }
      this.nCachedObjects_ = o;
    }
    subscribe_(t, e) {
      let n = this._bindingsIndicesByPath, r = n[t], o = this._bindings;
      if (r !== void 0) return o[r];
      let s = this._paths, a = this._parsedPaths, l = this._objects, c = l.length, d = this.nCachedObjects_, u = new Array(c);
      r = o.length, n[t] = r, s.push(t), a.push(e), o.push(u);
      for (let h = d, p = l.length; h !== p; ++h) {
        let f = l[h];
        u[h] = new Fn(f, t, e);
      }
      return u;
    }
    unsubscribe_(t) {
      let e = this._bindingsIndicesByPath, n = e[t];
      if (n !== void 0) {
        let r = this._paths, o = this._parsedPaths, s = this._bindings, a = s.length - 1, l = s[a], c = t[a];
        e[c] = n, s[n] = l, s.pop(), o[n] = o[a], o.pop(), r[n] = r[a], r.pop();
      }
    }
  };
  Tx.prototype.isAnimationObjectGroup = true;
  var A1 = class {
    constructor(t, e, n = null, r = e.blendMode) {
      this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
      let o = e.tracks, s = o.length, a = new Array(s), l = { endingStart: pd, endingEnd: pd };
      for (let c = 0; c !== s; ++c) {
        let d = o[c].createInterpolant(null);
        a[c] = d, d.settings = l;
      }
      this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(s), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Hz, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
    }
    play() {
      return this._mixer._activateAction(this), this;
    }
    stop() {
      return this._mixer._deactivateAction(this), this.reset();
    }
    reset() {
      return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
    }
    isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    }
    isScheduled() {
      return this._mixer._isActiveAction(this);
    }
    startAt(t) {
      return this._startTime = t, this;
    }
    setLoop(t, e) {
      return this.loop = t, this.repetitions = e, this;
    }
    setEffectiveWeight(t) {
      return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading();
    }
    getEffectiveWeight() {
      return this._effectiveWeight;
    }
    fadeIn(t) {
      return this._scheduleFading(t, 0, 1);
    }
    fadeOut(t) {
      return this._scheduleFading(t, 1, 0);
    }
    crossFadeFrom(t, e, n) {
      if (t.fadeOut(e), this.fadeIn(e), n) {
        let r = this._clip.duration, o = t._clip.duration, s = o / r, a = r / o;
        t.warp(1, s, e), this.warp(a, 1, e);
      }
      return this;
    }
    crossFadeTo(t, e, n) {
      return t.crossFadeFrom(this, e, n);
    }
    stopFading() {
      let t = this._weightInterpolant;
      return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
    setEffectiveTimeScale(t) {
      return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping();
    }
    getEffectiveTimeScale() {
      return this._effectiveTimeScale;
    }
    setDuration(t) {
      return this.timeScale = this._clip.duration / t, this.stopWarping();
    }
    syncWith(t) {
      return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping();
    }
    halt(t) {
      return this.warp(this._effectiveTimeScale, 0, t);
    }
    warp(t, e, n) {
      let r = this._mixer, o = r.time, s = this.timeScale, a = this._timeScaleInterpolant;
      a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
      let l = a.parameterPositions, c = a.sampleValues;
      return l[0] = o, l[1] = o + n, c[0] = t / s, c[1] = e / s, this;
    }
    stopWarping() {
      let t = this._timeScaleInterpolant;
      return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this;
    }
    getMixer() {
      return this._mixer;
    }
    getClip() {
      return this._clip;
    }
    getRoot() {
      return this._localRoot || this._mixer._root;
    }
    _update(t, e, n, r) {
      if (!this.enabled) {
        this._updateWeight(t);
        return;
      }
      let o = this._startTime;
      if (o !== null) {
        let l = (t - o) * n;
        if (l < 0 || n === 0) return;
        this._startTime = null, e = n * l;
      }
      e *= this._updateTimeScale(t);
      let s = this._updateTime(e), a = this._updateWeight(t);
      if (a > 0) {
        let l = this._interpolants, c = this._propertyBindings;
        switch (this.blendMode) {
          case tD:
            for (let d = 0, u = l.length; d !== u; ++d) l[d].evaluate(s), c[d].accumulateAdditive(a);
            break;
          case Bx:
          default:
            for (let d = 0, u = l.length; d !== u; ++d) l[d].evaluate(s), c[d].accumulate(r, a);
        }
      }
    }
    _updateWeight(t) {
      let e = 0;
      if (this.enabled) {
        e = this.weight;
        let n = this._weightInterpolant;
        if (n !== null) {
          let r = n.evaluate(t)[0];
          e *= r, t > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = false));
        }
      }
      return this._effectiveWeight = e, e;
    }
    _updateTimeScale(t) {
      let e = 0;
      if (!this.paused) {
        e = this.timeScale;
        let n = this._timeScaleInterpolant;
        if (n !== null) {
          let r = n.evaluate(t)[0];
          e *= r, t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = true : this.timeScale = e);
        }
      }
      return this._effectiveTimeScale = e, e;
    }
    _updateTime(t) {
      let e = this._clip.duration, n = this.loop, r = this.time + t, o = this._loopCount, s = n === jz;
      if (t === 0) return o === -1 ? r : s && (o & 1) === 1 ? e - r : r;
      if (n === Gz) {
        o === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
        e: {
          if (r >= e) r = e;
          else if (r < 0) r = 0;
          else {
            this.time = r;
            break e;
          }
          this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 });
        }
      } else {
        if (o === -1 && (t >= 0 ? (o = 0, this._setEndings(true, this.repetitions === 0, s)) : this._setEndings(this.repetitions === 0, true, s)), r >= e || r < 0) {
          let a = Math.floor(r / e);
          r -= e * a, o += Math.abs(a);
          let l = this.repetitions - o;
          if (l <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 });
          else {
            if (l === 1) {
              let c = t < 0;
              this._setEndings(c, !c, s);
            } else this._setEndings(false, false, s);
            this._loopCount = o, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a });
          }
        } else this.time = r;
        if (s && (o & 1) === 1) return e - r;
      }
      return r;
    }
    _setEndings(t, e, n) {
      let r = this._interpolantSettings;
      n ? (r.endingStart = fd, r.endingEnd = fd) : (t ? r.endingStart = this.zeroSlopeAtStart ? fd : pd : r.endingStart = Vm, e ? r.endingEnd = this.zeroSlopeAtEnd ? fd : pd : r.endingEnd = Vm);
    }
    _scheduleFading(t, e, n) {
      let r = this._mixer, o = r.time, s = this._weightInterpolant;
      s === null && (s = r._lendControlInterpolant(), this._weightInterpolant = s);
      let a = s.parameterPositions, l = s.sampleValues;
      return a[0] = o, l[0] = e, a[1] = o + t, l[1] = n, this;
    }
  };
  var Ix = class extends Vs {
    constructor(t) {
      super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
    }
    _bindAction(t, e) {
      let n = t._localRoot || this._root, r = t._clip.tracks, o = r.length, s = t._propertyBindings, a = t._interpolants, l = n.uuid, c = this._bindingsByRootAndName, d = c[l];
      d === void 0 && (d = {}, c[l] = d);
      for (let u = 0; u !== o; ++u) {
        let h = r[u], p = h.name, f = d[p];
        if (f !== void 0) s[u] = f;
        else {
          if (f = s[u], f !== void 0) {
            f._cacheIndex === null && (++f.referenceCount, this._addInactiveBinding(f, l, p));
            continue;
          }
          let m = e && e._propertyBindings[u].binding.parsedPath;
          f = new Ex(Fn.create(n, p, m), h.ValueTypeName, h.getValueSize()), ++f.referenceCount, this._addInactiveBinding(f, l, p), s[u] = f;
        }
        a[u].resultBuffer = f.buffer;
      }
    }
    _activateAction(t) {
      if (!this._isActiveAction(t)) {
        if (t._cacheIndex === null) {
          let n = (t._localRoot || this._root).uuid, r = t._clip.uuid, o = this._actionsByClip[r];
          this._bindAction(t, o && o.knownActions[0]), this._addInactiveAction(t, r, n);
        }
        let e = t._propertyBindings;
        for (let n = 0, r = e.length; n !== r; ++n) {
          let o = e[n];
          o.useCount++ === 0 && (this._lendBinding(o), o.saveOriginalState());
        }
        this._lendAction(t);
      }
    }
    _deactivateAction(t) {
      if (this._isActiveAction(t)) {
        let e = t._propertyBindings;
        for (let n = 0, r = e.length; n !== r; ++n) {
          let o = e[n];
          --o.useCount === 0 && (o.restoreOriginalState(), this._takeBackBinding(o));
        }
        this._takeBackAction(t);
      }
    }
    _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      let t = this;
      this.stats = { actions: { get total() {
        return t._actions.length;
      }, get inUse() {
        return t._nActiveActions;
      } }, bindings: { get total() {
        return t._bindings.length;
      }, get inUse() {
        return t._nActiveBindings;
      } }, controlInterpolants: { get total() {
        return t._controlInterpolants.length;
      }, get inUse() {
        return t._nActiveControlInterpolants;
      } } };
    }
    _isActiveAction(t) {
      let e = t._cacheIndex;
      return e !== null && e < this._nActiveActions;
    }
    _addInactiveAction(t, e, n) {
      let r = this._actions, o = this._actionsByClip, s = o[e];
      if (s === void 0) s = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, o[e] = s;
      else {
        let a = s.knownActions;
        t._byClipCacheIndex = a.length, a.push(t);
      }
      t._cacheIndex = r.length, r.push(t), s.actionByRoot[n] = t;
    }
    _removeInactiveAction(t) {
      let e = this._actions, n = e[e.length - 1], r = t._cacheIndex;
      n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
      let o = t._clip.uuid, s = this._actionsByClip, a = s[o], l = a.knownActions, c = l[l.length - 1], d = t._byClipCacheIndex;
      c._byClipCacheIndex = d, l[d] = c, l.pop(), t._byClipCacheIndex = null;
      let u = a.actionByRoot, h = (t._localRoot || this._root).uuid;
      delete u[h], l.length === 0 && delete s[o], this._removeInactiveBindingsForAction(t);
    }
    _removeInactiveBindingsForAction(t) {
      let e = t._propertyBindings;
      for (let n = 0, r = e.length; n !== r; ++n) {
        let o = e[n];
        --o.referenceCount === 0 && this._removeInactiveBinding(o);
      }
    }
    _lendAction(t) {
      let e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, o = e[r];
      t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o;
    }
    _takeBackAction(t) {
      let e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, o = e[r];
      t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o;
    }
    _addInactiveBinding(t, e, n) {
      let r = this._bindingsByRootAndName, o = this._bindings, s = r[e];
      s === void 0 && (s = {}, r[e] = s), s[n] = t, t._cacheIndex = o.length, o.push(t);
    }
    _removeInactiveBinding(t) {
      let e = this._bindings, n = t.binding, r = n.rootNode.uuid, o = n.path, s = this._bindingsByRootAndName, a = s[r], l = e[e.length - 1], c = t._cacheIndex;
      l._cacheIndex = c, e[c] = l, e.pop(), delete a[o], Object.keys(a).length === 0 && delete s[r];
    }
    _lendBinding(t) {
      let e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, o = e[r];
      t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o;
    }
    _takeBackBinding(t) {
      let e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, o = e[r];
      t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o;
    }
    _lendControlInterpolant() {
      let t = this._controlInterpolants, e = this._nActiveControlInterpolants++, n = t[e];
      return n === void 0 && (n = new wg(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n;
    }
    _takeBackControlInterpolant(t) {
      let e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, o = e[r];
      t.__cacheIndex = r, e[r] = t, o.__cacheIndex = n, e[n] = o;
    }
    clipAction(t, e, n) {
      let r = e || this._root, o = r.uuid, s = typeof t == "string" ? Od.findByName(r, t) : t, a = s !== null ? s.uuid : t, l = this._actionsByClip[a], c = null;
      if (n === void 0 && (s !== null ? n = s.blendMode : n = Bx), l !== void 0) {
        let u = l.actionByRoot[o];
        if (u !== void 0 && u.blendMode === n) return u;
        c = l.knownActions[0], s === null && (s = c._clip);
      }
      if (s === null) return null;
      let d = new A1(this, s, e, n);
      return this._bindAction(d, c), this._addInactiveAction(d, a, o), d;
    }
    existingAction(t, e) {
      let n = e || this._root, r = n.uuid, o = typeof t == "string" ? Od.findByName(n, t) : t, s = o ? o.uuid : t, a = this._actionsByClip[s];
      return a !== void 0 && a.actionByRoot[r] || null;
    }
    stopAllAction() {
      let t = this._actions, e = this._nActiveActions;
      for (let n = e - 1; n >= 0; --n) t[n].stop();
      return this;
    }
    update(t) {
      t *= this.timeScale;
      let e = this._actions, n = this._nActiveActions, r = this.time += t, o = Math.sign(t), s = this._accuIndex ^= 1;
      for (let c = 0; c !== n; ++c) e[c]._update(r, t, o, s);
      let a = this._bindings, l = this._nActiveBindings;
      for (let c = 0; c !== l; ++c) a[c].apply(s);
      return this;
    }
    setTime(t) {
      this.time = 0;
      for (let e = 0; e < this._actions.length; e++) this._actions[e].time = 0;
      return this.update(t);
    }
    getRoot() {
      return this._root;
    }
    uncacheClip(t) {
      let e = this._actions, n = t.uuid, r = this._actionsByClip, o = r[n];
      if (o !== void 0) {
        let s = o.knownActions;
        for (let a = 0, l = s.length; a !== l; ++a) {
          let c = s[a];
          this._deactivateAction(c);
          let d = c._cacheIndex, u = e[e.length - 1];
          c._cacheIndex = null, c._byClipCacheIndex = null, u._cacheIndex = d, e[d] = u, e.pop(), this._removeInactiveBindingsForAction(c);
        }
        delete r[n];
      }
    }
    uncacheRoot(t) {
      let e = t.uuid, n = this._actionsByClip;
      for (let s in n) {
        let a = n[s].actionByRoot, l = a[e];
        l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
      }
      let r = this._bindingsByRootAndName, o = r[e];
      if (o !== void 0) for (let s in o) {
        let a = o[s];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
    }
    uncacheAction(t, e) {
      let n = this.existingAction(t, e);
      n !== null && (this._deactivateAction(n), this._removeInactiveAction(n));
    }
  };
  Ix.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
  var Dx = class i58 {
    constructor(t) {
      typeof t == "string" && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t;
    }
    clone() {
      return new i58(this.value.clone === void 0 ? this.value : this.value.clone());
    }
  };
  var Px = class extends Na {
    constructor(t, e, n = 1) {
      super(t, e), this.meshPerAttribute = n;
    }
    copy(t) {
      return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this;
    }
    clone(t) {
      let e = super.clone(t);
      return e.meshPerAttribute = this.meshPerAttribute, e;
    }
    toJSON(t) {
      let e = super.toJSON(t);
      return e.isInstancedInterleavedBuffer = true, e.meshPerAttribute = this.meshPerAttribute, e;
    }
  };
  Px.prototype.isInstancedInterleavedBuffer = true;
  var Rx = class {
    constructor(t, e, n, r, o) {
      this.buffer = t, this.type = e, this.itemSize = n, this.elementSize = r, this.count = o, this.version = 0;
    }
    set needsUpdate(t) {
      t === true && this.version++;
    }
    setBuffer(t) {
      return this.buffer = t, this;
    }
    setType(t, e) {
      return this.type = t, this.elementSize = e, this;
    }
    setItemSize(t) {
      return this.itemSize = t, this;
    }
    setCount(t) {
      return this.count = t, this;
    }
  };
  Rx.prototype.isGLBufferAttribute = true;
  var N1 = class {
    constructor(t, e, n = 0, r = 1 / 0) {
      this.ray = new Us(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new Gm(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
    }
    set(t, e) {
      this.ray.set(t, e);
    }
    setFromCamera(t, e) {
      e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, 0.5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type);
    }
    intersectObject(t, e = true, n = []) {
      return k1(t, this, n, e), n.sort(hV), n;
    }
    intersectObjects(t, e = true, n = []) {
      for (let r = 0, o = t.length; r < o; r++) k1(t[r], this, n, e);
      return n.sort(hV), n;
    }
  };
  function hV(i59, t) {
    return i59.distance - t.distance;
  }
  function k1(i59, t, e, n) {
    if (i59.layers.test(t.layers) && i59.raycast(t, e), n === true) {
      let r = i59.children;
      for (let o = 0, s = r.length; o < s; o++) k1(r[o], t, e, true);
    }
  }
  var L1 = class {
    constructor(t = 1, e = 0, n = 0) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
    set(t, e, n) {
      return this.radius = t, this.phi = e, this.theta = n, this;
    }
    copy(t) {
      return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this;
    }
    makeSafe() {
      return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(tr(e / this.radius, -1, 1))), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var F1 = class {
    constructor(t = 1, e = 0, n = 0) {
      return this.radius = t, this.theta = e, this.y = n, this;
    }
    set(t, e, n) {
      return this.radius = t, this.theta = e, this.y = n, this;
    }
    copy(t) {
      return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this;
    }
    setFromVector3(t) {
      return this.setFromCartesianCoords(t.x, t.y, t.z);
    }
    setFromCartesianCoords(t, e, n) {
      return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var pV = new Me();
  var kl = class {
    constructor(t = new Me(1 / 0, 1 / 0), e = new Me(-1 / 0, -1 / 0)) {
      this.min = t, this.max = e;
    }
    set(t, e) {
      return this.min.copy(t), this.max.copy(e), this;
    }
    setFromPoints(t) {
      this.makeEmpty();
      for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
      return this;
    }
    setFromCenterAndSize(t, e) {
      let n = pV.copy(e).multiplyScalar(0.5);
      return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(t) {
      return this.min.copy(t.min), this.max.copy(t.max), this;
    }
    makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
    }
    isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    }
    getCenter(t) {
      return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(t) {
      return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min);
    }
    expandByPoint(t) {
      return this.min.min(t), this.max.max(t), this;
    }
    expandByVector(t) {
      return this.min.sub(t), this.max.add(t), this;
    }
    expandByScalar(t) {
      return this.min.addScalar(-t), this.max.addScalar(t), this;
    }
    containsPoint(t) {
      return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y);
    }
    containsBox(t) {
      return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y;
    }
    getParameter(t, e) {
      return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y));
    }
    intersectsBox(t) {
      return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y);
    }
    clampPoint(t, e) {
      return e.copy(t).clamp(this.min, this.max);
    }
    distanceToPoint(t) {
      return pV.copy(t).clamp(this.min, this.max).sub(t).length();
    }
    intersect(t) {
      return this.min.max(t.min), this.max.min(t.max), this;
    }
    union(t) {
      return this.min.min(t.min), this.max.max(t.max), this;
    }
    translate(t) {
      return this.min.add(t), this.max.add(t), this;
    }
    equals(t) {
      return t.min.equals(this.min) && t.max.equals(this.max);
    }
  };
  kl.prototype.isBox2 = true;
  var fV = new L();
  var k0 = new L();
  var Ox = class {
    constructor(t = new L(), e = new L()) {
      this.start = t, this.end = e;
    }
    set(t, e) {
      return this.start.copy(t), this.end.copy(e), this;
    }
    copy(t) {
      return this.start.copy(t.start), this.end.copy(t.end), this;
    }
    getCenter(t) {
      return t.addVectors(this.start, this.end).multiplyScalar(0.5);
    }
    delta(t) {
      return t.subVectors(this.end, this.start);
    }
    distanceSq() {
      return this.start.distanceToSquared(this.end);
    }
    distance() {
      return this.start.distanceTo(this.end);
    }
    at(t, e) {
      return this.delta(e).multiplyScalar(t).add(this.start);
    }
    closestPointToPointParameter(t, e) {
      fV.subVectors(t, this.start), k0.subVectors(this.end, this.start);
      let n = k0.dot(k0), o = k0.dot(fV) / n;
      return e && (o = tr(o, 0, 1)), o;
    }
    closestPointToPoint(t, e, n) {
      let r = this.closestPointToPointParameter(t, e);
      return this.delta(n).multiplyScalar(r).add(this.start);
    }
    applyMatrix4(t) {
      return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
    }
    equals(t) {
      return t.start.equals(this.start) && t.end.equals(this.end);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  };
  var mV = new L();
  var B1 = class extends ln {
    constructor(t, e) {
      super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = false, this.color = e;
      let n = new Ct(), r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let s = 0, a = 1, l = 32; s < l; s++, a++) {
        let c = s / l * Math.PI * 2, d = a / l * Math.PI * 2;
        r.push(Math.cos(c), Math.sin(c), 1, Math.cos(d), Math.sin(d), 1);
      }
      n.setAttribute("position", new it(r, 3));
      let o = new Ei({ fog: false, toneMapped: false });
      this.cone = new wr(n, o), this.add(this.cone), this.update();
    }
    dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }
    update() {
      this.light.updateMatrixWorld();
      let t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle);
      this.cone.scale.set(e, e, t), mV.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(mV), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
    }
  };
  var Sl = new L();
  var L0 = new ut();
  var t1 = new ut();
  var Ax = class extends wr {
    constructor(t) {
      let e = vU(t), n = new Ct(), r = [], o = [], s = new Ye(0, 0, 1), a = new Ye(0, 1, 0);
      for (let c = 0; c < e.length; c++) {
        let d = e[c];
        d.parent && d.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), o.push(s.r, s.g, s.b), o.push(a.r, a.g, a.b));
      }
      n.setAttribute("position", new it(r, 3)), n.setAttribute("color", new it(o, 3));
      let l = new Ei({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
      super(n, l), this.type = "SkeletonHelper", this.isSkeletonHelper = true, this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = false;
    }
    updateMatrixWorld(t) {
      let e = this.bones, n = this.geometry, r = n.getAttribute("position");
      t1.copy(this.root.matrixWorld).invert();
      for (let o = 0, s = 0; o < e.length; o++) {
        let a = e[o];
        a.parent && a.parent.isBone && (L0.multiplyMatrices(t1, a.matrixWorld), Sl.setFromMatrixPosition(L0), r.setXYZ(s, Sl.x, Sl.y, Sl.z), L0.multiplyMatrices(t1, a.parent.matrixWorld), Sl.setFromMatrixPosition(L0), r.setXYZ(s + 1, Sl.x, Sl.y, Sl.z), s += 2);
      }
      n.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(t);
    }
  };
  function vU(i59) {
    let t = [];
    i59 && i59.isBone && t.push(i59);
    for (let e = 0; e < i59.children.length; e++) t.push.apply(t, vU(i59.children[e]));
    return t;
  }
  var V1 = class extends li {
    constructor(t, e, n) {
      let r = new ip(e, 4, 2), o = new ls({ wireframe: true, fog: false, toneMapped: false });
      super(r, o), this.light = t, this.light.updateMatrixWorld(), this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
    update() {
      this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
    }
  };
  var Kre = new L();
  var gV = new Ye();
  var _V = new Ye();
  var z1 = class extends ln {
    constructor(t, e, n) {
      super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = false, this.color = n;
      let r = new tp(e);
      r.rotateY(Math.PI * 0.5), this.material = new ls({ wireframe: true, fog: false, toneMapped: false }), this.color === void 0 && (this.material.vertexColors = true);
      let o = r.getAttribute("position"), s = new Float32Array(o.count * 3);
      r.setAttribute("color", new an(s, 3)), this.add(new li(r, this.material)), this.update();
    }
    dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }
    update() {
      let t = this.children[0];
      if (this.color !== void 0) this.material.color.set(this.color);
      else {
        let e = t.geometry.getAttribute("color");
        gV.copy(this.light.color), _V.copy(this.light.groundColor);
        for (let n = 0, r = e.count; n < r; n++) {
          let o = n < r / 2 ? gV : _V;
          e.setXYZ(n, o.r, o.g, o.b);
        }
        e.needsUpdate = true;
      }
      t.lookAt(Kre.setFromMatrixPosition(this.light.matrixWorld).negate());
    }
  };
  var Nx = class extends wr {
    constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
      n = new Ye(n), r = new Ye(r);
      let o = e / 2, s = t / e, a = t / 2, l = [], c = [];
      for (let h = 0, p = 0, f = -a; h <= e; h++, f += s) {
        l.push(-a, 0, f, a, 0, f), l.push(f, 0, -a, f, 0, a);
        let m = h === o ? n : r;
        m.toArray(c, p), p += 3, m.toArray(c, p), p += 3, m.toArray(c, p), p += 3, m.toArray(c, p), p += 3;
      }
      let d = new Ct();
      d.setAttribute("position", new it(l, 3)), d.setAttribute("color", new it(c, 3));
      let u = new Ei({ vertexColors: true, toneMapped: false });
      super(d, u), this.type = "GridHelper";
    }
  };
  var U1 = class extends wr {
    constructor(t = 10, e = 16, n = 8, r = 64, o = 4473924, s = 8947848) {
      o = new Ye(o), s = new Ye(s);
      let a = [], l = [];
      for (let u = 0; u <= e; u++) {
        let h = u / e * (Math.PI * 2), p = Math.sin(h) * t, f = Math.cos(h) * t;
        a.push(0, 0, 0), a.push(p, 0, f);
        let m = u & 1 ? o : s;
        l.push(m.r, m.g, m.b), l.push(m.r, m.g, m.b);
      }
      for (let u = 0; u <= n; u++) {
        let h = u & 1 ? o : s, p = t - t / n * u;
        for (let f = 0; f < r; f++) {
          let m = f / r * (Math.PI * 2), v = Math.sin(m) * p, _ = Math.cos(m) * p;
          a.push(v, 0, _), l.push(h.r, h.g, h.b), m = (f + 1) / r * (Math.PI * 2), v = Math.sin(m) * p, _ = Math.cos(m) * p, a.push(v, 0, _), l.push(h.r, h.g, h.b);
        }
      }
      let c = new Ct();
      c.setAttribute("position", new it(a, 3)), c.setAttribute("color", new it(l, 3));
      let d = new Ei({ vertexColors: true, toneMapped: false });
      super(c, d), this.type = "PolarGridHelper";
    }
  };
  var vV = new L();
  var F0 = new L();
  var yV = new L();
  var G1 = class extends ln {
    constructor(t, e, n) {
      super(), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = false, this.color = n, e === void 0 && (e = 1);
      let r = new Ct();
      r.setAttribute("position", new it([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
      let o = new Ei({ fog: false, toneMapped: false });
      this.lightPlane = new ds(r, o), this.add(this.lightPlane), r = new Ct(), r.setAttribute("position", new it([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ds(r, o), this.add(this.targetLine), this.update();
    }
    dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
    }
    update() {
      vV.setFromMatrixPosition(this.light.matrixWorld), F0.setFromMatrixPosition(this.light.target.matrixWorld), yV.subVectors(F0, vV), this.lightPlane.lookAt(F0), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(F0), this.targetLine.scale.z = yV.length();
    }
  };
  var B0 = new L();
  var ai = new wd();
  var H1 = class extends wr {
    constructor(t) {
      let e = new Ct(), n = new Ei({ color: 16777215, vertexColors: true, toneMapped: false }), r = [], o = [], s = {}, a = new Ye(16755200), l = new Ye(16711680), c = new Ye(43775), d = new Ye(16777215), u = new Ye(3355443);
      h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", l), h("p", "n2", l), h("p", "n3", l), h("p", "n4", l), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", d), h("p", "c", u), h("cn1", "cn2", u), h("cn3", "cn4", u), h("cf1", "cf2", u), h("cf3", "cf4", u);
      function h(f, m, v) {
        p(f, v), p(m, v);
      }
      function p(f, m) {
        r.push(0, 0, 0), o.push(m.r, m.g, m.b), s[f] === void 0 && (s[f] = []), s[f].push(r.length / 3 - 1);
      }
      e.setAttribute("position", new it(r, 3)), e.setAttribute("color", new it(o, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = s, this.update();
    }
    update() {
      let t = this.geometry, e = this.pointMap, n = 1, r = 1;
      ai.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), yi("c", e, t, ai, 0, 0, -1), yi("t", e, t, ai, 0, 0, 1), yi("n1", e, t, ai, -n, -r, -1), yi("n2", e, t, ai, n, -r, -1), yi("n3", e, t, ai, -n, r, -1), yi("n4", e, t, ai, n, r, -1), yi("f1", e, t, ai, -n, -r, 1), yi("f2", e, t, ai, n, -r, 1), yi("f3", e, t, ai, -n, r, 1), yi("f4", e, t, ai, n, r, 1), yi("u1", e, t, ai, n * 0.7, r * 1.1, -1), yi("u2", e, t, ai, -n * 0.7, r * 1.1, -1), yi("u3", e, t, ai, 0, r * 2, -1), yi("cf1", e, t, ai, -n, 0, 1), yi("cf2", e, t, ai, n, 0, 1), yi("cf3", e, t, ai, 0, -r, 1), yi("cf4", e, t, ai, 0, r, 1), yi("cn1", e, t, ai, -n, 0, -1), yi("cn2", e, t, ai, n, 0, -1), yi("cn3", e, t, ai, 0, -r, -1), yi("cn4", e, t, ai, 0, r, -1), t.getAttribute("position").needsUpdate = true;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
  function yi(i59, t, e, n, r, o, s) {
    B0.set(r, o, s).unproject(n);
    let a = t[i59];
    if (a !== void 0) {
      let l = e.getAttribute("position");
      for (let c = 0, d = a.length; c < d; c++) l.setXYZ(a[c], B0.x, B0.y, B0.z);
    }
  }
  var V0 = new Lr();
  var kx = class extends wr {
    constructor(t, e = 16776960) {
      let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), o = new Ct();
      o.setIndex(new an(n, 1)), o.setAttribute("position", new an(r, 3)), super(o, new Ei({ color: e, toneMapped: false })), this.object = t, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
    }
    update(t) {
      if (t !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && V0.setFromObject(this.object), V0.isEmpty()) return;
      let e = V0.min, n = V0.max, r = this.geometry.attributes.position, o = r.array;
      o[0] = n.x, o[1] = n.y, o[2] = n.z, o[3] = e.x, o[4] = n.y, o[5] = n.z, o[6] = e.x, o[7] = e.y, o[8] = n.z, o[9] = n.x, o[10] = e.y, o[11] = n.z, o[12] = n.x, o[13] = n.y, o[14] = e.z, o[15] = e.x, o[16] = n.y, o[17] = e.z, o[18] = e.x, o[19] = e.y, o[20] = e.z, o[21] = n.x, o[22] = e.y, o[23] = e.z, r.needsUpdate = true, this.geometry.computeBoundingSphere();
    }
    setFromObject(t) {
      return this.object = t, this.update(), this;
    }
    copy(t) {
      return wr.prototype.copy.call(this, t), this.object = t.object, this;
    }
  };
  var j1 = class extends wr {
    constructor(t, e = 16776960) {
      let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], o = new Ct();
      o.setIndex(new an(n, 1)), o.setAttribute("position", new it(r, 3)), super(o, new Ei({ color: e, toneMapped: false })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
    }
    updateMatrixWorld(t) {
      let e = this.box;
      e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(t));
    }
  };
  var W1 = class extends ds {
    constructor(t, e = 1, n = 16776960) {
      let r = n, o = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], s = new Ct();
      s.setAttribute("position", new it(o, 3)), s.computeBoundingSphere(), super(s, new Ei({ color: r, toneMapped: false })), this.type = "PlaneHelper", this.plane = t, this.size = e;
      let a = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], l = new Ct();
      l.setAttribute("position", new it(a, 3)), l.computeBoundingSphere(), this.add(new li(l, new ls({ color: r, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
    }
    updateMatrixWorld(t) {
      let e = -this.plane.constant;
      Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(0.5 * this.size, 0.5 * this.size, e), this.children[0].material.side = e < 0 ? bi : yd, this.lookAt(this.plane.normal), super.updateMatrixWorld(t);
    }
  };
  var bV = new L();
  var z0;
  var n1;
  var $1 = class extends ln {
    constructor(t = new L(0, 0, 1), e = new L(0, 0, 0), n = 1, r = 16776960, o = n * 0.2, s = o * 0.2) {
      super(), this.type = "ArrowHelper", z0 === void 0 && (z0 = new Ct(), z0.setAttribute("position", new it([0, 0, 0, 0, 1, 0], 3)), n1 = new Ed(0, 0.5, 1, 5, 1), n1.translate(0, -0.5, 0)), this.position.copy(e), this.line = new ds(z0, new Ei({ color: r, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new li(n1, new ls({ color: r, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(t), this.setLength(n, o, s);
    }
    setDirection(t) {
      if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
      else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
      else {
        bV.set(t.z, 0, -t.x).normalize();
        let e = Math.acos(t.y);
        this.quaternion.setFromAxisAngle(bV, e);
      }
    }
    setLength(t, e = t * 0.2, n = e * 0.2) {
      this.line.scale.set(1, Math.max(1e-4, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix();
    }
    setColor(t) {
      this.line.material.color.set(t), this.cone.material.color.set(t);
    }
    copy(t) {
      return super.copy(t, false), this.line.copy(t.line), this.cone.copy(t.cone), this;
    }
  };
  var Lx = class extends wr {
    constructor(t = 1) {
      let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], r = new Ct();
      r.setAttribute("position", new it(e, 3)), r.setAttribute("color", new it(n, 3));
      let o = new Ei({ vertexColors: true, toneMapped: false });
      super(r, o), this.type = "AxesHelper";
    }
    setColors(t, e, n) {
      let r = new Ye(), o = this.geometry.attributes.color.array;
      return r.set(t), r.toArray(o, 0), r.toArray(o, 3), r.set(e), r.toArray(o, 6), r.toArray(o, 9), r.set(n), r.toArray(o, 12), r.toArray(o, 15), this.geometry.attributes.color.needsUpdate = true, this;
    }
    dispose() {
      this.geometry.dispose(), this.material.dispose();
    }
  };
  var q1 = class {
    constructor() {
      this.type = "ShapePath", this.color = new Ye(), this.subPaths = [], this.currentPath = null;
    }
    moveTo(t, e) {
      return this.currentPath = new Dd(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this;
    }
    lineTo(t, e) {
      return this.currentPath.lineTo(t, e), this;
    }
    quadraticCurveTo(t, e, n, r) {
      return this.currentPath.quadraticCurveTo(t, e, n, r), this;
    }
    bezierCurveTo(t, e, n, r, o, s) {
      return this.currentPath.bezierCurveTo(t, e, n, r, o, s), this;
    }
    splineThru(t) {
      return this.currentPath.splineThru(t), this;
    }
    toShapes(t, e) {
      function n(g) {
        let y = [];
        for (let w = 0, E = g.length; w < E; w++) {
          let P = g[w], S = new ko();
          S.curves = P.curves, y.push(S);
        }
        return y;
      }
      function r(g, y) {
        let w = y.length, E = false;
        for (let P = w - 1, S = 0; S < w; P = S++) {
          let A = y[P], W = y[S], H = W.x - A.x, O = W.y - A.y;
          if (Math.abs(O) > Number.EPSILON) {
            if (O < 0 && (A = y[S], H = -H, W = y[P], O = -O), g.y < A.y || g.y > W.y) continue;
            if (g.y === A.y) {
              if (g.x === A.x) return true;
            } else {
              let I = O * (g.x - A.x) - H * (g.y - A.y);
              if (I === 0) return true;
              if (I < 0) continue;
              E = !E;
            }
          } else {
            if (g.y !== A.y) continue;
            if (W.x <= g.x && g.x <= A.x || A.x <= g.x && g.x <= W.x) return true;
          }
        }
        return E;
      }
      let o = Bs.isClockWise, s = this.subPaths;
      if (s.length === 0) return [];
      if (e === true) return n(s);
      let a, l, c, d = [];
      if (s.length === 1) return l = s[0], c = new ko(), c.curves = l.curves, d.push(c), d;
      let u = !o(s[0].getPoints());
      u = t ? !u : u;
      let h = [], p = [], f = [], m = 0, v;
      p[m] = void 0, f[m] = [];
      for (let g = 0, y = s.length; g < y; g++) l = s[g], v = l.getPoints(), a = o(v), a = t ? !a : a, a ? (!u && p[m] && m++, p[m] = { s: new ko(), p: v }, p[m].s.curves = l.curves, u && m++, f[m] = []) : f[m].push({ h: l, p: v[0] });
      if (!p[0]) return n(s);
      if (p.length > 1) {
        let g = false, y = [];
        for (let w = 0, E = p.length; w < E; w++) h[w] = [];
        for (let w = 0, E = p.length; w < E; w++) {
          let P = f[w];
          for (let S = 0; S < P.length; S++) {
            let A = P[S], W = true;
            for (let H = 0; H < p.length; H++) r(A.p, p[H].p) && (w !== H && y.push({ froms: w, tos: H, hole: S }), W ? (W = false, h[H].push(A)) : g = true);
            W && h[w].push(A);
          }
        }
        y.length > 0 && (g || (f = h));
      }
      let _;
      for (let g = 0, y = p.length; g < y; g++) {
        c = p[g].s, d.push(c), _ = f[g];
        for (let w = 0, E = _.length; w < E; w++) c.holes.push(_[w].h);
      }
      return d;
    }
  };
  var yU = new Float32Array(1);
  var Jre = new Int32Array(yU.buffer);
  var Y1 = class {
    static toHalfFloat(t) {
      t > 65504 && (console.warn("THREE.DataUtils.toHalfFloat(): value exceeds 65504."), t = 65504), yU[0] = t;
      let e = Jre[0], n = e >> 16 & 32768, r = e >> 12 & 2047, o = e >> 23 & 255;
      return o < 103 ? n : o > 142 ? (n |= 31744, n |= (o == 255 ? 0 : 1) && e & 8388607, n) : o < 113 ? (r |= 2048, n |= (r >> 114 - o) + (r >> 113 - o & 1), n) : (n |= o - 112 << 10 | r >> 1, n += r & 1, n);
    }
  };
  var eoe = 0;
  var toe = 1;
  var noe = 0;
  var ioe = 1;
  var roe = 2;
  function ooe(i59) {
    return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), i59;
  }
  function soe(i59 = []) {
    return console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), i59.isMultiMaterial = true, i59.materials = i59, i59.clone = function() {
      return i59.slice();
    }, i59;
  }
  function aoe(i59, t) {
    return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Md(i59, t);
  }
  function loe(i59) {
    return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Yh(i59);
  }
  function coe(i59, t) {
    return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Md(i59, t);
  }
  function doe(i59) {
    return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new La(i59);
  }
  function uoe(i59) {
    return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new La(i59);
  }
  function hoe(i59) {
    return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new La(i59);
  }
  function poe(i59, t, e) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new L(i59, t, e);
  }
  function foe(i59, t) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."), new an(i59, t).setUsage(Lh);
  }
  function moe(i59, t) {
    return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new q0(i59, t);
  }
  function goe(i59, t) {
    return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new Y0(i59, t);
  }
  function _oe(i59, t) {
    return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new X0(i59, t);
  }
  function voe(i59, t) {
    return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new Z0(i59, t);
  }
  function yoe(i59, t) {
    return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new Fh(i59, t);
  }
  function boe(i59, t) {
    return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Q0(i59, t);
  }
  function xoe(i59, t) {
    return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new Bh(i59, t);
  }
  function woe(i59, t) {
    return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new it(i59, t);
  }
  function Coe(i59, t) {
    return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new J0(i59, t);
  }
  Br.create = function(i59, t) {
    return console.log("THREE.Curve.create() has been deprecated"), i59.prototype = Object.create(Br.prototype), i59.prototype.constructor = i59, i59.prototype.getPoint = t, i59;
  };
  Dd.prototype.fromPoints = function(i59) {
    return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(i59);
  };
  function Soe(i59) {
    return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new Lx(i59);
  }
  function Moe(i59, t) {
    return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new kx(i59, t);
  }
  function Eoe(i59, t) {
    return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new wr(new Jm(i59.geometry), new Ei({ color: t !== void 0 ? t : 16777215 }));
  }
  Nx.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  Ax.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  function Toe(i59, t) {
    return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new wr(new pg(i59.geometry), new Ei({ color: t !== void 0 ? t : 16777215 }));
  }
  sr.prototype.extractUrlBase = function(i59) {
    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), op.extractUrlBase(i59);
  };
  sr.Handlers = { add: function() {
    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
  }, get: function() {
    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
  } };
  function Ioe(i59) {
    return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new Lo(i59);
  }
  function Doe(i59) {
    return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new px(i59);
  }
  kl.prototype.center = function(i59) {
    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(i59);
  };
  kl.prototype.empty = function() {
    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  };
  kl.prototype.isIntersectionBox = function(i59) {
    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i59);
  };
  kl.prototype.size = function(i59) {
    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(i59);
  };
  Lr.prototype.center = function(i59) {
    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(i59);
  };
  Lr.prototype.empty = function() {
    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  };
  Lr.prototype.isIntersectionBox = function(i59) {
    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i59);
  };
  Lr.prototype.isIntersectionSphere = function(i59) {
    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(i59);
  };
  Lr.prototype.size = function(i59) {
    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(i59);
  };
  zs.prototype.empty = function() {
    return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty();
  };
  Cd.prototype.setFromMatrix = function(i59) {
    return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(i59);
  };
  Ox.prototype.center = function(i59) {
    return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(i59);
  };
  xi.prototype.flattenToArrayOffset = function(i59, t) {
    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(i59, t);
  };
  xi.prototype.multiplyVector3 = function(i59) {
    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), i59.applyMatrix3(this);
  };
  xi.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
  };
  xi.prototype.applyToBufferAttribute = function(i59) {
    return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), i59.applyMatrix3(this);
  };
  xi.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
  };
  xi.prototype.getInverse = function(i59) {
    return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(i59).invert();
  };
  ut.prototype.extractPosition = function(i59) {
    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(i59);
  };
  ut.prototype.flattenToArrayOffset = function(i59, t) {
    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(i59, t);
  };
  ut.prototype.getPosition = function() {
    return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), new L().setFromMatrixColumn(this, 3);
  };
  ut.prototype.setRotationFromQuaternion = function(i59) {
    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(i59);
  };
  ut.prototype.multiplyToArray = function() {
    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
  };
  ut.prototype.multiplyVector3 = function(i59) {
    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), i59.applyMatrix4(this);
  };
  ut.prototype.multiplyVector4 = function(i59) {
    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), i59.applyMatrix4(this);
  };
  ut.prototype.multiplyVector3Array = function() {
    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
  };
  ut.prototype.rotateAxis = function(i59) {
    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), i59.transformDirection(this);
  };
  ut.prototype.crossVector = function(i59) {
    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), i59.applyMatrix4(this);
  };
  ut.prototype.translate = function() {
    console.error("THREE.Matrix4: .translate() has been removed.");
  };
  ut.prototype.rotateX = function() {
    console.error("THREE.Matrix4: .rotateX() has been removed.");
  };
  ut.prototype.rotateY = function() {
    console.error("THREE.Matrix4: .rotateY() has been removed.");
  };
  ut.prototype.rotateZ = function() {
    console.error("THREE.Matrix4: .rotateZ() has been removed.");
  };
  ut.prototype.rotateByAxis = function() {
    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
  };
  ut.prototype.applyToBufferAttribute = function(i59) {
    return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), i59.applyMatrix4(this);
  };
  ut.prototype.applyToVector3Array = function() {
    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
  };
  ut.prototype.makeFrustum = function(i59, t, e, n, r, o) {
    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(i59, t, n, e, r, o);
  };
  ut.prototype.getInverse = function(i59) {
    return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(i59).invert();
  };
  No.prototype.isIntersectionLine = function(i59) {
    return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(i59);
  };
  Oi.prototype.multiplyVector3 = function(i59) {
    return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), i59.applyQuaternion(this);
  };
  Oi.prototype.inverse = function() {
    return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert();
  };
  Us.prototype.isIntersectionBox = function(i59) {
    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(i59);
  };
  Us.prototype.isIntersectionPlane = function(i59) {
    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(i59);
  };
  Us.prototype.isIntersectionSphere = function(i59) {
    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(i59);
  };
  rr.prototype.area = function() {
    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea();
  };
  rr.prototype.barycoordFromPoint = function(i59, t) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(i59, t);
  };
  rr.prototype.midpoint = function(i59) {
    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(i59);
  };
  rr.prototypenormal = function(i59) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(i59);
  };
  rr.prototype.plane = function(i59) {
    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(i59);
  };
  rr.barycoordFromPoint = function(i59, t, e, n, r) {
    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), rr.getBarycoord(i59, t, e, n, r);
  };
  rr.normal = function(i59, t, e, n) {
    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), rr.getNormal(i59, t, e, n);
  };
  ko.prototype.extractAllPoints = function(i59) {
    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(i59);
  };
  ko.prototype.extrude = function(i59) {
    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Ba(this, i59);
  };
  ko.prototype.makeGeometry = function(i59) {
    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new np(this, i59);
  };
  Me.prototype.fromAttribute = function(i59, t, e) {
    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i59, t, e);
  };
  Me.prototype.distanceToManhattan = function(i59) {
    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(i59);
  };
  Me.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  };
  L.prototype.setEulerFromRotationMatrix = function() {
    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
  };
  L.prototype.setEulerFromQuaternion = function() {
    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
  };
  L.prototype.getPositionFromMatrix = function(i59) {
    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(i59);
  };
  L.prototype.getScaleFromMatrix = function(i59) {
    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(i59);
  };
  L.prototype.getColumnFromMatrix = function(i59, t) {
    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(t, i59);
  };
  L.prototype.applyProjection = function(i59) {
    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(i59);
  };
  L.prototype.fromAttribute = function(i59, t, e) {
    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i59, t, e);
  };
  L.prototype.distanceToManhattan = function(i59) {
    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(i59);
  };
  L.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  };
  bn.prototype.fromAttribute = function(i59, t, e) {
    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(i59, t, e);
  };
  bn.prototype.lengthManhattan = function() {
    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength();
  };
  ln.prototype.getChildByName = function(i59) {
    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(i59);
  };
  ln.prototype.renderDepth = function() {
    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
  };
  ln.prototype.translate = function(i59, t) {
    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, i59);
  };
  ln.prototype.getWorldRotation = function() {
    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
  };
  ln.prototype.applyMatrix = function(i59) {
    return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(i59);
  };
  Object.defineProperties(ln.prototype, { eulerOrder: { get: function() {
    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order;
  }, set: function(i59) {
    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = i59;
  } }, useQuaternion: { get: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  }, set: function() {
    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
  } } });
  li.prototype.setDrawMode = function() {
    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  };
  Object.defineProperties(li.prototype, { drawMode: { get: function() {
    return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), Wz;
  }, set: function() {
    console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
  } } });
  Xh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Ci.prototype.setLens = function(i59, t) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), t !== void 0 && (this.filmGauge = t), this.setFocalLength(i59);
  };
  Object.defineProperties(mo.prototype, { onlyShadow: { set: function() {
    console.warn("THREE.Light: .onlyShadow has been removed.");
  } }, shadowCameraFov: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = i59;
  } }, shadowCameraLeft: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = i59;
  } }, shadowCameraRight: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = i59;
  } }, shadowCameraTop: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = i59;
  } }, shadowCameraBottom: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = i59;
  } }, shadowCameraNear: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = i59;
  } }, shadowCameraFar: { set: function(i59) {
    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = i59;
  } }, shadowCameraVisible: { set: function() {
    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
  } }, shadowBias: { set: function(i59) {
    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = i59;
  } }, shadowDarkness: { set: function() {
    console.warn("THREE.Light: .shadowDarkness has been removed.");
  } }, shadowMapWidth: { set: function(i59) {
    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = i59;
  } }, shadowMapHeight: { set: function(i59) {
    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = i59;
  } } });
  Object.defineProperties(an.prototype, { length: { get: function() {
    return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length;
  } }, dynamic: { get: function() {
    return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === Lh;
  }, set: function() {
    console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(Lh);
  } } });
  an.prototype.setDynamic = function(i59) {
    return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(i59 === true ? Lh : kh), this;
  };
  an.prototype.copyIndicesArray = function() {
    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
  }, an.prototype.setArray = function() {
    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  Ct.prototype.addIndex = function(i59) {
    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(i59);
  };
  Ct.prototype.addAttribute = function(i59, t) {
    return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), !(t && t.isBufferAttribute) && !(t && t.isInterleavedBufferAttribute) ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(i59, new an(arguments[1], arguments[2]))) : i59 === "index" ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(t), this) : this.setAttribute(i59, t);
  };
  Ct.prototype.addDrawCall = function(i59, t, e) {
    e !== void 0 && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(i59, t);
  };
  Ct.prototype.clearDrawCalls = function() {
    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups();
  };
  Ct.prototype.computeOffsets = function() {
    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
  };
  Ct.prototype.removeAttribute = function(i59) {
    return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(i59);
  };
  Ct.prototype.applyMatrix = function(i59) {
    return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(i59);
  };
  Object.defineProperties(Ct.prototype, { drawcalls: { get: function() {
    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups;
  } }, offsets: { get: function() {
    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups;
  } } });
  Na.prototype.setDynamic = function(i59) {
    return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(i59 === true ? Lh : kh), this;
  };
  Na.prototype.setArray = function() {
    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
  };
  Ba.prototype.getArrays = function() {
    console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
  };
  Ba.prototype.addShapeList = function() {
    console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
  };
  Ba.prototype.addShape = function() {
    console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
  };
  $h.prototype.dispose = function() {
    console.error("THREE.Scene: .dispose() has been removed.");
  };
  Dx.prototype.onUpdate = function() {
    return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this;
  };
  Object.defineProperties(Mi.prototype, { wrapAround: { get: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .wrapAround has been removed.");
  } }, overdraw: { get: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  }, set: function() {
    console.warn("THREE.Material: .overdraw has been removed.");
  } }, wrapRGB: { get: function() {
    return console.warn("THREE.Material: .wrapRGB has been removed."), new Ye();
  } }, shading: { get: function() {
    console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
  }, set: function(i59) {
    console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = i59 === Q1;
  } }, stencilMask: { get: function() {
    return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask;
  }, set: function(i59) {
    console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = i59;
  } }, vertexTangents: { get: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  }, set: function() {
    console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
  } } });
  Object.defineProperties(cs.prototype, { derivatives: { get: function() {
    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives;
  }, set: function(i59) {
    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = i59;
  } } });
  Sn.prototype.clearTarget = function(i59, t, e, n) {
    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(i59), this.clear(t, e, n);
  };
  Sn.prototype.animate = function(i59) {
    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(i59);
  };
  Sn.prototype.getCurrentRenderTarget = function() {
    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget();
  };
  Sn.prototype.getMaxAnisotropy = function() {
    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy();
  };
  Sn.prototype.getPrecision = function() {
    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision;
  };
  Sn.prototype.resetGLState = function() {
    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset();
  };
  Sn.prototype.supportsFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float");
  };
  Sn.prototype.supportsHalfFloatTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float");
  };
  Sn.prototype.supportsStandardDerivatives = function() {
    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives");
  };
  Sn.prototype.supportsCompressedTextureS3TC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc");
  };
  Sn.prototype.supportsCompressedTexturePVRTC = function() {
    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc");
  };
  Sn.prototype.supportsBlendMinMax = function() {
    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax");
  };
  Sn.prototype.supportsVertexTextures = function() {
    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures;
  };
  Sn.prototype.supportsInstancedArrays = function() {
    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays");
  };
  Sn.prototype.enableScissorTest = function(i59) {
    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(i59);
  };
  Sn.prototype.initMaterial = function() {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  };
  Sn.prototype.addPrePlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  };
  Sn.prototype.addPostPlugin = function() {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  };
  Sn.prototype.updateShadowMap = function() {
    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
  };
  Sn.prototype.setFaceCulling = function() {
    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
  };
  Sn.prototype.allocTextureUnit = function() {
    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
  };
  Sn.prototype.setTexture = function() {
    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
  };
  Sn.prototype.setTexture2D = function() {
    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
  };
  Sn.prototype.setTextureCube = function() {
    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
  };
  Sn.prototype.getActiveMipMapLevel = function() {
    return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel();
  };
  Object.defineProperties(Sn.prototype, { shadowMapEnabled: { get: function() {
    return this.shadowMap.enabled;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = i59;
  } }, shadowMapType: { get: function() {
    return this.shadowMap.type;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = i59;
  } }, shadowMapCullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
  } }, context: { get: function() {
    return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext();
  } }, vr: { get: function() {
    return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr;
  } }, gammaInput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), false;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
  } }, gammaOutput: { get: function() {
    return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), false;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = i59 === true ? Ll : or;
  } }, toneMappingWhitePoint: { get: function() {
    return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1;
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
  } } });
  Object.defineProperties(uU.prototype, { cullFace: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
  } }, renderReverseSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
  } }, renderSingleSided: { get: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  }, set: function() {
    console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
  } } });
  function Poe(i59, t, e) {
    return console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."), new Uh(i59, e);
  }
  Object.defineProperties(po.prototype, { wrapS: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = i59;
  } }, wrapT: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = i59;
  } }, magFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = i59;
  } }, minFilter: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = i59;
  } }, anisotropy: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = i59;
  } }, offset: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = i59;
  } }, repeat: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = i59;
  } }, format: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = i59;
  } }, type: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = i59;
  } }, generateMipmaps: { get: function() {
    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps;
  }, set: function(i59) {
    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = i59;
  } } });
  Ng.prototype.load = function(i59) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    let t = this;
    return new xx().load(i59, function(n) {
      t.setBuffer(n);
    }), this;
  };
  Mx.prototype.getData = function() {
    return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData();
  };
  zh.prototype.updateCubeMap = function(i59, t) {
    return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(i59, t);
  };
  zh.prototype.clear = function(i59, t, e, n) {
    return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(i59, t, e, n);
  };
  Aa.crossOrigin = void 0;
  Aa.loadTexture = function(i59, t, e, n) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    let r = new fx();
    r.setCrossOrigin(this.crossOrigin);
    let o = r.load(i59, e, void 0, n);
    return t && (o.mapping = t), o;
  };
  Aa.loadTextureCube = function(i59, t, e, n) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    let r = new hx();
    r.setCrossOrigin(this.crossOrigin);
    let o = r.load(i59, e, void 0, n);
    return t && (o.mapping = t), o;
  };
  Aa.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  Aa.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };
  function Roe() {
    console.error("THREE.CanvasRenderer has been removed");
  }
  function Ooe() {
    console.error("THREE.JSONLoader has been removed.");
  }
  var Aoe = { createMultiMaterialObject: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, detach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  }, attach: function() {
    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
  } };
  function Noe() {
    console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
  }
  function koe() {
    return console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js"), new Ct();
  }
  function Loe() {
    return console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js"), new Ct();
  }
  function Foe() {
    console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
  }
  function Boe() {
    console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
  }
  function Voe() {
    console.error("THREE.ImmediateRenderObject has been removed.");
  }
  typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: X1 } }));
  typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = X1);
  var Gs = (() => {
    class i59 {
      remoteSourceLoading = gt(false);
      loadedEdgeOverlays = gt([]);
      selectedOverlayIds = gt([]);
      selectedOverlays = It(() => {
        let e = [];
        for (let n of this.loadedEdgeOverlays()) for (let r of n.processedOverlays) this.selectedOverlayIds().includes(r.id) && e.push(r);
        return e;
      });
      addOverlay(e) {
        this.loadedEdgeOverlays.update((n) => [...n, zoe(e)]);
      }
      deleteOverlayData(e) {
        let n = this.loadedEdgeOverlays().find((r) => r.id === e);
        if (this.loadedEdgeOverlays.update((r) => r.filter((o) => o.id !== e)), n) {
          let r = new Set(n.processedOverlays.map((o) => o.id));
          this.selectedOverlayIds.update((o) => o.filter((s) => !r.has(s)));
        }
      }
      toggleOverlaySelection(e) {
        this.selectedOverlayIds.update((n) => {
          let r = [...n];
          return n.includes(e) ? r = r.filter((o) => o !== e) : r.push(e), r;
        });
      }
      addEdgeOverlayData(e) {
        this.addOverlay(e), this.selectedOverlayIds.update((n) => {
          let r = this.loadedEdgeOverlays(), s = r[r.length - 1].processedOverlays.map((a) => a.id);
          return [...n, ...s];
        });
      }
      addEdgeOverlayDataFromJsonData(e) {
        try {
          let n = JSON.parse(e);
          this.addEdgeOverlayData(n);
        } catch (n) {
          return `Failed to parse JSON file. ${n}`;
        }
        return "";
      }
      loadFromCns(e) {
        return $t(this, null, function* () {
          this.remoteSourceLoading.set(true);
          let n = `/read_file?path=${e}`, r = yield fetch(n);
          if (!r.ok) return this.remoteSourceLoading.set(false), `Failed to load JSON file "${e}"`;
          let o = JSON.parse((yield r.text()).replace(`)]}'
`, "")), s = this.addEdgeOverlayDataFromJsonData(o.content);
          return this.remoteSourceLoading.set(false), s;
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  function zoe(i59) {
    let t = le({ id: Li(), processedOverlays: [] }, i59);
    for (let e of i59.overlays) {
      let n = le({ id: Li(), nodeIds: /* @__PURE__ */ new Set() }, e);
      t.processedOverlays.push(n);
      for (let r of e.edges) n.nodeIds.add(r.sourceNodeId), n.nodeIds.add(r.targetNodeId);
    }
    return t;
  }
  var Hx = (() => {
    class i59 {
      linearGradientId = Math.random().toString(36).slice(-6);
      fillUrl = `url(#${this.linearGradientId})`;
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["me-logo"]], decls: 19, vars: 2, consts: [["width", "24", "height", "24", "viewBox", "0 0 256 256", "fill", "none", "xmlns", "http://www.w3.org/2000/svg"], ["width", "256", "height", "256", "fill", "none"], ["d", "M229 64.5V192.5L128 248.5L127.5 115.5L229 64.5Z"], ["d", "M208 76V99L128 141.5V116L208 76Z", "fill", "white"], ["d", "M208 122.5V141.5L128 182.5V161.5L208 122.5Z", "fill", "white"], ["d", "M208 164.5V183L128 225.5V206L208 164.5Z", "fill", "white"], ["d", "M149 106V214.5L127 226V117.5L149 106Z", "fill", "white"], ["d", "M26 61L47.5 72.5V200L26 187V61Z", "fill", "#FBBC04"], ["d", "M125.5 10.5L145.5 21V60.5L125.5 56.5V10.5Z", "fill", "#DCA810"], ["d", "M164 31L184 41.5V81L164 78V31Z", "fill", "#309C4D"], ["d", "M164 31L184 41.5L87 94L65 82L164 31Z", "fill", "#11792D"], ["d", "M208 54.5L229 64.5L128 116L107 105L208 54.5Z", "fill", "#2C5CAC"], ["d", "M125.5 10.5L145.5 21L47.5 72.5L26 61L125.5 10.5Z", "fill", "#C78B15"], ["d", "M65 82L87 94V224L65 210.5V82Z", "fill", "#34A853"], ["d", "M107 105L128 116V248.5L107 236V105Z", "fill", "#4285F4"], ["x1", "144.5", "y1", "232", "x2", "219", "y2", "69.5", "gradientUnits", "userSpaceOnUse"], ["stop-color", "#4285F4"], ["offset", "1", "stop-color", "#2C5CAC"]], template: function(n, r) {
        n & 1 && (to(), b(0, "svg", 0), ae(1, "rect", 1)(2, "path", 2)(3, "path", 3)(4, "path", 4)(5, "path", 5)(6, "path", 6)(7, "path", 7)(8, "path", 8)(9, "path", 9)(10, "path", 10)(11, "path", 11)(12, "path", 12)(13, "path", 13)(14, "path", 14), b(15, "defs")(16, "linearGradient", 15), ae(17, "stop", 16)(18, "stop", 17), x()()()), n & 2 && (C(2), Ke("fill", r.fillUrl), C(14), Ke("id", r.linearGradientId));
      }, styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:center}"] });
    }
    return i59;
  })();
  var Fl = (() => {
    class i59 {
      hiddenInputOpNodeIds = gt({});
      hiddenOutputIds = gt({});
      toggleInputOpNodeVisibility(e) {
        this.hiddenInputOpNodeIds.update((n) => (n[e] === true ? delete n[e] : n[e] = true, le({}, n)));
      }
      setInputOpNodeVisible(e, n) {
        let r = this.hiddenInputOpNodeIds()[e] !== true;
        for (let o of n) o !== e && (this.hiddenInputOpNodeIds()[o] || (r = false));
        if (r) this.hiddenInputOpNodeIds.set({});
        else {
          let o = {};
          for (let s of n) s !== e && (o[s] = true);
          this.hiddenInputOpNodeIds.set(o);
        }
      }
      toggleOutputVisibility(e, n) {
        this.hiddenOutputIds.update((r) => {
          let o = `${e}___${n}`;
          return r[o] === true ? delete r[o] : r[o] = true, le({}, r);
        });
      }
      setOutputVisible(e, n, r) {
        let o = `${e}___${n}`, s = this.hiddenOutputIds()[o] !== true;
        for (let { nodeId: a, outputId: l } of r) {
          let c = `${a}___${l}`;
          c !== o && (this.hiddenOutputIds()[c] || (s = false));
        }
        if (s) this.hiddenOutputIds.set({});
        else {
          let a = {};
          for (let { nodeId: l, outputId: c } of r) {
            let d = `${l}___${c}`;
            d !== o && (a[d] = true);
          }
          this.hiddenOutputIds.set(a);
        }
      }
      getInputOpNodeVisible(e) {
        return !this.hiddenInputOpNodeIds()[e];
      }
      getOutputVisible(e, n) {
        let r = `${e}___${n}`;
        return !this.hiddenOutputIds()[r];
      }
      resetInputOutputHiddenIds() {
        this.hiddenInputOpNodeIds.set({}), this.hiddenOutputIds.set({});
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Fo = (() => {
    class i59 {
      appService;
      selectedNodeIds = gt({});
      hasSelectedNodes = It(() => Object.keys(this.selectedNodeIds()).length > 0);
      selectedNodeCount = It(() => Object.keys(this.selectedNodeIds()).length);
      selectedNodes = It(() => this.modelGraph ? Object.keys(this.selectedNodeIds()).filter((n) => this.selectedNodeIds()[n]).map((n) => this.modelGraph.nodesById[n]) : []);
      paneId = "";
      constructor(e) {
        this.appService = e;
      }
      toggleNode(e) {
        this.selectedNodeIds.update((n) => {
          if (!this.modelGraph) return n;
          let r = this.modelGraph.nodesById[e];
          if (ct(r)) {
            let o = r.descendantsOpNodeIds || [], s = o.some((a) => n[a]);
            for (let a of o) dt(this.modelGraph.nodesById[a]) && (s ? delete n[a] : n[a] = true);
          } else n[e] ? delete n[e] : n[e] = true;
          return le({}, n);
        });
      }
      toggleNodes(e) {
        if (e.length === 0 || !this.modelGraph) return;
        let n = le({}, this.selectedNodeIds());
        for (let r of e) {
          let o = this.modelGraph.nodesById[r];
          if (dt(o)) n[r] ? delete n[r] : n[r] = true;
          else if (ct(o) && !o.expanded) for (let s of o.descendantsOpNodeIds || []) n[s] ? delete n[s] : n[s] = true;
        }
        this.selectedNodeIds.set(n);
      }
      clearSelection() {
        this.selectedNodeIds.set({});
      }
      isHiddenFromSelection(e) {
        return e.label === "pseudo_const";
      }
      getSelectedSubgraph() {
        if (!this.modelGraph) return;
        let e = this.appService.getGraphById(this.modelGraph.id);
        if (!e) return;
        e = JSON.parse(JSON.stringify(e));
        let n = {};
        for (let h of e.nodes) n[h.id] = h;
        let r = this.selectedNodeIds(), o = e.nodes.filter((h) => r[h.id] === true), s = o.find((h) => h.label === "GraphInputs");
        if (!s) {
          let h = e.nodes.find((p) => p.label === "GraphInputs");
          if (!h) throw new Error("GraphInputs node not found in the original graph.");
          s = structuredClone(h), s.outputsMetadata = [], o.push(s);
        }
        s.outputsMetadata = s.outputsMetadata || [];
        let a = /* @__PURE__ */ new Map(), l = s.outputsMetadata.length;
        for (let h of o) {
          let p = (h.incomingEdges || []).filter((f) => !r[f.sourceNodeId]);
          for (let f of p) {
            let m = n[f.sourceNodeId];
            if (this.isHiddenFromSelection(m)) {
              o.push(m);
              continue;
            }
            let v = (m.outputsMetadata || []).find((g) => g.id === f.sourceNodeOutputId);
            if (!v) continue;
            let _ = (v.attrs || []).find((g) => g.key === "tensor_index")?.value;
            _ && (a.has(_) || (a.set(_, l.toString()), s.outputsMetadata.push({ id: l.toString(), attrs: v.attrs }), l++), f.sourceNodeId = s.id, f.sourceNodeOutputId = a.get(_));
          }
        }
        let c = o.find((h) => h.label === "GraphOutputs");
        if (!c) {
          let h = e.nodes.find((p) => p.label === "GraphOutputs");
          if (!h) throw new Error("GraphOutputs node not found in the original graph.");
          c = structuredClone(h), c.incomingEdges = [], o.push(c);
        }
        c.incomingEdges = c.incomingEdges || [];
        let d = /* @__PURE__ */ new Set(), u = c.incomingEdges.length;
        for (let h of e.nodes) {
          if (r[h.id]) continue;
          let p = (h.incomingEdges || []).filter((f) => r[f.sourceNodeId]);
          for (let f of p) {
            let v = (n[f.sourceNodeId].outputsMetadata || []).find((g) => g.id === f.sourceNodeOutputId);
            if (!v) continue;
            let _ = (v.attrs || []).find((g) => g.key === "tensor_index")?.value;
            if (_ && !d.has(_)) {
              d.add(_);
              let g = structuredClone(f);
              g.targetNodeInputId = u.toString(), c.incomingEdges.push(g), u++;
            }
          }
        }
        return { id: `${e.id}_subgraph`, collectionLabel: e.collectionLabel, nodes: o };
      }
      get modelGraph() {
        return this.appService.getCurrentModelGraphFromPane(this.paneId);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Wx = class {
  };
  function xU(i59) {
    return i59 && typeof i59.connect == "function" && !(i59 instanceof Tp);
  }
  var zd = class {
    _multiple;
    _emitChanges;
    compareWith;
    _selection = /* @__PURE__ */ new Set();
    _deselectedToEmit = [];
    _selectedToEmit = [];
    _selected;
    get selected() {
      return this._selected || (this._selected = Array.from(this._selection.values())), this._selected;
    }
    changed = new we();
    constructor(t = false, e, n = true, r) {
      this._multiple = t, this._emitChanges = n, this.compareWith = r, e && e.length && (t ? e.forEach((o) => this._markSelected(o)) : this._markSelected(e[0]), this._selectedToEmit.length = 0);
    }
    select(...t) {
      this._verifyValueAssignment(t), t.forEach((n) => this._markSelected(n));
      let e = this._hasQueuedChanges();
      return this._emitChangeEvent(), e;
    }
    deselect(...t) {
      this._verifyValueAssignment(t), t.forEach((n) => this._unmarkSelected(n));
      let e = this._hasQueuedChanges();
      return this._emitChangeEvent(), e;
    }
    setSelection(...t) {
      this._verifyValueAssignment(t);
      let e = this.selected, n = new Set(t);
      t.forEach((o) => this._markSelected(o)), e.filter((o) => !n.has(this._getConcreteValue(o, n))).forEach((o) => this._unmarkSelected(o));
      let r = this._hasQueuedChanges();
      return this._emitChangeEvent(), r;
    }
    toggle(t) {
      return this.isSelected(t) ? this.deselect(t) : this.select(t);
    }
    clear(t = true) {
      this._unmarkAll();
      let e = this._hasQueuedChanges();
      return t && this._emitChangeEvent(), e;
    }
    isSelected(t) {
      return this._selection.has(this._getConcreteValue(t));
    }
    isEmpty() {
      return this._selection.size === 0;
    }
    hasValue() {
      return !this.isEmpty();
    }
    sort(t) {
      this._multiple && this.selected && this._selected.sort(t);
    }
    isMultipleSelection() {
      return this._multiple;
    }
    _emitChangeEvent() {
      this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }), this._deselectedToEmit = [], this._selectedToEmit = []);
    }
    _markSelected(t) {
      t = this._getConcreteValue(t), this.isSelected(t) || (this._multiple || this._unmarkAll(), this.isSelected(t) || this._selection.add(t), this._emitChanges && this._selectedToEmit.push(t));
    }
    _unmarkSelected(t) {
      t = this._getConcreteValue(t), this.isSelected(t) && (this._selection.delete(t), this._emitChanges && this._deselectedToEmit.push(t));
    }
    _unmarkAll() {
      this.isEmpty() || this._selection.forEach((t) => this._unmarkSelected(t));
    }
    _verifyValueAssignment(t) {
      t.length > 1 && this._multiple;
    }
    _hasQueuedChanges() {
      return !!(this._deselectedToEmit.length || this._selectedToEmit.length);
    }
    _getConcreteValue(t, e) {
      if (this.compareWith) {
        e = e ?? this._selection;
        for (let n of e) if (this.compareWith(t, n)) return n;
        return t;
      } else return t;
    }
  };
  var wU = (() => {
    class i59 {
      _listeners = [];
      notify(e, n) {
        for (let r of this._listeners) r(e, n);
      }
      listen(e) {
        return this._listeners.push(e), () => {
          this._listeners = this._listeners.filter((n) => e !== n);
        };
      }
      ngOnDestroy() {
        this._listeners = [];
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Goe = 20;
  var Ud = (() => {
    class i59 {
      _ngZone = M(We);
      _platform = M(Nn);
      _renderer = M(pr).createRenderer(null, null);
      _cleanupGlobalListener;
      constructor() {
      }
      _scrolled = new we();
      _scrolledCount = 0;
      scrollContainers = /* @__PURE__ */ new Map();
      register(e) {
        this.scrollContainers.has(e) || this.scrollContainers.set(e, e.elementScrolled().subscribe(() => this._scrolled.next(e)));
      }
      deregister(e) {
        let n = this.scrollContainers.get(e);
        n && (n.unsubscribe(), this.scrollContainers.delete(e));
      }
      scrolled(e = Goe) {
        return this._platform.isBrowser ? new Et((n) => {
          this._cleanupGlobalListener || (this._cleanupGlobalListener = this._ngZone.runOutsideAngular(() => this._renderer.listen("document", "scroll", () => this._scrolled.next())));
          let r = e > 0 ? this._scrolled.pipe(R_(e)).subscribe(n) : this._scrolled.subscribe(n);
          return this._scrolledCount++, () => {
            r.unsubscribe(), this._scrolledCount--, this._scrolledCount || (this._cleanupGlobalListener?.(), this._cleanupGlobalListener = void 0);
          };
        }) : qt();
      }
      ngOnDestroy() {
        this._cleanupGlobalListener?.(), this._cleanupGlobalListener = void 0, this.scrollContainers.forEach((e, n) => this.deregister(n)), this._scrolled.complete();
      }
      ancestorScrolled(e, n) {
        let r = this.getAncestorScrollContainers(e);
        return this.scrolled(n).pipe(En((o) => !o || r.indexOf(o) > -1));
      }
      getAncestorScrollContainers(e) {
        let n = [];
        return this.scrollContainers.forEach((r, o) => {
          this._scrollableContainsElement(o, e) && n.push(o);
        }), n;
      }
      _scrollableContainsElement(e, n) {
        let r = Ji(n), o = e.getElementRef().nativeElement;
        do
          if (r == o) return true;
        while (r = r.parentElement);
        return false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var pD = (() => {
    class i59 {
      elementRef = M(He);
      scrollDispatcher = M(Ud);
      ngZone = M(We);
      dir = M(_i, { optional: true });
      _scrollElement = this.elementRef.nativeElement;
      _destroyed = new we();
      _renderer = M(Pr);
      _cleanupScroll;
      _elementScrolled = new we();
      constructor() {
      }
      ngOnInit() {
        this._cleanupScroll = this.ngZone.runOutsideAngular(() => this._renderer.listen(this._scrollElement, "scroll", (e) => this._elementScrolled.next(e))), this.scrollDispatcher.register(this);
      }
      ngOnDestroy() {
        this._cleanupScroll?.(), this._elementScrolled.complete(), this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete();
      }
      elementScrolled() {
        return this._elementScrolled;
      }
      getElementRef() {
        return this.elementRef;
      }
      scrollTo(e) {
        let n = this.elementRef.nativeElement, r = this.dir && this.dir.value == "rtl";
        e.left == null && (e.left = r ? e.end : e.start), e.right == null && (e.right = r ? e.start : e.end), e.bottom != null && (e.top = n.scrollHeight - n.clientHeight - e.bottom), r && Vu() != es.NORMAL ? (e.left != null && (e.right = n.scrollWidth - n.clientWidth - e.left), Vu() == es.INVERTED ? e.left = e.right : Vu() == es.NEGATED && (e.left = e.right ? -e.right : e.right)) : e.right != null && (e.left = n.scrollWidth - n.clientWidth - e.right), this._applyScrollToOptions(e);
      }
      _applyScrollToOptions(e) {
        let n = this.elementRef.nativeElement;
        Zy() ? n.scrollTo(e) : (e.top != null && (n.scrollTop = e.top), e.left != null && (n.scrollLeft = e.left));
      }
      measureScrollOffset(e) {
        let n = "left", r = "right", o = this.elementRef.nativeElement;
        if (e == "top") return o.scrollTop;
        if (e == "bottom") return o.scrollHeight - o.clientHeight - o.scrollTop;
        let s = this.dir && this.dir.value == "rtl";
        return e == "start" ? e = s ? r : n : e == "end" && (e = s ? n : r), s && Vu() == es.INVERTED ? e == n ? o.scrollWidth - o.clientWidth - o.scrollLeft : o.scrollLeft : s && Vu() == es.NEGATED ? e == n ? o.scrollLeft + o.scrollWidth - o.clientWidth : -o.scrollLeft : e == n ? o.scrollLeft : o.scrollWidth - o.clientWidth - o.scrollLeft;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]] });
    }
    return i59;
  })();
  var Hoe = 20;
  var Bl = (() => {
    class i59 {
      _platform = M(Nn);
      _listeners;
      _viewportSize;
      _change = new we();
      _document = M(yt, { optional: true });
      constructor() {
        let e = M(We), n = M(pr).createRenderer(null, null);
        e.runOutsideAngular(() => {
          if (this._platform.isBrowser) {
            let r = (o) => this._change.next(o);
            this._listeners = [n.listen("window", "resize", r), n.listen("window", "orientationchange", r)];
          }
          this.change().subscribe(() => this._viewportSize = null);
        });
      }
      ngOnDestroy() {
        this._listeners?.forEach((e) => e()), this._change.complete();
      }
      getViewportSize() {
        this._viewportSize || this._updateViewportSize();
        let e = { width: this._viewportSize.width, height: this._viewportSize.height };
        return this._platform.isBrowser || (this._viewportSize = null), e;
      }
      getViewportRect() {
        let e = this.getViewportScrollPosition(), { width: n, height: r } = this.getViewportSize();
        return { top: e.top, left: e.left, bottom: e.top + r, right: e.left + n, height: r, width: n };
      }
      getViewportScrollPosition() {
        if (!this._platform.isBrowser) return { top: 0, left: 0 };
        let e = this._document, n = this._getWindow(), r = e.documentElement, o = r.getBoundingClientRect(), s = -o.top || e.body.scrollTop || n.scrollY || r.scrollTop || 0, a = -o.left || e.body.scrollLeft || n.scrollX || r.scrollLeft || 0;
        return { top: s, left: a };
      }
      change(e = Hoe) {
        return e > 0 ? this._change.pipe(R_(e)) : this._change;
      }
      _getWindow() {
        return this._document.defaultView || window;
      }
      _updateViewportSize() {
        let e = this._getWindow();
        this._viewportSize = this._platform.isBrowser ? { width: e.innerWidth, height: e.innerHeight } : { width: 0, height: 0 };
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Hs = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  var fD = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [hl, Hs, hl, Hs] });
    }
    return i59;
  })();
  var Fg = class {
    _attachedHost;
    attach(t) {
      return this._attachedHost = t, t.attach(this);
    }
    detach() {
      let t = this._attachedHost;
      t != null && (this._attachedHost = null, t.detach());
    }
    get isAttached() {
      return this._attachedHost != null;
    }
    setAttachedHost(t) {
      this._attachedHost = t;
    }
  };
  var Ui = class extends Fg {
    component;
    viewContainerRef;
    injector;
    componentFactoryResolver;
    projectableNodes;
    constructor(t, e, n, r, o) {
      super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.projectableNodes = o;
    }
  };
  var go = class extends Fg {
    templateRef;
    viewContainerRef;
    context;
    injector;
    constructor(t, e, n, r) {
      super(), this.templateRef = t, this.viewContainerRef = e, this.context = n, this.injector = r;
    }
    get origin() {
      return this.templateRef.elementRef;
    }
    attach(t, e = this.context) {
      return this.context = e, super.attach(t);
    }
    detach() {
      return this.context = void 0, super.detach();
    }
  };
  var mD = class extends Fg {
    element;
    constructor(t) {
      super(), this.element = t instanceof He ? t.nativeElement : t;
    }
  };
  var js = class {
    _attachedPortal;
    _disposeFn;
    _isDisposed = false;
    hasAttached() {
      return !!this._attachedPortal;
    }
    attach(t) {
      if (t instanceof Ui) return this._attachedPortal = t, this.attachComponentPortal(t);
      if (t instanceof go) return this._attachedPortal = t, this.attachTemplatePortal(t);
      if (this.attachDomPortal && t instanceof mD) return this._attachedPortal = t, this.attachDomPortal(t);
    }
    attachDomPortal = null;
    detach() {
      this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn();
    }
    dispose() {
      this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = true;
    }
    setDisposeFn(t) {
      this._disposeFn = t;
    }
    _invokeDisposeFn() {
      this._disposeFn && (this._disposeFn(), this._disposeFn = null);
    }
  };
  var Bg = class extends js {
    outletElement;
    _appRef;
    _defaultInjector;
    _document;
    constructor(t, e, n, r, o) {
      super(), this.outletElement = t, this._appRef = n, this._defaultInjector = r, this._document = o;
    }
    attachComponentPortal(t) {
      let e;
      if (t.viewContainerRef) {
        let n = t.injector || t.viewContainerRef.injector, r = n.get(aa, null, { optional: true }) || void 0;
        e = t.viewContainerRef.createComponent(t.component, { index: t.viewContainerRef.length, injector: n, ngModuleRef: r, projectableNodes: t.projectableNodes || void 0 }), this.setDisposeFn(() => e.destroy());
      } else e = Wv(t.component, { elementInjector: t.injector || this._defaultInjector || mt.NULL, environmentInjector: this._appRef.injector, projectableNodes: t.projectableNodes || void 0 }), this._appRef.attachView(e.hostView), this.setDisposeFn(() => {
        this._appRef.viewCount > 0 && this._appRef.detachView(e.hostView), e.destroy();
      });
      return this.outletElement.appendChild(this._getComponentRootNode(e)), this._attachedPortal = t, e;
    }
    attachTemplatePortal(t) {
      let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context, { injector: t.injector });
      return n.rootNodes.forEach((r) => this.outletElement.appendChild(r)), n.detectChanges(), this.setDisposeFn(() => {
        let r = e.indexOf(n);
        r !== -1 && e.remove(r);
      }), this._attachedPortal = t, n;
    }
    attachDomPortal = (t) => {
      let e = t.element;
      e.parentNode;
      let n = this._document.createComment("dom-portal");
      e.parentNode.insertBefore(n, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => {
        n.parentNode && n.parentNode.replaceChild(e, n);
      });
    };
    dispose() {
      super.dispose(), this.outletElement.remove();
    }
    _getComponentRootNode(t) {
      return t.hostView.rootNodes[0];
    }
  };
  var Bo = (() => {
    class i59 extends js {
      _moduleRef = M(aa, { optional: true });
      _document = M(yt);
      _viewContainerRef = M(un);
      _isInitialized = false;
      _attachedRef;
      constructor() {
        super();
      }
      get portal() {
        return this._attachedPortal;
      }
      set portal(e) {
        this.hasAttached() && !e && !this._isInitialized || (this.hasAttached() && super.detach(), e && super.attach(e), this._attachedPortal = e || null);
      }
      attached = new Ue();
      get attachedRef() {
        return this._attachedRef;
      }
      ngOnInit() {
        this._isInitialized = true;
      }
      ngOnDestroy() {
        super.dispose(), this._attachedRef = this._attachedPortal = null;
      }
      attachComponentPortal(e) {
        e.setAttachedHost(this);
        let n = e.viewContainerRef != null ? e.viewContainerRef : this._viewContainerRef, r = n.createComponent(e.component, { index: n.length, injector: e.injector || n.injector, projectableNodes: e.projectableNodes || void 0, ngModuleRef: this._moduleRef || void 0 });
        return n !== this._viewContainerRef && this._getRootNode().appendChild(r.hostView.rootNodes[0]), super.setDisposeFn(() => r.destroy()), this._attachedPortal = e, this._attachedRef = r, this.attached.emit(r), r;
      }
      attachTemplatePortal(e) {
        e.setAttachedHost(this);
        let n = this._viewContainerRef.createEmbeddedView(e.templateRef, e.context, { injector: e.injector });
        return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = e, this._attachedRef = n, this.attached.emit(n), n;
      }
      attachDomPortal = (e) => {
        let n = e.element;
        n.parentNode;
        let r = this._document.createComment("dom-portal");
        e.setAttachedHost(this), n.parentNode.insertBefore(r, n), this._getRootNode().appendChild(n), this._attachedPortal = e, super.setDisposeFn(() => {
          r.parentNode && r.parentNode.replaceChild(n, r);
        });
      };
      _getRootNode() {
        let e = this._viewContainerRef.element.nativeElement;
        return e.nodeType === e.ELEMENT_NODE ? e : e.parentNode;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: [0, "cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [Zt] });
    }
    return i59;
  })();
  var Ws = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  var CU = Zy();
  var gD = class {
    _viewportRuler;
    _previousHTMLStyles = { top: "", left: "" };
    _previousScrollPosition;
    _isEnabled = false;
    _document;
    constructor(t, e) {
      this._viewportRuler = t, this._document = e;
    }
    attach() {
    }
    enable() {
      if (this._canBeEnabled()) {
        let t = this._document.documentElement;
        this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = gi(-this._previousScrollPosition.left), t.style.top = gi(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = true;
      }
    }
    disable() {
      if (this._isEnabled) {
        let t = this._document.documentElement, e = this._document.body, n = t.style, r = e.style, o = n.scrollBehavior || "", s = r.scrollBehavior || "";
        this._isEnabled = false, n.left = this._previousHTMLStyles.left, n.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), CU && (n.scrollBehavior = r.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), CU && (n.scrollBehavior = o, r.scrollBehavior = s);
      }
    }
    _canBeEnabled() {
      if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return false;
      let e = this._document.body, n = this._viewportRuler.getViewportSize();
      return e.scrollHeight > n.height || e.scrollWidth > n.width;
    }
  };
  var _D = class {
    _scrollDispatcher;
    _ngZone;
    _viewportRuler;
    _config;
    _scrollSubscription = null;
    _overlayRef;
    _initialScrollPosition;
    constructor(t, e, n, r) {
      this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = r;
    }
    attach(t) {
      this._overlayRef, this._overlayRef = t;
    }
    enable() {
      if (this._scrollSubscription) return;
      let t = this._scrollDispatcher.scrolled(0).pipe(En((e) => !e || !this._overlayRef.overlayElement.contains(e.getElementRef().nativeElement)));
      this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => {
        let e = this._viewportRuler.getViewportScrollPosition().top;
        Math.abs(e - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition();
      })) : this._scrollSubscription = t.subscribe(this._detach);
    }
    disable() {
      this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null);
    }
    detach() {
      this.disable(), this._overlayRef = null;
    }
    _detach = () => {
      this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach());
    };
  };
  var $x = class {
    enable() {
    }
    disable() {
    }
    attach() {
    }
  };
  function vD(i59, t) {
    return t.some((e) => {
      let n = i59.bottom < e.top, r = i59.top > e.bottom, o = i59.right < e.left, s = i59.left > e.right;
      return n || r || o || s;
    });
  }
  function SU(i59, t) {
    return t.some((e) => {
      let n = i59.top < e.top, r = i59.bottom > e.bottom, o = i59.left < e.left, s = i59.right > e.right;
      return n || r || o || s;
    });
  }
  var yD = class {
    _scrollDispatcher;
    _viewportRuler;
    _ngZone;
    _config;
    _scrollSubscription = null;
    _overlayRef;
    constructor(t, e, n, r) {
      this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = r;
    }
    attach(t) {
      this._overlayRef, this._overlayRef = t;
    }
    enable() {
      if (!this._scrollSubscription) {
        let t = this._config ? this._config.scrollThrottle : 0;
        this._scrollSubscription = this._scrollDispatcher.scrolled(t).subscribe(() => {
          if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) {
            let e = this._overlayRef.overlayElement.getBoundingClientRect(), { width: n, height: r } = this._viewportRuler.getViewportSize();
            vD(e, [{ width: n, height: r, bottom: r, right: n, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach()));
          }
        });
      }
    }
    disable() {
      this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null);
    }
    detach() {
      this.disable(), this._overlayRef = null;
    }
  };
  var $oe = (() => {
    class i59 {
      _scrollDispatcher = M(Ud);
      _viewportRuler = M(Bl);
      _ngZone = M(We);
      _document = M(yt);
      constructor() {
      }
      noop = () => new $x();
      close = (e) => new _D(this._scrollDispatcher, this._ngZone, this._viewportRuler, e);
      block = () => new gD(this._viewportRuler, this._document);
      reposition = (e) => new yD(this._scrollDispatcher, this._viewportRuler, this._ngZone, e);
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Gi = class {
    positionStrategy;
    scrollStrategy = new $x();
    panelClass = "";
    hasBackdrop = false;
    backdropClass = "cdk-overlay-dark-backdrop";
    width;
    height;
    minWidth;
    minHeight;
    maxWidth;
    maxHeight;
    direction;
    disposeOnNavigation = false;
    constructor(t) {
      if (t) {
        let e = Object.keys(t);
        for (let n of e) t[n] !== void 0 && (this[n] = t[n]);
      }
    }
  };
  var bD = class {
    connectionPair;
    scrollableViewProperties;
    constructor(t, e) {
      this.connectionPair = t, this.scrollableViewProperties = e;
    }
  };
  var PU = (() => {
    class i59 {
      _attachedOverlays = [];
      _document = M(yt);
      _isAttached;
      constructor() {
      }
      ngOnDestroy() {
        this.detach();
      }
      add(e) {
        this.remove(e), this._attachedOverlays.push(e);
      }
      remove(e) {
        let n = this._attachedOverlays.indexOf(e);
        n > -1 && this._attachedOverlays.splice(n, 1), this._attachedOverlays.length === 0 && this.detach();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var qoe = (() => {
    class i59 extends PU {
      _ngZone = M(We);
      _renderer = M(pr).createRenderer(null, null);
      _cleanupKeydown;
      add(e) {
        super.add(e), this._isAttached || (this._ngZone.runOutsideAngular(() => {
          this._cleanupKeydown = this._renderer.listen("body", "keydown", this._keydownListener);
        }), this._isAttached = true);
      }
      detach() {
        this._isAttached && (this._cleanupKeydown?.(), this._isAttached = false);
      }
      _keydownListener = (e) => {
        let n = this._attachedOverlays;
        for (let r = n.length - 1; r > -1; r--) if (n[r]._keydownEvents.observers.length > 0) {
          this._ngZone.run(() => n[r]._keydownEvents.next(e));
          break;
        }
      };
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Yoe = (() => {
    class i59 extends PU {
      _platform = M(Nn);
      _ngZone = M(We, { optional: true });
      _cursorOriginalValue;
      _cursorStyleIsSet = false;
      _pointerDownEventTarget;
      add(e) {
        if (super.add(e), !this._isAttached) {
          let n = this._document.body;
          this._ngZone ? this._ngZone.runOutsideAngular(() => this._addEventListeners(n)) : this._addEventListeners(n), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = n.style.cursor, n.style.cursor = "pointer", this._cursorStyleIsSet = true), this._isAttached = true;
        }
      }
      detach() {
        if (this._isAttached) {
          let e = this._document.body;
          e.removeEventListener("pointerdown", this._pointerDownListener, true), e.removeEventListener("click", this._clickListener, true), e.removeEventListener("auxclick", this._clickListener, true), e.removeEventListener("contextmenu", this._clickListener, true), this._platform.IOS && this._cursorStyleIsSet && (e.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = false), this._isAttached = false;
        }
      }
      _addEventListeners(e) {
        e.addEventListener("pointerdown", this._pointerDownListener, true), e.addEventListener("click", this._clickListener, true), e.addEventListener("auxclick", this._clickListener, true), e.addEventListener("contextmenu", this._clickListener, true);
      }
      _pointerDownListener = (e) => {
        this._pointerDownEventTarget = Fi(e);
      };
      _clickListener = (e) => {
        let n = Fi(e), r = e.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : n;
        this._pointerDownEventTarget = null;
        let o = this._attachedOverlays.slice();
        for (let s = o.length - 1; s > -1; s--) {
          let a = o[s];
          if (a._outsidePointerEvents.observers.length < 1 || !a.hasAttached()) continue;
          if (MU(a.overlayElement, n) || MU(a.overlayElement, r)) break;
          let l = a._outsidePointerEvents;
          this._ngZone ? this._ngZone.run(() => l.next(e)) : l.next(e);
        }
      };
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function MU(i59, t) {
    let e = typeof ShadowRoot < "u" && ShadowRoot, n = t;
    for (; n; ) {
      if (n === i59) return true;
      n = e && n instanceof ShadowRoot ? n.host : n.parentNode;
    }
    return false;
  }
  var RU = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["ng-component"]], hostAttrs: ["cdk-overlay-style-loader", ""], decls: 0, vars: 0, template: function(n, r) {
      }, styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var qx = (() => {
    class i59 {
      _platform = M(Nn);
      _containerElement;
      _document = M(yt);
      _styleLoader = M(mi);
      constructor() {
      }
      ngOnDestroy() {
        this._containerElement?.remove();
      }
      getContainerElement() {
        return this._loadStyles(), this._containerElement || this._createContainer(), this._containerElement;
      }
      _createContainer() {
        let e = "cdk-overlay-container";
        if (this._platform.isBrowser || fT()) {
          let r = this._document.querySelectorAll(`.${e}[platform="server"], .${e}[platform="test"]`);
          for (let o = 0; o < r.length; o++) r[o].remove();
        }
        let n = this._document.createElement("div");
        n.classList.add(e), fT() ? n.setAttribute("platform", "test") : this._platform.isBrowser || n.setAttribute("platform", "server"), this._document.body.appendChild(n), this._containerElement = n;
      }
      _loadStyles() {
        this._styleLoader.load(RU);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var xD = class {
    _renderer;
    _ngZone;
    element;
    _cleanupClick;
    _cleanupTransitionEnd;
    _fallbackTimeout;
    constructor(t, e, n, r) {
      this._renderer = e, this._ngZone = n, this.element = t.createElement("div"), this.element.classList.add("cdk-overlay-backdrop"), this._cleanupClick = e.listen(this.element, "click", r);
    }
    detach() {
      this._ngZone.runOutsideAngular(() => {
        let t = this.element;
        clearTimeout(this._fallbackTimeout), this._cleanupTransitionEnd?.(), this._cleanupTransitionEnd = this._renderer.listen(t, "transitionend", this.dispose), this._fallbackTimeout = setTimeout(this.dispose, 500), t.style.pointerEvents = "none", t.classList.remove("cdk-overlay-backdrop-showing");
      });
    }
    dispose = () => {
      clearTimeout(this._fallbackTimeout), this._cleanupClick?.(), this._cleanupTransitionEnd?.(), this._cleanupClick = this._cleanupTransitionEnd = this._fallbackTimeout = void 0, this.element.remove();
    };
  };
  var lp = class {
    _portalOutlet;
    _host;
    _pane;
    _config;
    _ngZone;
    _keyboardDispatcher;
    _document;
    _location;
    _outsideClickDispatcher;
    _animationsDisabled;
    _injector;
    _renderer;
    _backdropClick = new we();
    _attachments = new we();
    _detachments = new we();
    _positionStrategy;
    _scrollStrategy;
    _locationChanges = Rt.EMPTY;
    _backdropRef = null;
    _previousHostParent;
    _keydownEvents = new we();
    _outsidePointerEvents = new we();
    _renders = new we();
    _afterRenderRef;
    _afterNextRenderRef;
    constructor(t, e, n, r, o, s, a, l, c, d = false, u, h) {
      this._portalOutlet = t, this._host = e, this._pane = n, this._config = r, this._ngZone = o, this._keyboardDispatcher = s, this._document = a, this._location = l, this._outsideClickDispatcher = c, this._animationsDisabled = d, this._injector = u, this._renderer = h, r.scrollStrategy && (this._scrollStrategy = r.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = r.positionStrategy, this._afterRenderRef = Rr(() => tf(() => {
        this._renders.next();
      }, { injector: this._injector }));
    }
    get overlayElement() {
      return this._pane;
    }
    get backdropElement() {
      return this._backdropRef?.element || null;
    }
    get hostElement() {
      return this._host;
    }
    attach(t) {
      !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host);
      let e = this._portalOutlet.attach(t);
      return this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._afterNextRenderRef?.destroy(), this._afterNextRenderRef = Yi(() => {
        this.hasAttached() && this.updatePosition();
      }, { injector: this._injector }), this._togglePointerEvents(true), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, true), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), typeof e?.onDestroy == "function" && e.onDestroy(() => {
        this.hasAttached() && this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
      }), e;
    }
    detach() {
      if (!this.hasAttached()) return;
      this.detachBackdrop(), this._togglePointerEvents(false), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable();
      let t = this._portalOutlet.detach();
      return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenEmpty(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t;
    }
    dispose() {
      let t = this.hasAttached();
      this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._backdropRef?.dispose(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host?.remove(), this._afterNextRenderRef?.destroy(), this._previousHostParent = this._pane = this._host = this._backdropRef = null, t && this._detachments.next(), this._detachments.complete(), this._afterRenderRef.destroy(), this._renders.complete();
    }
    hasAttached() {
      return this._portalOutlet.hasAttached();
    }
    backdropClick() {
      return this._backdropClick;
    }
    attachments() {
      return this._attachments;
    }
    detachments() {
      return this._detachments;
    }
    keydownEvents() {
      return this._keydownEvents;
    }
    outsidePointerEvents() {
      return this._outsidePointerEvents;
    }
    getConfig() {
      return this._config;
    }
    updatePosition() {
      this._positionStrategy && this._positionStrategy.apply();
    }
    updatePositionStrategy(t) {
      t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition()));
    }
    updateSize(t) {
      this._config = le(le({}, this._config), t), this._updateElementSize();
    }
    setDirection(t) {
      this._config = xt(le({}, this._config), { direction: t }), this._updateElementDirection();
    }
    addPanelClass(t) {
      this._pane && this._toggleClasses(this._pane, t, true);
    }
    removePanelClass(t) {
      this._pane && this._toggleClasses(this._pane, t, false);
    }
    getDirection() {
      let t = this._config.direction;
      return t ? typeof t == "string" ? t : t.value : "ltr";
    }
    updateScrollStrategy(t) {
      t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable()));
    }
    _updateElementDirection() {
      this._host.setAttribute("dir", this.getDirection());
    }
    _updateElementSize() {
      if (!this._pane) return;
      let t = this._pane.style;
      t.width = gi(this._config.width), t.height = gi(this._config.height), t.minWidth = gi(this._config.minWidth), t.minHeight = gi(this._config.minHeight), t.maxWidth = gi(this._config.maxWidth), t.maxHeight = gi(this._config.maxHeight);
    }
    _togglePointerEvents(t) {
      this._pane.style.pointerEvents = t ? "" : "none";
    }
    _attachBackdrop() {
      let t = "cdk-overlay-backdrop-showing";
      this._backdropRef?.dispose(), this._backdropRef = new xD(this._document, this._renderer, this._ngZone, (e) => {
        this._backdropClick.next(e);
      }), this._animationsDisabled && this._backdropRef.element.classList.add("cdk-overlay-backdrop-noop-animation"), this._config.backdropClass && this._toggleClasses(this._backdropRef.element, this._config.backdropClass, true), this._host.parentElement.insertBefore(this._backdropRef.element, this._host), !this._animationsDisabled && typeof requestAnimationFrame < "u" ? this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => this._backdropRef?.element.classList.add(t));
      }) : this._backdropRef.element.classList.add(t);
    }
    _updateStackingOrder() {
      this._host.nextSibling && this._host.parentNode.appendChild(this._host);
    }
    detachBackdrop() {
      this._animationsDisabled ? (this._backdropRef?.dispose(), this._backdropRef = null) : this._backdropRef?.detach();
    }
    _toggleClasses(t, e, n) {
      let r = Vc(e || []).filter((o) => !!o);
      r.length && (n ? t.classList.add(...r) : t.classList.remove(...r));
    }
    _detachContentWhenEmpty() {
      this._ngZone.runOutsideAngular(() => {
        let t = this._renders.pipe(Je(Jn(this._attachments, this._detachments))).subscribe(() => {
          (!this._pane || !this._host || this._pane.children.length === 0) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, false), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._host.remove()), t.unsubscribe());
        });
      });
    }
    _disposeScrollStrategy() {
      let t = this._scrollStrategy;
      t?.disable(), t?.detach?.();
    }
  };
  var EU = "cdk-overlay-connected-position-bounding-box";
  var Xoe = /([A-Za-z%]+)$/;
  var wD = class {
    _viewportRuler;
    _document;
    _platform;
    _overlayContainer;
    _overlayRef;
    _isInitialRender;
    _lastBoundingBoxSize = { width: 0, height: 0 };
    _isPushed = false;
    _canPush = true;
    _growAfterOpen = false;
    _hasFlexibleDimensions = true;
    _positionLocked = false;
    _originRect;
    _overlayRect;
    _viewportRect;
    _containerRect;
    _viewportMargin = 0;
    _scrollables = [];
    _preferredPositions = [];
    _origin;
    _pane;
    _isDisposed;
    _boundingBox;
    _lastPosition;
    _lastScrollVisibility;
    _positionChanges = new we();
    _resizeSubscription = Rt.EMPTY;
    _offsetX = 0;
    _offsetY = 0;
    _transformOriginSelector;
    _appliedPanelClasses = [];
    _previousPushAmount;
    positionChanges = this._positionChanges;
    get positions() {
      return this._preferredPositions;
    }
    constructor(t, e, n, r, o) {
      this._viewportRuler = e, this._document = n, this._platform = r, this._overlayContainer = o, this.setOrigin(t);
    }
    attach(t) {
      this._overlayRef && this._overlayRef, this._validatePositions(), t.hostElement.classList.add(EU), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = false, this._isInitialRender = true, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
        this._isInitialRender = true, this.apply();
      });
    }
    apply() {
      if (this._isDisposed || !this._platform.isBrowser) return;
      if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
        this.reapplyLastPosition();
        return;
      }
      this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      let t = this._originRect, e = this._overlayRect, n = this._viewportRect, r = this._containerRect, o = [], s;
      for (let a of this._preferredPositions) {
        let l = this._getOriginPoint(t, r, a), c = this._getOverlayPoint(l, e, a), d = this._getOverlayFit(c, e, n, a);
        if (d.isCompletelyWithinViewport) {
          this._isPushed = false, this._applyPosition(a, l);
          return;
        }
        if (this._canFitWithFlexibleDimensions(d, c, n)) {
          o.push({ position: a, origin: l, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(l, a) });
          continue;
        }
        (!s || s.overlayFit.visibleArea < d.visibleArea) && (s = { overlayFit: d, overlayPoint: c, originPoint: l, position: a, overlayRect: e });
      }
      if (o.length) {
        let a = null, l = -1;
        for (let c of o) {
          let d = c.boundingBoxRect.width * c.boundingBoxRect.height * (c.position.weight || 1);
          d > l && (l = d, a = c);
        }
        this._isPushed = false, this._applyPosition(a.position, a.origin);
        return;
      }
      if (this._canPush) {
        this._isPushed = true, this._applyPosition(s.position, s.originPoint);
        return;
      }
      this._applyPosition(s.position, s.originPoint);
    }
    detach() {
      this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe();
    }
    dispose() {
      this._isDisposed || (this._boundingBox && Gd(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(EU), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = true);
    }
    reapplyLastPosition() {
      if (this._isDisposed || !this._platform.isBrowser) return;
      let t = this._lastPosition;
      if (t) {
        this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
        let e = this._getOriginPoint(this._originRect, this._containerRect, t);
        this._applyPosition(t, e);
      } else this.apply();
    }
    withScrollableContainers(t) {
      return this._scrollables = t, this;
    }
    withPositions(t) {
      return this._preferredPositions = t, t.indexOf(this._lastPosition) === -1 && (this._lastPosition = null), this._validatePositions(), this;
    }
    withViewportMargin(t) {
      return this._viewportMargin = t, this;
    }
    withFlexibleDimensions(t = true) {
      return this._hasFlexibleDimensions = t, this;
    }
    withGrowAfterOpen(t = true) {
      return this._growAfterOpen = t, this;
    }
    withPush(t = true) {
      return this._canPush = t, this;
    }
    withLockedPosition(t = true) {
      return this._positionLocked = t, this;
    }
    setOrigin(t) {
      return this._origin = t, this;
    }
    withDefaultOffsetX(t) {
      return this._offsetX = t, this;
    }
    withDefaultOffsetY(t) {
      return this._offsetY = t, this;
    }
    withTransformOriginOn(t) {
      return this._transformOriginSelector = t, this;
    }
    _getOriginPoint(t, e, n) {
      let r;
      if (n.originX == "center") r = t.left + t.width / 2;
      else {
        let s = this._isRtl() ? t.right : t.left, a = this._isRtl() ? t.left : t.right;
        r = n.originX == "start" ? s : a;
      }
      e.left < 0 && (r -= e.left);
      let o;
      return n.originY == "center" ? o = t.top + t.height / 2 : o = n.originY == "top" ? t.top : t.bottom, e.top < 0 && (o -= e.top), { x: r, y: o };
    }
    _getOverlayPoint(t, e, n) {
      let r;
      n.overlayX == "center" ? r = -e.width / 2 : n.overlayX === "start" ? r = this._isRtl() ? -e.width : 0 : r = this._isRtl() ? 0 : -e.width;
      let o;
      return n.overlayY == "center" ? o = -e.height / 2 : o = n.overlayY == "top" ? 0 : -e.height, { x: t.x + r, y: t.y + o };
    }
    _getOverlayFit(t, e, n, r) {
      let o = IU(e), { x: s, y: a } = t, l = this._getOffset(r, "x"), c = this._getOffset(r, "y");
      l && (s += l), c && (a += c);
      let d = 0 - s, u = s + o.width - n.width, h = 0 - a, p = a + o.height - n.height, f = this._subtractOverflows(o.width, d, u), m = this._subtractOverflows(o.height, h, p), v = f * m;
      return { visibleArea: v, isCompletelyWithinViewport: o.width * o.height === v, fitsInViewportVertically: m === o.height, fitsInViewportHorizontally: f == o.width };
    }
    _canFitWithFlexibleDimensions(t, e, n) {
      if (this._hasFlexibleDimensions) {
        let r = n.bottom - e.y, o = n.right - e.x, s = TU(this._overlayRef.getConfig().minHeight), a = TU(this._overlayRef.getConfig().minWidth), l = t.fitsInViewportVertically || s != null && s <= r, c = t.fitsInViewportHorizontally || a != null && a <= o;
        return l && c;
      }
      return false;
    }
    _pushOverlayOnScreen(t, e, n) {
      if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y };
      let r = IU(e), o = this._viewportRect, s = Math.max(t.x + r.width - o.width, 0), a = Math.max(t.y + r.height - o.height, 0), l = Math.max(o.top - n.top - t.y, 0), c = Math.max(o.left - n.left - t.x, 0), d = 0, u = 0;
      return r.width <= o.width ? d = c || -s : d = t.x < this._viewportMargin ? o.left - n.left - t.x : 0, r.height <= o.height ? u = l || -a : u = t.y < this._viewportMargin ? o.top - n.top - t.y : 0, this._previousPushAmount = { x: d, y: u }, { x: t.x + d, y: t.y + u };
    }
    _applyPosition(t, e) {
      if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._positionChanges.observers.length) {
        let n = this._getScrollVisibility();
        if (t !== this._lastPosition || !this._lastScrollVisibility || !Zoe(this._lastScrollVisibility, n)) {
          let r = new bD(t, n);
          this._positionChanges.next(r);
        }
        this._lastScrollVisibility = n;
      }
      this._lastPosition = t, this._isInitialRender = false;
    }
    _setTransformOrigin(t) {
      if (!this._transformOriginSelector) return;
      let e = this._boundingBox.querySelectorAll(this._transformOriginSelector), n, r = t.overlayY;
      t.overlayX === "center" ? n = "center" : this._isRtl() ? n = t.overlayX === "start" ? "right" : "left" : n = t.overlayX === "start" ? "left" : "right";
      for (let o = 0; o < e.length; o++) e[o].style.transformOrigin = `${n} ${r}`;
    }
    _calculateBoundingBoxRect(t, e) {
      let n = this._viewportRect, r = this._isRtl(), o, s, a;
      if (e.overlayY === "top") s = t.y, o = n.height - s + this._viewportMargin;
      else if (e.overlayY === "bottom") a = n.height - t.y + this._viewportMargin * 2, o = n.height - a + this._viewportMargin;
      else {
        let p = Math.min(n.bottom - t.y + n.top, t.y), f = this._lastBoundingBoxSize.height;
        o = p * 2, s = t.y - p, o > f && !this._isInitialRender && !this._growAfterOpen && (s = t.y - f / 2);
      }
      let l = e.overlayX === "start" && !r || e.overlayX === "end" && r, c = e.overlayX === "end" && !r || e.overlayX === "start" && r, d, u, h;
      if (c) h = n.width - t.x + this._viewportMargin * 2, d = t.x - this._viewportMargin;
      else if (l) u = t.x, d = n.right - t.x;
      else {
        let p = Math.min(n.right - t.x + n.left, t.x), f = this._lastBoundingBoxSize.width;
        d = p * 2, u = t.x - p, d > f && !this._isInitialRender && !this._growAfterOpen && (u = t.x - f / 2);
      }
      return { top: s, left: u, bottom: a, right: h, width: d, height: o };
    }
    _setBoundingBoxStyles(t, e) {
      let n = this._calculateBoundingBoxRect(t, e);
      !this._isInitialRender && !this._growAfterOpen && (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width));
      let r = {};
      if (this._hasExactPosition()) r.top = r.left = "0", r.bottom = r.right = r.maxHeight = r.maxWidth = "", r.width = r.height = "100%";
      else {
        let o = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth;
        r.height = gi(n.height), r.top = gi(n.top), r.bottom = gi(n.bottom), r.width = gi(n.width), r.left = gi(n.left), r.right = gi(n.right), e.overlayX === "center" ? r.alignItems = "center" : r.alignItems = e.overlayX === "end" ? "flex-end" : "flex-start", e.overlayY === "center" ? r.justifyContent = "center" : r.justifyContent = e.overlayY === "bottom" ? "flex-end" : "flex-start", o && (r.maxHeight = gi(o)), s && (r.maxWidth = gi(s));
      }
      this._lastBoundingBoxSize = n, Gd(this._boundingBox.style, r);
    }
    _resetBoundingBoxStyles() {
      Gd(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" });
    }
    _resetOverlayElementStyles() {
      Gd(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" });
    }
    _setOverlayElementStyles(t, e) {
      let n = {}, r = this._hasExactPosition(), o = this._hasFlexibleDimensions, s = this._overlayRef.getConfig();
      if (r) {
        let d = this._viewportRuler.getViewportScrollPosition();
        Gd(n, this._getExactOverlayY(e, t, d)), Gd(n, this._getExactOverlayX(e, t, d));
      } else n.position = "static";
      let a = "", l = this._getOffset(e, "x"), c = this._getOffset(e, "y");
      l && (a += `translateX(${l}px) `), c && (a += `translateY(${c}px)`), n.transform = a.trim(), s.maxHeight && (r ? n.maxHeight = gi(s.maxHeight) : o && (n.maxHeight = "")), s.maxWidth && (r ? n.maxWidth = gi(s.maxWidth) : o && (n.maxWidth = "")), Gd(this._pane.style, n);
    }
    _getExactOverlayY(t, e, n) {
      let r = { top: "", bottom: "" }, o = this._getOverlayPoint(e, this._overlayRect, t);
      if (this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, n)), t.overlayY === "bottom") {
        let s = this._document.documentElement.clientHeight;
        r.bottom = `${s - (o.y + this._overlayRect.height)}px`;
      } else r.top = gi(o.y);
      return r;
    }
    _getExactOverlayX(t, e, n) {
      let r = { left: "", right: "" }, o = this._getOverlayPoint(e, this._overlayRect, t);
      this._isPushed && (o = this._pushOverlayOnScreen(o, this._overlayRect, n));
      let s;
      if (this._isRtl() ? s = t.overlayX === "end" ? "left" : "right" : s = t.overlayX === "end" ? "right" : "left", s === "right") {
        let a = this._document.documentElement.clientWidth;
        r.right = `${a - (o.x + this._overlayRect.width)}px`;
      } else r.left = gi(o.x);
      return r;
    }
    _getScrollVisibility() {
      let t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map((r) => r.getElementRef().nativeElement.getBoundingClientRect());
      return { isOriginClipped: SU(t, n), isOriginOutsideView: vD(t, n), isOverlayClipped: SU(e, n), isOverlayOutsideView: vD(e, n) };
    }
    _subtractOverflows(t, ...e) {
      return e.reduce((n, r) => n - Math.max(r, 0), t);
    }
    _getNarrowedViewportRect() {
      let t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition();
      return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin };
    }
    _isRtl() {
      return this._overlayRef.getDirection() === "rtl";
    }
    _hasExactPosition() {
      return !this._hasFlexibleDimensions || this._isPushed;
    }
    _getOffset(t, e) {
      return e === "x" ? t.offsetX == null ? this._offsetX : t.offsetX : t.offsetY == null ? this._offsetY : t.offsetY;
    }
    _validatePositions() {
    }
    _addPanelClasses(t) {
      this._pane && Vc(t).forEach((e) => {
        e !== "" && this._appliedPanelClasses.indexOf(e) === -1 && (this._appliedPanelClasses.push(e), this._pane.classList.add(e));
      });
    }
    _clearPanelClasses() {
      this._pane && (this._appliedPanelClasses.forEach((t) => {
        this._pane.classList.remove(t);
      }), this._appliedPanelClasses = []);
    }
    _getOriginRect() {
      let t = this._origin;
      if (t instanceof He) return t.nativeElement.getBoundingClientRect();
      if (t instanceof Element) return t.getBoundingClientRect();
      let e = t.width || 0, n = t.height || 0;
      return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e };
    }
  };
  function Gd(i59, t) {
    for (let e in t) t.hasOwnProperty(e) && (i59[e] = t[e]);
    return i59;
  }
  function TU(i59) {
    if (typeof i59 != "number" && i59 != null) {
      let [t, e] = i59.split(Xoe);
      return !e || e === "px" ? parseFloat(t) : null;
    }
    return i59 || null;
  }
  function IU(i59) {
    return { top: Math.floor(i59.top), right: Math.floor(i59.right), bottom: Math.floor(i59.bottom), left: Math.floor(i59.left), width: Math.floor(i59.width), height: Math.floor(i59.height) };
  }
  function Zoe(i59, t) {
    return i59 === t ? true : i59.isOriginClipped === t.isOriginClipped && i59.isOriginOutsideView === t.isOriginOutsideView && i59.isOverlayClipped === t.isOverlayClipped && i59.isOverlayOutsideView === t.isOverlayOutsideView;
  }
  var DU = "cdk-global-overlay-wrapper";
  var CD = class {
    _overlayRef;
    _cssPosition = "static";
    _topOffset = "";
    _bottomOffset = "";
    _alignItems = "";
    _xPosition = "";
    _xOffset = "";
    _width = "";
    _height = "";
    _isDisposed = false;
    attach(t) {
      let e = t.getConfig();
      this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(DU), this._isDisposed = false;
    }
    top(t = "") {
      return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this;
    }
    left(t = "") {
      return this._xOffset = t, this._xPosition = "left", this;
    }
    bottom(t = "") {
      return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this;
    }
    right(t = "") {
      return this._xOffset = t, this._xPosition = "right", this;
    }
    start(t = "") {
      return this._xOffset = t, this._xPosition = "start", this;
    }
    end(t = "") {
      return this._xOffset = t, this._xPosition = "end", this;
    }
    width(t = "") {
      return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this;
    }
    height(t = "") {
      return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this;
    }
    centerHorizontally(t = "") {
      return this.left(t), this._xPosition = "center", this;
    }
    centerVertically(t = "") {
      return this.top(t), this._alignItems = "center", this;
    }
    apply() {
      if (!this._overlayRef || !this._overlayRef.hasAttached()) return;
      let t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(), { width: r, height: o, maxWidth: s, maxHeight: a } = n, l = (r === "100%" || r === "100vw") && (!s || s === "100%" || s === "100vw"), c = (o === "100%" || o === "100vh") && (!a || a === "100%" || a === "100vh"), d = this._xPosition, u = this._xOffset, h = this._overlayRef.getConfig().direction === "rtl", p = "", f = "", m = "";
      l ? m = "flex-start" : d === "center" ? (m = "center", h ? f = u : p = u) : h ? d === "left" || d === "end" ? (m = "flex-end", p = u) : (d === "right" || d === "start") && (m = "flex-start", f = u) : d === "left" || d === "start" ? (m = "flex-start", p = u) : (d === "right" || d === "end") && (m = "flex-end", f = u), t.position = this._cssPosition, t.marginLeft = l ? "0" : p, t.marginTop = c ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = l ? "0" : f, e.justifyContent = m, e.alignItems = c ? "flex-start" : this._alignItems;
    }
    dispose() {
      if (this._isDisposed || !this._overlayRef) return;
      let t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style;
      e.classList.remove(DU), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = true;
    }
  };
  var Qoe = (() => {
    class i59 {
      _viewportRuler = M(Bl);
      _document = M(yt);
      _platform = M(Nn);
      _overlayContainer = M(qx);
      constructor() {
      }
      global() {
        return new CD();
      }
      flexibleConnectedTo(e) {
        return new wD(e, this._viewportRuler, this._document, this._platform, this._overlayContainer);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var fn = (() => {
    class i59 {
      scrollStrategies = M($oe);
      _overlayContainer = M(qx);
      _positionBuilder = M(Qoe);
      _keyboardDispatcher = M(qoe);
      _injector = M(mt);
      _ngZone = M(We);
      _document = M(yt);
      _directionality = M(_i);
      _location = M(OM);
      _outsideClickDispatcher = M(Yoe);
      _animationsModuleType = M(An, { optional: true });
      _idGenerator = M(kn);
      _renderer = M(pr).createRenderer(null, null);
      _appRef;
      _styleLoader = M(mi);
      constructor() {
      }
      create(e) {
        this._styleLoader.load(RU);
        let n = this._createHostElement(), r = this._createPaneElement(n), o = this._createPortalOutlet(r), s = new Gi(e);
        return s.direction = s.direction || this._directionality.value, new lp(o, n, r, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, this._animationsModuleType === "NoopAnimations", this._injector.get(Jr), this._renderer);
      }
      position() {
        return this._positionBuilder;
      }
      _createPaneElement(e) {
        let n = this._document.createElement("div");
        return n.id = this._idGenerator.getId("cdk-overlay-"), n.classList.add("cdk-overlay-pane"), e.appendChild(n), n;
      }
      _createHostElement() {
        let e = this._document.createElement("div");
        return this._overlayContainer.getContainerElement().appendChild(e), e;
      }
      _createPortalOutlet(e) {
        return this._appRef || (this._appRef = this._injector.get(Ur)), new Bg(e, null, this._appRef, this._injector, this._document);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Koe = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }];
  var OU = new Ee("cdk-connected-overlay-scroll-strategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.reposition();
  } });
  var Vg = (() => {
    class i59 {
      elementRef = M(He);
      constructor() {
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]], exportAs: ["cdkOverlayOrigin"] });
    }
    return i59;
  })();
  var SD = (() => {
    class i59 {
      _overlay = M(fn);
      _dir = M(_i, { optional: true });
      _overlayRef;
      _templatePortal;
      _backdropSubscription = Rt.EMPTY;
      _attachSubscription = Rt.EMPTY;
      _detachSubscription = Rt.EMPTY;
      _positionSubscription = Rt.EMPTY;
      _offsetX;
      _offsetY;
      _position;
      _scrollStrategyFactory = M(OU);
      _disposeOnNavigation = false;
      _ngZone = M(We);
      origin;
      positions;
      positionStrategy;
      get offsetX() {
        return this._offsetX;
      }
      set offsetX(e) {
        this._offsetX = e, this._position && this._updatePositionStrategy(this._position);
      }
      get offsetY() {
        return this._offsetY;
      }
      set offsetY(e) {
        this._offsetY = e, this._position && this._updatePositionStrategy(this._position);
      }
      width;
      height;
      minWidth;
      minHeight;
      backdropClass;
      panelClass;
      viewportMargin = 0;
      scrollStrategy;
      open = false;
      disableClose = false;
      transformOriginSelector;
      hasBackdrop = false;
      lockPosition = false;
      flexibleDimensions = false;
      growAfterOpen = false;
      push = false;
      get disposeOnNavigation() {
        return this._disposeOnNavigation;
      }
      set disposeOnNavigation(e) {
        this._disposeOnNavigation = e;
      }
      backdropClick = new Ue();
      positionChange = new Ue();
      attach = new Ue();
      detach = new Ue();
      overlayKeydown = new Ue();
      overlayOutsideClick = new Ue();
      constructor() {
        let e = M(ni), n = M(un);
        this._templatePortal = new go(e, n), this.scrollStrategy = this._scrollStrategyFactory();
      }
      get overlayRef() {
        return this._overlayRef;
      }
      get dir() {
        return this._dir ? this._dir.value : "ltr";
      }
      ngOnDestroy() {
        this._attachSubscription.unsubscribe(), this._detachSubscription.unsubscribe(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this._overlayRef && this._overlayRef.dispose();
      }
      ngOnChanges(e) {
        this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({ width: this.width, minWidth: this.minWidth, height: this.height, minHeight: this.minHeight }), e.origin && this.open && this._position.apply()), e.open && (this.open ? this._attachOverlay() : this._detachOverlay());
      }
      _createOverlay() {
        (!this.positions || !this.positions.length) && (this.positions = Koe);
        let e = this._overlayRef = this._overlay.create(this._buildConfig());
        this._attachSubscription = e.attachments().subscribe(() => this.attach.emit()), this._detachSubscription = e.detachments().subscribe(() => this.detach.emit()), e.keydownEvents().subscribe((n) => {
          this.overlayKeydown.next(n), n.keyCode === 27 && !this.disableClose && !Ki(n) && (n.preventDefault(), this._detachOverlay());
        }), this._overlayRef.outsidePointerEvents().subscribe((n) => {
          let r = this._getOriginElement(), o = Fi(n);
          (!r || r !== o && !r.contains(o)) && this.overlayOutsideClick.next(n);
        });
      }
      _buildConfig() {
        let e = this._position = this.positionStrategy || this._createPositionStrategy(), n = new Gi({ direction: this._dir || "ltr", positionStrategy: e, scrollStrategy: this.scrollStrategy, hasBackdrop: this.hasBackdrop, disposeOnNavigation: this.disposeOnNavigation });
        return (this.width || this.width === 0) && (n.width = this.width), (this.height || this.height === 0) && (n.height = this.height), (this.minWidth || this.minWidth === 0) && (n.minWidth = this.minWidth), (this.minHeight || this.minHeight === 0) && (n.minHeight = this.minHeight), this.backdropClass && (n.backdropClass = this.backdropClass), this.panelClass && (n.panelClass = this.panelClass), n;
      }
      _updatePositionStrategy(e) {
        let n = this.positions.map((r) => ({ originX: r.originX, originY: r.originY, overlayX: r.overlayX, overlayY: r.overlayY, offsetX: r.offsetX || this.offsetX, offsetY: r.offsetY || this.offsetY, panelClass: r.panelClass || void 0 }));
        return e.setOrigin(this._getOrigin()).withPositions(n).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector);
      }
      _createPositionStrategy() {
        let e = this._overlay.position().flexibleConnectedTo(this._getOrigin());
        return this._updatePositionStrategy(e), e;
      }
      _getOrigin() {
        return this.origin instanceof Vg ? this.origin.elementRef : this.origin;
      }
      _getOriginElement() {
        return this.origin instanceof Vg ? this.origin.elementRef.nativeElement : this.origin instanceof He ? this.origin.nativeElement : typeof Element < "u" && this.origin instanceof Element ? this.origin : null;
      }
      _attachOverlay() {
        this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || this._overlayRef.attach(this._templatePortal), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe((e) => {
          this.backdropClick.emit(e);
        }) : this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this.positionChange.observers.length > 0 && (this._positionSubscription = this._position.positionChanges.pipe(aC(() => this.positionChange.observers.length > 0)).subscribe((e) => {
          this._ngZone.run(() => this.positionChange.emit(e)), this.positionChange.observers.length === 0 && this._positionSubscription.unsubscribe();
        }));
      }
      _detachOverlay() {
        this._overlayRef && this._overlayRef.detach(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]], inputs: { origin: [0, "cdkConnectedOverlayOrigin", "origin"], positions: [0, "cdkConnectedOverlayPositions", "positions"], positionStrategy: [0, "cdkConnectedOverlayPositionStrategy", "positionStrategy"], offsetX: [0, "cdkConnectedOverlayOffsetX", "offsetX"], offsetY: [0, "cdkConnectedOverlayOffsetY", "offsetY"], width: [0, "cdkConnectedOverlayWidth", "width"], height: [0, "cdkConnectedOverlayHeight", "height"], minWidth: [0, "cdkConnectedOverlayMinWidth", "minWidth"], minHeight: [0, "cdkConnectedOverlayMinHeight", "minHeight"], backdropClass: [0, "cdkConnectedOverlayBackdropClass", "backdropClass"], panelClass: [0, "cdkConnectedOverlayPanelClass", "panelClass"], viewportMargin: [0, "cdkConnectedOverlayViewportMargin", "viewportMargin"], scrollStrategy: [0, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"], open: [0, "cdkConnectedOverlayOpen", "open"], disableClose: [0, "cdkConnectedOverlayDisableClose", "disableClose"], transformOriginSelector: [0, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"], hasBackdrop: [2, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", tt], lockPosition: [2, "cdkConnectedOverlayLockPosition", "lockPosition", tt], flexibleDimensions: [2, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", tt], growAfterOpen: [2, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", tt], push: [2, "cdkConnectedOverlayPush", "push", tt], disposeOnNavigation: [2, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", tt] }, outputs: { backdropClick: "backdropClick", positionChange: "positionChange", attach: "attach", detach: "detach", overlayKeydown: "overlayKeydown", overlayOutsideClick: "overlayOutsideClick" }, exportAs: ["cdkConnectedOverlay"], features: [on, yn] });
    }
    return i59;
  })();
  function Joe(i59) {
    return () => i59.scrollStrategies.reposition();
  }
  var ese = { provide: OU, deps: [fn], useFactory: Joe };
  var ps = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [fn, ese], imports: [hl, Ws, fD, fD] });
    }
    return i59;
  })();
  var tse = ["*"];
  var Yx;
  function nse() {
    if (Yx === void 0 && (Yx = null, typeof window < "u")) {
      let i59 = window;
      i59.trustedTypes !== void 0 && (Yx = i59.trustedTypes.createPolicy("angular#components", { createHTML: (t) => t }));
    }
    return Yx;
  }
  function Ug(i59) {
    return nse()?.createHTML(i59) || i59;
  }
  function AU(i59) {
    return Error(`Unable to find icon with the name "${i59}"`);
  }
  function ise() {
    return Error("Could not find HttpClient for use with Angular Material icons. Please add provideHttpClient() to your providers.");
  }
  function NU(i59) {
    return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${i59}".`);
  }
  function kU(i59) {
    return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${i59}".`);
  }
  var Ua = class {
    url;
    svgText;
    options;
    svgElement;
    constructor(t, e, n) {
      this.url = t, this.svgText = e, this.options = n;
    }
  };
  var rse = (() => {
    class i59 {
      _httpClient;
      _sanitizer;
      _errorHandler;
      _document;
      _svgIconConfigs = /* @__PURE__ */ new Map();
      _iconSetConfigs = /* @__PURE__ */ new Map();
      _cachedIconsByUrl = /* @__PURE__ */ new Map();
      _inProgressUrlFetches = /* @__PURE__ */ new Map();
      _fontCssClassesByAlias = /* @__PURE__ */ new Map();
      _resolvers = [];
      _defaultFontSetClass = ["material-icons", "mat-ligature-font"];
      constructor(e, n, r, o) {
        this._httpClient = e, this._sanitizer = n, this._errorHandler = o, this._document = r;
      }
      addSvgIcon(e, n, r) {
        return this.addSvgIconInNamespace("", e, n, r);
      }
      addSvgIconLiteral(e, n, r) {
        return this.addSvgIconLiteralInNamespace("", e, n, r);
      }
      addSvgIconInNamespace(e, n, r, o) {
        return this._addSvgIconConfig(e, n, new Ua(r, null, o));
      }
      addSvgIconResolver(e) {
        return this._resolvers.push(e), this;
      }
      addSvgIconLiteralInNamespace(e, n, r, o) {
        let s = this._sanitizer.sanitize(Dr.HTML, r);
        if (!s) throw kU(r);
        let a = Ug(s);
        return this._addSvgIconConfig(e, n, new Ua("", a, o));
      }
      addSvgIconSet(e, n) {
        return this.addSvgIconSetInNamespace("", e, n);
      }
      addSvgIconSetLiteral(e, n) {
        return this.addSvgIconSetLiteralInNamespace("", e, n);
      }
      addSvgIconSetInNamespace(e, n, r) {
        return this._addSvgIconSetConfig(e, new Ua(n, null, r));
      }
      addSvgIconSetLiteralInNamespace(e, n, r) {
        let o = this._sanitizer.sanitize(Dr.HTML, n);
        if (!o) throw kU(n);
        let s = Ug(o);
        return this._addSvgIconSetConfig(e, new Ua("", s, r));
      }
      registerFontClassAlias(e, n = e) {
        return this._fontCssClassesByAlias.set(e, n), this;
      }
      classNameForFontAlias(e) {
        return this._fontCssClassesByAlias.get(e) || e;
      }
      setDefaultFontSetClass(...e) {
        return this._defaultFontSetClass = e, this;
      }
      getDefaultFontSetClass() {
        return this._defaultFontSetClass;
      }
      getSvgIconFromUrl(e) {
        let n = this._sanitizer.sanitize(Dr.RESOURCE_URL, e);
        if (!n) throw NU(e);
        let r = this._cachedIconsByUrl.get(n);
        return r ? qt(Xx(r)) : this._loadSvgIconFromConfig(new Ua(e, null)).pipe(Wi((o) => this._cachedIconsByUrl.set(n, o)), kt((o) => Xx(o)));
      }
      getNamedSvgIcon(e, n = "") {
        let r = LU(n, e), o = this._svgIconConfigs.get(r);
        if (o) return this._getSvgFromConfig(o);
        if (o = this._getIconConfigFromResolvers(n, e), o) return this._svgIconConfigs.set(r, o), this._getSvgFromConfig(o);
        let s = this._iconSetConfigs.get(n);
        return s ? this._getSvgFromIconSetConfigs(e, s) : rC(AU(r));
      }
      ngOnDestroy() {
        this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear();
      }
      _getSvgFromConfig(e) {
        return e.svgText ? qt(Xx(this._svgElementFromConfig(e))) : this._loadSvgIconFromConfig(e).pipe(kt((n) => Xx(n)));
      }
      _getSvgFromIconSetConfigs(e, n) {
        let r = this._extractIconWithNameFromAnySet(e, n);
        if (r) return qt(r);
        let o = n.filter((s) => !s.svgText).map((s) => this._loadSvgIconSetFromConfig(s).pipe(O_((a) => {
          let c = `Loading icon set URL: ${this._sanitizer.sanitize(Dr.RESOURCE_URL, s.url)} failed: ${a.message}`;
          return this._errorHandler.handleError(new Error(c)), qt(null);
        })));
        return Pp(o).pipe(kt(() => {
          let s = this._extractIconWithNameFromAnySet(e, n);
          if (!s) throw AU(e);
          return s;
        }));
      }
      _extractIconWithNameFromAnySet(e, n) {
        for (let r = n.length - 1; r >= 0; r--) {
          let o = n[r];
          if (o.svgText && o.svgText.toString().indexOf(e) > -1) {
            let s = this._svgElementFromConfig(o), a = this._extractSvgIconFromSet(s, e, o.options);
            if (a) return a;
          }
        }
        return null;
      }
      _loadSvgIconFromConfig(e) {
        return this._fetchIcon(e).pipe(Wi((n) => e.svgText = n), kt(() => this._svgElementFromConfig(e)));
      }
      _loadSvgIconSetFromConfig(e) {
        return e.svgText ? qt(null) : this._fetchIcon(e).pipe(Wi((n) => e.svgText = n));
      }
      _extractSvgIconFromSet(e, n, r) {
        let o = e.querySelector(`[id="${n}"]`);
        if (!o) return null;
        let s = o.cloneNode(true);
        if (s.removeAttribute("id"), s.nodeName.toLowerCase() === "svg") return this._setSvgAttributes(s, r);
        if (s.nodeName.toLowerCase() === "symbol") return this._setSvgAttributes(this._toSvgElement(s), r);
        let a = this._svgElementFromString(Ug("<svg></svg>"));
        return a.appendChild(s), this._setSvgAttributes(a, r);
      }
      _svgElementFromString(e) {
        let n = this._document.createElement("DIV");
        n.innerHTML = e;
        let r = n.querySelector("svg");
        if (!r) throw Error("<svg> tag not found");
        return r;
      }
      _toSvgElement(e) {
        let n = this._svgElementFromString(Ug("<svg></svg>")), r = e.attributes;
        for (let o = 0; o < r.length; o++) {
          let { name: s, value: a } = r[o];
          s !== "id" && n.setAttribute(s, a);
        }
        for (let o = 0; o < e.childNodes.length; o++) e.childNodes[o].nodeType === this._document.ELEMENT_NODE && n.appendChild(e.childNodes[o].cloneNode(true));
        return n;
      }
      _setSvgAttributes(e, n) {
        return e.setAttribute("fit", ""), e.setAttribute("height", "100%"), e.setAttribute("width", "100%"), e.setAttribute("preserveAspectRatio", "xMidYMid meet"), e.setAttribute("focusable", "false"), n && n.viewBox && e.setAttribute("viewBox", n.viewBox), e;
      }
      _fetchIcon(e) {
        let { url: n, options: r } = e, o = r?.withCredentials ?? false;
        if (!this._httpClient) throw ise();
        if (n == null) throw Error(`Cannot fetch icon from URL "${n}".`);
        let s = this._sanitizer.sanitize(Dr.RESOURCE_URL, n);
        if (!s) throw NU(n);
        let a = this._inProgressUrlFetches.get(s);
        if (a) return a;
        let l = this._httpClient.get(s, { responseType: "text", withCredentials: o }).pipe(kt((c) => Ug(c)), N_(() => this._inProgressUrlFetches.delete(s)), Op());
        return this._inProgressUrlFetches.set(s, l), l;
      }
      _addSvgIconConfig(e, n, r) {
        return this._svgIconConfigs.set(LU(e, n), r), this;
      }
      _addSvgIconSetConfig(e, n) {
        let r = this._iconSetConfigs.get(e);
        return r ? r.push(n) : this._iconSetConfigs.set(e, [n]), this;
      }
      _svgElementFromConfig(e) {
        if (!e.svgElement) {
          let n = this._svgElementFromString(e.svgText);
          this._setSvgAttributes(n, e.options), e.svgElement = n;
        }
        return e.svgElement;
      }
      _getIconConfigFromResolvers(e, n) {
        for (let r = 0; r < this._resolvers.length; r++) {
          let o = this._resolvers[r](n, e);
          if (o) return ose(o) ? new Ua(o.url, null, o.options) : new Ua(o, null);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(hk, 8), Ze(YM), Ze(yt, 8), Ze(Ir));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function Xx(i59) {
    return i59.cloneNode(true);
  }
  function LU(i59, t) {
    return i59 + ":" + t;
  }
  function ose(i59) {
    return !!(i59.url && i59.options);
  }
  var sse = new Ee("MAT_ICON_DEFAULT_OPTIONS");
  var ase = new Ee("mat-icon-location", { providedIn: "root", factory: lse });
  function lse() {
    let i59 = M(yt), t = i59 ? i59.location : null;
    return { getPathname: () => t ? t.pathname + t.search : "" };
  }
  var FU = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"];
  var cse = FU.map((i59) => `[${i59}]`).join(", ");
  var dse = /^url\(['"]?#(.*?)['"]?\)$/;
  var St = (() => {
    class i59 {
      _elementRef = M(He);
      _iconRegistry = M(rse);
      _location = M(ase);
      _errorHandler = M(Ir);
      _defaultColor;
      get color() {
        return this._color || this._defaultColor;
      }
      set color(e) {
        this._color = e;
      }
      _color;
      inline = false;
      get svgIcon() {
        return this._svgIcon;
      }
      set svgIcon(e) {
        e !== this._svgIcon && (e ? this._updateSvgIcon(e) : this._svgIcon && this._clearSvgElement(), this._svgIcon = e);
      }
      _svgIcon;
      get fontSet() {
        return this._fontSet;
      }
      set fontSet(e) {
        let n = this._cleanupFontValue(e);
        n !== this._fontSet && (this._fontSet = n, this._updateFontIconClasses());
      }
      _fontSet;
      get fontIcon() {
        return this._fontIcon;
      }
      set fontIcon(e) {
        let n = this._cleanupFontValue(e);
        n !== this._fontIcon && (this._fontIcon = n, this._updateFontIconClasses());
      }
      _fontIcon;
      _previousFontSetClass = [];
      _previousFontIconClass;
      _svgName;
      _svgNamespace;
      _previousPath;
      _elementsWithExternalReferences;
      _currentIconFetch = Rt.EMPTY;
      constructor() {
        let e = M(new Tr("aria-hidden"), { optional: true }), n = M(sse, { optional: true });
        n && (n.color && (this.color = this._defaultColor = n.color), n.fontSet && (this.fontSet = n.fontSet)), e || this._elementRef.nativeElement.setAttribute("aria-hidden", "true");
      }
      _splitIconName(e) {
        if (!e) return ["", ""];
        let n = e.split(":");
        switch (n.length) {
          case 1:
            return ["", n[0]];
          case 2:
            return n;
          default:
            throw Error(`Invalid icon name: "${e}"`);
        }
      }
      ngOnInit() {
        this._updateFontIconClasses();
      }
      ngAfterViewChecked() {
        let e = this._elementsWithExternalReferences;
        if (e && e.size) {
          let n = this._location.getPathname();
          n !== this._previousPath && (this._previousPath = n, this._prependPathToReferences(n));
        }
      }
      ngOnDestroy() {
        this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear();
      }
      _usingFontIcon() {
        return !this.svgIcon;
      }
      _setSvgElement(e) {
        this._clearSvgElement();
        let n = this._location.getPathname();
        this._previousPath = n, this._cacheChildrenWithExternalReferences(e), this._prependPathToReferences(n), this._elementRef.nativeElement.appendChild(e);
      }
      _clearSvgElement() {
        let e = this._elementRef.nativeElement, n = e.childNodes.length;
        for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); n--; ) {
          let r = e.childNodes[n];
          (r.nodeType !== 1 || r.nodeName.toLowerCase() === "svg") && r.remove();
        }
      }
      _updateFontIconClasses() {
        if (!this._usingFontIcon()) return;
        let e = this._elementRef.nativeElement, n = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter((r) => r.length > 0);
        this._previousFontSetClass.forEach((r) => e.classList.remove(r)), n.forEach((r) => e.classList.add(r)), this._previousFontSetClass = n, this.fontIcon !== this._previousFontIconClass && !n.includes("mat-ligature-font") && (this._previousFontIconClass && e.classList.remove(this._previousFontIconClass), this.fontIcon && e.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon);
      }
      _cleanupFontValue(e) {
        return typeof e == "string" ? e.trim().split(" ")[0] : e;
      }
      _prependPathToReferences(e) {
        let n = this._elementsWithExternalReferences;
        n && n.forEach((r, o) => {
          r.forEach((s) => {
            o.setAttribute(s.name, `url('${e}#${s.value}')`);
          });
        });
      }
      _cacheChildrenWithExternalReferences(e) {
        let n = e.querySelectorAll(cse), r = this._elementsWithExternalReferences = this._elementsWithExternalReferences || /* @__PURE__ */ new Map();
        for (let o = 0; o < n.length; o++) FU.forEach((s) => {
          let a = n[o], l = a.getAttribute(s), c = l ? l.match(dse) : null;
          if (c) {
            let d = r.get(a);
            d || (d = [], r.set(a, d)), d.push({ name: s, value: c[1] });
          }
        });
      }
      _updateSvgIcon(e) {
        if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), e) {
          let [n, r] = this._splitIconName(e);
          n && (this._svgNamespace = n), r && (this._svgName = r), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(r, n).pipe(On(1)).subscribe((o) => this._setSvgElement(o), (o) => {
            let s = `Error retrieving icon ${n}:${r}! ${o.message}`;
            this._errorHandler.handleError(new Error(s));
          });
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 10, hostBindings: function(n, r) {
        n & 2 && (Ke("data-mat-icon-type", r._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", r._svgName || r.fontIcon)("data-mat-icon-namespace", r._svgNamespace || r.fontSet)("fontIcon", r._usingFontIcon() ? r.fontIcon : null), io(r.color ? "mat-" + r.color : ""), ye("mat-icon-inline", r.inline)("mat-icon-no-color", r.color !== "primary" && r.color !== "accent" && r.color !== "warn"));
      }, inputs: { color: "color", inline: [2, "inline", "inline", tt], svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [on], ngContentSelectors: tse, decls: 1, vars: 0, template: function(n, r) {
        n & 1 && (Tn(), zt(0));
      }, styles: ["mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var vt = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt, Yt] });
    }
    return i59;
  })();
  var use = ["mat-menu-item", ""];
  var hse = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"];
  var pse = ["mat-icon, [matMenuItemIcon]", "*"];
  function fse(i59, t) {
    i59 & 1 && (to(), b(0, "svg", 2), ae(1, "polygon", 3), x());
  }
  var mse = ["*"];
  function gse(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 0), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.closed.emit("click"));
      })("animationstart", function(r) {
        q(e);
        let o = T();
        return Y(o._onAnimationStart(r.animationName));
      })("animationend", function(r) {
        q(e);
        let o = T();
        return Y(o._onAnimationDone(r.animationName));
      })("animationcancel", function(r) {
        q(e);
        let o = T();
        return Y(o._onAnimationDone(r.animationName));
      }), b(1, "div", 1), zt(2), x()();
    }
    if (i59 & 2) {
      let e = T();
      io(e._classList), ye("mat-menu-panel-animations-disabled", e._animationsDisabled)("mat-menu-panel-exit-animation", e._panelAnimationState === "void")("mat-menu-panel-animating", e._isAnimating), U("id", e.panelId), Ke("aria-label", e.ariaLabel || null)("aria-labelledby", e.ariaLabelledby || null)("aria-describedby", e.ariaDescribedby || null);
    }
  }
  var TD = new Ee("MAT_MENU_PANEL");
  var ED = (() => {
    class i59 {
      _elementRef = M(He);
      _document = M(yt);
      _focusMonitor = M(so);
      _parentMenu = M(TD, { optional: true });
      _changeDetectorRef = M(Ge);
      role = "menuitem";
      disabled = false;
      disableRipple = false;
      _hovered = new we();
      _focused = new we();
      _highlighted = false;
      _triggersSubmenu = false;
      constructor() {
        M(mi).load(ts), this._parentMenu?.addItem?.(this);
      }
      focus(e, n) {
        this._focusMonitor && e ? this._focusMonitor.focusVia(this._getHostElement(), e, n) : this._getHostElement().focus(n), this._focused.next(this);
      }
      ngAfterViewInit() {
        this._focusMonitor && this._focusMonitor.monitor(this._elementRef, false);
      }
      ngOnDestroy() {
        this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete();
      }
      _getTabIndex() {
        return this.disabled ? "-1" : "0";
      }
      _getHostElement() {
        return this._elementRef.nativeElement;
      }
      _checkDisabled(e) {
        this.disabled && (e.preventDefault(), e.stopPropagation());
      }
      _handleMouseEnter() {
        this._hovered.next(this);
      }
      getLabel() {
        let e = this._elementRef.nativeElement.cloneNode(true), n = e.querySelectorAll("mat-icon, .material-icons");
        for (let r = 0; r < n.length; r++) n[r].remove();
        return e.textContent?.trim() || "";
      }
      _setHighlighted(e) {
        this._highlighted = e, this._changeDetectorRef.markForCheck();
      }
      _setTriggersSubmenu(e) {
        this._triggersSubmenu = e, this._changeDetectorRef.markForCheck();
      }
      _hasFocus() {
        return this._document && this._document.activeElement === this._getHostElement();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["", "mat-menu-item", ""]], hostAttrs: [1, "mat-mdc-menu-item", "mat-focus-indicator"], hostVars: 8, hostBindings: function(n, r) {
        n & 1 && Z("click", function(s) {
          return r._checkDisabled(s);
        })("mouseenter", function() {
          return r._handleMouseEnter();
        }), n & 2 && (Ke("role", r.role)("tabindex", r._getTabIndex())("aria-disabled", r.disabled)("disabled", r.disabled || null), ye("mat-mdc-menu-item-highlighted", r._highlighted)("mat-mdc-menu-item-submenu-trigger", r._triggersSubmenu));
      }, inputs: { role: "role", disabled: [2, "disabled", "disabled", tt], disableRipple: [2, "disableRipple", "disableRipple", tt] }, exportAs: ["matMenuItem"], features: [on], attrs: use, ngContentSelectors: pse, decls: 5, vars: 3, consts: [[1, "mat-mdc-menu-item-text"], ["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"], ["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"], ["points", "0,0 5,5 0,10"]], template: function(n, r) {
        n & 1 && (Tn(hse), zt(0), b(1, "span", 0), zt(2, 1), x(), ae(3, "div", 1), X(4, fse, 2, 0, ":svg:svg", 2)), n & 2 && (C(3), U("matRippleDisabled", r.disableRipple || r.disabled)("matRippleTrigger", r._getHostElement()), C(), he(r._triggersSubmenu ? 4 : -1));
      }, dependencies: [ba], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var _se = new Ee("MatMenuContent");
  var vse = new Ee("mat-menu-default-options", { providedIn: "root", factory: yse });
  function yse() {
    return { overlapTrigger: false, xPosition: "after", yPosition: "below", backdropClass: "cdk-overlay-transparent-backdrop" };
  }
  var MD = "_mat-menu-enter";
  var Zx = "_mat-menu-exit";
  var $s = (() => {
    class i59 {
      _elementRef = M(He);
      _changeDetectorRef = M(Ge);
      _injector = M(mt);
      _keyManager;
      _xPosition;
      _yPosition;
      _firstItemFocusRef;
      _exitFallbackTimeout;
      _animationsDisabled;
      _allItems;
      _directDescendantItems = new Ni();
      _classList = {};
      _panelAnimationState = "void";
      _animationDone = new we();
      _isAnimating = false;
      parentMenu;
      direction;
      overlayPanelClass;
      backdropClass;
      ariaLabel;
      ariaLabelledby;
      ariaDescribedby;
      get xPosition() {
        return this._xPosition;
      }
      set xPosition(e) {
        this._xPosition = e, this.setPositionClasses();
      }
      get yPosition() {
        return this._yPosition;
      }
      set yPosition(e) {
        this._yPosition = e, this.setPositionClasses();
      }
      templateRef;
      items;
      lazyContent;
      overlapTrigger;
      hasBackdrop;
      set panelClass(e) {
        let n = this._previousPanelClass, r = le({}, this._classList);
        n && n.length && n.split(" ").forEach((o) => {
          r[o] = false;
        }), this._previousPanelClass = e, e && e.length && (e.split(" ").forEach((o) => {
          r[o] = true;
        }), this._elementRef.nativeElement.className = ""), this._classList = r;
      }
      _previousPanelClass;
      get classList() {
        return this.panelClass;
      }
      set classList(e) {
        this.panelClass = e;
      }
      closed = new Ue();
      close = this.closed;
      panelId = M(kn).getId("mat-menu-panel-");
      constructor() {
        let e = M(vse);
        this.overlayPanelClass = e.overlayPanelClass || "", this._xPosition = e.xPosition, this._yPosition = e.yPosition, this.backdropClass = e.backdropClass, this.overlapTrigger = e.overlapTrigger, this.hasBackdrop = e.hasBackdrop, this._animationsDisabled = M(An, { optional: true }) === "NoopAnimations";
      }
      ngOnInit() {
        this.setPositionClasses();
      }
      ngAfterContentInit() {
        this._updateDirectDescendants(), this._keyManager = new ab(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(), this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe(ei(this._directDescendantItems), Ai((e) => Jn(...e.map((n) => n._focused)))).subscribe((e) => this._keyManager.updateActiveItem(e)), this._directDescendantItems.changes.subscribe((e) => {
          let n = this._keyManager;
          if (this._panelAnimationState === "enter" && n.activeItem?._hasFocus()) {
            let r = e.toArray(), o = Math.max(0, Math.min(r.length - 1, n.activeItemIndex || 0));
            r[o] && !r[o].disabled ? n.setActiveItem(o) : n.setNextItemActive();
          }
        });
      }
      ngOnDestroy() {
        this._keyManager?.destroy(), this._directDescendantItems.destroy(), this.closed.complete(), this._firstItemFocusRef?.destroy(), clearTimeout(this._exitFallbackTimeout);
      }
      _hovered() {
        return this._directDescendantItems.changes.pipe(ei(this._directDescendantItems), Ai((n) => Jn(...n.map((r) => r._hovered))));
      }
      addItem(e) {
      }
      removeItem(e) {
      }
      _handleKeydown(e) {
        let n = e.keyCode, r = this._keyManager;
        switch (n) {
          case 27:
            Ki(e) || (e.preventDefault(), this.closed.emit("keydown"));
            break;
          case 37:
            this.parentMenu && this.direction === "ltr" && this.closed.emit("keydown");
            break;
          case 39:
            this.parentMenu && this.direction === "rtl" && this.closed.emit("keydown");
            break;
          default:
            (n === 38 || n === 40) && r.setFocusOrigin("keyboard"), r.onKeydown(e);
            return;
        }
      }
      focusFirstItem(e = "program") {
        this._firstItemFocusRef?.destroy(), this._firstItemFocusRef = Yi(() => {
          let n = this._resolvePanel();
          if (!n || !n.contains(document.activeElement)) {
            let r = this._keyManager;
            r.setFocusOrigin(e).setFirstItemActive(), !r.activeItem && n && n.focus();
          }
        }, { injector: this._injector });
      }
      resetActiveItem() {
        this._keyManager.setActiveItem(-1);
      }
      setElevation(e) {
      }
      setPositionClasses(e = this.xPosition, n = this.yPosition) {
        this._classList = xt(le({}, this._classList), { "mat-menu-before": e === "before", "mat-menu-after": e === "after", "mat-menu-above": n === "above", "mat-menu-below": n === "below" }), this._changeDetectorRef.markForCheck();
      }
      _onAnimationDone(e) {
        let n = e === Zx;
        (n || e === MD) && (n && (clearTimeout(this._exitFallbackTimeout), this._exitFallbackTimeout = void 0), this._animationDone.next(n ? "void" : "enter"), this._isAnimating = false);
      }
      _onAnimationStart(e) {
        (e === MD || e === Zx) && (this._isAnimating = true);
      }
      _setIsOpen(e) {
        if (this._panelAnimationState = e ? "enter" : "void", e) {
          if (this._keyManager.activeItemIndex === 0) {
            let n = this._resolvePanel();
            n && (n.scrollTop = 0);
          }
        } else this._animationsDisabled || (this._exitFallbackTimeout = setTimeout(() => this._onAnimationDone(Zx), 200));
        this._animationsDisabled && setTimeout(() => {
          this._onAnimationDone(e ? MD : Zx);
        }), this._changeDetectorRef.markForCheck();
      }
      _updateDirectDescendants() {
        this._allItems.changes.pipe(ei(this._allItems)).subscribe((e) => {
          this._directDescendantItems.reset(e.filter((n) => n._parentMenu === this)), this._directDescendantItems.notifyOnChanges();
        });
      }
      _resolvePanel() {
        let e = null;
        return this._directDescendantItems.length && (e = this._directDescendantItems.first._getHostElement().closest('[role="menu"]')), e;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-menu"]], contentQueries: function(n, r, o) {
        if (n & 1 && (Xi(o, _se, 5), Xi(o, ED, 5), Xi(o, ED, 4)), n & 2) {
          let s;
          Ie(s = De()) && (r.lazyContent = s.first), Ie(s = De()) && (r._allItems = s), Ie(s = De()) && (r.items = s);
        }
      }, viewQuery: function(n, r) {
        if (n & 1 && Fe(ni, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.templateRef = o.first);
        }
      }, hostVars: 3, hostBindings: function(n, r) {
        n & 2 && Ke("aria-label", null)("aria-labelledby", null)("aria-describedby", null);
      }, inputs: { backdropClass: "backdropClass", ariaLabel: [0, "aria-label", "ariaLabel"], ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"], ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"], xPosition: "xPosition", yPosition: "yPosition", overlapTrigger: [2, "overlapTrigger", "overlapTrigger", tt], hasBackdrop: [2, "hasBackdrop", "hasBackdrop", (e) => e == null ? null : tt(e)], panelClass: [0, "class", "panelClass"], classList: "classList" }, outputs: { closed: "closed", close: "close" }, exportAs: ["matMenu"], features: [Bt([{ provide: TD, useExisting: i59 }]), on], ngContentSelectors: mse, decls: 1, vars: 0, consts: [["tabindex", "-1", "role", "menu", 1, "mat-mdc-menu-panel", 3, "click", "animationstart", "animationend", "animationcancel", "id"], [1, "mat-mdc-menu-content"]], template: function(n, r) {
        n & 1 && (Tn(), X(0, gse, 3, 12, "ng-template"));
      }, styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;outline:0}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mat-mdc-menu-item-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;flex:1;white-space:normal;font-family:var(--mat-menu-item-label-text-font, var(--mat-sys-label-large-font));line-height:var(--mat-menu-item-label-text-line-height, var(--mat-sys-label-large-line-height));font-size:var(--mat-menu-item-label-text-size, var(--mat-sys-label-large-size));letter-spacing:var(--mat-menu-item-label-text-tracking, var(--mat-sys-label-large-tracking));font-weight:var(--mat-menu-item-label-text-weight, var(--mat-sys-label-large-weight))}@keyframes _mat-menu-enter{from{opacity:0;transform:scale(0.8)}to{opacity:1;transform:none}}@keyframes _mat-menu-exit{from{opacity:1}to{opacity:0}}.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;box-sizing:border-box;outline:0;animation:_mat-menu-enter 120ms cubic-bezier(0, 0, 0.2, 1);border-radius:var(--mat-menu-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mat-menu-container-color, var(--mat-sys-surface-container));box-shadow:var(--mat-menu-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12));will-change:transform,opacity}.mat-mdc-menu-panel.mat-menu-panel-exit-animation{animation:_mat-menu-exit 100ms 25ms linear forwards}.mat-mdc-menu-panel.mat-menu-panel-animations-disabled{animation:none}.mat-mdc-menu-panel.mat-menu-panel-animating{pointer-events:none}.mat-mdc-menu-panel.mat-menu-panel-animating:has(.mat-mdc-menu-content:empty){display:none}@media(forced-colors: active){.mat-mdc-menu-panel{outline:solid 1px}}.mat-mdc-menu-panel .mat-divider{color:var(--mat-menu-divider-color, var(--mat-sys-surface-variant));margin-bottom:var(--mat-menu-divider-bottom-spacing, 8px);margin-top:var(--mat-menu-divider-top-spacing, 8px)}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px;padding-left:var(--mat-menu-item-leading-spacing, 12px);padding-right:var(--mat-menu-item-trailing-spacing, 12px);-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-menu-item::-moz-focus-inner{border:0}[dir=rtl] .mat-mdc-menu-item{padding-left:var(--mat-menu-item-trailing-spacing, 12px);padding-right:var(--mat-menu-item-leading-spacing, 12px)}.mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-leading-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-trailing-spacing, 12px)}[dir=rtl] .mat-mdc-menu-item:has(.material-icons,mat-icon,[matButtonIcon]){padding-left:var(--mat-menu-item-with-icon-trailing-spacing, 12px);padding-right:var(--mat-menu-item-with-icon-leading-spacing, 12px)}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color, var(--mat-sys-on-surface))}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item:focus{outline:0}.mat-mdc-menu-item .mat-icon{flex-shrink:0;margin-right:var(--mat-menu-item-spacing, 12px);height:var(--mat-menu-item-icon-size, 24px);width:var(--mat-menu-item-icon-size, 24px)}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:var(--mat-menu-item-spacing, 12px)}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-hover-state-layer-opacity) * 100%), transparent))}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color, color-mix(in srgb, var(--mat-sys-on-surface) calc(var(--mat-sys-focus-state-layer-opacity) * 100%), transparent))}@media(forced-colors: active){.mat-mdc-menu-item{margin-top:1px}}.mat-mdc-menu-submenu-icon{width:var(--mat-menu-item-icon-size, 24px);height:10px;fill:currentColor;padding-left:var(--mat-menu-item-spacing, 12px)}[dir=rtl] .mat-mdc-menu-submenu-icon{padding-right:var(--mat-menu-item-spacing, 12px);padding-left:0}[dir=rtl] .mat-mdc-menu-submenu-icon polygon{transform:scaleX(-1);transform-origin:center}@media(forced-colors: active){.mat-mdc-menu-submenu-icon{fill:CanvasText}}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var VU = new Ee("mat-menu-scroll-strategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.reposition();
  } });
  function bse(i59) {
    return () => i59.scrollStrategies.reposition();
  }
  var xse = { provide: VU, deps: [fn], useFactory: bse };
  var BU = Or({ passive: true });
  var Gg = /* @__PURE__ */ new WeakMap();
  var cp = (() => {
    class i59 {
      _overlay = M(fn);
      _element = M(He);
      _viewContainerRef = M(un);
      _menuItemInstance = M(ED, { optional: true, self: true });
      _dir = M(_i, { optional: true });
      _focusMonitor = M(so);
      _ngZone = M(We);
      _scrollStrategy = M(VU);
      _changeDetectorRef = M(Ge);
      _portal;
      _overlayRef = null;
      _menuOpen = false;
      _closingActionsSubscription = Rt.EMPTY;
      _hoverSubscription = Rt.EMPTY;
      _menuCloseSubscription = Rt.EMPTY;
      _pendingRemoval;
      _parentMaterialMenu;
      _parentInnerPadding;
      _handleTouchStart = (e) => {
        Hc(e) || (this._openedBy = "touch");
      };
      _openedBy = void 0;
      get _deprecatedMatMenuTriggerFor() {
        return this.menu;
      }
      set _deprecatedMatMenuTriggerFor(e) {
        this.menu = e;
      }
      get menu() {
        return this._menu;
      }
      set menu(e) {
        e !== this._menu && (this._menu = e, this._menuCloseSubscription.unsubscribe(), e && (this._parentMaterialMenu, this._menuCloseSubscription = e.close.subscribe((n) => {
          this._destroyMenu(n), (n === "click" || n === "tab") && this._parentMaterialMenu && this._parentMaterialMenu.closed.emit(n);
        })), this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu()));
      }
      _menu;
      menuData;
      restoreFocus = true;
      menuOpened = new Ue();
      onMenuOpen = this.menuOpened;
      menuClosed = new Ue();
      onMenuClose = this.menuClosed;
      constructor() {
        let e = M(TD, { optional: true });
        this._parentMaterialMenu = e instanceof $s ? e : void 0, this._element.nativeElement.addEventListener("touchstart", this._handleTouchStart, BU);
      }
      ngAfterContentInit() {
        this._handleHover();
      }
      ngOnDestroy() {
        this.menu && this._ownsMenu(this.menu) && Gg.delete(this.menu), this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, BU), this._pendingRemoval?.unsubscribe(), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe(), this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null);
      }
      get menuOpen() {
        return this._menuOpen;
      }
      get dir() {
        return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
      }
      triggersSubmenu() {
        return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu);
      }
      toggleMenu() {
        return this._menuOpen ? this.closeMenu() : this.openMenu();
      }
      openMenu() {
        let e = this.menu;
        if (this._menuOpen || !e) return;
        this._pendingRemoval?.unsubscribe();
        let n = Gg.get(e);
        Gg.set(e, this), n && n !== this && n.closeMenu();
        let r = this._createOverlay(e), o = r.getConfig(), s = o.positionStrategy;
        this._setPosition(e, s), o.hasBackdrop = e.hasBackdrop == null ? !this.triggersSubmenu() : e.hasBackdrop, r.hasAttached() || (r.attach(this._getPortal(e)), e.lazyContent?.attach(this.menuData)), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), e.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0, e.direction = this.dir, e.focusFirstItem(this._openedBy || "program"), this._setIsMenuOpen(true), e instanceof $s && (e._setIsOpen(true), e._directDescendantItems.changes.pipe(Je(e.close)).subscribe(() => {
          s.withLockedPosition(false).reapplyLastPosition(), s.withLockedPosition(true);
        }));
      }
      closeMenu() {
        this.menu?.close.emit();
      }
      focus(e, n) {
        this._focusMonitor && e ? this._focusMonitor.focusVia(this._element, e, n) : this._element.nativeElement.focus(n);
      }
      updatePosition() {
        this._overlayRef?.updatePosition();
      }
      _destroyMenu(e) {
        let n = this._overlayRef, r = this._menu;
        !n || !this.menuOpen || (this._closingActionsSubscription.unsubscribe(), this._pendingRemoval?.unsubscribe(), r instanceof $s && this._ownsMenu(r) ? (this._pendingRemoval = r._animationDone.pipe(On(1)).subscribe(() => {
          n.detach(), r.lazyContent?.detach();
        }), r._setIsOpen(false)) : (n.detach(), r?.lazyContent?.detach()), r && this._ownsMenu(r) && Gg.delete(r), this.restoreFocus && (e === "keydown" || !this._openedBy || !this.triggersSubmenu()) && this.focus(this._openedBy), this._openedBy = void 0, this._setIsMenuOpen(false));
      }
      _setIsMenuOpen(e) {
        e !== this._menuOpen && (this._menuOpen = e, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && this._menuItemInstance._setHighlighted(e), this._changeDetectorRef.markForCheck());
      }
      _createOverlay(e) {
        if (!this._overlayRef) {
          let n = this._getOverlayConfig(e);
          this._subscribeToPositions(e, n.positionStrategy), this._overlayRef = this._overlay.create(n), this._overlayRef.keydownEvents().subscribe((r) => {
            this.menu instanceof $s && this.menu._handleKeydown(r);
          });
        }
        return this._overlayRef;
      }
      _getOverlayConfig(e) {
        return new Gi({ positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"), backdropClass: e.backdropClass || "cdk-overlay-transparent-backdrop", panelClass: e.overlayPanelClass, scrollStrategy: this._scrollStrategy(), direction: this._dir || "ltr" });
      }
      _subscribeToPositions(e, n) {
        e.setPositionClasses && n.positionChanges.subscribe((r) => {
          this._ngZone.run(() => {
            let o = r.connectionPair.overlayX === "start" ? "after" : "before", s = r.connectionPair.overlayY === "top" ? "below" : "above";
            e.setPositionClasses(o, s);
          });
        });
      }
      _setPosition(e, n) {
        let [r, o] = e.xPosition === "before" ? ["end", "start"] : ["start", "end"], [s, a] = e.yPosition === "above" ? ["bottom", "top"] : ["top", "bottom"], [l, c] = [s, a], [d, u] = [r, o], h = 0;
        if (this.triggersSubmenu()) {
          if (u = r = e.xPosition === "before" ? "start" : "end", o = d = r === "end" ? "start" : "end", this._parentMaterialMenu) {
            if (this._parentInnerPadding == null) {
              let p = this._parentMaterialMenu.items.first;
              this._parentInnerPadding = p ? p._getHostElement().offsetTop : 0;
            }
            h = s === "bottom" ? this._parentInnerPadding : -this._parentInnerPadding;
          }
        } else e.overlapTrigger || (l = s === "top" ? "bottom" : "top", c = a === "top" ? "bottom" : "top");
        n.withPositions([{ originX: r, originY: l, overlayX: d, overlayY: s, offsetY: h }, { originX: o, originY: l, overlayX: u, overlayY: s, offsetY: h }, { originX: r, originY: c, overlayX: d, overlayY: a, offsetY: -h }, { originX: o, originY: c, overlayX: u, overlayY: a, offsetY: -h }]);
      }
      _menuClosingActions() {
        let e = this._overlayRef.backdropClick(), n = this._overlayRef.detachments(), r = this._parentMaterialMenu ? this._parentMaterialMenu.closed : qt(), o = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(En((s) => this._menuOpen && s !== this._menuItemInstance)) : qt();
        return Jn(e, r, o, n);
      }
      _handleMousedown(e) {
        Gc(e) || (this._openedBy = e.button === 0 ? "mouse" : void 0, this.triggersSubmenu() && e.preventDefault());
      }
      _handleKeydown(e) {
        let n = e.keyCode;
        (n === 13 || n === 32) && (this._openedBy = "keyboard"), this.triggersSubmenu() && (n === 39 && this.dir === "ltr" || n === 37 && this.dir === "rtl") && (this._openedBy = "keyboard", this.openMenu());
      }
      _handleClick(e) {
        this.triggersSubmenu() ? (e.stopPropagation(), this.openMenu()) : this.toggleMenu();
      }
      _handleHover() {
        this.triggersSubmenu() && this._parentMaterialMenu && (this._hoverSubscription = this._parentMaterialMenu._hovered().subscribe((e) => {
          e === this._menuItemInstance && !e.disabled && (this._openedBy = "mouse", this.openMenu());
        }));
      }
      _getPortal(e) {
        return (!this._portal || this._portal.templateRef !== e.templateRef) && (this._portal = new go(e.templateRef, this._viewContainerRef)), this._portal;
      }
      _ownsMenu(e) {
        return Gg.get(e) === this;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-menu-trigger-for", ""], ["", "matMenuTriggerFor", ""]], hostAttrs: [1, "mat-mdc-menu-trigger"], hostVars: 3, hostBindings: function(n, r) {
        n & 1 && Z("click", function(s) {
          return r._handleClick(s);
        })("mousedown", function(s) {
          return r._handleMousedown(s);
        })("keydown", function(s) {
          return r._handleKeydown(s);
        }), n & 2 && Ke("aria-haspopup", r.menu ? "menu" : null)("aria-expanded", r.menuOpen)("aria-controls", r.menuOpen ? r.menu.panelId : null);
      }, inputs: { _deprecatedMatMenuTriggerFor: [0, "mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"], menu: [0, "matMenuTriggerFor", "menu"], menuData: [0, "matMenuTriggerData", "menuData"], restoreFocus: [0, "matMenuTriggerRestoreFocus", "restoreFocus"] }, outputs: { menuOpened: "menuOpened", onMenuOpen: "onMenuOpen", menuClosed: "menuClosed", onMenuClose: "onMenuClose" }, exportAs: ["matMenuTrigger"] });
    }
    return i59;
  })();
  var Vl = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [xse], imports: [$c, Yt, ps, Hs, Yt] });
    }
    return i59;
  })();
  var zU = { transformMenu: ki("transformMenu", [Zi("void", _n({ opacity: 0, transform: "scale(0.8)" })), Yn("void => enter", oi("120ms cubic-bezier(0, 0, 0.2, 1)", _n({ opacity: 1, transform: "scale(1)" }))), Yn("* => void", oi("100ms 25ms linear", _n({ opacity: 0 })))]), fadeInItems: ki("fadeInItems", [Zi("showing", _n({ opacity: 1 })), Yn("void => *", [_n({ opacity: 0 }), oi("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) };
  var YBe = zU.fadeInItems;
  var XBe = zU.transformMenu;
  var wse = ["tooltip"];
  var HU = 20;
  var jU = new Ee("mat-tooltip-scroll-strategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.reposition({ scrollThrottle: HU });
  } });
  function Cse(i59) {
    return () => i59.scrollStrategies.reposition({ scrollThrottle: HU });
  }
  var Sse = { provide: jU, deps: [fn], useFactory: Cse };
  function Mse() {
    return { showDelay: 0, hideDelay: 0, touchendHideDelay: 1500 };
  }
  var Ese = new Ee("mat-tooltip-default-options", { providedIn: "root", factory: Mse });
  var UU = "tooltip-panel";
  var GU = Or({ passive: true });
  var Tse = 8;
  var Ise = 8;
  var Dse = 24;
  var Pse = 200;
  var $n = (() => {
    class i59 {
      _elementRef = M(He);
      _ngZone = M(We);
      _platform = M(Nn);
      _ariaDescriber = M(sL);
      _focusMonitor = M(so);
      _dir = M(_i);
      _injector = M(mt);
      _defaultOptions = M(Ese, { optional: true });
      _overlayRef;
      _tooltipInstance;
      _portal;
      _position = "below";
      _positionAtOrigin = false;
      _disabled = false;
      _tooltipClass;
      _viewInitialized = false;
      _pointerExitEventsInitialized = false;
      _tooltipComponent = Rse;
      _viewportMargin = 8;
      _currentPosition;
      _cssClassPrefix = "mat-mdc";
      _ariaDescriptionPending;
      _dirSubscribed = false;
      get position() {
        return this._position;
      }
      set position(e) {
        e !== this._position && (this._position = e, this._overlayRef && (this._updatePosition(this._overlayRef), this._tooltipInstance?.show(0), this._overlayRef.updatePosition()));
      }
      get positionAtOrigin() {
        return this._positionAtOrigin;
      }
      set positionAtOrigin(e) {
        this._positionAtOrigin = zf(e), this._detach(), this._overlayRef = null;
      }
      get disabled() {
        return this._disabled;
      }
      set disabled(e) {
        let n = zf(e);
        this._disabled !== n && (this._disabled = n, n ? this.hide(0) : this._setupPointerEnterEventsIfNeeded(), this._syncAriaDescription(this.message));
      }
      get showDelay() {
        return this._showDelay;
      }
      set showDelay(e) {
        this._showDelay = ya(e);
      }
      _showDelay;
      get hideDelay() {
        return this._hideDelay;
      }
      set hideDelay(e) {
        this._hideDelay = ya(e), this._tooltipInstance && (this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay);
      }
      _hideDelay;
      touchGestures = "auto";
      get message() {
        return this._message;
      }
      set message(e) {
        let n = this._message;
        this._message = e != null ? String(e).trim() : "", !this._message && this._isTooltipVisible() ? this.hide(0) : (this._setupPointerEnterEventsIfNeeded(), this._updateTooltipMessage()), this._syncAriaDescription(n);
      }
      _message = "";
      get tooltipClass() {
        return this._tooltipClass;
      }
      set tooltipClass(e) {
        this._tooltipClass = e, this._tooltipInstance && this._setTooltipClass(this._tooltipClass);
      }
      _passiveListeners = [];
      _touchstartTimeout = null;
      _destroyed = new we();
      _isDestroyed = false;
      constructor() {
        let e = this._defaultOptions;
        e && (this._showDelay = e.showDelay, this._hideDelay = e.hideDelay, e.position && (this.position = e.position), e.positionAtOrigin && (this.positionAtOrigin = e.positionAtOrigin), e.touchGestures && (this.touchGestures = e.touchGestures), e.tooltipClass && (this.tooltipClass = e.tooltipClass)), this._viewportMargin = Tse;
      }
      ngAfterViewInit() {
        this._viewInitialized = true, this._setupPointerEnterEventsIfNeeded(), this._focusMonitor.monitor(this._elementRef).pipe(Je(this._destroyed)).subscribe((e) => {
          e ? e === "keyboard" && this._ngZone.run(() => this.show()) : this._ngZone.run(() => this.hide(0));
        });
      }
      ngOnDestroy() {
        let e = this._elementRef.nativeElement;
        this._touchstartTimeout && clearTimeout(this._touchstartTimeout), this._overlayRef && (this._overlayRef.dispose(), this._tooltipInstance = null), this._passiveListeners.forEach(([n, r]) => {
          e.removeEventListener(n, r, GU);
        }), this._passiveListeners.length = 0, this._destroyed.next(), this._destroyed.complete(), this._isDestroyed = true, this._ariaDescriber.removeDescription(e, this.message, "tooltip"), this._focusMonitor.stopMonitoring(e);
      }
      show(e = this.showDelay, n) {
        if (this.disabled || !this.message || this._isTooltipVisible()) {
          this._tooltipInstance?._cancelPendingAnimations();
          return;
        }
        let r = this._createOverlay(n);
        this._detach(), this._portal = this._portal || new Ui(this._tooltipComponent, this._injector.get(un));
        let o = this._tooltipInstance = r.attach(this._portal).instance;
        o._triggerElement = this._elementRef.nativeElement, o._mouseLeaveHideDelay = this._hideDelay, o.afterHidden().pipe(Je(this._destroyed)).subscribe(() => this._detach()), this._setTooltipClass(this._tooltipClass), this._updateTooltipMessage(), o.show(e);
      }
      hide(e = this.hideDelay) {
        let n = this._tooltipInstance;
        n && (n.isVisible() ? n.hide(e) : (n._cancelPendingAnimations(), this._detach()));
      }
      toggle(e) {
        this._isTooltipVisible() ? this.hide() : this.show(void 0, e);
      }
      _isTooltipVisible() {
        return !!this._tooltipInstance && this._tooltipInstance.isVisible();
      }
      _createOverlay(e) {
        if (this._overlayRef) {
          let s = this._overlayRef.getConfig().positionStrategy;
          if ((!this.positionAtOrigin || !e) && s._origin instanceof He) return this._overlayRef;
          this._detach();
        }
        let n = this._injector.get(Ud).getAncestorScrollContainers(this._elementRef), r = this._injector.get(fn), o = r.position().flexibleConnectedTo(this.positionAtOrigin ? e || this._elementRef : this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(false).withViewportMargin(this._viewportMargin).withScrollableContainers(n);
        return o.positionChanges.pipe(Je(this._destroyed)).subscribe((s) => {
          this._updateCurrentPositionClass(s.connectionPair), this._tooltipInstance && s.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible() && this._ngZone.run(() => this.hide(0));
        }), this._overlayRef = r.create({ direction: this._dir, positionStrategy: o, panelClass: `${this._cssClassPrefix}-${UU}`, scrollStrategy: this._injector.get(jU)() }), this._updatePosition(this._overlayRef), this._overlayRef.detachments().pipe(Je(this._destroyed)).subscribe(() => this._detach()), this._overlayRef.outsidePointerEvents().pipe(Je(this._destroyed)).subscribe(() => this._tooltipInstance?._handleBodyInteraction()), this._overlayRef.keydownEvents().pipe(Je(this._destroyed)).subscribe((s) => {
          this._isTooltipVisible() && s.keyCode === 27 && !Ki(s) && (s.preventDefault(), s.stopPropagation(), this._ngZone.run(() => this.hide(0)));
        }), this._defaultOptions?.disableTooltipInteractivity && this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`), this._dirSubscribed || (this._dirSubscribed = true, this._dir.change.pipe(Je(this._destroyed)).subscribe(() => {
          this._overlayRef && this._updatePosition(this._overlayRef);
        })), this._overlayRef;
      }
      _detach() {
        this._overlayRef && this._overlayRef.hasAttached() && this._overlayRef.detach(), this._tooltipInstance = null;
      }
      _updatePosition(e) {
        let n = e.getConfig().positionStrategy, r = this._getOrigin(), o = this._getOverlayPosition();
        n.withPositions([this._addOffset(le(le({}, r.main), o.main)), this._addOffset(le(le({}, r.fallback), o.fallback))]);
      }
      _addOffset(e) {
        let n = Ise, r = !this._dir || this._dir.value == "ltr";
        return e.originY === "top" ? e.offsetY = -n : e.originY === "bottom" ? e.offsetY = n : e.originX === "start" ? e.offsetX = r ? -n : n : e.originX === "end" && (e.offsetX = r ? n : -n), e;
      }
      _getOrigin() {
        let e = !this._dir || this._dir.value == "ltr", n = this.position, r;
        n == "above" || n == "below" ? r = { originX: "center", originY: n == "above" ? "top" : "bottom" } : n == "before" || n == "left" && e || n == "right" && !e ? r = { originX: "start", originY: "center" } : (n == "after" || n == "right" && e || n == "left" && !e) && (r = { originX: "end", originY: "center" });
        let { x: o, y: s } = this._invertPosition(r.originX, r.originY);
        return { main: r, fallback: { originX: o, originY: s } };
      }
      _getOverlayPosition() {
        let e = !this._dir || this._dir.value == "ltr", n = this.position, r;
        n == "above" ? r = { overlayX: "center", overlayY: "bottom" } : n == "below" ? r = { overlayX: "center", overlayY: "top" } : n == "before" || n == "left" && e || n == "right" && !e ? r = { overlayX: "end", overlayY: "center" } : (n == "after" || n == "right" && e || n == "left" && !e) && (r = { overlayX: "start", overlayY: "center" });
        let { x: o, y: s } = this._invertPosition(r.overlayX, r.overlayY);
        return { main: r, fallback: { overlayX: o, overlayY: s } };
      }
      _updateTooltipMessage() {
        this._tooltipInstance && (this._tooltipInstance.message = this.message, this._tooltipInstance._markForCheck(), Yi(() => {
          this._tooltipInstance && this._overlayRef.updatePosition();
        }, { injector: this._injector }));
      }
      _setTooltipClass(e) {
        this._tooltipInstance && (this._tooltipInstance.tooltipClass = e, this._tooltipInstance._markForCheck());
      }
      _invertPosition(e, n) {
        return this.position === "above" || this.position === "below" ? n === "top" ? n = "bottom" : n === "bottom" && (n = "top") : e === "end" ? e = "start" : e === "start" && (e = "end"), { x: e, y: n };
      }
      _updateCurrentPositionClass(e) {
        let { overlayY: n, originX: r, originY: o } = e, s;
        if (n === "center" ? this._dir && this._dir.value === "rtl" ? s = r === "end" ? "left" : "right" : s = r === "start" ? "left" : "right" : s = n === "bottom" && o === "top" ? "above" : "below", s !== this._currentPosition) {
          let a = this._overlayRef;
          if (a) {
            let l = `${this._cssClassPrefix}-${UU}-`;
            a.removePanelClass(l + this._currentPosition), a.addPanelClass(l + s);
          }
          this._currentPosition = s;
        }
      }
      _setupPointerEnterEventsIfNeeded() {
        this._disabled || !this.message || !this._viewInitialized || this._passiveListeners.length || (this._platformSupportsMouseEvents() ? this._passiveListeners.push(["mouseenter", (e) => {
          this._setupPointerExitEventsIfNeeded();
          let n;
          e.x !== void 0 && e.y !== void 0 && (n = e), this.show(void 0, n);
        }]) : this.touchGestures !== "off" && (this._disableNativeGesturesIfNecessary(), this._passiveListeners.push(["touchstart", (e) => {
          let n = e.targetTouches?.[0], r = n ? { x: n.clientX, y: n.clientY } : void 0;
          this._setupPointerExitEventsIfNeeded(), this._touchstartTimeout && clearTimeout(this._touchstartTimeout);
          let o = 500;
          this._touchstartTimeout = setTimeout(() => {
            this._touchstartTimeout = null, this.show(void 0, r);
          }, this._defaultOptions?.touchLongPressShowDelay ?? o);
        }])), this._addListeners(this._passiveListeners));
      }
      _setupPointerExitEventsIfNeeded() {
        if (this._pointerExitEventsInitialized) return;
        this._pointerExitEventsInitialized = true;
        let e = [];
        if (this._platformSupportsMouseEvents()) e.push(["mouseleave", (n) => {
          let r = n.relatedTarget;
          (!r || !this._overlayRef?.overlayElement.contains(r)) && this.hide();
        }], ["wheel", (n) => this._wheelListener(n)]);
        else if (this.touchGestures !== "off") {
          this._disableNativeGesturesIfNecessary();
          let n = () => {
            this._touchstartTimeout && clearTimeout(this._touchstartTimeout), this.hide(this._defaultOptions?.touchendHideDelay);
          };
          e.push(["touchend", n], ["touchcancel", n]);
        }
        this._addListeners(e), this._passiveListeners.push(...e);
      }
      _addListeners(e) {
        e.forEach(([n, r]) => {
          this._elementRef.nativeElement.addEventListener(n, r, GU);
        });
      }
      _platformSupportsMouseEvents() {
        return !this._platform.IOS && !this._platform.ANDROID;
      }
      _wheelListener(e) {
        if (this._isTooltipVisible()) {
          let n = this._injector.get(yt).elementFromPoint(e.clientX, e.clientY), r = this._elementRef.nativeElement;
          n !== r && !r.contains(n) && this.hide();
        }
      }
      _disableNativeGesturesIfNecessary() {
        let e = this.touchGestures;
        if (e !== "off") {
          let n = this._elementRef.nativeElement, r = n.style;
          (e === "on" || n.nodeName !== "INPUT" && n.nodeName !== "TEXTAREA") && (r.userSelect = r.msUserSelect = r.webkitUserSelect = r.MozUserSelect = "none"), (e === "on" || !n.draggable) && (r.webkitUserDrag = "none"), r.touchAction = "none", r.webkitTapHighlightColor = "transparent";
        }
      }
      _syncAriaDescription(e) {
        this._ariaDescriptionPending || (this._ariaDescriptionPending = true, this._ariaDescriber.removeDescription(this._elementRef.nativeElement, e, "tooltip"), this._isDestroyed || Yi({ write: () => {
          this._ariaDescriptionPending = false, this.message && !this.disabled && this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, "tooltip");
        } }, { injector: this._injector }));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "matTooltip", ""]], hostAttrs: [1, "mat-mdc-tooltip-trigger"], hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("mat-mdc-tooltip-disabled", r.disabled);
      }, inputs: { position: [0, "matTooltipPosition", "position"], positionAtOrigin: [0, "matTooltipPositionAtOrigin", "positionAtOrigin"], disabled: [0, "matTooltipDisabled", "disabled"], showDelay: [0, "matTooltipShowDelay", "showDelay"], hideDelay: [0, "matTooltipHideDelay", "hideDelay"], touchGestures: [0, "matTooltipTouchGestures", "touchGestures"], message: [0, "matTooltip", "message"], tooltipClass: [0, "matTooltipClass", "tooltipClass"] }, exportAs: ["matTooltip"] });
    }
    return i59;
  })();
  var Rse = (() => {
    class i59 {
      _changeDetectorRef = M(Ge);
      _elementRef = M(He);
      _isMultiline = false;
      message;
      tooltipClass;
      _showTimeoutId;
      _hideTimeoutId;
      _triggerElement;
      _mouseLeaveHideDelay;
      _animationsDisabled;
      _tooltip;
      _closeOnInteraction = false;
      _isVisible = false;
      _onHide = new we();
      _showAnimation = "mat-mdc-tooltip-show";
      _hideAnimation = "mat-mdc-tooltip-hide";
      constructor() {
        let e = M(An, { optional: true });
        this._animationsDisabled = e === "NoopAnimations";
      }
      show(e) {
        this._hideTimeoutId != null && clearTimeout(this._hideTimeoutId), this._showTimeoutId = setTimeout(() => {
          this._toggleVisibility(true), this._showTimeoutId = void 0;
        }, e);
      }
      hide(e) {
        this._showTimeoutId != null && clearTimeout(this._showTimeoutId), this._hideTimeoutId = setTimeout(() => {
          this._toggleVisibility(false), this._hideTimeoutId = void 0;
        }, e);
      }
      afterHidden() {
        return this._onHide;
      }
      isVisible() {
        return this._isVisible;
      }
      ngOnDestroy() {
        this._cancelPendingAnimations(), this._onHide.complete(), this._triggerElement = null;
      }
      _handleBodyInteraction() {
        this._closeOnInteraction && this.hide(0);
      }
      _markForCheck() {
        this._changeDetectorRef.markForCheck();
      }
      _handleMouseLeave({ relatedTarget: e }) {
        (!e || !this._triggerElement.contains(e)) && (this.isVisible() ? this.hide(this._mouseLeaveHideDelay) : this._finalizeAnimation(false));
      }
      _onShow() {
        this._isMultiline = this._isTooltipMultiline(), this._markForCheck();
      }
      _isTooltipMultiline() {
        let e = this._elementRef.nativeElement.getBoundingClientRect();
        return e.height > Dse && e.width >= Pse;
      }
      _handleAnimationEnd({ animationName: e }) {
        (e === this._showAnimation || e === this._hideAnimation) && this._finalizeAnimation(e === this._showAnimation);
      }
      _cancelPendingAnimations() {
        this._showTimeoutId != null && clearTimeout(this._showTimeoutId), this._hideTimeoutId != null && clearTimeout(this._hideTimeoutId), this._showTimeoutId = this._hideTimeoutId = void 0;
      }
      _finalizeAnimation(e) {
        e ? this._closeOnInteraction = true : this.isVisible() || this._onHide.next();
      }
      _toggleVisibility(e) {
        let n = this._tooltip.nativeElement, r = this._showAnimation, o = this._hideAnimation;
        if (n.classList.remove(e ? o : r), n.classList.add(e ? r : o), this._isVisible !== e && (this._isVisible = e, this._changeDetectorRef.markForCheck()), e && !this._animationsDisabled && typeof getComputedStyle == "function") {
          let s = getComputedStyle(n);
          (s.getPropertyValue("animation-duration") === "0s" || s.getPropertyValue("animation-name") === "none") && (this._animationsDisabled = true);
        }
        e && this._onShow(), this._animationsDisabled && (n.classList.add("_mat-animation-noopable"), this._finalizeAnimation(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-tooltip-component"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(wse, 7), n & 2) {
          let o;
          Ie(o = De()) && (r._tooltip = o.first);
        }
      }, hostAttrs: ["aria-hidden", "true"], hostBindings: function(n, r) {
        n & 1 && Z("mouseleave", function(s) {
          return r._handleMouseLeave(s);
        });
      }, decls: 4, vars: 4, consts: [["tooltip", ""], [1, "mdc-tooltip", "mat-mdc-tooltip", 3, "animationend", "ngClass"], [1, "mat-mdc-tooltip-surface", "mdc-tooltip__surface"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 1, 0), Z("animationend", function(a) {
            return q(o), Y(r._handleAnimationEnd(a));
          }), b(2, "div", 2), D(3), x()();
        }
        n & 2 && (ye("mdc-tooltip--multiline", r._isMultiline), U("ngClass", r.tooltipClass), C(3), Qe(r.message));
      }, dependencies: [Xv], styles: ['.mat-mdc-tooltip{position:relative;transform:scale(0);display:inline-flex}.mat-mdc-tooltip::before{content:"";top:0;right:0;bottom:0;left:0;z-index:-1;position:absolute}.mat-mdc-tooltip-panel-below .mat-mdc-tooltip::before{top:-8px}.mat-mdc-tooltip-panel-above .mat-mdc-tooltip::before{bottom:-8px}.mat-mdc-tooltip-panel-right .mat-mdc-tooltip::before{left:-8px}.mat-mdc-tooltip-panel-left .mat-mdc-tooltip::before{right:-8px}.mat-mdc-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.mat-mdc-tooltip-surface{word-break:normal;overflow-wrap:anywhere;padding:4px 8px;min-width:40px;max-width:200px;min-height:24px;max-height:40vh;box-sizing:border-box;overflow:hidden;text-align:center;will-change:transform,opacity;background-color:var(--mdc-plain-tooltip-container-color, var(--mat-sys-inverse-surface));color:var(--mdc-plain-tooltip-supporting-text-color, var(--mat-sys-inverse-on-surface));border-radius:var(--mdc-plain-tooltip-container-shape, var(--mat-sys-corner-extra-small));font-family:var(--mdc-plain-tooltip-supporting-text-font, var(--mat-sys-body-small-font));font-size:var(--mdc-plain-tooltip-supporting-text-size, var(--mat-sys-body-small-size));font-weight:var(--mdc-plain-tooltip-supporting-text-weight, var(--mat-sys-body-small-weight));line-height:var(--mdc-plain-tooltip-supporting-text-line-height, var(--mat-sys-body-small-line-height));letter-spacing:var(--mdc-plain-tooltip-supporting-text-tracking, var(--mat-sys-body-small-tracking))}.mat-mdc-tooltip-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:left}[dir=rtl] .mdc-tooltip--multiline .mat-mdc-tooltip-surface{text-align:right}.mat-mdc-tooltip-panel{line-height:normal}.mat-mdc-tooltip-panel.mat-mdc-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-mdc-tooltip-show{0%{opacity:0;transform:scale(0.8)}100%{opacity:1;transform:scale(1)}}@keyframes mat-mdc-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(0.8)}}.mat-mdc-tooltip-show{animation:mat-mdc-tooltip-show 150ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-mdc-tooltip-hide{animation:mat-mdc-tooltip-hide 75ms cubic-bezier(0.4, 0, 1, 1) forwards}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var tn = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [Sse], imports: [hb, ps, Yt, Yt, Hs] });
    }
    return i59;
  })();
  var Ose = /^\s*(?!javascript:)(?:[\w+.-]+:|[^:/?#]*(?:[/?#]|$))/i;
  function Ase(i59) {
    let t = !Ose.test(i59);
    return t;
  }
  function Nse(i59) {
    if (!Ase(i59)) return i59;
  }
  function Ga(i59) {
    return Nse(i59);
  }
  function qs(i59, t) {
    let e = Ga(t);
    e !== void 0 && (i59.href = e);
  }
  var WU = globalThis.trustedTypes;
  function Zse(i59, t) {
    if (i59 & 1 && ae(0, "div", 1), i59 & 2) {
      let e = T();
      sn("top", e.top, "px")("left", e.left, "px")("width", e.width, "px")("height", e.height, "px")("border-color", e.borderColor)("background-color", e.bgColor);
    }
  }
  var qU = (() => {
    class i59 {
      changeDetectorRef;
      borderColor;
      bgColor;
      startX = -1;
      startY = -1;
      endX = -1;
      endY = -1;
      isMac = typeof navigator < "u" && /Macintosh/.test(navigator.userAgent);
      constructor(e) {
        this.changeDetectorRef = e;
      }
      start(e, n) {
        e.preventDefault(), e.stopPropagation(), this.startX = e.offsetX, this.startY = e.offsetY, this.endX = this.startX, this.endY = this.startY;
        let r = zn(document, "mousemove"), o = zn(window, "mouseup"), s = 0, a = 0;
        cr([r]).pipe(Je(o)).subscribe({ next: ([l]) => {
          s = l.offsetX - this.startX, a = l.offsetY - this.startY, this.endX = this.startX + s, this.endY = this.startY + a, this.changeDetectorRef.detectChanges();
        }, complete: () => {
          let l = Math.abs(s) < 5 && Math.abs(a) < 5;
          n(l, this.startX, this.startY, this.endX, this.endY), this.startX = -1, this.startY = -1, this.endX = -1, this.endY = -1, this.changeDetectorRef.detectChanges();
        } });
      }
      get top() {
        return Math.min(this.startY, this.endY);
      }
      get left() {
        return Math.min(this.startX, this.endX);
      }
      get width() {
        return Math.abs(this.endX - this.startX);
      }
      get height() {
        return Math.abs(this.endY - this.startY);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["drag-area"]], inputs: { borderColor: "borderColor", bgColor: "bgColor" }, decls: 1, vars: 1, consts: [[1, "container", 3, "top", "left", "width", "height", "border-color", "background-color"], [1, "container"]], template: function(n, r) {
        n & 1 && X(0, Zse, 1, 12, "div", 0), n & 2 && he(r.startX > 0 ? 0 : -1);
      }, dependencies: [et], styles: [`.container[_ngcontent-%COMP%]{position:absolute;z-index:5000;box-sizing:border-box;border-width:1px;border-style:solid;pointer-events:none}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var DD = class {
    dataNodes;
    expansionModel = new zd(true);
    trackBy;
    getLevel;
    isExpandable;
    getChildren;
    toggle(t) {
      this.expansionModel.toggle(this._trackByValue(t));
    }
    expand(t) {
      this.expansionModel.select(this._trackByValue(t));
    }
    collapse(t) {
      this.expansionModel.deselect(this._trackByValue(t));
    }
    isExpanded(t) {
      return this.expansionModel.isSelected(this._trackByValue(t));
    }
    toggleDescendants(t) {
      this.expansionModel.isSelected(this._trackByValue(t)) ? this.collapseDescendants(t) : this.expandDescendants(t);
    }
    collapseAll() {
      this.expansionModel.clear();
    }
    expandDescendants(t) {
      let e = [t];
      e.push(...this.getDescendants(t)), this.expansionModel.select(...e.map((n) => this._trackByValue(n)));
    }
    collapseDescendants(t) {
      let e = [t];
      e.push(...this.getDescendants(t)), this.expansionModel.deselect(...e.map((n) => this._trackByValue(n)));
    }
    _trackByValue(t) {
      return this.trackBy ? this.trackBy(t) : t;
    }
  };
  var Jx = class extends DD {
    getLevel;
    isExpandable;
    options;
    constructor(t, e, n) {
      super(), this.getLevel = t, this.isExpandable = e, this.options = n, this.options && (this.trackBy = this.options.trackBy);
    }
    getDescendants(t) {
      let e = this.dataNodes.indexOf(t), n = [];
      for (let r = e + 1; r < this.dataNodes.length && this.getLevel(t) < this.getLevel(this.dataNodes[r]); r++) n.push(this.dataNodes[r]);
      return n;
    }
    expandAll() {
      this.expansionModel.select(...this.dataNodes.map((t) => this._trackByValue(t)));
    }
  };
  var RD = new Ee("CDK_TREE_NODE_OUTLET_NODE");
  var ew = (() => {
    class i59 {
      viewContainer = M(un);
      _node = M(RD, { optional: true });
      constructor() {
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkTreeNodeOutlet", ""]] });
    }
    return i59;
  })();
  var PD = class {
    $implicit;
    level;
    index;
    count;
    constructor(t) {
      this.$implicit = t;
    }
  };
  var tw = (() => {
    class i59 {
      template = M(ni);
      when;
      constructor() {
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkTreeNodeDef", ""]], inputs: { when: [0, "cdkTreeNodeDefWhen", "when"] } });
    }
    return i59;
  })();
  function YU() {
    return Error("Could not find a tree control, levelAccessor, or childrenAccessor for the tree.");
  }
  var dp = (() => {
    class i59 {
      _differs = M(Cu);
      _changeDetectorRef = M(Ge);
      _elementRef = M(He);
      _dir = M(_i);
      _onDestroy = new we();
      _dataDiffer;
      _defaultNodeDef;
      _dataSubscription;
      _levels = /* @__PURE__ */ new Map();
      _parents = /* @__PURE__ */ new Map();
      _ariaSets = /* @__PURE__ */ new Map();
      get dataSource() {
        return this._dataSource;
      }
      set dataSource(e) {
        this._dataSource !== e && this._switchDataSource(e);
      }
      _dataSource;
      treeControl;
      levelAccessor;
      childrenAccessor;
      trackBy;
      expansionKey;
      _nodeOutlet;
      _nodeDefs;
      viewChange = new hi({ start: 0, end: Number.MAX_VALUE });
      _expansionModel;
      _flattenedNodes = new hi([]);
      _nodeType = new hi(null);
      _nodes = new hi(/* @__PURE__ */ new Map());
      _keyManagerNodes = new hi([]);
      _keyManagerFactory = M(aL);
      _keyManager;
      _viewInit = false;
      constructor() {
      }
      ngAfterContentInit() {
        this._initializeKeyManager();
      }
      ngAfterContentChecked() {
        this._updateDefaultNodeDefinition(), this._subscribeToDataChanges();
      }
      ngOnDestroy() {
        this._nodeOutlet.viewContainer.clear(), this.viewChange.complete(), this._onDestroy.next(), this._onDestroy.complete(), this._dataSource && typeof this._dataSource.disconnect == "function" && this.dataSource.disconnect(this), this._dataSubscription && (this._dataSubscription.unsubscribe(), this._dataSubscription = null), this._keyManager?.destroy();
      }
      ngOnInit() {
        this._checkTreeControlUsage(), this._initializeDataDiffer();
      }
      ngAfterViewInit() {
        this._viewInit = true;
      }
      _updateDefaultNodeDefinition() {
        let e = this._nodeDefs.filter((n) => !n.when);
        e.length > 1, this._defaultNodeDef = e[0];
      }
      _setNodeTypeIfUnset(e) {
        this._nodeType.value === null && this._nodeType.next(e);
      }
      _switchDataSource(e) {
        this._dataSource && typeof this._dataSource.disconnect == "function" && this.dataSource.disconnect(this), this._dataSubscription && (this._dataSubscription.unsubscribe(), this._dataSubscription = null), e || this._nodeOutlet.viewContainer.clear(), this._dataSource = e, this._nodeDefs && this._subscribeToDataChanges();
      }
      _getExpansionModel() {
        return this.treeControl ? this.treeControl.expansionModel : (this._expansionModel ??= new zd(true), this._expansionModel);
      }
      _subscribeToDataChanges() {
        if (this._dataSubscription) return;
        let e;
        xU(this._dataSource) ? e = this._dataSource.connect(this) : Js(this._dataSource) ? e = this._dataSource : Array.isArray(this._dataSource) && (e = qt(this._dataSource)), e && (this._dataSubscription = this._getRenderData(e).pipe(Je(this._onDestroy)).subscribe((n) => {
          this._renderDataChanges(n);
        }));
      }
      _getRenderData(e) {
        let n = this._getExpansionModel();
        return cr([e, this._nodeType, n.changed.pipe(ei(null), Wi((r) => {
          this._emitExpansionChanges(r);
        }))]).pipe(Ai(([r, o]) => o === null ? qt({ renderNodes: r, flattenedNodes: null, nodeType: o }) : this._computeRenderingData(r, o).pipe(kt((s) => xt(le({}, s), { nodeType: o })))));
      }
      _renderDataChanges(e) {
        if (e.nodeType === null) {
          this.renderNodeChanges(e.renderNodes);
          return;
        }
        this._updateCachedData(e.flattenedNodes), this.renderNodeChanges(e.renderNodes), this._updateKeyManagerItems(e.flattenedNodes);
      }
      _emitExpansionChanges(e) {
        if (!e) return;
        let n = this._nodes.value;
        for (let r of e.added) n.get(r)?._emitExpansionState(true);
        for (let r of e.removed) n.get(r)?._emitExpansionState(false);
      }
      _initializeKeyManager() {
        let e = cr([this._keyManagerNodes, this._nodes]).pipe(kt(([r, o]) => r.reduce((s, a) => {
          let l = o.get(this._getExpansionKey(a));
          return l && s.push(l), s;
        }, []))), n = { trackBy: (r) => this._getExpansionKey(r.data), skipPredicate: (r) => !!r.isDisabled, typeAheadDebounceInterval: true, horizontalOrientation: this._dir.value };
        this._keyManager = this._keyManagerFactory(e, n);
      }
      _initializeDataDiffer() {
        let e = this.trackBy ?? ((n, r) => this._getExpansionKey(r));
        this._dataDiffer = this._differs.find([]).create(e);
      }
      _checkTreeControlUsage() {
      }
      renderNodeChanges(e, n = this._dataDiffer, r = this._nodeOutlet.viewContainer, o) {
        let s = n.diff(e);
        !s && !this._viewInit || (s?.forEachOperation((a, l, c) => {
          if (a.previousIndex == null) this.insertNode(e[c], c, r, o);
          else if (c == null) r.remove(l);
          else {
            let d = r.get(l);
            r.move(d, c);
          }
        }), s?.forEachIdentityChange((a) => {
          let l = a.item;
          if (a.currentIndex != null) {
            let c = r.get(a.currentIndex);
            c.context.$implicit = l;
          }
        }), o ? this._changeDetectorRef.markForCheck() : this._changeDetectorRef.detectChanges());
      }
      _getNodeDef(e, n) {
        if (this._nodeDefs.length === 1) return this._nodeDefs.first;
        let r = this._nodeDefs.find((o) => o.when && o.when(n, e)) || this._defaultNodeDef;
        return r;
      }
      insertNode(e, n, r, o) {
        let s = this._getLevelAccessor(), a = this._getNodeDef(e, n), l = this._getExpansionKey(e), c = new PD(e);
        o ??= this._parents.get(l) ?? void 0, s ? c.level = s(e) : o !== void 0 && this._levels.has(this._getExpansionKey(o)) ? c.level = this._levels.get(this._getExpansionKey(o)) + 1 : c.level = 0, this._levels.set(l, c.level), (r || this._nodeOutlet.viewContainer).createEmbeddedView(a.template, c, n), Hd.mostRecentTreeNode && (Hd.mostRecentTreeNode.data = e);
      }
      isExpanded(e) {
        return !!(this.treeControl?.isExpanded(e) || this._expansionModel?.isSelected(this._getExpansionKey(e)));
      }
      toggle(e) {
        this.treeControl ? this.treeControl.toggle(e) : this._expansionModel && this._expansionModel.toggle(this._getExpansionKey(e));
      }
      expand(e) {
        this.treeControl ? this.treeControl.expand(e) : this._expansionModel && this._expansionModel.select(this._getExpansionKey(e));
      }
      collapse(e) {
        this.treeControl ? this.treeControl.collapse(e) : this._expansionModel && this._expansionModel.deselect(this._getExpansionKey(e));
      }
      toggleDescendants(e) {
        this.treeControl ? this.treeControl.toggleDescendants(e) : this._expansionModel && (this.isExpanded(e) ? this.collapseDescendants(e) : this.expandDescendants(e));
      }
      expandDescendants(e) {
        if (this.treeControl) this.treeControl.expandDescendants(e);
        else if (this._expansionModel) {
          let n = this._expansionModel;
          n.select(this._getExpansionKey(e)), this._getDescendants(e).pipe(On(1), Je(this._onDestroy)).subscribe((r) => {
            n.select(...r.map((o) => this._getExpansionKey(o)));
          });
        }
      }
      collapseDescendants(e) {
        if (this.treeControl) this.treeControl.collapseDescendants(e);
        else if (this._expansionModel) {
          let n = this._expansionModel;
          n.deselect(this._getExpansionKey(e)), this._getDescendants(e).pipe(On(1), Je(this._onDestroy)).subscribe((r) => {
            n.deselect(...r.map((o) => this._getExpansionKey(o)));
          });
        }
      }
      expandAll() {
        this.treeControl ? this.treeControl.expandAll() : this._expansionModel && this._forEachExpansionKey((e) => this._expansionModel?.select(...e));
      }
      collapseAll() {
        this.treeControl ? this.treeControl.collapseAll() : this._expansionModel && this._forEachExpansionKey((e) => this._expansionModel?.deselect(...e));
      }
      _getLevelAccessor() {
        return this.treeControl?.getLevel?.bind(this.treeControl) ?? this.levelAccessor;
      }
      _getChildrenAccessor() {
        return this.treeControl?.getChildren?.bind(this.treeControl) ?? this.childrenAccessor;
      }
      _getDirectChildren(e) {
        let n = this._getLevelAccessor(), r = this._expansionModel ?? this.treeControl?.expansionModel;
        if (!r) return qt([]);
        let o = this._getExpansionKey(e), s = r.changed.pipe(Ai((l) => l.added.includes(o) ? qt(true) : l.removed.includes(o) ? qt(false) : ec), ei(this.isExpanded(e)));
        if (n) return cr([s, this._flattenedNodes]).pipe(kt(([l, c]) => l ? this._findChildrenByLevel(n, c, e, 1) : []));
        let a = this._getChildrenAccessor();
        if (a) return Bc(a(e) ?? []);
        throw YU();
      }
      _findChildrenByLevel(e, n, r, o) {
        let s = this._getExpansionKey(r), a = n.findIndex((u) => this._getExpansionKey(u) === s), l = e(r), c = l + o, d = [];
        for (let u = a + 1; u < n.length; u++) {
          let h = e(n[u]);
          if (h <= l) break;
          h <= c && d.push(n[u]);
        }
        return d;
      }
      _registerNode(e) {
        this._nodes.value.set(this._getExpansionKey(e.data), e), this._nodes.next(this._nodes.value);
      }
      _unregisterNode(e) {
        this._nodes.value.delete(this._getExpansionKey(e.data)), this._nodes.next(this._nodes.value);
      }
      _getLevel(e) {
        return this._levels.get(this._getExpansionKey(e));
      }
      _getSetSize(e) {
        return this._getAriaSet(e).length;
      }
      _getPositionInSet(e) {
        let n = this._getAriaSet(e), r = this._getExpansionKey(e);
        return n.findIndex((o) => this._getExpansionKey(o) === r) + 1;
      }
      _getNodeParent(e) {
        let n = this._parents.get(this._getExpansionKey(e.data));
        return n && this._nodes.value.get(this._getExpansionKey(n));
      }
      _getNodeChildren(e) {
        return this._getDirectChildren(e.data).pipe(kt((n) => n.reduce((r, o) => {
          let s = this._nodes.value.get(this._getExpansionKey(o));
          return s && r.push(s), r;
        }, [])));
      }
      _sendKeydownToKeyManager(e) {
        if (e.target === this._elementRef.nativeElement) this._keyManager.onKeydown(e);
        else {
          let n = this._nodes.getValue();
          for (let [, r] of n) if (e.target === r._elementRef.nativeElement) {
            this._keyManager.onKeydown(e);
            break;
          }
        }
      }
      _getDescendants(e) {
        if (this.treeControl) return qt(this.treeControl.getDescendants(e));
        if (this.levelAccessor) {
          let n = this._findChildrenByLevel(this.levelAccessor, this._flattenedNodes.value, e, 1 / 0);
          return qt(n);
        }
        if (this.childrenAccessor) return this._getAllChildrenRecursively(e).pipe(A_((n, r) => (n.push(...r), n), []));
        throw YU();
      }
      _getAllChildrenRecursively(e) {
        return this.childrenAccessor ? Bc(this.childrenAccessor(e)).pipe(On(1), Ai((n) => {
          for (let r of n) this._parents.set(this._getExpansionKey(r), e);
          return qt(...n).pipe(nu((r) => ea(qt([r]), this._getAllChildrenRecursively(r))));
        })) : qt([]);
      }
      _getExpansionKey(e) {
        return this.expansionKey?.(e) ?? e;
      }
      _getAriaSet(e) {
        let n = this._getExpansionKey(e), r = this._parents.get(n), o = r ? this._getExpansionKey(r) : null;
        return this._ariaSets.get(o) ?? [e];
      }
      _findParentForNode(e, n, r) {
        if (!r.length) return null;
        let o = this._levels.get(this._getExpansionKey(e)) ?? 0;
        for (let s = n - 1; s >= 0; s--) {
          let a = r[s];
          if ((this._levels.get(this._getExpansionKey(a)) ?? 0) < o) return a;
        }
        return null;
      }
      _flattenNestedNodesWithExpansion(e, n = 0) {
        let r = this._getChildrenAccessor();
        return r ? qt(...e).pipe(nu((o) => {
          let s = this._getExpansionKey(o);
          this._parents.has(s) || this._parents.set(s, null), this._levels.set(s, n);
          let a = Bc(r(o));
          return ea(qt([o]), a.pipe(On(1), Wi((l) => {
            this._ariaSets.set(s, [...l ?? []]);
            for (let c of l ?? []) {
              let d = this._getExpansionKey(c);
              this._parents.set(d, o), this._levels.set(d, n + 1);
            }
          }), Ai((l) => l ? this._flattenNestedNodesWithExpansion(l, n + 1).pipe(kt((c) => this.isExpanded(o) ? c : [])) : qt([]))));
        }), A_((o, s) => (o.push(...s), o), [])) : qt([...e]);
      }
      _computeRenderingData(e, n) {
        if (this.childrenAccessor && n === "flat") return this._ariaSets.set(null, [...e]), this._flattenNestedNodesWithExpansion(e).pipe(kt((r) => ({ renderNodes: r, flattenedNodes: r })));
        if (this.levelAccessor && n === "nested") {
          let r = this.levelAccessor;
          return qt(e.filter((o) => r(o) === 0)).pipe(kt((o) => ({ renderNodes: o, flattenedNodes: e })), Wi(({ flattenedNodes: o }) => {
            this._calculateParents(o);
          }));
        } else return n === "flat" ? qt({ renderNodes: e, flattenedNodes: e }).pipe(Wi(({ flattenedNodes: r }) => {
          this._calculateParents(r);
        })) : (this._ariaSets.set(null, [...e]), this._flattenNestedNodesWithExpansion(e).pipe(kt((r) => ({ renderNodes: e, flattenedNodes: r }))));
      }
      _updateCachedData(e) {
        this._flattenedNodes.next(e);
      }
      _updateKeyManagerItems(e) {
        this._keyManagerNodes.next(e);
      }
      _calculateParents(e) {
        let n = this._getLevelAccessor();
        if (n) {
          this._parents.clear(), this._ariaSets.clear();
          for (let r = 0; r < e.length; r++) {
            let o = e[r], s = this._getExpansionKey(o);
            this._levels.set(s, n(o));
            let a = this._findParentForNode(o, r, e);
            this._parents.set(s, a);
            let l = a ? this._getExpansionKey(a) : null, c = this._ariaSets.get(l) ?? [];
            c.splice(r, 0, o), this._ariaSets.set(l, c);
          }
        }
      }
      _forEachExpansionKey(e) {
        let n = [], r = [];
        this._nodes.value.forEach((o) => {
          n.push(this._getExpansionKey(o.data)), r.push(this._getDescendants(o.data));
        }), r.length > 0 ? cr(r).pipe(On(1), Je(this._onDestroy)).subscribe((o) => {
          o.forEach((s) => s.forEach((a) => n.push(this._getExpansionKey(a)))), e(n);
        }) : e(n);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["cdk-tree"]], contentQueries: function(n, r, o) {
        if (n & 1 && Xi(o, tw, 5), n & 2) {
          let s;
          Ie(s = De()) && (r._nodeDefs = s);
        }
      }, viewQuery: function(n, r) {
        if (n & 1 && Fe(ew, 7), n & 2) {
          let o;
          Ie(o = De()) && (r._nodeOutlet = o.first);
        }
      }, hostAttrs: ["role", "tree", 1, "cdk-tree"], hostBindings: function(n, r) {
        n & 1 && Z("keydown", function(s) {
          return r._sendKeydownToKeyManager(s);
        });
      }, inputs: { dataSource: "dataSource", treeControl: "treeControl", levelAccessor: "levelAccessor", childrenAccessor: "childrenAccessor", trackBy: "trackBy", expansionKey: "expansionKey" }, exportAs: ["cdkTree"], decls: 1, vars: 0, consts: [["cdkTreeNodeOutlet", ""]], template: function(n, r) {
        n & 1 && fi(0, 0);
      }, dependencies: [ew], encapsulation: 2 });
    }
    return i59;
  })();
  var Hd = (() => {
    class i59 {
      _elementRef = M(He);
      _tree = M(dp);
      _tabindex = -1;
      _type = "flat";
      get role() {
        return "treeitem";
      }
      set role(e) {
      }
      get isExpandable() {
        return this._isExpandable();
      }
      set isExpandable(e) {
        this._inputIsExpandable = e, !(this.data && !this._isExpandable || !this._inputIsExpandable) && (this._inputIsExpanded ? this.expand() : this._inputIsExpanded === false && this.collapse());
      }
      get isExpanded() {
        return this._tree.isExpanded(this._data);
      }
      set isExpanded(e) {
        this._inputIsExpanded = e, e ? this.expand() : this.collapse();
      }
      isDisabled;
      typeaheadLabel;
      getLabel() {
        return this.typeaheadLabel || this._elementRef.nativeElement.textContent?.trim() || "";
      }
      activation = new Ue();
      expandedChange = new Ue();
      static mostRecentTreeNode = null;
      _destroyed = new we();
      _dataChanges = new we();
      _inputIsExpandable = false;
      _inputIsExpanded = void 0;
      _shouldFocus = true;
      _parentNodeAriaLevel;
      get data() {
        return this._data;
      }
      set data(e) {
        e !== this._data && (this._data = e, this._dataChanges.next());
      }
      _data;
      get isLeafNode() {
        return this._tree.treeControl?.isExpandable !== void 0 && !this._tree.treeControl.isExpandable(this._data) ? true : this._tree.treeControl?.isExpandable === void 0 && this._tree.treeControl?.getDescendants(this._data).length === 0;
      }
      get level() {
        return this._tree._getLevel(this._data) ?? this._parentNodeAriaLevel;
      }
      _isExpandable() {
        return this._tree.treeControl ? !this.isLeafNode : this._inputIsExpandable;
      }
      _getAriaExpanded() {
        return this._isExpandable() ? String(this.isExpanded) : null;
      }
      _getSetSize() {
        return this._tree._getSetSize(this._data);
      }
      _getPositionInSet() {
        return this._tree._getPositionInSet(this._data);
      }
      _changeDetectorRef = M(Ge);
      constructor() {
        i59.mostRecentTreeNode = this;
      }
      ngOnInit() {
        this._parentNodeAriaLevel = Qse(this._elementRef.nativeElement), this._tree._getExpansionModel().changed.pipe(kt(() => this.isExpanded), qa()).subscribe(() => this._changeDetectorRef.markForCheck()), this._tree._setNodeTypeIfUnset(this._type), this._tree._registerNode(this);
      }
      ngOnDestroy() {
        i59.mostRecentTreeNode === this && (i59.mostRecentTreeNode = null), this._dataChanges.complete(), this._destroyed.next(), this._destroyed.complete();
      }
      getParent() {
        return this._tree._getNodeParent(this) ?? null;
      }
      getChildren() {
        return this._tree._getNodeChildren(this);
      }
      focus() {
        this._tabindex = 0, this._shouldFocus && this._elementRef.nativeElement.focus(), this._changeDetectorRef.markForCheck();
      }
      unfocus() {
        this._tabindex = -1, this._changeDetectorRef.markForCheck();
      }
      activate() {
        this.isDisabled || this.activation.next(this._data);
      }
      collapse() {
        this.isExpandable && this._tree.collapse(this._data);
      }
      expand() {
        this.isExpandable && this._tree.expand(this._data);
      }
      makeFocusable() {
        this._tabindex = 0, this._changeDetectorRef.markForCheck();
      }
      _focusItem() {
        this.isDisabled || this._tree._keyManager.focusItem(this);
      }
      _setActiveItem() {
        this.isDisabled || (this._shouldFocus = false, this._tree._keyManager.focusItem(this), this._shouldFocus = true);
      }
      _emitExpansionState(e) {
        this.expandedChange.emit(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["cdk-tree-node"]], hostAttrs: ["role", "treeitem", 1, "cdk-tree-node"], hostVars: 5, hostBindings: function(n, r) {
        n & 1 && Z("click", function() {
          return r._setActiveItem();
        })("focus", function() {
          return r._focusItem();
        }), n & 2 && (gr("tabindex", r._tabindex), Ke("aria-expanded", r._getAriaExpanded())("aria-level", r.level + 1)("aria-posinset", r._getPositionInSet())("aria-setsize", r._getSetSize()));
      }, inputs: { role: "role", isExpandable: [2, "isExpandable", "isExpandable", tt], isExpanded: "isExpanded", isDisabled: [2, "isDisabled", "isDisabled", tt], typeaheadLabel: [0, "cdkTreeNodeTypeaheadLabel", "typeaheadLabel"] }, outputs: { activation: "activation", expandedChange: "expandedChange" }, exportAs: ["cdkTreeNode"], features: [on] });
    }
    return i59;
  })();
  function Qse(i59) {
    let t = i59.parentElement;
    for (; t && !Kse(t); ) t = t.parentElement;
    return t ? t.classList.contains("cdk-nested-tree-node") ? Gn(t.getAttribute("aria-level")) : 0 : -1;
  }
  function Kse(i59) {
    let t = i59.classList;
    return !!(t?.contains("cdk-nested-tree-node") || t?.contains("cdk-tree"));
  }
  var Jse = /([A-Za-z%]+)$/;
  var OD = (() => {
    class i59 {
      _treeNode = M(Hd);
      _tree = M(dp);
      _element = M(He);
      _dir = M(_i, { optional: true });
      _currentPadding;
      _destroyed = new we();
      indentUnits = "px";
      get level() {
        return this._level;
      }
      set level(e) {
        this._setLevelInput(e);
      }
      _level;
      get indent() {
        return this._indent;
      }
      set indent(e) {
        this._setIndentInput(e);
      }
      _indent = 40;
      constructor() {
        this._setPadding(), this._dir?.change.pipe(Je(this._destroyed)).subscribe(() => this._setPadding(true)), this._treeNode._dataChanges.subscribe(() => this._setPadding());
      }
      ngOnDestroy() {
        this._destroyed.next(), this._destroyed.complete();
      }
      _paddingIndent() {
        let e = (this._treeNode.data && this._tree._getLevel(this._treeNode.data)) ?? null, n = this._level == null ? e : this._level;
        return typeof n == "number" ? `${n * this._indent}${this.indentUnits}` : null;
      }
      _setPadding(e = false) {
        let n = this._paddingIndent();
        if (n !== this._currentPadding || e) {
          let r = this._element.nativeElement, o = this._dir && this._dir.value === "rtl" ? "paddingRight" : "paddingLeft", s = o === "paddingLeft" ? "paddingRight" : "paddingLeft";
          r.style[o] = n || "", r.style[s] = "", this._currentPadding = n;
        }
      }
      _setLevelInput(e) {
        this._level = isNaN(e) ? null : e, this._setPadding();
      }
      _setIndentInput(e) {
        let n = e, r = "px";
        if (typeof e == "string") {
          let o = e.split(Jse);
          n = o[0], r = o[1] || r;
        }
        this.indentUnits = r, this._indent = Gn(n), this._setPadding();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkTreeNodePadding", ""]], inputs: { level: [2, "cdkTreeNodePadding", "level", Gn], indent: [0, "cdkTreeNodePaddingIndent", "indent"] }, features: [on] });
    }
    return i59;
  })();
  var AD = (() => {
    class i59 {
      _tree = M(dp);
      _treeNode = M(Hd);
      recursive = false;
      constructor() {
      }
      _toggle() {
        this.recursive ? this._tree.toggleDescendants(this._treeNode.data) : this._tree.toggle(this._treeNode.data), this._tree._keyManager.focusItem(this._treeNode);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkTreeNodeToggle", ""]], hostAttrs: ["tabindex", "-1"], hostBindings: function(n, r) {
        n & 1 && Z("click", function(s) {
          return r._toggle(), s.stopPropagation();
        })("keydown.Enter", function(s) {
          return r._toggle(), s.preventDefault();
        })("keydown.Space", function(s) {
          return r._toggle(), s.preventDefault();
        });
      }, inputs: { recursive: [2, "cdkTreeNodeToggleRecursive", "recursive", tt] }, features: [on] });
    }
    return i59;
  })();
  var XU = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({});
    }
    return i59;
  })();
  function eae(i59) {
    return !!i59._isNoopTreeKeyManager;
  }
  var QU = (() => {
    class i59 extends Hd {
      get tabIndexInputBinding() {
        return this._tabIndexInputBinding;
      }
      set tabIndexInputBinding(e) {
        this._tabIndexInputBinding = e;
      }
      _tabIndexInputBinding;
      defaultTabIndex = 0;
      _getTabindexAttribute() {
        return eae(this._tree._keyManager) ? this.tabIndexInputBinding : this._tabindex;
      }
      get disabled() {
        return this.isDisabled;
      }
      set disabled(e) {
        this.isDisabled = e;
      }
      constructor() {
        super();
        let e = M(new Tr("tabindex"), { optional: true });
        this.tabIndexInputBinding = Number(e) || this.defaultTabIndex;
      }
      ngOnInit() {
        super.ngOnInit();
      }
      ngOnDestroy() {
        super.ngOnDestroy();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["mat-tree-node"]], hostAttrs: [1, "mat-tree-node"], hostVars: 5, hostBindings: function(n, r) {
        n & 1 && Z("click", function() {
          return r._focusItem();
        }), n & 2 && (gr("tabindex", r._getTabindexAttribute()), Ke("aria-expanded", r._getAriaExpanded())("aria-level", r.level + 1)("aria-posinset", r._getPositionInSet())("aria-setsize", r._getSetSize()));
      }, inputs: { tabIndexInputBinding: [2, "tabIndex", "tabIndexInputBinding", (e) => e == null ? 0 : Gn(e)], disabled: [2, "disabled", "disabled", tt] }, outputs: { activation: "activation", expandedChange: "expandedChange" }, exportAs: ["matTreeNode"], features: [Bt([{ provide: Hd, useExisting: i59 }]), on, Zt] });
    }
    return i59;
  })();
  var KU = (() => {
    class i59 extends tw {
      data;
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["", "matTreeNodeDef", ""]], inputs: { when: [0, "matTreeNodeDefWhen", "when"], data: [0, "matTreeNode", "data"] }, features: [Bt([{ provide: tw, useExisting: i59 }]), Zt] });
    }
    return i59;
  })();
  var JU = (() => {
    class i59 extends OD {
      get level() {
        return this._level;
      }
      set level(e) {
        this._setLevelInput(e);
      }
      get indent() {
        return this._indent;
      }
      set indent(e) {
        this._setIndentInput(e);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["", "matTreeNodePadding", ""]], inputs: { level: [2, "matTreeNodePadding", "level", Gn], indent: [0, "matTreeNodePaddingIndent", "indent"] }, features: [Bt([{ provide: OD, useExisting: i59 }]), on, Zt] });
    }
    return i59;
  })();
  var ZU = (() => {
    class i59 {
      viewContainer = M(un);
      _node = M(RD, { optional: true });
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "matTreeNodeOutlet", ""]], features: [Bt([{ provide: ew, useExisting: i59 }])] });
    }
    return i59;
  })();
  var eG = (() => {
    class i59 extends dp {
      _nodeOutlet = void 0;
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275cmp = xe({ type: i59, selectors: [["mat-tree"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(ZU, 7), n & 2) {
          let o;
          Ie(o = De()) && (r._nodeOutlet = o.first);
        }
      }, hostAttrs: [1, "mat-tree"], exportAs: ["matTree"], features: [Bt([{ provide: dp, useExisting: i59 }]), Zt], decls: 1, vars: 0, consts: [["matTreeNodeOutlet", ""]], template: function(n, r) {
        n & 1 && fi(0, 0);
      }, dependencies: [ZU], styles: [".mat-tree{display:block;background-color:var(--mat-tree-container-background-color, var(--mat-sys-surface))}.mat-tree-node,.mat-nested-tree-node{color:var(--mat-tree-node-text-color, var(--mat-sys-on-surface));font-family:var(--mat-tree-node-text-font, var(--mat-sys-body-large-font));font-size:var(--mat-tree-node-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-tree-node-text-weight, var(--mat-sys-body-large-weight))}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word;min-height:var(--mat-tree-node-min-height, 48px)}.mat-nested-tree-node{border-bottom-width:0}"], encapsulation: 2 });
    }
    return i59;
  })();
  var tG = (() => {
    class i59 extends AD {
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["", "matTreeNodeToggle", ""]], inputs: { recursive: [0, "matTreeNodeToggleRecursive", "recursive"] }, features: [Bt([{ provide: AD, useExisting: i59 }]), Zt] });
    }
    return i59;
  })();
  var nG = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [XU, Yt, Yt] });
    }
    return i59;
  })();
  var nw = class {
    transformFunction;
    getLevel;
    isExpandable;
    getChildren;
    constructor(t, e, n, r) {
      this.transformFunction = t, this.getLevel = e, this.isExpandable = n, this.getChildren = r;
    }
    _flattenNode(t, e, n, r) {
      let o = this.transformFunction(t, e);
      if (n.push(o), this.isExpandable(o)) {
        let s = this.getChildren(t);
        s && (Array.isArray(s) ? this._flattenChildren(s, e, n, r) : s.pipe(On(1)).subscribe((a) => {
          this._flattenChildren(a, e, n, r);
        }));
      }
      return n;
    }
    _flattenChildren(t, e, n, r) {
      t.forEach((o, s) => {
        let a = r.slice();
        a.push(s != t.length - 1), this._flattenNode(o, e + 1, n, a);
      });
    }
    flattenNodes(t) {
      let e = [];
      return t.forEach((n) => this._flattenNode(n, 0, e, [])), e;
    }
    expandFlattenedNodes(t, e) {
      let n = [], r = [];
      return r[0] = true, t.forEach((o) => {
        let s = true;
        for (let a = 0; a <= this.getLevel(o); a++) s = s && r[a];
        s && n.push(o), this.isExpandable(o) && (r[this.getLevel(o) + 1] = e.isExpanded(o));
      }), n;
    }
  };
  var iw = class extends Wx {
    _treeControl;
    _treeFlattener;
    _flattenedData = new hi([]);
    _expandedData = new hi([]);
    get data() {
      return this._data.value;
    }
    set data(t) {
      this._data.next(t), this._flattenedData.next(this._treeFlattener.flattenNodes(this.data)), this._treeControl.dataNodes = this._flattenedData.value;
    }
    _data = new hi([]);
    constructor(t, e, n) {
      super(), this._treeControl = t, this._treeFlattener = e, n && (this.data = n);
    }
    connect(t) {
      return Jn(t.viewChange, this._treeControl.expansionModel.changed, this._flattenedData).pipe(kt(() => (this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl)), this._expandedData.value)));
    }
    disconnect() {
    }
  };
  var Hg = 200;
  var iG = _n({ opacity: 0 });
  var rG = _n({ opacity: 1 });
  var nae = `${Hg}ms ${RT.DECELERATION_CURVE}`;
  var iae = `${Hg}ms ${RT.STANDARD_CURVE}`;
  var oG = { bubbleContainer: ki("bubbleContainer", [Zi("void, hidden", iG), Zi("visible", rG), Yn("void => *, * => visible", oi(nae, rG)), Yn("* => void, * => hidden", oi(iae, iG))]) };
  function rae(i59, t) {
    i59 & 1 && ae(0, "a", 1);
  }
  var sG = (() => {
    class i59 extends js {
      portalOutlet;
      animationState = "hidden";
      changeDetector = M(Ge);
      attachComponentPortal(e) {
        return this.portalOutlet.attachComponentPortal(e);
      }
      attachTemplatePortal(e) {
        return this.portalOutlet.attachTemplatePortal(e);
      }
      toggleAnimation(e) {
        this.animationState = e ? "visible" : "hidden", this.changeDetector.markForCheck();
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275cmp = xe({ type: i59, selectors: [["bubble-container"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Bo, 7), n & 2) {
          let o;
          Ie(o = De()) && (r.portalOutlet = o.first);
        }
      }, hostAttrs: ["role", "dialog", 1, "bubble-container"], hostVars: 1, hostBindings: function(n, r) {
        n & 2 && cf("@bubbleContainer", r.animationState);
      }, features: [Zt], decls: 2, vars: 0, consts: [["cdkPortalOutlet", ""], ["cdkFocusInitial", "", "tabindex", "0"]], template: function(n, r) {
        n & 1 && (b(0, "div"), X(1, rae, 1, 0, "ng-template", 0), x());
      }, dependencies: [Ws, Bo], styles: [`.bubble-container{box-shadow:0 1px 2px #3c40434d,0 1px 3px 1px #3c404326;border-radius:8px;overflow:auto;background:#fff;color:#000000de;font-family:Google Sans Text,Arial,Helvetica,sans-serif;font-size:.875rem;font-weight:400;line-height:1.25rem;letter-spacing:normal}
/**
 * @license
 * Copyright 2024 The Model Explorer Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==============================================================================
 */
`], encapsulation: 2, data: { animation: [oG.bubbleContainer] }, changeDetection: 0 });
    }
    return i59;
  })();
  var oae = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top", offsetY: 8 }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", offsetY: -8 }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom", offsetY: -8 }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top", offsetY: 8 }];
  var sae = { minWidth: 220, maxWidth: 420, minHeight: 64, maxHeight: 420 };
  var rw = (() => {
    class i59 {
      ngZone;
      overlay;
      elementRef;
      viewContainerRef;
      document;
      focusTrapFactory;
      injector;
      overlayRef;
      portal;
      disabledInternal = false;
      panelClassInternal;
      set dialog(e) {
        e && (e instanceof ni ? this.setPortal(new go(e, this.viewContainerRef)) : this.setPortal(new Ui(e, this.viewContainerRef)));
      }
      set disabled(e) {
        this.disabledInternal = e, this.disabledInternal && this.closeDialog();
      }
      get disabled() {
        return this.disabledInternal;
      }
      overlaySize;
      overlayPositions;
      overlayDimensions = sae;
      set panelClass(e) {
        this.panelClassInternal !== e && (this.panelClassInternal && this.overlayRef?.removePanelClass(this.panelClassInternal), e && this.overlayRef?.addPanelClass(e), this.panelClassInternal = e);
      }
      opened = new Ue();
      closed = new Ue();
      destroyed = new $o();
      openStatusChange = new hi(false);
      openings = this.openStatusChange.pipe(En((e) => e && !this.disabled));
      bubbleContainerRef;
      focusTrap;
      elementFocusedBeforeDialogWasOpened = void 0;
      constructor(e, n, r, o, s, a, l) {
        this.ngZone = e, this.overlay = n, this.elementRef = r, this.viewContainerRef = o, this.document = s, this.focusTrapFactory = a, this.injector = l, this.attachKeyboardCloseEventListeners(r.nativeElement);
      }
      ngOnInit() {
      }
      ngOnDestroy() {
        this.closeDialog(), this.openStatusChange.complete(), this.destroyed.next(), this.destroyed.complete(), this.overlayRef && this.overlayRef.dispose();
      }
      setPortal(e) {
        this.portal = e;
      }
      openDialog() {
        if (this.disabled || this.overlayRef?.hasAttached()) return;
        let e = this.portal;
        e != null && this.ngZone.run(() => {
          this.bubbleContainerRef = this.createAndAttachBubbleContainer(), this.bubbleContainerRef.instance.attach(e);
          let n = this.bubbleContainerRef.location.nativeElement;
          this.attachMouseEventListeners(n), this.attachKeyboardCloseEventListeners(n), this.trapFocus(n), this.bubbleContainerRef.instance.toggleAnimation(true), this.opened.observers.length && setTimeout(() => {
            this.opened.emit();
          }, Hg);
        });
      }
      closeDialog() {
        this.overlayRef?.hasAttached() && (this.bubbleContainerRef.instance.toggleAnimation(false), setTimeout(() => {
          this.ngZone.run(() => {
            this.overlayRef && this.overlayRef.detach(), this.cleanupFocusTrap(), this.restoreFocus(), this.cleanupBubbleContainer(), this.closed.emit();
          });
        }, Hg));
      }
      trapFocus(e) {
        let n = this.document.activeElement, r = this.elementRef.nativeElement;
        n && n === r && (this.document && (this.elementFocusedBeforeDialogWasOpened = this.document.activeElement), this.focusTrap = this.focusTrapFactory.create(e), this.focusTrap.attachAnchors());
      }
      focusInitialElement() {
        this.focusTrap && this.focusTrap.focusInitialElementWhenReady();
      }
      cleanupFocusTrap() {
        this.focusTrap && (this.focusTrap.destroy(), this.focusTrap = void 0);
      }
      restoreFocus() {
        let e = this.elementFocusedBeforeDialogWasOpened;
        if (!e || typeof e.focus != "function") return;
        let n = this.bubbleContainerRef?.location.nativeElement, r = this.document.activeElement;
        !r || !n?.contains(r) || (e.focus(), this.elementFocusedBeforeDialogWasOpened = void 0);
      }
      cleanupBubbleContainer() {
        this.bubbleContainerRef && (this.bubbleContainerRef.destroy(), this.bubbleContainerRef = void 0);
      }
      createPositionStrategy(e) {
        return this.overlay.position().flexibleConnectedTo(this.elementRef).withPositions(e).setOrigin(this.elementRef);
      }
      createScrollStrategy() {
        return this.overlay.scrollStrategies.close();
      }
      createAndAttachBubbleContainer() {
        let e = mt.create({ parent: this.injector, providers: [] }), n = new Ui(sG, null, e);
        return this.overlayRef == null && (this.overlayRef = this.overlay.create(this.createOverlayConfig(oae))), this.overlaySize && this.overlayRef.updateSize(this.overlaySize), this.overlayPositions && this.overlayPositions.length > 0 && this.overlayRef.updatePositionStrategy(this.createPositionStrategy(this.overlayPositions)), this.overlayRef.attach(n);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(We), K(fn), K(He), K(un), K(Document), K($u), K(mt));
      };
      static \u0275dir = qe({ type: i59, inputs: { overlaySize: "overlaySize", overlayPositions: "overlayPositions", overlayDimensions: "overlayDimensions", panelClass: "panelClass" }, outputs: { opened: "opened", closed: "closed" } });
    }
    return i59;
  })();
  var aae = 500;
  var Bn = (() => {
    class i59 extends rw {
      hoverDelayMs = aae;
      activity = new we();
      constructor(e, n, r, o, s, a, l) {
        super(e, n, r, o, s, a, l), this.attachMouseEventListeners(r.nativeElement);
      }
      ngOnInit() {
        super.ngOnInit(), this.listenForOpenEvents(this.hoverDelayMs);
      }
      listenForOpenEvents(e) {
        this.openStatusChange.pipe(Rp(() => this.activity.pipe(vo(e)))).pipe(Je(this.destroyed)).subscribe((r) => {
          r ? this.openDialog() : this.closeDialog();
        });
      }
      attachMouseEventListeners(e) {
        this.ngZone.runOutsideAngular(() => {
          zn(e, "mouseenter").pipe(Je(this.destroyed)).subscribe(() => {
            this.openingDialog();
          }), zn(e, "click").pipe(Je(this.destroyed)).subscribe((n) => {
            n.target.closest("[bubbleClose]") ? this.closingDialog() : (this.openingDialog(), this.openDialog());
          }), zn(e, "mouseleave").pipe(Je(this.destroyed)).subscribe(() => {
            this.closingDialog();
          }), zn(e, "mousemove").pipe(Je(this.destroyed)).subscribe(() => {
            this.activity.next();
          });
        });
      }
      attachKeyboardCloseEventListeners(e) {
        this.ngZone.runOutsideAngular(() => {
          zn(e, "keydown").pipe(Je(this.destroyed)).subscribe((n) => {
            switch (n.keyCode) {
              case 27:
                this.overlayRef?.hasAttached() && n.stopPropagation(), this.closeDialog();
                return;
              default:
                return;
            }
          });
        });
      }
      openingDialog() {
        this.disabled || (this.openStatusChange.next(true), this.activity.next());
      }
      closingDialog() {
        this.openStatusChange.next(false), this.activity.next();
      }
      createOverlayConfig(e) {
        return new Gi(xt(le({}, this.overlayDimensions), { positionStrategy: super.createPositionStrategy(e), scrollStrategy: this.createScrollStrategy(), panelClass: this.panelClassInternal }));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(We), K(fn), K(He), K(un), K(yt), K($u), K(mt));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "bubble", ""]], hostAttrs: [1, "bubble"], inputs: { dialog: [0, "bubble", "dialog"], disabled: [0, "bubbleDisabled", "disabled"], hoverDelayMs: "hoverDelayMs" }, exportAs: ["bubble"], features: [Zt] });
    }
    return i59;
  })();
  var ow = [ki("transformPanel", [Zi("void", _n({ opacity: 0, transform: "scale(1, 0.8)" })), Yn("void => showing", oi("120ms cubic-bezier(0, 0, 0.2, 1)", _n({ opacity: 1, transform: "scale(1, 1)" }))), Yn("* => void", oi("100ms linear", _n({ opacity: 0 })))])];
  var lae = ["tree"];
  var lG = (i59) => ({ node: i59 });
  function cae(i59, t) {
    if (i59 & 1 && D(0), i59 & 2) {
      let e = T().$implicit;
      wM(" ", e.boldLabel, " (", e.label, ") ");
    }
  }
  function dae(i59, t) {
    if (i59 & 1 && D(0), i59 & 2) {
      let e = T().$implicit;
      Oe(" ", e.label, " ");
    }
  }
  function uae(i59, t) {
    i59 & 1 && fi(0);
  }
  function hae(i59, t) {
    if (i59 & 1 && X(0, uae, 1, 0, "ng-container", 14), i59 & 2) {
      let e = T().$implicit;
      T();
      let n = Ce(5);
      U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(2, lG, e));
    }
  }
  function pae(i59, t) {
    if (i59 & 1 && (b(0, "tr")(1, "td", 17)(2, "mat-icon", 18), D(3, "circle"), x(), D(4), x(), b(5, "td", 19), D(6), x()()), i59 & 2) {
      let e = t.$implicit, n = T(2).$implicit, r = T();
      ye("search-match", r.isSearchMatched(n.metadata[e])), C(4), Oe(" ", e, ""), C(2), Qe(n.metadata[e]);
    }
  }
  function fae(i59, t) {
    if (i59 & 1 && (b(0, "table", 15), X(1, pae, 7, 4, "tr", 16), x()), i59 & 2) {
      let e = T().$implicit, n = T();
      C(), U("ngForOf", n.getSortedMetadataKeys(e));
    }
  }
  function mae(i59, t) {
    if (i59 & 1 && (b(0, "div", 20)(1, "mat-icon", 21), D(2, "my_location"), x()()), i59 & 2) {
      let e = T(2);
      U("matTooltip", e.locatorTooltip)("matTooltipPosition", e.tooltipPosition);
    }
  }
  function gae(i59, t) {
    if (i59 & 1 && (b(0, "div", 23), D(1), x()), i59 & 2) {
      let e = T(3);
      C(), Oe(" Showing at most ", e.getMaxConstValueCount(), " elements ");
    }
  }
  function _ae(i59, t) {
    if (i59 & 1 && (b(0, "div", 22), X(1, gae, 2, 1, "div", 23), b(2, "div", 24), D(3), x()()), i59 & 2) {
      let e = T().$implicit, n = T();
      C(), he(n.getMaxConstValueCount() !== 0 ? 1 : -1), C(2), Qe(n.getConstValues(e));
    }
  }
  function vae(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "mat-tree-node", 6)(1, "div", 7), Z("click", function(r) {
        let o = q(e).$implicit, s = T();
        return Y(s.handleLocateNode(o, r.altKey));
      }), b(2, "div", 8)(3, "div", 9)(4, "div", 10)(5, "span", 11), X(6, cae, 1, 2)(7, dae, 1, 1), x(), X(8, hae, 1, 4, "ng-container"), x()(), X(9, fae, 2, 1, "table", 12), x(), X(10, mae, 3, 2, "div", 13), x(), X(11, _ae, 4, 2, "ng-template", null, 2, Tt), x();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = Ce(12), r = T();
      ye("has-locator", e.showLocator)("has-values", r.showHoverForValuesLabel(e))("highlight", e.highlight)("has-metadata", r.hasMetadata(e)), U("bubble", n)("overlaySize", r.constValuesPopupSize)("overlayPositions", r.constValuesPopupPosition)("hoverDelayMs", 50)("bubbleDisabled", !r.showHoverForValuesLabel(e))("matTreeNodePaddingIndent", r.treeItemPadding), Ke("data-id", e.nodeId), C(2), ye("has-extra-data", e.extraData != null), C(3), ye("color-bold", r.colorBoldNodeLabel)("search-match", r.isSearchMatched(e.label, e.boldLabel)), C(), he(e.boldLabel ? 6 : 7), C(2), he(e.extraData ? 8 : -1), C(), U("ngIf", r.hasMetadata(e)), C(), U("ngIf", e.showLocator && r.showLocator);
    }
  }
  function yae(i59, t) {
    i59 & 1 && fi(0);
  }
  function bae(i59, t) {
    if (i59 & 1 && X(0, yae, 1, 0, "ng-container", 14), i59 & 2) {
      let e = T().$implicit;
      T();
      let n = Ce(5);
      U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(2, lG, e));
    }
  }
  function xae(i59, t) {
    if (i59 & 1 && (b(0, "div", 20)(1, "mat-icon", 21), D(2, "my_location"), x()()), i59 & 2) {
      let e = T(2);
      U("matTooltip", e.locatorTooltip)("matTooltipPosition", e.tooltipPosition);
    }
  }
  function wae(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "mat-tree-node", 25)(1, "div", 26), Z("click", function(r) {
        let o = q(e).$implicit, s = T();
        return Y(s.handleLocateNode(o, r.altKey));
      }), b(2, "div", 9)(3, "button", 27)(4, "mat-icon", 28), D(5), x()(), b(6, "div", 10), D(7), X(8, bae, 1, 4, "ng-container"), x()(), X(9, xae, 3, 2, "div", 13), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T();
      ye("has-locator", e.showLocator), U("matTreeNodePaddingIndent", n.treeItemPadding), Ke("data-id", e.nodeId), C(), ye("highlight", e.highlightGroupLabel), C(), ye("has-extra-data", e.extraData != null), C(), Ke("aria-label", "Toggle " + e.label), C(2), Oe(" ", n.treeControl.isExpanded(e) ? "keyboard_arrow_down" : "chevron_right", " "), C(2), Oe(" ", e.label, " "), C(), he(e.extraData ? 8 : -1), C(), U("ngIf", e.showLocator && n.showLocator);
    }
  }
  function Cae(i59, t) {
    if (i59 & 1 && (b(0, "div", 30)(1, "mat-icon"), D(2), x()()), i59 & 2) {
      let e = t.$implicit, n = T(2);
      U("matTooltip", n.getExtraLabelTooltip(e)), C(2), Qe(e);
    }
  }
  function Sae(i59, t) {
    if (i59 & 1 && (b(0, "div", 29), Qt(1, Cae, 3, 2, "div", 30, mr), x()), i59 & 2) {
      let e = t.node;
      C(), Kt(e.extraData.matchTypes);
    }
  }
  var Ul = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      data;
      solidBackground = false;
      rendererId = "";
      tooltipPosition = "left";
      showLocator = true;
      colorBoldNodeLabel = false;
      onClose = new Ue();
      tree;
      constValuesPopupSize = { minWidth: 100 };
      constValuesPopupPosition = [{ originX: "start", originY: "top", overlayX: "end", overlayY: "top" }];
      locatorTooltip = `Click: locate
Alt+click: select`;
      transformer = (e, n) => ({ nodeId: e.nodeId, node: e.node, expandable: !!e.children && e.children.length > 0, label: e.label, boldLabel: e.boldLabel, level: n, showLocator: e.showLocator, highlight: e.highlight, metadata: e.metadata, extraData: e.extraData });
      curSearchMatches = [];
      treeItemPadding = 8;
      treeControl = new Jx((e) => e.level, (e) => e.expandable);
      treeFlattener = new nw(this.transformer, (e) => e.level, (e) => e.expandable, (e) => e.children);
      dataSource = new iw(this.treeControl, this.treeFlattener);
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n;
      }
      ngOnChanges(e) {
        this.data != null && (this.dataSource.data = this.data, this.treeControl.expandAll());
      }
      updateData(e) {
        this.data = e, this.dataSource.data = this.data, this.treeControl.expandAll(), this.changeDetectorRef.markForCheck();
      }
      updateSearchResults(e) {
        this.curSearchMatches = e, this.changeDetectorRef.markForCheck();
      }
      handleLocateNode(e, n) {
        e.showLocator && (this.appService.curToLocateNodeInfo.set({ nodeId: e.nodeId || "", rendererId: this.rendererId, isGroupNode: e.expandable, select: n }), this.onClose.emit({}));
      }
      hasChild(e, n) {
        return n.expandable;
      }
      hasMetadata(e) {
        return e.metadata != null && Object.keys(e.metadata).length > 0;
      }
      getSortedMetadataKeys(e) {
        return Object.keys(e.metadata || {}).filter((n) => !n.startsWith("__")).sort();
      }
      showHoverForValuesLabel(e) {
        let n = e.node;
        if (!n) return false;
        if (dt(n)) {
          let r = n.attrs || {};
          if (r[_a]) return r[_a] !== "DATA_ELIDED";
        }
        return false;
      }
      getMaxConstValueCount() {
        return this.appService.config()?.maxConstValueCount ?? 0;
      }
      getConstValues(e) {
        let n = e.node;
        if (!n) return "";
        if (dt(n)) {
          let o = (n.attrs || {})[_a];
          return o && typeof o == "string" ? o : "<empty>";
        }
        return "";
      }
      getExtraLabelTooltip(e) {
        switch (e) {
          case _t.NODE_LABEL:
            return "Node label matched";
          case _t.ATTRIBUTE:
            return "Node attribute(s) matched";
          case _t.INPUT_METADATA:
            return "Input(s) matched";
          case _t.OUTPUT_METADATA:
            return "Output(s) matched";
          default:
            return "";
        }
      }
      isSearchMatched(e, n) {
        return this.curSearchMatches ? this.curSearchMatches.find((r) => r.matchedText === e || r.matchedText === n) != null : false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["io-tree"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(lae, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.tree = o.first);
        }
      }, inputs: { data: "data", solidBackground: "solidBackground", rendererId: "rendererId", tooltipPosition: "tooltipPosition", showLocator: "showLocator", colorBoldNodeLabel: "colorBoldNodeLabel" }, outputs: { onClose: "onClose" }, features: [yn], decls: 6, vars: 7, consts: [["tree", ""], ["matchTypes", ""], ["constValuesPopup", ""], [1, "io-tree", 3, "dataSource", "treeControl"], ["class", "leaf", "matTreeNodePadding", "", 3, "has-locator", "has-values", "highlight", "has-metadata", "bubble", "overlaySize", "overlayPositions", "hoverDelayMs", "bubbleDisabled", "matTreeNodePaddingIndent", 4, "matTreeNodeDef"], ["matTreeNodePadding", "", 3, "has-locator", "matTreeNodePaddingIndent", 4, "matTreeNodeDef", "matTreeNodeDefWhen"], ["matTreeNodePadding", "", 1, "leaf", 3, "bubble", "overlaySize", "overlayPositions", "hoverDelayMs", "bubbleDisabled", "matTreeNodePaddingIndent"], [1, "edge-node", 3, "click"], [1, "label-and-metadata"], [1, "label-container"], [1, "label"], [1, "node-label"], ["class", "metadata-table", 4, "ngIf"], ["class", "locator-container", "matTooltipClass", "multiline-tooltip-left", 3, "matTooltip", "matTooltipPosition", 4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "metadata-table"], [3, "search-match", 4, "ngFor", "ngForOf"], [1, "key"], [1, "bullet"], [1, "value"], ["matTooltipClass", "multiline-tooltip-left", 1, "locator-container", 3, "matTooltip", "matTooltipPosition"], [1, "locator-icon"], [1, "model-explorer-const-values-popup"], [1, "values-count-msg"], [1, "content"], ["matTreeNodePadding", "", 3, "matTreeNodePaddingIndent"], [1, "expandable-tree-node", 3, "click"], ["mat-icon-button", "", "matTreeNodeToggle", "", 1, "expand-icon-button"], [1, "expander"], [1, "match-types-container"], [1, "extra-label-container", 3, "matTooltip"]], template: function(n, r) {
        n & 1 && (b(0, "mat-tree", 3, 0), X(2, vae, 13, 25, "mat-tree-node", 4)(3, wae, 10, 13, "mat-tree-node", 5), x(), X(4, Sae, 3, 0, "ng-template", null, 1, Tt)), n & 2 && (ye("solid-background", r.solidBackground), U("dataSource", r.dataSource)("treeControl", r.treeControl)("@transformPanel", "showing")("@.disabled", !r.solidBackground), C(3), U("matTreeNodeDefWhen", r.hasChild));
      }, dependencies: [Bn, et, Wr, In, Ss, Hn, pl, vt, St, tn, $n, nG, KU, JU, tG, eG, QU], styles: [`.io-tree[_ngcontent-%COMP%]{background-color:transparent;padding-top:4px}.io-tree.solid-background[_ngcontent-%COMP%]{transform-origin:top center;background-color:#fff;border:1px solid #ccc;border-radius:4px;padding-bottom:8px;min-width:270px;box-shadow:0 4px 6px -1px #0000001a,0 2px 4px -2px #0000001a}.io-tree[_ngcontent-%COMP%]   mat-tree-node.has-locator[_ngcontent-%COMP%], .io-tree[_ngcontent-%COMP%]   mat-tree-node.has-values[_ngcontent-%COMP%]{cursor:pointer}.io-tree[_ngcontent-%COMP%]   mat-tree-node.has-locator[_ngcontent-%COMP%]:hover, .io-tree[_ngcontent-%COMP%]   mat-tree-node.has-values[_ngcontent-%COMP%]:hover{background-color:#f3f3f3}.io-tree[_ngcontent-%COMP%]   mat-tree-node.highlight[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{color:#00639b;font-weight:500}.io-tree[_ngcontent-%COMP%]   mat-tree-node[_ngcontent-%COMP%]:not(:last-child).has-metadata.leaf{margin-bottom:6px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]{display:flex;align-items:flex-start;justify-content:space-between;width:100%;box-sizing:border-box;padding-right:12px;padding-left:27px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]:hover   .locator-container[_ngcontent-%COMP%]{opacity:.8}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata.has-extra-data[_ngcontent-%COMP%]{width:100%}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata.has-extra-data[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:100%;justify-content:space-between}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%], .io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{display:flex;align-items:center}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%]   .node-label.color-bold[_ngcontent-%COMP%]{color:#00639b;font-weight:500}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%]   .node-label.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .hover-for-values-label[_ngcontent-%COMP%]{text-decoration:underline;text-decoration-style:dotted;color:#999;margin-left:8px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]{border-spacing:0;border-collapse:collapse;padding:0;font-size:11px;margin-top:2px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]{vertical-align:text-top}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   mat-icon.bullet[_ngcontent-%COMP%]{font-size:4px;width:5px;height:5px;color:#bbb;margin-right:2px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.key[_ngcontent-%COMP%]{color:#999;padding-right:4px;white-space:nowrap;line-height:12px}.io-tree[_ngcontent-%COMP%]   .edge-node[_ngcontent-%COMP%]   .label-and-metadata[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.value[_ngcontent-%COMP%]{line-height:12px}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%], .io-tree[_ngcontent-%COMP%]   mat-tree-node[_ngcontent-%COMP%]{font-size:13px;min-height:22px;word-break:break-word}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]{color:#999;display:flex;align-items:center;justify-content:space-between;width:100%;box-sizing:border-box;padding-right:12px;padding-left:4px}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node.highlight[_ngcontent-%COMP%]{color:#000000de}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]:hover   .locator-container[_ngcontent-%COMP%]{opacity:.8}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]   mat-icon.expander[_ngcontent-%COMP%]{color:#999}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%]{display:flex;align-items:center}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]   .label-container.has-extra-data[_ngcontent-%COMP%]{width:100%}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]   .label-container.has-extra-data[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{flex-grow:1;justify-content:space-between}.io-tree[_ngcontent-%COMP%]   .expandable-tree-node[_ngcontent-%COMP%]   .label-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{display:flex;align-items:center}.io-tree[_ngcontent-%COMP%]   .expand-icon-button[_ngcontent-%COMP%]{padding:0;width:24px;height:24px;display:flex;align-items:center;justify-content:center}.io-tree[_ngcontent-%COMP%]   .expand-icon-button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:18px;margin-top:6px}.io-tree[_ngcontent-%COMP%]   .locator-container[_ngcontent-%COMP%]{height:18px;opacity:.5;cursor:pointer;display:flex;align-items:center}.io-tree[_ngcontent-%COMP%]   .locator-container[_ngcontent-%COMP%]   mat-icon.locator-icon[_ngcontent-%COMP%]{color:#333;font-size:16px;width:16px;height:16px}.io-tree[_ngcontent-%COMP%]   .locator-container[_ngcontent-%COMP%]:hover{opacity:.8}.io-tree[_ngcontent-%COMP%]   .match-types-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-self:center;gap:2px;margin-left:8px}.io-tree[_ngcontent-%COMP%]   .extra-label-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-self:center;padding:4px;border-radius:99px;background-color:#e8f0fe;box-sizing:border-box}.io-tree[_ngcontent-%COMP%]   .extra-label-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:12px;width:12px;height:12px;color:#9da3a9}.io-tree[_ngcontent-%COMP%]     .mat-mdc-button-touch-target{width:24px;height:24px}.io-tree-invisible[_ngcontent-%COMP%]{display:none}.io-tree[_ngcontent-%COMP%]   ul[_ngcontent-%COMP%], .io-tree[_ngcontent-%COMP%]   li[_ngcontent-%COMP%]{margin-top:0;margin-bottom:0;list-style-type:none}.io-tree[_ngcontent-%COMP%]   .mat-nested-tree-node[_ngcontent-%COMP%]   div[role=group][_ngcontent-%COMP%]{padding-left:8px}.io-tree[_ngcontent-%COMP%]   div[role=group][_ngcontent-%COMP%] > .mat-tree-node[_ngcontent-%COMP%]{padding-left:16px}  bubble-container:has(.model-explorer-const-values-popup){width:100%}  .model-explorer-const-values-popup{padding:8px;font-size:11px;line-height:12px;background-color:#fff}  .model-explorer-const-values-popup .values-count-msg{margin-bottom:8px;color:#999}  .model-explorer-const-values-popup .content{white-space:pre-wrap;font-family:monospace}

















`], data: { animation: ow }, changeDetection: 0 });
    }
    return i59;
  })();
  function Ha(i59, t, e, n, r = []) {
    let o = { label: "<root>", children: [], type: e, isGroupNode: true }, s = [];
    for (let l = 0; l < i59.length; l++) {
      let c = i59[l], d = t[l], u = r[l];
      if (dt(c) && c.hideInLayout) s.push({ node: c, index: l, metadata: d });
      else {
        let h = Mae(c.savedNamespace || c.namespace, o);
        if (h) {
          h.children == null && (h.children = []);
          let p = h.children.find((f) => f.label === c.label && f.isGroupNode);
          if (p == null) {
            let f = { label: c.label, boldLabel: aG(d), nodeId: c.id, node: c, type: e, showLocator: true, highlight: c.id === n, isGroupNode: c.nodeType === Ds.GROUP_NODE, metadata: d };
            u != null && (f.extraData = u), h.children.push(f);
          } else p.nodeId = c.id, p.showLocator = true, p.extraData = u;
        }
      }
    }
    o = Eae(o);
    let a = [o];
    if (s.length > 0) {
      let l = "weights";
      for (let c of s) if (!c.node.label.toLowerCase().includes("const")) {
        l = "<hidden>";
        break;
      }
      a.push({ label: l, children: s.map((c) => ({ label: c.node.label, boldLabel: aG(c.metadata), nodeId: c.node.id, node: c.node, type: e, showLocator: false, highlight: c.node.id === n, isGroupNode: false, metadata: t[c.index] })), type: e, isGroupNode: false });
    }
    return a;
  }
  function aG(i59) {
    if (i59) return i59[To];
  }
  function Mae(i59, t) {
    let e = i59 ? ["<root>", ...i59.split("/")] : ["<root>"], n, r = [];
    for (let o of e) if (o !== "<root>" && r.push(o), o === "<root>") n = t;
    else {
      n && !n.children && (n.children = []);
      let s = n.children.find((a) => a.label === o);
      if (s == null) {
        let a = { label: o, children: [], type: t.type, isGroupNode: true };
        n.children.push(a), n = a;
      } else n = s;
    }
    return n;
  }
  function Eae(i59) {
    let t = i59, e = [];
    for (; e.push(t.label), t?.children && t.children.length === 1 && (t.children[0].children || []).length > 0 && !t.showLocator; ) t = t.children[0];
    return t !== i59 && (t.label = e.join(" / ")), t;
  }
  var Tae = pn;
  var Hi = (() => {
    class i59 {
      charsInfoRegular = {};
      charsInfoMedium = {};
      charsInfoBold = {};
      charsInfoIcons = {};
      textureRegular;
      textureMedium;
      textureBold;
      textureIcons;
      fontInfoRegular;
      fontInfoMedium;
      fontInfoBold;
      fontInfoIcons;
      depsLoadedPromise;
      constructor() {
        this.depsLoadedPromise = new Promise((e) => $t(this, null, function* () {
          yield this.loadDeps(), e();
        }));
      }
      loadDeps() {
        return $t(this, null, function* () {
          let e = window.modelExplorer?.assetFilesBaseUrl ?? "static_files", n = yield Promise.all([this.loadFontAtals(`${e}/FontRegular.png`), this.loadFontAtals(`${e}/FontMedium.png`), this.loadFontAtals(`${e}/FontBold.png`), this.loadFontAtals(`${e}/icons_20240521.png`), this.loadFontInfo(`${e}/FontRegular.json`), this.loadFontInfo(`${e}/FontMedium.json`), this.loadFontInfo(`${e}/FontBold.json`), this.loadFontInfo(`${e}/icons_20240521.json`)]);
          this.textureRegular = n[0], this.textureMedium = n[1], this.textureBold = n[2], this.textureIcons = n[3], this.charsInfoRegular = n[4].charsInfo, this.charsInfoMedium = n[5].charsInfo, this.charsInfoBold = n[6].charsInfo, this.charsInfoIcons = n[7].charsInfo, this.fontInfoRegular = n[4].fontInfo, this.fontInfoMedium = n[5].fontInfo, this.fontInfoBold = n[6].fontInfo, this.fontInfoIcons = n[7].fontInfo;
        });
      }
      getCharsInfo(e) {
        switch (e) {
          case Jt.REGULAR:
            return this.charsInfoRegular;
          case Jt.MEDIUM:
            return this.charsInfoMedium;
          case Jt.BOLD:
            return this.charsInfoBold;
          case Jt.ICONS:
            return this.charsInfoIcons;
          default:
            return this.charsInfoRegular;
        }
      }
      getFontInfo(e) {
        switch (e) {
          case Jt.REGULAR:
            return this.fontInfoRegular;
          case Jt.MEDIUM:
            return this.fontInfoMedium;
          case Jt.BOLD:
            return this.fontInfoBold;
          case Jt.ICONS:
            return this.fontInfoIcons;
          default:
            return this.fontInfoRegular;
        }
      }
      loadFontAtals(e) {
        return $t(this, null, function* () {
          return new Promise((n) => {
            new Tae.TextureLoader().load(e, (r) => {
              n(r);
            });
          });
        });
      }
      loadFontInfo(e) {
        return $t(this, null, function* () {
          let r = yield (yield fetch(e)).json(), o = {};
          for (let s of r.chars) o[s.char] = s;
          return { fontInfo: r, charsInfo: o };
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var ar = pn;
  var Dae = `
precision highp float;

#define PI 3.1415926535897932384626433832795

uniform float edgeWidth;
uniform float animationProgress;

attribute vec4 endPoints;
attribute vec4 targetEndPoints;
attribute vec3 color;
attribute float yOffset;

varying vec3 vColor;

float atan2(in float y, in float x) {
  bool s = (abs(x) > abs(y));
  return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}

void main() {
  vColor = color;

  vec3 pos = position;

  float curStartX = endPoints.x;
  float curStartY = endPoints.y;
  float curEndX = endPoints.z;
  float curEndY = endPoints.w;
  float targetStartX = targetEndPoints.x;
  float targetStartY = targetEndPoints.y;
  float targetEndX = targetEndPoints.z;
  float targetEndY = targetEndPoints.w;

  float progress = animationProgress * step(0.0, animationProgress); 
  float startX = curStartX + (targetStartX - curStartX) * progress;
  float startY = curStartY + (targetStartY - curStartY) * progress;
  float endX = curEndX + (targetEndX - curEndX) * progress;
  float endY = curEndY + (targetEndY - curEndY) * progress;

  float length = distance(vec2(startX, startY), vec2(endX, endY));
  pos.x = (step(0.0, pos.x) * 2.0 - 1.0) * (edgeWidth / 2.0);
  pos.z = (step(0.0, pos.z) * 2.0 - 1.0) * (length / 2.0);

  float angle = PI / 2.0 - atan2(endY - startY, endX - startX);
  float c = cos(angle);
  float s = sin(angle);

  float posX = pos.x;
  float posZ = pos.z;
  pos.x = posX * c + posZ * s;
  pos.z = posZ * c - posX * s;

  float centerX = (startX + endX) / 2.0;
  float centerZ = (startY + endY) / 2.0;

  gl_Position = projectionMatrix * modelViewMatrix *
      vec4(pos.x + centerX, yOffset, pos.z + centerZ, 1.0);
}
`;
  var Pae = `
precision highp float;

varying vec3 vColor;

void main() {
  gl_FragColor = vec4(vColor, 1.0);
}
`;
  var Rae = `
precision highp float;

#define PI 3.1415926535897932384626433832795

uniform float animationProgress;

// End points of the last segment of the edge.
attribute vec4 endPoints;
attribute vec4 targetEndPoints;
attribute vec3 color;
attribute float yOffset;

varying vec3 vColor;

float atan2(in float y, in float x) {
  bool s = (abs(x) > abs(y));
  return mix(PI/2.0 - atan(x,y), atan(y,x), s);
}

void main() {
  vColor = color;

  vec3 pos = position;

  float curStartX = endPoints.x;
  float curStartY = endPoints.y;
  float curEndX = endPoints.z;
  float curEndY = endPoints.w;
  float targetStartX = targetEndPoints.x;
  float targetStartY = targetEndPoints.y;
  float targetEndX = targetEndPoints.z;
  float targetEndY = targetEndPoints.w;

  float progress = animationProgress * step(0.0, animationProgress); 
  float startX = curStartX + (targetStartX - curStartX) * progress;
  float startY = curStartY + (targetStartY - curStartY) * progress;
  float endX = curEndX + (targetEndX - curEndX) * progress;
  float endY = curEndY + (targetEndY - curEndY) * progress;

  float angle = PI - atan2(endY - startY, endX - startX) + PI / 2.0;
  float c = cos(angle);
  float s = sin(angle);

  float posX = pos.x;
  float posZ = pos.z;
  pos.x = posX * c + posZ * s;
  pos.z = posZ * c - posX * s;

  gl_Position = projectionMatrix * modelViewMatrix *
      vec4(pos.x + endX, yOffset, pos.z + endY, 1.0);
}
`;
  var Oae = `
precision highp float;

varying vec3 vColor;

void main() {
  gl_FragColor = vec4(vColor, 1.0);
}
`;
  var Aae = 6;
  var ND = 6;
  var Nae = 4;
  var ja = class {
    color;
    edgeWidth;
    arrowScale;
    edgesMesh;
    material;
    arrowHeadMat;
    arrowHeadsMesh;
    planeGeo;
    arrowHeadGeometry;
    savedEdgeSegments = {};
    savedEdges = {};
    savedArrowHeads = {};
    curAnimationProgrssUniform = { value: -1 };
    originalColors = [];
    originalYOffsets = [];
    originalArrowHeadYOffsets = [];
    lastColorUpdateEdgeSegments = [];
    lastColorUpdateArrowHeads = [];
    lastYOffsetsUpdateEdgeSegments = [];
    lastYOffsetsUpdateArrowHeads = [];
    constructor(t, e, n = 1) {
      this.color = t, this.edgeWidth = e, this.arrowScale = n, this.planeGeo = new ar.PlaneGeometry(1, 1), this.planeGeo.rotateX(-Math.PI / 2), this.material = new ar.ShaderMaterial({ uniforms: { edgeWidth: { value: this.edgeWidth }, animationProgress: this.curAnimationProgrssUniform }, vertexShader: Dae, fragmentShader: Pae, transparent: true });
      let r = new ar.Shape(), o = Aae * n, s = ND * n, a = Nae * n;
      r.moveTo(-o / 2, -s).lineTo(0, -a).lineTo(o / 2, -s).lineTo(0, 0).lineTo(-o / 2, -s), this.arrowHeadGeometry = new ar.ShapeGeometry(r), this.arrowHeadGeometry.rotateX(-Math.PI / 2), this.arrowHeadMat = new ar.ShaderMaterial({ uniforms: { animationProgress: this.curAnimationProgrssUniform }, vertexShader: Rae, fragmentShader: Oae, transparent: true });
    }
    generateMesh(t, e, n = false) {
      if (t.length === 0) {
        this.edgesMesh = void 0, this.arrowHeadsMesh = void 0;
        return;
      }
      let r = [], o = [], s = [], a = [], l = [], c = [], d = [], u = [], h = {}, p = {};
      this.savedEdges = {};
      let f = 0, m = 0;
      for (let { edge: g, index: y } of t) {
        let w = g.curvePoints || [], E = e.nodesById[g.fromNodeId], P = e.nodesById[g.toNodeId], S = E.globalX || 0, A = E.globalY || 0;
        for (let W = 0; W < w.length - 1; W++) {
          let H = w[W], O = w[W + 1], I = `${E.id}__${P.id}___${W}`, F = [H.x + S, H.y + A, O.x + S, O.y + A], j = [...F];
          if (W === w.length - 2 && w.length >= 2) {
            let k = Math.atan2(O.y - H.y, O.x - H.x);
            F[2] -= Math.cos(k) * ND * this.arrowScale / 2, F[3] -= Math.sin(k) * ND * this.arrowScale / 2;
          }
          let $ = this.savedEdgeSegments[I];
          if (n ? r.push(...F) : $ ? r.push(...$.endPoints) : r.push(...F), o.push(...F), c.push(y * At), l.push(this.color.r, this.color.g, this.color.b), h[I] = { endPoints: F, index: f }, this.savedEdges[g.id] == null && (this.savedEdges[g.id] = []), this.savedEdges[g.id].push(h[I]), W === w.length - 2) {
            let k = g.id, z = j, R = this.savedArrowHeads[k];
            n ? s.push(...z) : R ? s.push(...R.lastSegmentEndPoints) : s.push(...z), a.push(...z), d.push(y * At + At / 2), u.push(this.color.r, this.color.g, this.color.b), p[k] = { index: m, lastSegmentEndPoints: z };
          }
          f++;
        }
        m++;
      }
      this.savedEdgeSegments = h, this.savedArrowHeads = p, this.originalColors = l, this.originalYOffsets = c, this.originalArrowHeadYOffsets = d;
      let v = new ar.InstancedBufferGeometry().copy(this.planeGeo);
      v.instanceCount = c.length, v.setAttribute("endPoints", new ar.InstancedBufferAttribute(new Float32Array(r), 4)), v.setAttribute("targetEndPoints", new ar.InstancedBufferAttribute(new Float32Array(o), 4)), v.setAttribute("color", new ar.InstancedBufferAttribute(new Float32Array(l), 3)), v.setAttribute("yOffset", new ar.InstancedBufferAttribute(new Float32Array(c), 1)), this.edgesMesh = new ar.Mesh(v, this.material), this.edgesMesh.frustumCulled = false;
      let _ = new ar.InstancedBufferGeometry().copy(this.arrowHeadGeometry);
      _.instanceCount = d.length, _.setAttribute("endPoints", new ar.InstancedBufferAttribute(new Float32Array(s), 4)), _.setAttribute("targetEndPoints", new ar.InstancedBufferAttribute(new Float32Array(a), 4)), _.setAttribute("color", new ar.InstancedBufferAttribute(new Float32Array(u), 3)), _.setAttribute("yOffset", new ar.InstancedBufferAttribute(new Float32Array(d), 1)), this.arrowHeadsMesh = new ar.Mesh(_, this.arrowHeadMat), this.arrowHeadsMesh.frustumCulled = false;
    }
    updateColors(t, e) {
      if (this.edgesMesh) {
        let n = this.edgesMesh.geometry.getAttribute("color");
        if (t.length > 0) for (let r of t) for (let o of this.savedEdges[r] || []) {
          let s = o.index;
          n.setXYZ(s, e.r, e.g, e.b), this.lastColorUpdateEdgeSegments.push(o);
        }
        n.needsUpdate = true;
      }
      if (this.arrowHeadsMesh) {
        let n = this.arrowHeadsMesh.geometry.getAttribute("color");
        if (t.length > 0) for (let r of t) {
          let o = this.savedArrowHeads[r], s = o.index;
          n.setXYZ(s, e.r, e.g, e.b), this.lastColorUpdateArrowHeads.push(o);
        }
        n.needsUpdate = true;
      }
    }
    updateYOffsets(t, e) {
      if (this.edgesMesh) {
        let n = this.edgesMesh.geometry.getAttribute("yOffset");
        if (t.length > 0) for (let r of t) for (let o of this.savedEdges[r] || []) {
          let s = o.index;
          n.setX(s, e), this.lastYOffsetsUpdateEdgeSegments.push(o);
        }
        n.needsUpdate = true;
      }
      if (this.arrowHeadsMesh) {
        let n = this.arrowHeadsMesh.geometry.getAttribute("yOffset");
        if (t.length > 0) for (let r of t) {
          let o = this.savedArrowHeads[r], s = o.index;
          n.setX(s, e), this.lastYOffsetsUpdateArrowHeads.push(o);
        }
        n.needsUpdate = true;
      }
    }
    restoreColors() {
      if (this.edgesMesh) {
        let t = this.edgesMesh.geometry.getAttribute("color");
        if (this.lastColorUpdateEdgeSegments.length > 0) {
          for (let e of this.lastColorUpdateEdgeSegments) {
            let n = e.index;
            t.setXYZ(n, this.originalColors[n * 3], this.originalColors[n * 3 + 1], this.originalColors[n * 3 + 2]);
          }
          t.needsUpdate = true;
        }
        this.lastColorUpdateEdgeSegments = [];
      }
      if (this.arrowHeadsMesh) {
        let t = this.arrowHeadsMesh.geometry.getAttribute("color");
        if (this.lastColorUpdateArrowHeads.length > 0) {
          for (let e of this.lastColorUpdateArrowHeads) {
            let n = e.index;
            t.setXYZ(n, this.originalColors[n * 3], this.originalColors[n * 3 + 1], this.originalColors[n * 3 + 2]);
          }
          t.needsUpdate = true;
        }
        this.lastColorUpdateArrowHeads = [];
      }
    }
    restoreYOffsets() {
      if (this.edgesMesh) {
        let t = this.edgesMesh.geometry.getAttribute("yOffset");
        if (this.lastYOffsetsUpdateEdgeSegments.length > 0) {
          for (let e of this.lastYOffsetsUpdateEdgeSegments) {
            let n = e.index;
            t.setX(n, this.originalYOffsets[n]);
          }
          t.needsUpdate = true;
        }
        this.lastYOffsetsUpdateEdgeSegments = [];
      }
      if (this.arrowHeadsMesh) {
        let t = this.arrowHeadsMesh.geometry.getAttribute("yOffset");
        if (this.lastYOffsetsUpdateArrowHeads.length > 0) {
          for (let e of this.lastYOffsetsUpdateArrowHeads) {
            let n = e.index;
            t.setX(n, this.originalArrowHeadYOffsets[n]);
          }
          t.needsUpdate = true;
        }
        this.lastYOffsetsUpdateArrowHeads = [];
      }
    }
    clear() {
      this.edgesMesh && this.edgesMesh.removeFromParent(), this.arrowHeadsMesh && this.arrowHeadsMesh.removeFromParent();
    }
    clearSavedDataForAnimation() {
      this.savedEdgeSegments = {}, this.savedEdges = {}, this.savedArrowHeads = {};
    }
    updateAnimationProgress(t) {
      this.edgesMesh && (this.curAnimationProgrssUniform.value = t);
    }
  };
  var ji = pn;
  var kae = `
precision highp float;

uniform float borderRadius;
// Set this to <0 to disable animation.
uniform float animationProgress;
uniform vec4 bgColorWhenFar;

attribute vec4 bound;
attribute vec4 targetBound;
attribute float yOffset;
attribute float isRounded;
attribute float borderWidth;
attribute vec3 bgColor;
attribute vec3 borderColor;
attribute float angle;
attribute float opacity;
attribute float changeColorWhenFar;

varying vec2 vUv;
varying vec2 vSize;
varying float vIsRounded;
varying float vBorderWidth;
varying vec3 vBgColor;
varying vec3 vBorderColor;
varying float vOpacity;
varying float vChangeColorWhenFar;

void main() {
  vUv = uv;
  vIsRounded = isRounded;
  vBorderWidth = borderWidth;
  vBgColor = bgColor;
  vBorderColor = borderColor;
  vOpacity = opacity;
  vChangeColorWhenFar = changeColorWhenFar;

  vec3 pos = position;
  float curX = bound.x;
  float curY = bound.y;
  float curW = bound.z;
  float curH = bound.w;

  float progress = animationProgress * step(0.0, animationProgress); 
  float x = curX + (targetBound.x - curX) * progress;
  float y = curY + (targetBound.y - curY) * progress;
  float w = curW + (targetBound.z - curW) * progress;
  float h = curH + (targetBound.w - curH) * progress;
  vSize = vec2(w, h);

  // For each vertex, move it by delta calculated below so that the final
  // rectangle's width and height match the width and height stored in "bound".
  //
  // pos.x < 0: the first () below returns -1.
  // pos.x > 0: the first () below returns 1.
  pos.x = (step(0.0, pos.x) * 2.0 - 1.0) * (w / 2.0);
  pos.z = (step(0.0, pos.z) * 2.0 - 1.0) * (h / 2.0);

  // Rotate.
  //
  float c = cos(angle);
  float s = sin(angle);
  float posX = pos.x * c + pos.z * s;
  float posZ = pos.z * c - pos.x * s;

  gl_Position = projectionMatrix * modelViewMatrix *
      vec4(posX + x, yOffset, posZ + y, 1.0);
}
`;
  var Lae = `
precision highp float;

uniform float borderRadius;
uniform vec4 bgColorWhenFar;

varying vec2 vUv;
varying vec2 vSize;
varying float vIsRounded;
varying float vBorderWidth;
varying vec3 vBgColor;
varying vec3 vBorderColor;
varying float vOpacity;
varying float vChangeColorWhenFar;

// See:
// https://www.shadertoy.com/view/4tc3DX#

// Clamp [0..1] range
#define saturate(a) clamp(a, 0.0, 1.0)

// This function will make a signed distance field that says how far you are
// from the edge of the line at any point U,V.
// Pass it UVs, line end points, line thickness (x is along the line and y is
// perpendicular), How rounded the end points should be (0.0 is rectangular,
// setting rounded to thick.y will be circular).
float LineDistField(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded, float dashOn) {
  // Don't let it get more round than circular.
  rounded = min(thick.y, rounded);
  // midpoint
  vec2 mid = (pB + pA) * 0.5;
  // vector from point A to B
  vec2 delta = pB - pA;
  // Distance between endpoints
  float lenD = length(delta);
  // unit vector pointing in the line's direction
  vec2 unit = delta / lenD;
  // Check for when line endpoints are the same
  if (lenD < 0.0001) unit = vec2(1.0, 0.0);	// if pA and pB are same
  // Perpendicular vector to unit - also length 1.0
  vec2 perp = unit.yx * vec2(-1.0, 1.0);
  // position along line from midpoint
  float dpx = dot(unit, uv - mid);
  // distance away from line at a right angle
  float dpy = dot(perp, uv - mid);
  // Make a distance function that is 0 at the transition from black to white
  float disty = abs(dpy) - thick.y + rounded;
  float distx = abs(dpx) - lenD * 0.5 - thick.x + rounded;

  // Too tired to remember what this does. Something like rounded endpoints for distance function.
  float dist = length(vec2(max(0.0, distx), max(0.0,disty))) - rounded;
  dist = min(dist, max(distx, disty));

  return dist;
}

// This makes a line in UV units. A 1.0 thick line will span a whole 0..1 in
// UV space.
float FillLine(vec2 uv, vec2 pA, vec2 pB, vec2 thick, float rounded) {
  float df = LineDistField(uv, pA, pB, vec2(thick), rounded, 0.0);
  return saturate(df / abs(dFdy(uv).y));
}

void main() {
  // Normalize uv.
  vec2 uv = vUv;
  uv -= 0.5;
  float aspect = vSize.x / vSize.y;
  uv.x *= aspect;

  vec4 finalColor = vec4(1.0);

  float radius = mix(1.0 / vSize.y, borderRadius / vSize.y, step(0.5, vIsRounded));
  float borderWidth = vBorderWidth / vSize.y;

  // Border.
  float c = FillLine(uv,
    vec2(-0.5 * aspect, 0.0), vec2(0.5 * aspect, 0.0), vec2(0.0, 0.5), radius);
  finalColor = mix(vec4(vBorderColor.rgb, 1.0), vec4(1.0, 1.0, 1.0, 0.0), c);

  // Body.
  float c2 = FillLine(uv,
    vec2(-0.5 * aspect + borderWidth, 0.0),
    vec2(0.5 * aspect - borderWidth, 0.0), vec2(0.0, 0.5 - borderWidth),
    radius - 1.0 / vSize.y);
  finalColor = mix(vec4(vBgColor.rgb, 1.0), finalColor, c2);
  finalColor = saturate(finalColor);
  finalColor.rgb = mix(finalColor.rgb, bgColorWhenFar.rgb, bgColorWhenFar.a * vChangeColorWhenFar);

  float alpha = finalColor.w * vOpacity;
  if (alpha < 0.00001) {
    discard;
  }
  gl_FragColor = vec4(finalColor.rgb, alpha);
}
`;
  var ci = class {
    radius;
    mesh;
    meshForRayCasting;
    material;
    materialForRayCasting;
    planeGeo;
    hoveredRectangelId = "";
    curRectangles = [];
    savedRectangles = {};
    curAnimationProgrssUniform = { value: -1 };
    dummy = new ji.Object3D();
    originalBorderColors = [];
    originalBgColors = [];
    originalBorderWidths = [];
    originalOpacities = [];
    lastBorderColorUpdateRectangles = [];
    lastBgColorUpdateRectangles = [];
    lastBorderWidthUpdateRectangles = [];
    lastOpacityUpdateRectangles = [];
    constructor(t) {
      this.radius = t, this.planeGeo = new ji.PlaneGeometry(1, 1), this.planeGeo.rotateX(-Math.PI / 2), this.material = new ji.ShaderMaterial({ extensions: { derivatives: true }, uniforms: { borderRadius: { value: this.radius }, animationProgress: this.curAnimationProgrssUniform, bgColorWhenFar: { value: [0, 0, 0, 0] } }, vertexShader: kae, fragmentShader: Lae, transparent: true }), this.materialForRayCasting = new ji.MeshBasicMaterial({ opacity: 0, transparent: true });
    }
    generateMesh(t, e = false, n = false, r = false, o = false) {
      if (t.length === 0) {
        this.savedRectangles = {}, this.mesh = void 0, this.meshForRayCasting = void 0;
        return;
      }
      this.curRectangles = t;
      let s = [], a = [], l = [], c = [], d = [], u = [], h = [], p = [], f = [], m = [], v = Object.keys(this.savedRectangles).length > 0, _ = le({}, this.savedRectangles);
      this.savedRectangles = {};
      let g = 0;
      for (let w = 0; w < t.length; w++) {
        let E = t[w], P = E.bound, S = _[E.id]?.bound;
        (!v || n) && !r ? s.push(P.x, P.y, P.width, P.height) : s.push(S?.x ?? P.x, S?.y ?? P.y, S?.width ?? (o ? P.width : 0), S?.height ?? (o ? P.height : 0)), l.push(P.x, P.y, P.width, P.height), a.push(E.yOffset), c.push(E.isRounded ? 1 : 0), d.push(E.borderWidth), u.push(E.bgColor.r, E.bgColor.g, E.bgColor.b), h.push(E.borderColor.r, E.borderColor.g, E.borderColor.b), p.push(0), f.push(E.opacity), m.push(E.changeColorWhenFar ? 1 : 0), this.savedRectangles[E.id] = E, g++;
      }
      this.originalBorderColors = h, this.originalBgColors = u, this.originalBorderWidths = d, this.originalOpacities = f;
      let y = new ji.InstancedBufferGeometry().copy(this.planeGeo);
      if (y.instanceCount = t.length, y.setAttribute("bound", new ji.InstancedBufferAttribute(new Float32Array(s), 4)), y.setAttribute("targetBound", new ji.InstancedBufferAttribute(new Float32Array(l), 4)), y.setAttribute("yOffset", new ji.InstancedBufferAttribute(new Float32Array(a), 1)), y.setAttribute("isRounded", new ji.InstancedBufferAttribute(new Float32Array(c), 1)), y.setAttribute("borderWidth", new ji.InstancedBufferAttribute(new Float32Array(d), 1)), y.setAttribute("bgColor", new ji.InstancedBufferAttribute(new Float32Array(u), 3)), y.setAttribute("borderColor", new ji.InstancedBufferAttribute(new Float32Array(h), 3)), y.setAttribute("angle", new ji.InstancedBufferAttribute(new Float32Array(p), 1)), y.setAttribute("opacity", new ji.InstancedBufferAttribute(new Float32Array(f), 1)), y.setAttribute("changeColorWhenFar", new ji.InstancedBufferAttribute(new Float32Array(m), 1)), this.mesh = new ji.Mesh(y, this.material), this.mesh.frustumCulled = false, e) {
        this.meshForRayCasting = new ji.InstancedMesh(new ji.BoxGeometry(1, 1, 1), this.materialForRayCasting, t.length);
        for (let w = 0; w < t.length; w++) {
          let P = t[w].bound;
          this.setInstancePositionAndScale(this.meshForRayCasting, w, P.x, -10, P.y, P.width, P.height);
        }
        this.meshForRayCasting.frustumCulled = false;
      }
    }
    raycast(t, e, n = true) {
      if (!this.meshForRayCasting) return;
      let r = t.intersectObject(this.meshForRayCasting), o = "";
      if (r.length > 0) {
        let a = r[r.length - 1].instanceId;
        a != null && (o = this.getRectangleId(a));
      }
      if (this.hoveredRectangelId !== o) {
        this.hoveredRectangelId = o, n && (document.body.style.cursor = this.hoveredRectangelId === "" ? "default" : "pointer");
        let s = this.savedRectangles[this.hoveredRectangelId];
        e(this.hoveredRectangelId, s);
      }
    }
    updateBorderColor(t, e) {
      if (!this.mesh) return;
      t = t.filter((r) => r !== "");
      let n = this.mesh.geometry.getAttribute("borderColor");
      if (t.length > 0) for (let r of t) {
        let o = this.savedRectangles[r];
        if (!o) continue;
        let s = o.index;
        n.setXYZ(s, e.r, e.g, e.b), o.borderColor.r = e.r, o.borderColor.g = e.g, o.borderColor.b = e.b, this.lastBorderColorUpdateRectangles.push(o);
      }
      n.needsUpdate = true;
    }
    restoreBorderColors() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("borderColor");
      if (this.lastBorderColorUpdateRectangles.length >= 0) {
        for (let e of this.lastBorderColorUpdateRectangles) {
          let n = e.index;
          t.setXYZ(n, this.originalBorderColors[n * 3], this.originalBorderColors[n * 3 + 1], this.originalBorderColors[n * 3 + 2]), e.borderColor.r = this.originalBorderColors[n * 3], e.borderColor.g = this.originalBorderColors[n * 3 + 1], e.borderColor.b = this.originalBorderColors[n * 3 + 2];
        }
        t.needsUpdate = true;
      }
      this.lastBorderColorUpdateRectangles = [];
    }
    updateBgColor(t, e, n = false) {
      if (!this.mesh) return;
      t = t.filter((o) => o !== "");
      let r = this.mesh.geometry.getAttribute("bgColor");
      if (t.length > 0) for (let o of t) {
        let s = this.savedRectangles[o];
        if (!s) continue;
        let a = s.index;
        if (n) {
          let l = this.originalBgColors[a * 3], c = this.originalBgColors[a * 3 + 1], d = this.originalBgColors[a * 3 + 2];
          if (l !== 1 || c !== 1 || d !== 1) continue;
        }
        r.setXYZ(a, e.r, e.g, e.b), s.bgColor.r = e.r, s.bgColor.g = e.g, s.bgColor.b = e.b, this.lastBgColorUpdateRectangles.push(s);
      }
      r.needsUpdate = true;
    }
    restoreBgColors() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("bgColor");
      if (this.lastBgColorUpdateRectangles.length >= 0) {
        for (let e of this.lastBgColorUpdateRectangles) {
          let n = e.index;
          t.setXYZ(n, this.originalBgColors[n * 3], this.originalBgColors[n * 3 + 1], this.originalBgColors[n * 3 + 2]), e.bgColor.r = this.originalBgColors[n * 3], e.bgColor.g = this.originalBgColors[n * 3 + 1], e.bgColor.b = this.originalBgColors[n * 3 + 2];
        }
        t.needsUpdate = true;
      }
      this.lastBgColorUpdateRectangles = [];
    }
    updateBorderWidth(t, e) {
      if (!this.mesh) return;
      t = t.filter((r) => r !== "");
      let n = this.mesh.geometry.getAttribute("borderWidth");
      if (t.length > 0) for (let r of t) {
        let o = this.savedRectangles[r];
        if (!o) continue;
        let s = o.index;
        n.setX(s, e), o.borderWidth = e, this.lastBorderWidthUpdateRectangles.push(o);
      }
      n.needsUpdate = true;
    }
    restoreBorderWidths() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("borderWidth");
      if (this.lastBorderWidthUpdateRectangles.length >= 0) {
        for (let e of this.lastBorderWidthUpdateRectangles) {
          let n = e.index;
          t.setX(n, this.originalBorderWidths[n]), e.borderWidth = this.originalBorderWidths[n];
        }
        t.needsUpdate = true;
      }
      this.lastBorderWidthUpdateRectangles = [];
    }
    updateOpacity(t, e) {
      if (!this.mesh) return;
      t = t.filter((r) => r !== "");
      let n = this.mesh.geometry.getAttribute("opacity");
      if (t.length > 0) for (let r of t) {
        let o = this.savedRectangles[r];
        if (!o) continue;
        let s = o.index;
        n.setX(s, e), o.opacity = e, this.lastOpacityUpdateRectangles.push(o);
      }
      n.needsUpdate = true;
    }
    restoreOpacities() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("opacity");
      if (this.lastOpacityUpdateRectangles.length >= 0) {
        for (let e of this.lastOpacityUpdateRectangles) {
          let n = e.index;
          t.setX(n, this.originalOpacities[n]), e.opacity = this.originalOpacities[n];
        }
        t.needsUpdate = true;
      }
      this.lastOpacityUpdateRectangles = [];
    }
    updateAngle(t, e) {
      if (!this.mesh) return;
      let n = this.mesh.geometry.getAttribute("angle"), r = this.savedRectangles[t];
      if (!r) return;
      let o = e / 180 * Math.PI;
      n.setX(r.index, o), n.needsUpdate = true;
    }
    updateAnimationProgress(t) {
      this.mesh && (this.curAnimationProgrssUniform.value = t);
    }
    getRectangleId(t) {
      return this.curRectangles[t].id;
    }
    getNodeIndex(t) {
      return this.savedRectangles[t]?.index ?? -1;
    }
    setBgColorWhenFar(t, e) {
      this.mesh && (this.material.uniforms.bgColorWhenFar.value = [t.r, t.g, t.b, e]);
    }
    clearSavedDataForAnimation() {
      this.savedRectangles = {};
    }
    setInstancePositionAndScale(t, e, n, r, o, s, a) {
      this.dummy.position.set(n, r, o), this.dummy.scale.set(s, 1, a), this.dummy.updateMatrix(), t.setMatrixAt(e, this.dummy.matrix), t.instanceMatrix.needsUpdate = true;
    }
  };
  var Yr = pn;
  var Fae = `
precision highp float;

// Set this to <0 to disable animation.
uniform float animationProgress;

// 0: regular. 1: medium. 2: bold.
attribute float weight;
attribute vec3 color;
attribute vec4 bound;
attribute vec4 targetBound;
attribute vec4 uvBound;
attribute float yOffset;
attribute float opacity;
attribute float angle;
attribute vec3 borderColor;
attribute float weightLevel;

varying vec2 vUv;
varying vec3 vColor;
varying float vWeight;
varying float vOpacity;
varying vec3 vBorderColor;
varying float vWeightLevel;

void main() {
  vUv = vec2(0.0, 0.0);
  vec3 pos = position;
  if (pos.x < 0.0 && pos.z < 0.0) {
    vUv = vec2(uvBound.x, uvBound.y + uvBound.w);
  } else if (pos.x > 0.0 && pos.z < 0.0) {
    vUv = vec2(uvBound.x + uvBound.z, uvBound.y + uvBound.w);
  } else if (pos.x > 0.0 && pos.z > 0.0) {
    vUv = vec2(uvBound.x + uvBound.z, uvBound.y);
  } else {
    vUv = vec2(uvBound.x, uvBound.y);
  }

  vColor = color;
  vWeight = weight;
  vOpacity = opacity;
  vBorderColor = borderColor;
  vWeightLevel = weightLevel;

  float curX = bound.x;
  float curY = bound.y;
  float curW = bound.z;
  float curH = bound.w;

  float x = curX;
  float y = curY;
  float w = curW;
  float h = curH;

  if (animationProgress >= 0.0) {
    x = curX + (targetBound.x - curX) * animationProgress;
    y = curY + (targetBound.y - curY) * animationProgress;
    w = curW + (targetBound.z - curW) * animationProgress;
    h = curH + (targetBound.w - curH) * animationProgress;
  }

  // For each vertex, move it by delta calculated below so that the final
  // rectangle's width and height match the width and height stored in "bound".
  //
  if (pos.x < 0.0) {
    pos.x = - w / 2.0;
  } else if (pos.x > 0.0) {
    pos.x = w / 2.0;
  }

  if (pos.z < 0.0) {
    pos.z = - h / 2.0;
  } else if (pos.z > 0.0) {
    pos.z = h / 2.0;
  }

  // Rotate.
  //
  float c = cos(angle);
  float s = sin(angle);
  float posX = pos.x * c + pos.z * s;
  float posZ = pos.z * c - pos.x * s;

  gl_Position = projectionMatrix * modelViewMatrix *
      vec4(posX + x, yOffset, posZ + y, 1.0);
}
`;
  var Bae = `
precision highp float;

uniform sampler2D textureRegular;
uniform sampler2D textureMedium;
uniform sampler2D textureBold;
uniform sampler2D textureIcons;
uniform float distanceRange;
varying vec2 vUv;
varying float vWeight;
varying vec3 vColor;
varying float vOpacity;
varying vec3 vBorderColor;
varying float vWeightLevel;

vec3 getSampleColor() {
  if (vWeight < 0.5) {
    return texture2D(textureRegular, vUv).rgb;
  }
  if (vWeight < 1.5) {
    return texture2D(textureMedium, vUv).rgb;
  }
  if (vWeight < 2.5) {
    return texture2D(textureBold, vUv).rgb;
  }
  return texture2D(textureIcons, vUv).rgb;
}

float median(float r, float g, float b) {
  return max(min(r, g), min(max(r, g), b));
}

float screenPxRange() {
  vec2 unitRange = vec2(distanceRange) / vec2(textureSize(textureRegular, 0));
  vec2 screenTexSize = vec2(1.0) / fwidth(vUv);
  return max(0.5 * dot(unitRange, screenTexSize), 1.0);
}

void main() {
  vec3 sampleColor = getSampleColor();

  float dist = median(sampleColor.r, sampleColor.g, sampleColor.b);
  vec3 color = vColor;
  float threshold = step(0.0, vBorderColor.r) * 0.35;
  float pxDist = screenPxRange() * (dist - 0.5 + threshold) + vWeightLevel - threshold;

  // Has border.
  if (vBorderColor.r >= 0.0) {
    float blur = fwidth(dist) / 2.0;
    color = mix(vBorderColor, vColor, smoothstep(0.5 - blur, 0.5 + blur, dist));
  }

  float opacity = clamp(pxDist, 0.0, 1.0);
  if (opacity > 0.001) {
    opacity *= vOpacity;
  }
  gl_FragColor = vec4(color, opacity);
}
`;
  var di = class {
    threejsService;
    mesh;
    material;
    planeGeo;
    labelCharSizesCache = {};
    fontSize;
    distanceRange;
    savedBounds = {};
    nodeIdToOpacityIndexRanges = {};
    nodeIdToColorIndexRanges = {};
    lastOpacityUpdateIndexRanges = [];
    lastColorUpdateIndexRanges = [];
    originalColors = [];
    curAnimationProgrssUniform = { value: -1 };
    constructor(t) {
      this.threejsService = t, this.planeGeo = new Yr.PlaneGeometry(1, 1), this.planeGeo.rotateX(-Math.PI / 2), this.fontSize = this.threejsService.fontInfoRegular.info.size, this.distanceRange = this.threejsService.fontInfoRegular.distanceField.distanceRange, this.material = new Yr.ShaderMaterial({ uniforms: { textureRegular: { value: this.threejsService.textureRegular }, textureMedium: { value: this.threejsService.textureMedium }, textureBold: { value: this.threejsService.textureBold }, textureIcons: { value: this.threejsService.textureIcons }, distanceRange: { value: this.distanceRange }, animationProgress: this.curAnimationProgrssUniform }, extensions: { derivatives: true }, vertexShader: Fae, fragmentShader: Bae, transparent: true, alphaToCoverage: true });
    }
    generateMesh(t, e = false, n = false, r = false) {
      let o = 0;
      this.nodeIdToOpacityIndexRanges = {}, this.nodeIdToColorIndexRanges = {};
      let s = [], a = [], l = [], c = [], d = [], u = [], h = [], p = [], f = [], m = [], v = Object.keys(this.savedBounds).length > 0, _ = le({}, this.savedBounds);
      this.savedBounds = {};
      for (let y of t) {
        let w = this.threejsService.getCharsInfo(y.weight), P = this.threejsService.getFontInfo(y.weight).common.scaleW, S = this.getLabelSizes(y.label, y.weight, y.height, y.maxWidth, y.treatLabelAsAWhole, y.angle, y.edgeTextMode).sizes, A = y.height / this.fontSize, W = y.x, H = y.z, I = (y.treatLabelAsAWhole ? { rects: [{ x: 0, y: 0, width: 20, height: y.height }] } : this.getLabelSizes("a", y.weight, y.height).sizes).rects[0].height * A;
        switch (y.vAlign) {
          case "top":
            H -= S.minZ * A;
            break;
          case "bottom":
            H -= S.maxZ * A;
            break;
          case "center":
            H -= (S.minZ + S.maxZ) / 2 * A + I / 2;
            break;
          default:
            break;
        }
        switch (y.hAlign) {
          case "left":
            W -= S.minX * A;
            break;
          case "right":
            W -= S.maxX * A;
            break;
          case "center":
            W -= (S.minX + S.maxX) / 2 * A;
            break;
          default:
            break;
        }
        let F = y.y, j = u.length;
        for (let $ = 0; $ < S.rects.length; $++) {
          let k = S.rects[$], z = y.treatLabelAsAWhole ? y.label : y.label[$], R = w[z] || w["?"], V = `${y.id}_${z}_${$}`, ie = k.width * A, re = k.height * A, Re = W + k.x * A, ne = H + k.y * A, oe = { x: y.edgeTextMode ? Re : Re + ie / 2, y: y.edgeTextMode ? ne : ne + re / 2, width: ie, height: re }, Be = _[V];
          (!v || e) && !n ? l.push(oe.x, oe.y, oe.width, oe.height) : l.push(Be?.x ?? oe.x, Be?.y ?? oe.y, Be?.width ?? (r ? oe.width : 0), Be?.height ?? (r ? oe.height : 0)), c.push(oe.x, oe.y, oe.width, oe.height), d.push(F);
          let me = R.x / P, Ve = 1 - R.y / P - R.height / P, ue = R.width / P, ee = R.height / P;
          h.push(me, Ve, ue, ee);
          let Q = y.color?.r ?? 0, _e = y.color?.g ?? 0, te = y.color?.b ?? 0;
          a.push(Q, _e, te), s.push(y.weight), u.push(1), p.push(y.angle || 0), f.push(y.borderColor?.r ?? -1, y.borderColor?.g ?? -1, y.borderColor?.b ?? -1), m.push(y.weightLevel ?? 0.5), this.savedBounds[V] = oe, o++;
        }
        y.nodeId && (this.nodeIdToOpacityIndexRanges[y.nodeId] || (this.nodeIdToOpacityIndexRanges[y.nodeId] = []), this.nodeIdToOpacityIndexRanges[y.nodeId].push({ minIndex: j, maxIndex: u.length - 1 }), this.nodeIdToColorIndexRanges[y.nodeId] || (this.nodeIdToColorIndexRanges[y.nodeId] = []), this.nodeIdToColorIndexRanges[y.nodeId].push({ minIndex: j, maxIndex: u.length - 1 }));
      }
      this.originalColors = a;
      let g = new Yr.InstancedBufferGeometry().copy(this.planeGeo);
      g.instanceCount = d.length, g.setAttribute("bound", new Yr.InstancedBufferAttribute(new Float32Array(l), 4)), g.setAttribute("targetBound", new Yr.InstancedBufferAttribute(new Float32Array(c), 4)), g.setAttribute("uvBound", new Yr.InstancedBufferAttribute(new Float32Array(h), 4)), g.setAttribute("yOffset", new Yr.InstancedBufferAttribute(new Float32Array(d), 1)), g.setAttribute("weight", new Yr.InstancedBufferAttribute(new Float32Array(s), 1)), g.setAttribute("color", new Yr.InstancedBufferAttribute(new Float32Array(a), 3)), g.setAttribute("opacity", new Yr.InstancedBufferAttribute(new Float32Array(u), 1)), g.setAttribute("angle", new Yr.InstancedBufferAttribute(new Float32Array(p), 1)), g.setAttribute("borderColor", new Yr.InstancedBufferAttribute(new Float32Array(f), 3)), g.setAttribute("weightLevel", new Yr.InstancedBufferAttribute(new Float32Array(m), 1)), this.mesh = new Yr.Mesh(g, this.material), this.mesh.frustumCulled = false;
    }
    updateOpacityInNode(t, e) {
      if (!this.mesh) return;
      let n = this.mesh.geometry.getAttribute("opacity");
      if (t.length > 0) {
        for (let r of t) if (this.nodeIdToOpacityIndexRanges[r]) for (let { minIndex: o, maxIndex: s } of this.nodeIdToOpacityIndexRanges[r]) {
          for (let a = o; a <= s; a++) n.setX(a, e);
          this.lastOpacityUpdateIndexRanges.push({ minIndex: o, maxIndex: s });
        }
      }
      n.needsUpdate = true;
    }
    updateColorInNode(t, e) {
      if (!this.mesh) return;
      let n = this.mesh.geometry.getAttribute("color");
      if (t.length > 0) {
        for (let r of t) if (this.nodeIdToColorIndexRanges[r]) for (let { minIndex: o, maxIndex: s } of this.nodeIdToColorIndexRanges[r]) {
          for (let a = o; a <= s; a++) n.setXYZ(a, e.r, e.g, e.b);
          this.lastColorUpdateIndexRanges.push({ minIndex: o, maxIndex: s });
        }
      }
      n.needsUpdate = true;
    }
    restoreOpacities() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("opacity");
      if (this.lastOpacityUpdateIndexRanges.length >= 0) {
        for (let { minIndex: e, maxIndex: n } of this.lastOpacityUpdateIndexRanges) for (let r = e; r <= n; r++) t.setX(r, 1);
        t.needsUpdate = true;
      }
      this.lastOpacityUpdateIndexRanges = [];
    }
    restoreColors() {
      if (!this.mesh) return;
      let t = this.mesh.geometry.getAttribute("color");
      if (this.lastColorUpdateIndexRanges.length >= 0) {
        for (let { minIndex: e, maxIndex: n } of this.lastColorUpdateIndexRanges) for (let r = e; r <= n; r++) t.setXYZ(r, this.originalColors[r * 3], this.originalColors[r * 3 + 1], this.originalColors[r * 3 + 2]);
        t.needsUpdate = true;
      }
      this.lastColorUpdateIndexRanges = [];
    }
    updateAnimationProgress(t) {
      this.curAnimationProgrssUniform.value = t;
    }
    getLabelSizes(t, e, n, r, o, s, a) {
      let l = this.getLabelCharSizesKey(t, e, s), c = this.labelCharSizesCache[l], d;
      if (c == null) {
        if (c = this.getLabelSizesInternal(t, e, o, s, a), r != null) {
          let u = n / this.fontSize, h = t;
          for (let p = 0; p < c.rects.length; p++) {
            let f = c.rects[p];
            if ((f.x + f.width) * u > r) {
              h = h.substring(0, p - 1), h += "...";
              break;
            }
          }
          d = h, c = this.getLabelSizesInternal(h, e, o), l = this.getLabelCharSizesKey(h, e);
        }
        this.labelCharSizesCache[l] = c;
      }
      return { sizes: this.labelCharSizesCache[l], updatedLabel: d };
    }
    updateLabelSizesCache(t, e, n) {
      let r = this.getLabelCharSizesKey(t, e);
      this.labelCharSizesCache[r] = n;
    }
    getFontSize() {
      return this.fontSize;
    }
    clearSavedDataForAnimation() {
      this.savedBounds = {};
    }
    getLabelCharSizesKey(t, e, n) {
      return `${t}__${e}__${n}`;
    }
    getLabelSizesInternal(t, e, n, r, o) {
      let s = this.threejsService.getCharsInfo(e), a = [], l = 0, c = Number.MAX_VALUE, d = Number.MAX_VALUE, u = Number.NEGATIVE_INFINITY, h = Number.NEGATIVE_INFINITY;
      for (let p of n ? [t] : t) {
        let f = s[p];
        f || (f = s["?"]);
        let m = f.yoffset;
        o ? (l += Math.sin(r || 0) * (f.yoffset + f.height / 2), m = Math.cos(r || 0) * (f.yoffset + f.height / 2)) : l += f.xoffset;
        let v = f.width, _ = f.height, g = { x: l, y: m, width: v, height: _ };
        a.push(g), c = Math.min(c, g.x), d = Math.min(d, g.y), u = Math.max(u, g.x + g.width), h = Math.max(h, g.y + g.height), l += f.xadvance * 0.98;
      }
      return { rects: a, minX: c, minZ: 0, maxX: u, maxZ: this.fontSize };
    }
  };
  var cG = 26;
  var Vae = At * 0.2;
  var dG = At * 0.4;
  var uG = pn;
  var sw = (() => {
    class i59 {
      ATTRS_TABLE_KEY_COLOR = new uG.Color("#808080");
      ATTRS_TABLE_VALUE_COLOR = new uG.Color("#0d0d0d");
      threejsService = M(Hi);
      attrsTableTexts = new di(this.threejsService);
      webglRenderer;
      webglRendererThreejsService;
      attrsTableBgs = new ci(4);
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      renderAttrsTable() {
        if (Object.keys(this.webglRenderer.curShowOnNodeItemTypes).filter((s) => this.webglRenderer.curShowOnNodeItemTypes[s].selected).length === 0) return;
        let e = [], r = 9 / this.attrsTableTexts.getFontSize(), o = [];
        for (let { node: s, index: a } of this.webglRenderer.nodesToRender) {
          let l = [], c = cG + kE - 4 + QE(s.label), d = 0, u = 0, h = [];
          if (dt(s)) {
            let m = GE(this.webglRenderer.curShowOnNodeItemTypes);
            for (let v of m) {
              let _ = Ry(s, v);
              h.push({ key: v, value: _ });
            }
            this.webglRenderer.curShowOnNodeItemTypes[Wt.OP_ATTRS]?.selected && h.push(...jE(s, this.webglRenderer.curShowOnNodeItemTypes[Wt.OP_ATTRS]?.filterRegex || "")), this.webglRenderer.curShowOnNodeItemTypes[Wt.OP_INPUTS]?.selected && h.push(...$E(s, this.webglRenderer.curModelGraph)), this.webglRenderer.curShowOnNodeItemTypes[Wt.OP_OUTPUTS]?.selected && h.push(...qE(s)), h.push(...YE(s, this.webglRenderer.curModelGraph.id, this.webglRenderer.curShowOnNodeItemTypes, this.webglRenderer.curNodeDataProviderRuns, this.webglRenderer.appService.config()));
          } else if (ct(s)) {
            let m = HE(this.webglRenderer.curShowOnNodeItemTypes);
            for (let v of m) {
              let _ = Ry(s, v);
              h.push({ key: v, value: _ });
            }
            this.webglRenderer.curShowOnNodeItemTypes[Wt.LAYER_NODE_ATTRS]?.selected && h.push(...WE(s, this.webglRenderer.curModelGraph, this.webglRenderer.curShowOnNodeItemTypes[Wt.LAYER_NODE_ATTRS]?.filterRegex || ""));
          }
          for (let { key: m, value: v } of h) {
            let { keyLabelData: _, keyLabelWidth: g, valueLabelData: y, valueLabelWidth: w } = this.createAttrsTableKeyValueLabels(s, a, m, v, c, r);
            e.push(_, y), d = Math.max(g, d), u = Math.max(w, u), l.push({ keyLabelData: _, valueLabelData: y }), c += Sf;
          }
          let p = d + u + Cy, f = (this.webglRenderer.getNodeWidth(s) - p) / 2;
          for (let m of l) m.keyLabelData.x = this.webglRenderer.getNodeX(s) + d, m.valueLabelData.x = this.webglRenderer.getNodeX(s) + d + Cy, m.keyLabelData.x += f, m.valueLabelData.x += f;
          if (l.length > 0 && dt(s)) {
            let v = this.webglRenderer.getNodeWidth(s) - 16, _ = l.length * Sf;
            o.push({ id: s.id, index: o.length, bound: { x: this.webglRenderer.getNodeX(s) + 16 / 2 + v / 2, y: l[0].keyLabelData.z + _ / 2 - Sf / 2, width: v, height: _ }, yOffset: At * a + Vae, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: { r: 1, g: 1, b: 1 }, borderWidth: 1, opacity: 1 });
          }
        }
        e.length > 0 && (this.attrsTableTexts.generateMesh(e), this.webglRendererThreejsService.addToScene(this.attrsTableTexts.mesh), this.attrsTableBgs.generateMesh(o), this.webglRendererThreejsService.addToScene(this.attrsTableBgs.mesh));
      }
      updateAnimationProgress(e) {
        this.attrsTableTexts.updateAnimationProgress(e), this.attrsTableBgs.updateAnimationProgress(e);
      }
      createAttrsTableKeyValueLabels(e, n, r, o, s, a) {
        let l = { id: `${e.id}_attrs_table_${r}_key`, nodeId: e.id, label: `${r}:`, height: 9, hAlign: "right", vAlign: "center", weight: Jt.MEDIUM, x: this.webglRenderer.getNodeX(e), y: n * At + dG, z: this.webglRenderer.getNodeY(e) + s, color: this.ATTRS_TABLE_KEY_COLOR }, c = this.attrsTableTexts.getLabelSizes(l.label, l.weight, l.height).sizes, d = (c.maxX - c.minX) * a, u = { id: `${e.id}_attrs_table_${r}_value`, nodeId: e.id, label: o, height: 9, hAlign: "left", vAlign: "center", weight: Jt.REGULAR, x: this.webglRenderer.getNodeX(e), y: n * At + dG, z: this.webglRenderer.getNodeY(e) + s, color: this.ATTRS_TABLE_VALUE_COLOR, maxWidth: LE }, { sizes: h, updatedLabel: p } = this.attrsTableTexts.getLabelSizes(u.label, u.weight, u.height, u.maxWidth);
        p != null && (u.label = p);
        let f = (h.maxX - h.minX) * a;
        return { keyLabelData: l, keyLabelWidth: d, valueLabelData: u, valueLabelWidth: f };
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var hG = pn;
  var pG = 1.5;
  var aw = (() => {
    class i59 {
      threejsService = M(Hi);
      webglRenderer;
      webglRendererThreejsService;
      overlaysEdgesList = [];
      overlaysEdgeTextsList = [];
      edgeOverlaysService = M(Gs);
      curOverlays = [];
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      updateOverlaysData() {
        this.clearOverlaysData();
        let e = this.webglRenderer.selectedNodeId;
        if (!e) return;
        let n = this.edgeOverlaysService.selectedOverlays();
        for (let r of n) r.nodeIds.has(e) && this.curOverlays.push(r);
      }
      clearOverlaysData() {
        this.curOverlays = [];
      }
      updateOverlaysEdges() {
        if (this.clearOverlaysEdges(), this.curOverlays.length === 0) return;
        let e = {}, n = {};
        for (let r = 0; r < this.curOverlays.length; r++) {
          let o = this.curOverlays[r];
          for (let { sourceNodeId: s, targetNodeId: a, label: l } of o.edges) this.addToEdgePairs(s, a, n);
        }
        for (let r = 0; r < this.curOverlays.length; r++) {
          let o = this.curOverlays[r], s = o.edgeWidth ?? pG, a = [], l = new ja(new hG.Color(o.edgeColor), s, s / pG);
          for (let { sourceNodeId: u, targetNodeId: h, label: p } of o.edges) {
            let f = this.webglRenderer.curModelGraph.nodesById[u], m = this.webglRenderer.curModelGraph.nodesById[h], v = this.addToEdgePairs(u, h, e), g = 1 / (n[this.getEdgeKey(u, h)] + 1) * v - 0.5, { intersection1: y, intersection2: w } = M2(this.webglRenderer.getNodeRect(f), this.webglRenderer.getNodeRect(m), g);
            a.push({ edge: { id: `overlay_edge_${r}_${u}_${h}`, fromNodeId: u, toNodeId: h, label: p ?? "", points: [], curvePoints: [{ x: y.x - (f?.globalX || 0), y: y.y - (f?.globalY || 0) }, { x: w.x - (f.globalX || 0), y: w.y - (f.globalY || 0) }] }, index: 96 / At });
          }
          l.generateMesh(a, this.webglRenderer.curModelGraph), this.webglRendererThreejsService.addToScene(l.edgesMesh), this.webglRendererThreejsService.addToScene(l.arrowHeadsMesh), this.overlaysEdgesList.push(l);
          let c = this.webglRenderer.webglRendererEdgeTextsService.genLabelsOnEdges(a, new hG.Color(o.edgeColor), s / 2, 96.5, o.edgeLabelFontSize ?? 7.5), d = new di(this.threejsService);
          d.generateMesh(c, true, false, true), this.webglRendererThreejsService.addToScene(d.mesh), this.overlaysEdgeTextsList.push(d);
        }
      }
      clearOverlaysEdges() {
        for (let e of this.overlaysEdgesList) e.clear();
        for (let e of this.overlaysEdgeTextsList) e.mesh && e.mesh.geometry && (e.mesh.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e.mesh));
        this.overlaysEdgesList = [], this.overlaysEdgeTextsList = [];
      }
      getDeepestExpandedGroupNodeIds() {
        if (this.curOverlays.length === 0) return [];
        let e = /* @__PURE__ */ new Set(), n = (r) => {
          let o = this.webglRenderer.curModelGraph.nodesById[r];
          if (o.nsParentId) {
            let s = this.webglRenderer.curModelGraph.nodesById[o.nsParentId];
            (!s.expanded || !this.webglRenderer.isNodeRendered(s.id)) && e.add(o.nsParentId);
          }
        };
        for (let r of this.curOverlays) for (let { sourceNodeId: o, targetNodeId: s } of r.edges) n(o), n(s);
        return [...e];
      }
      addToEdgePairs(e, n, r) {
        let o = this.getEdgeKey(e, n);
        return r[o] === void 0 && (r[o] = 0), r[o]++, r[o];
      }
      getEdgeKey(e, n) {
        return e.localeCompare(n) < 0 ? `${e}___${n}` : `${n}___${e}`;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var jg = pn;
  var lw = (() => {
    class i59 {
      appService;
      EDGE_TEXT_COLOR = new jg.Color("#041E49");
      threejsService = M(Hi);
      edgeTexts = new di(this.threejsService);
      webglRenderer;
      webglRendererThreejsService;
      constructor(e) {
        this.appService = e;
      }
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      renderEdgeTexts(e) {
        let n = this.genLabelsOnEdges(this.webglRenderer.edgesToRender, this.EDGE_TEXT_COLOR, 0, 95, void 0, e?.outputMetadataKey, e?.inputMetadataKey, e?.sourceNodeAttrKey, e?.targetNodeAttrKey);
        this.edgeTexts.generateMesh(n), this.webglRendererThreejsService.addToScene(this.edgeTexts.mesh);
      }
      genLabelsOnEdges(e, n, r = 0, o = 95, s, a, l, c, d) {
        let u = s ?? this.appService.config()?.edgeLabelFontSize ?? y2, h = this.appService.config()?.disallowVerticalEdgeLabels || false, p = [], f = this.threejsService.getCharsInfo(Jt.MEDIUM);
        for (let { edge: m } of e) {
          let v = this.webglRenderer.curModelGraph.nodesById[m.fromNodeId], _ = this.webglRenderer.curModelGraph.nodesById[m.toNodeId];
          if (!dt(v) || !dt(_)) continue;
          let g = "?";
          if (m.label != null) {
            if (g = m.label, g === "") continue;
          } else if (a != null) {
            let O = v.outputsMetadata || {};
            for (let I of Object.keys(O)) if ((v.outgoingEdges || []).find((j) => j.sourceNodeOutputId === I && j.targetNodeId === m.toNodeId) != null) {
              g = O[I][a] || "?", g = g.split("").map((j) => (j === "x" && (j = "x"), j === "\u2217" && (j = "*"), j === "" && (j = ""), f[j] == null ? "?" : j)).join("");
              break;
            }
          } else if (l != null) {
            let O = _.inputsMetadata || {};
            for (let I of Object.keys(O)) if ((_.incomingEdges || []).find((j) => j.sourceNodeId === m.fromNodeId && j.targetNodeInputId === I) != null) {
              g = O[I][l] || "?";
              break;
            }
          } else c != null ? g = KE(v, c) || "?" : d != null && (g = KE(_, d) || "?");
          let y = m.curvePoints || [], w = v.globalX || 0, E = v.globalY || 0, P = new jg.CurvePath();
          for (let O = 0; O < y.length - 1; O++) {
            let I = y[O], F = y[O + 1], j = new jg.LineCurve(new jg.Vector2(I.x + w, I.y + E), new jg.Vector2(F.x + w, F.y + E));
            P.add(j);
          }
          let S = P.getLength(), A = u / 2 / S, W = A * (g.length + 3) > 1, H = () => {
            let O = P.getPointAt(0.5), I = O.x, F = y[0].y === y[y.length - 1].y ? O.y - 10 - r : O.y;
            p.push({ id: `${m.id}_${g}`, nodeId: m.toNodeId, label: g, height: u, hAlign: "center", vAlign: "center", weight: Jt.MEDIUM, x: I, y: o, z: F, color: n, borderColor: { r: 1, g: 1, b: 1 } });
          };
          if (W) H();
          else {
            let O = [], I = Math.max(0, Math.min(0.25, 1 - g.length * A - 5 / S)), F = Math.max(0.05, 1 - 5 / S - I - A * g.length), j = 0.05, $ = true, k = u / this.edgeTexts.getFontSize();
            for (let z = 0; z < F; z += j) {
              let R = I + z;
              $ = true;
              let V;
              O = [];
              let ie = R;
              for (let re = 0; re < g.length; re++) {
                let Re = g[re], ne = P.getPointAt(Math.min(ie, 1)), oe = P.getTangentAt(Math.min(ie, 1)), Be = (Math.PI * 2 - Math.atan(oe.y / oe.x)) % (Math.PI * 2);
                if (Be < 0 && (Be += Math.PI * 2), h && Be >= Math.PI / 4 && Be <= Math.PI * 1.75) {
                  $ = false;
                  break;
                }
                if (O.push({ pos: ne, position: Math.min(ie, 1), angle: Be, tan: oe, char: Re }), V != null) {
                  let ee = Math.abs(Be - V);
                  if (Math.min(ee, Math.abs(ee - Math.PI)) > 0.15 && ($ = false, z + 0.05 < F)) break;
                }
                V = Be;
                let me = f[Re], Ve = 0;
                if (re !== g.length - 1) {
                  let ee = g[re + 1];
                  Ve = f[ee].xadvance;
                }
                let ue = (me.xadvance / 2 + Ve / 2) * k / S;
                ie += ue;
              }
              if ($) break;
            }
            if (!$) H();
            else {
              let z = O[0].pos.x >= O[O.length - 1].pos.x;
              if (z) {
                let R = [], V = O[0].position;
                for (let ie = g.length - 1; ie >= 0; ie--) {
                  let re = g[ie], Re = P.getPointAt(Math.min(1, V)), ne = P.getTangentAt(Math.min(1, V)), oe = (Math.PI * 2 - Math.atan(ne.y / ne.x)) % (Math.PI * 2);
                  oe < 0 && (oe += Math.PI * 2), R.push({ pos: Re, angle: oe, tan: ne, position: V, char: re });
                  let Be = f[re], me = 0;
                  ie >= 1 && (me = f[g[ie - 1]].xadvance);
                  let Ve = (Be.xadvance / 2 + me / 2) * k / S;
                  V += Ve;
                }
                O = R;
              }
              for (let R = 0; R < O.length; R++) {
                let V = O[R], ie = V.char, re = V.pos, Re = V.tan, ne = V.angle;
                Math.abs(Re.x) < 1e-7 && (ne = (z ? 1 : -1) * Math.PI / 2), p.push({ id: `${m.id}_${ie}_${R}`, nodeId: m.toNodeId, label: ie, height: u, hAlign: "", vAlign: "", weight: Jt.MEDIUM, x: re.x + Math.sin(ne) * (-u * 1.5 - r), y: o, z: re.y + Math.cos(ne) * (-u * 1.5 - r), color: n, angle: ne, edgeTextMode: true, borderColor: { r: 1, g: 1, b: 1 } });
              }
            }
          }
        }
        return p;
      }
      updateAnimationProgress(e) {
        this.edgeTexts.updateAnimationProgress(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Hae = -At * 0.3;
  var jae = pn;
  var Wae = "#ff00be";
  var $ae = 2;
  var cw = (() => {
    class i59 {
      highlightNodesBorders = new ci(8);
      highlightNodeIds = gt([]);
      webglRenderer;
      webglRendererThreejsService;
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService, ht(() => {
          this.clearAndRenderHighlightNodes();
        });
      }
      setHighlightNodeIds(e) {
        this.highlightNodeIds.set(e);
      }
      clearAndRenderHighlightNodes() {
        this.clearHighlightNodes();
        let e = this.highlightNodeIds();
        if (e.length > 0) {
          let n = [], r = new jae.Color(this.borderColor), o = this.webglRenderer.syncNavigationService.getSyncNavigationData()?.relatedNodesBorderWidth ?? $ae;
          for (let s of e) {
            let a = this.webglRenderer.curModelGraph.nodesById[s], l = this.webglRenderer.nodesToRenderMap[s].index, c = this.webglRenderer.getNodeX(a) - o, d = this.webglRenderer.getNodeY(a) - o, u = this.webglRenderer.getNodeWidth(a) + o * 2, h = this.webglRenderer.getNodeHeight(a) + o * 2;
            n.push({ id: s, index: n.length, bound: { x: c + u / 2, y: d + h / 2, width: u, height: h }, yOffset: At * l + Hae, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: r, borderWidth: 0, opacity: 1 });
          }
          this.highlightNodesBorders.generateMesh(n), this.webglRendererThreejsService.addToScene(this.highlightNodesBorders.mesh);
        }
        this.webglRenderer.animateIntoPositions((n) => {
          this.highlightNodesBorders.updateAnimationProgress(n);
        });
      }
      clearHighlightNodes() {
        for (let e of [this.highlightNodesBorders.mesh]) e && (e.geometry && e.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e));
      }
      get borderColor() {
        return this.webglRenderer.syncNavigationService.getSyncNavigationData()?.relatedNodesBorderColor ?? Wae;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var fG = 1.5;
  var dw = "||||";
  var kD = 14;
  var Yae = 40;
  var up = pn;
  var uw = (() => {
    class i59 {
      EDGE_COLOR_INCOMING = new up.Color("#009e73");
      EDGE_TEXT_COLOR_INCOMING = new up.Color("#125341");
      EDGE_COLOR_OUTGOING = new up.Color("#d55e00");
      EDGE_TEXT_COLOR_OUTGOING = new up.Color("#994d11");
      inputsRenderedEdges = [];
      outputsRenderedEdges = [];
      inputsByHighlightedNode = {};
      outputsByHighlightedNode = {};
      webglRenderer;
      webglRendererThreejsService;
      threejsService = M(Hi);
      ioPickerBgs = new ci(99);
      ioPickerTexts = new di(this.threejsService);
      incomingHighlightedEdges = new ja(this.EDGE_COLOR_INCOMING, fG);
      outgoingHighlightedEdges = new ja(this.EDGE_COLOR_OUTGOING, fG);
      incomingHighlightedEdgeTexts = new di(this.threejsService);
      outgoingHighlightedEdgeTexts = new di(this.threejsService);
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      updateIncomingAndOutgoingHighlights() {
        if (!this.webglRenderer.curModelGraph) return;
        if (this.clearIncomingAndOutgoingHighlights(), !this.shouldUpdateIncomingAndOutgoingEdgesHighlights()) {
          this.incomingHighlightedEdges.clearSavedDataForAnimation(), this.outgoingHighlightedEdges.clearSavedDataForAnimation(), this.incomingHighlightedEdgeTexts.clearSavedDataForAnimation(), this.outgoingHighlightedEdgeTexts.clearSavedDataForAnimation(), this.ioPickerBgs.clearSavedDataForAnimation(), this.ioPickerTexts.clearSavedDataForAnimation();
          return;
        }
        let e = this.webglRenderer.appService.config()?.showOpNodeOutOfLayerEdgesWithoutSelecting, n = this.getHighlightedIncomingNodesAndEdges(this.webglRenderer.curHiddenInputOpNodeIds, void 0, { reuseRenderedEdgeCurvePoints: e });
        if (n.overlayEdges.length > 0) {
          let a = n.overlayEdges.map((h) => e ? { edge: h, index: 95 / At } : { edge: xt(le({}, h), { curvePoints: Nu(h.points, nh, ih, up) }), index: 95 / At });
          this.incomingHighlightedEdges.generateMesh(a, this.webglRenderer.curModelGraph), this.webglRendererThreejsService.addToScene(this.incomingHighlightedEdges.edgesMesh), this.webglRendererThreejsService.addToScene(this.incomingHighlightedEdges.arrowHeadsMesh);
          let { outputMetadataKey: l, inputMetadataKey: c, sourceNodeAttrKey: d, targetNodeAttrKey: u } = Df(this.webglRenderer.curShowOnEdgeItem);
          if (l != null || c != null || d != null || u != null) {
            let h = this.webglRenderer.webglRendererEdgeTextsService.genLabelsOnEdges(a, this.EDGE_TEXT_COLOR_INCOMING, 0, 95, void 0, l, c, d, u);
            this.incomingHighlightedEdgeTexts.generateMesh(h, false, true, true), this.webglRendererThreejsService.addToScene(this.incomingHighlightedEdgeTexts.mesh);
          }
        }
        this.inputsByHighlightedNode = n.inputsByHighlightedNode, this.inputsRenderedEdges = n.renderedEdges;
        let r = this.getHighlightedOutgoingNodesAndEdges(this.webglRenderer.curHiddenOutputIds, void 0, { reuseRenderedEdgeCurvePoints: e });
        if (r.overlayEdges.length > 0) {
          let a = r.overlayEdges.map((h) => e ? { edge: h, index: 95 / At } : { edge: xt(le({}, h), { curvePoints: Nu(h.points, nh, ih, up) }), index: 95 / At });
          this.outgoingHighlightedEdges.generateMesh(a, this.webglRenderer.curModelGraph), this.webglRendererThreejsService.addToScene(this.outgoingHighlightedEdges.edgesMesh), this.webglRendererThreejsService.addToScene(this.outgoingHighlightedEdges.arrowHeadsMesh);
          let { outputMetadataKey: l, inputMetadataKey: c, sourceNodeAttrKey: d, targetNodeAttrKey: u } = Df(this.webglRenderer.curShowOnEdgeItem);
          if (l != null || c != null || d != null || u != null) {
            let h = this.webglRenderer.webglRendererEdgeTextsService.genLabelsOnEdges(a, this.EDGE_TEXT_COLOR_OUTGOING, void 0, 95, void 0, l, c, d, u);
            this.outgoingHighlightedEdgeTexts.generateMesh(h, false, true, true), this.webglRendererThreejsService.addToScene(this.outgoingHighlightedEdgeTexts.mesh);
          }
        }
        this.outputsByHighlightedNode = r.outputsByHighlightedNode, this.outputsRenderedEdges = r.renderedEdges;
        let o = [], s = [];
        for (let a of Object.keys(le(le({}, this.inputsByHighlightedNode), this.outputsByHighlightedNode))) {
          let l = this.webglRenderer.curModelGraph.nodesById[a];
          if (ct(l)) {
            let c = Yae, d = kD, u = this.inputsByHighlightedNode[a] != null, h = u ? this.inputsByHighlightedNode[a].length : this.outputsByHighlightedNode[a].length;
            o.push({ id: `${a}${dw}${u ? "input" : "output"}`, index: o.length, bound: { x: this.webglRenderer.getNodeX(l) + c / 2, y: this.webglRenderer.getNodeY(l) - d / 4, width: c, height: d }, yOffset: 95, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: u ? this.EDGE_COLOR_INCOMING : this.EDGE_COLOR_OUTGOING, borderWidth: 0, opacity: 1 }), s.push({ id: `${a}${dw}${u ? "input" : "output"}`, nodeId: a, label: `${h} ${u ? "input" : "output"}${h !== 1 ? "s" : ""}`, height: 8, hAlign: "center", vAlign: "center", weight: Jt.MEDIUM, color: { r: 1, g: 1, b: 1 }, x: this.webglRenderer.getNodeX(l) + c / 2, y: 96, z: this.webglRenderer.getNodeY(l) - d / 4 + 1 });
          }
        }
        this.ioPickerTexts.generateMesh(s, false, true, true), this.webglRendererThreejsService.addToScene(this.ioPickerTexts.mesh), this.ioPickerBgs.generateMesh(o, true, false, false, true), this.webglRendererThreejsService.addToScene(this.ioPickerBgs.mesh), this.webglRendererThreejsService.addToScene(this.ioPickerBgs.meshForRayCasting), this.webglRenderer.animateIntoPositions((a) => {
          this.incomingHighlightedEdges.updateAnimationProgress(a), this.outgoingHighlightedEdges.updateAnimationProgress(a), this.incomingHighlightedEdgeTexts.updateAnimationProgress(a), this.outgoingHighlightedEdgeTexts.updateAnimationProgress(a), this.ioPickerBgs.updateAnimationProgress(a), this.ioPickerTexts.updateAnimationProgress(a);
        });
      }
      handleClickIoPicker(e, n) {
        e ? this.inputsByHighlightedNode[n].length === 1 ? this.webglRenderer.sendLocateNodeRequest(this.inputsByHighlightedNode[n][0].id, this.webglRenderer.rendererId) : this.webglRenderer.showIoTree(this.webglRenderer.ioPicker.nativeElement, this.inputsByHighlightedNode[n], "incoming") : this.outputsByHighlightedNode[n].length === 1 ? this.webglRenderer.sendLocateNodeRequest(this.outputsByHighlightedNode[n][0].id, this.webglRenderer.rendererId) : this.webglRenderer.showIoTree(this.webglRenderer.ioPicker.nativeElement, this.outputsByHighlightedNode[n], "outgoing");
      }
      getHighlightedIncomingNodesAndEdges(e, n, r) {
        let o = r?.ignoreEdgesWithinSameNamespace ?? false, s = r?.reuseRenderedEdgeCurvePoints ?? false;
        n || (n = this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.selectedNodeId]);
        let a = [], l = [], c = {}, d = [], u = [], h = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set();
        if (dt(n)) u.push(n);
        else if (ct(n)) for (let f of n.descendantsOpNodeIds || []) {
          let m = this.webglRenderer.curModelGraph.nodesById[f];
          u.push(m), h.add(f);
        }
        for (let f of u) for (let m of f.incomingEdges || []) {
          if (e[m.sourceNodeId]) continue;
          let v = this.webglRenderer.curModelGraph.nodesById[m.sourceNodeId];
          if (!v || h.has(v.id) || p.has(v.id) || (p.add(v.id), o && v.namespace === f.namespace)) continue;
          let _ = XE(v.namespace, f.namespace), g = this.getLastCollapsedAncestorNode(v, _);
          l.push(g), c[g.id] == null && (c[g.id] = []), c[g.id].push(v);
          let y = this.findEdgeConnectingTwoNodesInNamespace(_, v.id, f.id), w = [], E = [];
          if (y) {
            a.push(y);
            let P = y.curvePoints || [], S = this.webglRenderer.curModelGraph.nodesById[y.fromNodeId];
            if (y.fromNodeId !== g.id) {
              let H = y.points[0].x + (S.globalX || 0), O = y.points[0].y + (S.globalY || 0), I = this.getBestAnchorPointOnNode(H, O, g);
              w.push({ x: I.x - (g.globalX || 0), y: I.y - (g.globalY || 0) }), s && E.push({ x: I.x - (g.globalX || 0), y: I.y - (g.globalY || 0) }, { x: P[0].x - (g.globalX || 0) + (S.globalX || 0), y: P[0].y - (g.globalY || 0) + (S.globalY || 0) });
            }
            let A = w, W = y.points;
            if (s && (A = E, W = P), A.push(...W.map((H) => ({ x: H.x - (g.globalX || 0) + (S.globalX || 0), y: H.y - (g.globalY || 0) + (S.globalY || 0) }))), y.toNodeId !== f?.id && dt(n)) {
              let H = y.points[y.points.length - 1].x + (S.globalX || 0), O = y.points[y.points.length - 1].y + (S.globalY || 0), I = this.getBestAnchorPointOnNode(H, O, f);
              s ? E.push({ x: P[P.length - 1].x - (g.globalX || 0) + (S.globalX || 0), y: P[P.length - 1].y - (g.globalY || 0) + (S.globalY || 0) }, { x: I.x - (g.globalX || 0), y: I.y - (g.globalY || 0) }) : w.push({ x: I.x - (g.globalX || 0), y: I.y - (g.globalY || 0) });
            }
          } else (ct(g) || dt(g) && !g.hideInLayout) && (s ? E : w).push(...this.getDirectEdgeBetweenNodes(g, f));
          s ? E.length > 0 && d.push({ id: `overlay_${g.id}___${f.id}`, fromNodeId: g.id, toNodeId: f.id, points: [], curvePoints: E, type: "incoming" }) : w.length > 0 && d.push({ id: `overlay_${g.id}___${f.id}`, fromNodeId: g.id, toNodeId: f.id, points: w, type: "incoming" });
        }
        return { renderedEdges: a, highlightedNodes: l, inputsByHighlightedNode: c, overlayEdges: d };
      }
      getHighlightedOutgoingNodesAndEdges(e, n, r) {
        let o = r?.ignoreEdgesWithinSameNamespace ?? false, s = r?.reuseRenderedEdgeCurvePoints ?? false;
        n || (n = this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.selectedNodeId]);
        let a = [], l = [], c = {}, d = [], u = [], h = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ new Set();
        if (dt(n)) u.push(n);
        else if (ct(n)) for (let f of n.descendantsOpNodeIds || []) {
          let m = this.webglRenderer.curModelGraph.nodesById[f];
          u.push(m), h.add(f);
        }
        for (let f of u) for (let m of f.outgoingEdges || []) {
          if (e[`${f.id}___${m.sourceNodeOutputId}`]) continue;
          let v = this.webglRenderer.curModelGraph.nodesById[m.targetNodeId];
          if (!v || h.has(v.id) || p.has(v.id) || (p.add(v.id), o && v.namespace === f.namespace)) continue;
          let _ = XE(v.namespace, f.namespace), g = this.getLastCollapsedAncestorNode(v, _);
          l.push(g), c[g.id] == null && (c[g.id] = []), c[g.id].push(v);
          let y = this.findEdgeConnectingTwoNodesInNamespace(_, f.id, v.id), w = [], E = [];
          if (y) {
            a.push(y);
            let P = y.curvePoints || [], S = this.webglRenderer.curModelGraph.nodesById[y.fromNodeId];
            if (dt(n) && y.fromNodeId !== f?.id) {
              let H = y.points[0].x + (S.globalX || 0), O = y.points[0].y + (S.globalY || 0), I = this.getBestAnchorPointOnNode(H, O, f);
              w.push({ x: I.x - (f.globalX || 0), y: I.y - (f.globalY || 0) }), s && E.push({ x: I.x - (f.globalX || 0), y: I.y - (f.globalY || 0) }, { x: P[0].x - (f.globalX || 0) + (S.globalX || 0), y: P[0].y - (f.globalY || 0) + (S.globalY || 0) });
            }
            let A = w, W = y.points;
            if (s && (A = E, W = P), A.push(...W.map((H) => ({ x: H.x - (f.globalX || 0) + (S.globalX || 0), y: H.y - (f.globalY || 0) + (S.globalY || 0) }))), y.toNodeId !== g.id) {
              let H = y.points[y.points.length - 1].x + (S.globalX || 0), O = y.points[y.points.length - 1].y + (S.globalY || 0), I = this.getBestAnchorPointOnNode(H, O, g);
              s ? E.push({ x: P[P.length - 1].x - (f.globalX || 0) + (S.globalX || 0), y: P[P.length - 1].y - (f.globalY || 0) + (S.globalY || 0) }, { x: I.x - (f.globalX || 0), y: I.y - (f.globalY || 0) }) : w.push({ x: I.x - (f.globalX || 0), y: I.y - (f.globalY || 0) });
            }
          } else (ct(g) || dt(g) && !g.hideInLayout) && (s ? E : w).push(...this.getDirectEdgeBetweenNodes(f, g));
          s ? E.length > 0 && d.push({ id: `overlay_${f.id}___${g.id}`, fromNodeId: f.id, toNodeId: g.id, points: [], curvePoints: E, type: "outgoing" }) : w.length > 0 && d.push({ id: `overlay_${f.id}___${g.id}`, fromNodeId: f.id, toNodeId: g.id, points: w, type: "outgoing" });
        }
        return { renderedEdges: a, highlightedNodes: l, outputsByHighlightedNode: c, overlayEdges: d };
      }
      getLastCollapsedAncestorNode(e, n) {
        let r = e, o = [];
        for (; r && (ct(r) && !r.expanded && o.push(r), r.namespace !== n); ) r = this.webglRenderer.curModelGraph.nodesById[r.nsParentId || ""];
        return o.length > 0 ? o[o.length - 1] : e;
      }
      shouldUpdateIncomingAndOutgoingEdgesHighlights() {
        if (!this.webglRenderer.selectedNodeId) return false;
        let e = this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.selectedNodeId];
        if (ct(e) && !this.webglRenderer.appService.config()?.highlightLayerNodeInputsOutputs) return false;
        let n = this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.rootNodeId || ""];
        return !(n && ct(n) && !(n.descendantsOpNodeIds || []).includes(this.webglRenderer.selectedNodeId) || !this.webglRenderer.isNodeRendered(this.webglRenderer.selectedNodeId));
      }
      clearIncomingAndOutgoingHighlights() {
        this.incomingHighlightedEdges.clear(), this.outgoingHighlightedEdges.clear(), this.inputsByHighlightedNode = {}, this.outputsByHighlightedNode = {}, this.inputsRenderedEdges = [], this.outputsRenderedEdges = [];
        for (let e of [this.ioPickerBgs.mesh, this.ioPickerBgs.meshForRayCasting, this.ioPickerTexts.mesh, this.incomingHighlightedEdgeTexts.mesh, this.outgoingHighlightedEdgeTexts.mesh]) e && (e.geometry && e.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e));
        this.ioPickerBgs.meshForRayCasting = void 0;
      }
      findEdgeConnectingTwoNodesInNamespace(e, n, r) {
        let o = e === "" ? "" : `${e}___group___`;
        return (this.webglRenderer.curModelGraph.edgesByGroupNodeIds[o] ?? []).find((s) => {
          let a = this.webglRenderer.curModelGraph.nodesById[s.fromNodeId], l = this.webglRenderer.curModelGraph.nodesById[s.toNodeId], c = this.containNode(a, n), d = this.containNode(l, r);
          return c && d;
        });
      }
      containNode(e, n) {
        return dt(e) && e.id === n || ct(e) && (e.descendantsOpNodeIds || []).includes(n);
      }
      getDirectEdgeBetweenNodes(e, n) {
        let r = [], o = e.globalX || 0, s = e.globalY || 0, a = e.width || 0, l = e.height || 0, c = n.globalX || 0, d = n.globalY || 0, u = n.width || 0, h = n.height || 0, p = o + a / 2, f = d > s ? s + l : s, m = c + u / 2, v = d > s ? d : d + h;
        return r.push({ x: p + (e.x || 0) - o, y: f + (e.y || 0) - s }, { x: m + (n.x || 0) - o, y: v + (n.y || 0) - s }), r;
      }
      getBestAnchorPointOnNode(e, n, r) {
        let o = this.webglRenderer.getNodeX(r), s = this.webglRenderer.getNodeY(r), a = this.webglRenderer.getNodeWidth(r), l = this.webglRenderer.getNodeHeight(r), c = [{ point: { x: o + a / 2, y: s }, distance: 0, direction: "horizontal" }, { point: { x: o + a, y: s + l / 2 }, distance: 0, direction: "vertical" }, { point: { x: o + a / 2, y: s + l }, distance: 0, direction: "horizontal" }, { point: { x: o, y: s + l / 2 }, distance: 0, direction: "vertical" }];
        for (let d of c) d.distance = this.getDistanceSquared(e, n, d.point.x, d.point.y);
        if (c.sort((d, u) => d.distance - u.distance), c[0].direction !== c[1].direction) {
          let d = this.getAngle(e, n, c[0].point.x, c[0].point.y, c[0].direction), u = this.getAngle(e, n, c[1].point.x, c[1].point.y, c[1].direction);
          return d >= u ? c[0].point : c[1].point;
        }
        return c[0].point;
      }
      getAngle(e, n, r, o, s) {
        return Math.atan(s === "horizontal" ? Math.abs(o - n) / Math.abs(r - e) : Math.abs(r - e) / Math.abs(o - n));
      }
      getDistanceSquared(e, n, r, o) {
        return Math.pow(e - r, 2) + Math.pow(n - o, 2);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var LD = kD;
  var mG = 68;
  var FD = pn;
  var hw = (() => {
    class i59 {
      IDENTICAL_GROUPS_BG_COLOR = new FD.Color("#e2edff");
      IDENTICAL_GROUPS_INDICATOR_BG_COLOR = new FD.Color("#e3e3e3");
      IDENTICAL_GROUPS_INDICATOR_BORDER_COLOR = new FD.Color("#ccc");
      webglRenderer;
      webglRendererThreejsService;
      threejsService = M(Hi);
      identicalLayerIndicatorBgs = new ci(99);
      identicalLayerIndicatorTexts = new di(this.threejsService);
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      updateIdenticalLayerIndicators() {
        if (!this.webglRenderer.curModelGraph) return;
        this.clearIdenticalLayerIndicators();
        let e = this.webglRenderer.webglRendererIoHighlightService, n = this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.selectedNodeId], r = [], o = [];
        if (ct(n) && n?.identicalGroupIndex != null) {
          let s = n.identicalGroupIndex, a = this.webglRenderer.nodesToRender.filter(({ node: l }) => ct(l) && l.identicalGroupIndex === s).map(({ node: l }) => this.webglRenderer.curModelGraph.nodesById[l.id]);
          for (let l of a) {
            if (l.id === n.id) continue;
            let c = this.webglRenderer.getNodeX(l) + mG / 2, d = this.webglRenderer.getNodeY(l) - LD / 2 + LD / 4, u = 0;
            ct(l) && (e.inputsByHighlightedNode[l.id] != null || e.outputsByHighlightedNode[l.id] != null) && (u = -15), r.push({ id: l.id, index: r.length, bound: { x: c, y: d + u, width: mG, height: LD }, yOffset: 95.2, isRounded: true, borderColor: this.IDENTICAL_GROUPS_INDICATOR_BORDER_COLOR, bgColor: this.IDENTICAL_GROUPS_INDICATOR_BG_COLOR, borderWidth: 1, opacity: 1 }), o.push({ id: l.id, label: "Identical layer", height: 8, hAlign: "center", vAlign: "center", weight: Jt.MEDIUM, color: { r: 0, g: 0, b: 0 }, x: c, y: 96, z: d + u });
          }
        }
        this.identicalLayerIndicatorBgs.generateMesh(r, false, false, true, true), this.webglRendererThreejsService.addToScene(this.identicalLayerIndicatorBgs.mesh), this.identicalLayerIndicatorTexts.generateMesh(o, false, true, true), this.webglRendererThreejsService.addToScene(this.identicalLayerIndicatorTexts.mesh), this.webglRenderer.animateIntoPositions((s) => {
          this.identicalLayerIndicatorBgs.updateAnimationProgress(s), this.identicalLayerIndicatorTexts.updateAnimationProgress(s);
        });
      }
      clearIdenticalLayerIndicators() {
        for (let e of [this.identicalLayerIndicatorBgs.mesh, this.identicalLayerIndicatorTexts.mesh]) e && (e.geometry && e.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var pw = (() => {
    class i59 {
      curIoTracingData;
      webglRenderer;
      init(e) {
        this.webglRenderer = e;
      }
      genTracingData() {
        if (!this.webglRenderer.selectedNodeId || !dt(this.webglRenderer.curModelGraph.nodesById[this.webglRenderer.selectedNodeId])) return;
        let e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), r = [this.webglRenderer.selectedNodeId];
        for (; r.length > 0; ) {
          let s = r.shift();
          if (n.has(s)) continue;
          n.add(s);
          let a = this.webglRenderer.curModelGraph.nodesById[s];
          a.hideInLayout || e.add(s);
          for (let l of a.incomingEdges || []) r.push(l.sourceNodeId);
        }
        let o = /* @__PURE__ */ new Set();
        for (r = [this.webglRenderer.selectedNodeId]; r.length > 0; ) {
          let s = r.shift();
          if (o.has(s)) continue;
          o.add(s);
          let a = this.webglRenderer.curModelGraph.nodesById[s];
          a.hideInLayout || e.add(s);
          for (let l of a.outgoingEdges || []) r.push(l.targetNodeId);
        }
        for (let s of [...e]) {
          let a = s;
          for (; ; ) {
            let l = this.webglRenderer.curModelGraph.nodesById[a];
            if (!l.nsParentId || e.has(l.nsParentId)) break;
            a = l.nsParentId, e.add(a);
          }
        }
        this.curIoTracingData = { tracedNodeId: this.webglRenderer.selectedNodeId, visibleNodeIds: e };
      }
      clearTracingData() {
        this.curIoTracingData = void 0;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Kae = "/api/v1/read_text_file";
  var Jae = "/api/v1/load_node_data";
  var Cr = (() => {
    class i59 {
      appService;
      runs = gt({});
      remoteSourceLoading = gt(false);
      leftPaneModelGraph$ = wy(It(() => this.appService.panes()[0].modelGraph));
      rightPaneModelGraph$ = wy(It(() => {
        let e = this.appService.panes();
        if (!(e.length <= 1)) return e[1].modelGraph;
      }));
      constructor(e) {
        this.appService = e, this.leftPaneModelGraph$.subscribe((n) => {
          n != null && this.handleModelGraphInPaneChanged(n, 0);
        }), this.rightPaneModelGraph$.subscribe((n) => {
          n != null && this.handleModelGraphInPaneChanged(n, 1);
        });
      }
      addRun(e, n, r, o, s, a = false, l) {
        let c = o.collectionLabel;
        this.runs.update((d) => {
          if (a) {
            let h = [];
            for (let [p, f] of Object.entries(d)) a && f.collectionId === c && h.push(p);
            for (let p of h) delete d[p];
          }
          d[e] = { runId: e, runName: n, done: s != null, results: s == null ? void 0 : { [o.id]: this.processNodeDataProviderDataForGraph(o, s) }, extensionId: r, collectionId: c, remotePath: l, nodeDataProviderData: s };
          let u = this.appService.panes();
          for (let h of u) h.modelGraph?.id === o.id && h.modelGraph?.collectionLabel === o.collectionLabel && this.appService.setSelectedNodeDataProviderRunId(h.id, e);
          return le({}, d);
        });
      }
      updateRunResults(e, n, r, o) {
        this.runs.update((s) => {
          let a = s[e];
          return a.done = true, a.nodeDataProviderData = n, a.results == null && (a.results = {}), a.results[r.id] = this.processNodeDataProviderDataForGraph(r, n), o && (a.error = o), le({}, s);
        });
      }
      addRunFromRemoteSource(e, n) {
        return $t(this, null, function* () {
          this.remoteSourceLoading.set(true);
          let r = e.split("/"), o = r[r.length - 1], s = `/read_file?path=${e}`;
          if (true) if (e.startsWith("node_data://")) {
            let d = e.replace("node_data://", "").split("/");
            o = d[0];
            let u = Number(d[1]);
            s = `${Jae}?node_data_index=${u}`;
          } else s = `${Kae}?path=${e}`;
          let a = Li();
          this.addRun(a, o, "", n, void 0, false, e);
          let l = yield fetch(s);
          if (!l.ok) {
            this.updateRunResults(a, { [n.id]: { results: {} } }, n, `Failed to load JSON file "${e}"`), this.remoteSourceLoading.set(false);
            return;
          }
          if (true) {
            let c = JSON.parse(yield l.text());
            if (c.error) this.updateRunResults(a, { [n.id]: { results: {} } }, n, `Failed to process JSON file. ${c.error}`);
            else try {
              this.updateRunResults(a, this.getNodeDataProviderData(c.content, n), n), this.notifyRemoteNodeDataChanges();
            } catch (d) {
              this.updateRunResults(a, { [n.id]: { results: {} } }, n, `Failed to process JSON file. ${d}`);
            }
          } else {
            let c = JSON.parse((yield l.text()).replace(`)]}'
`, ""));
            try {
              this.updateRunResults(a, this.getNodeDataProviderData(c.content, n), n), this.notifyRemoteNodeDataChanges();
            } catch (d) {
              this.updateRunResults(a, { [n.id]: { results: {} } }, n, `Failed to process JSON file. ${d}`);
            }
          }
          this.remoteSourceLoading.set(false);
        });
      }
      deleteRun(e) {
        this.runs.update((n) => (delete n[e], le({}, n))), this.notifyRemoteNodeDataChanges();
        for (let n of this.appService.panes()) if (n.selectedNodeDataProviderRunId === e) {
          let r = this.getRunsForModelGraph(n.modelGraph);
          this.appService.setSelectedNodeDataProviderRunId(n.id, r.length > 0 ? r[0].runId : void 0);
        }
      }
      getSelectedRunForModelGraph(e, n) {
        let r = this.appService.getSelectedNodeDataProviderRunId(e);
        return r ? this.getRunsForModelGraph(n).find((s) => s.runId === r) : void 0;
      }
      getRunsForModelGraph(e) {
        let n = [], r = this.runs();
        for (let o of Object.values(r)) {
          if (o.collectionId !== e.collectionLabel) continue;
          let s = o.nodeDataProviderData;
          s && s[e.id] != null && n.push(o);
        }
        return n;
      }
      processNodeDataProviderDataForGraph(e, n) {
        this.genOutputTensorIdToNodeIdMap(e);
        let r = {}, o = n[e.id];
        if (!o) return {};
        let s = [];
        for (let c of o.gradient || []) {
          let d = { stop: c.stop };
          c.bgColor != null && (d.bgColor = this.getRgbFromColor(c.bgColor, "#ffffff")), c.textColor != null && (d.textColor = this.getRgbFromColor(c.textColor, "#000000")), s.push(d);
        }
        s.sort((c, d) => c.stop - d.stop);
        let a = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
        if (s.length > 0) for (let { value: c } of Object.values(o.results)) typeof c == "number" && (a = Math.min(a, c), l = Math.max(l, c));
        for (let c of Object.keys(o.results)) {
          let d = o.results[c];
          if (typeof d.value == "number" && d.bgColor == null && (d.bgColor = this.getBgColor(d.value, o.thresholds || [], s, a, l)), typeof d.value == "number" && d.textColor == null && (d.textColor = this.getTextColor(d.value, o.thresholds || [], s, a, l)), (d.textColor == null || d.textColor === "") && d.bgColor != null) {
            let v = this.getRgbFromColor(d.bgColor, "#ffffff");
            v != null && Math.pow(v.r / 255, 2.2) * 0.2126 + Math.pow(v.g / 255, 2.2) * 0.7152 + Math.pow(v.b / 255, 2.2) * 0.0722 < 0.38 && (d.textColor = "#ffffff");
          }
          let u = "-", h = d.value;
          typeof h == "number" || typeof h == "boolean" || typeof h == "string" ? u = `${h}` : u = JSON.stringify(h), u = u;
          let f = `${(e.outputTensorIdToNodeId || {})[c] ?? c}`, m = r[f];
          if (!m) r[f] = xt(le({}, d), { strValue: u, allValues: { [c]: d.value } });
          else {
            let v = m.allValues;
            v[c] = d.value, r[f] = { value: d.value, bgColor: d.bgColor, textColor: d.textColor, allValues: v, strValue: `${m.strValue}, ${u}` };
          }
        }
        return r;
      }
      getBgColor(e, n, r, o, s) {
        if (r.length > 0) return this.getColorFromGradient(e, r, o, s, true, "transparent");
        for (let a of n) if (e <= a.value) return a.bgColor;
        return "transparent";
      }
      getTextColor(e, n, r, o, s) {
        if (r.length > 0) return this.getColorFromGradient(e, r, o, s, false, "");
        for (let a of n) if (e <= a.value) return a.textColor || "";
        return "";
      }
      getColorFromGradient(e, n, r, o, s, a) {
        let l = (e - r) / (o - r);
        for (let c = 0; c < n.length - 1; c++) {
          let d = n[c], u = n[c + 1], h = s ? d.bgColor : d.textColor, p = s ? u.bgColor : u.textColor;
          if (l >= d.stop && l <= u.stop) {
            if (h == null || p == null) return a;
            let f = (l - d.stop) / (u.stop - d.stop), m = Math.floor(h.r + (p.r - h.r) * f), v = Math.floor(h.g + (p.g - h.g) * f), _ = Math.floor(h.b + (p.b - h.b) * f);
            return `#${this.numToHex(m)}${this.numToHex(v)}${this.numToHex(_)}`;
          }
        }
        return a;
      }
      genOutputTensorIdToNodeIdMap(e) {
        if (e.outputTensorIdToNodeId == null) {
          e.outputTensorIdToNodeId = {};
          for (let n of e.nodes) if (dt(n)) {
            let r = n.outputsMetadata || {};
            for (let o of Object.keys(r)) {
              let a = r[o].tensor_name;
              a != null && (e.outputTensorIdToNodeId[a] = n.id);
            }
          }
        }
      }
      handleModelGraphInPaneChanged(e, n) {
        let r = this.getRunsForModelGraph(e);
        if (r.length > 0) {
          for (let o of r) o.results == null && (o.results = {}), o.results[e.id] == null && o.nodeDataProviderData != null && (o.results[e.id] = this.processNodeDataProviderDataForGraph(e, o.nodeDataProviderData));
          this.appService.setSelectedNodeDataProviderRunId(this.appService.panes()[n].id, r[0].runId);
        }
      }
      getRgbFromColor(e, n) {
        let r = e;
        return e.startsWith("#") || (r = Dy[e]), r || (r = n), r = r.replace("#", ""), { r: this.hexStrToInt(r.substring(0, 2)), g: this.hexStrToInt(r.substring(2, 4)), b: this.hexStrToInt(r.substring(4, 6)) };
      }
      numToHex(e) {
        let n = e.toString(16);
        return n.length === 1 ? `0${n}` : n;
      }
      hexStrToInt(e) {
        return /^[a-fA-F0-9]+$/.test(e) ? parseInt(e, 16) : 255;
      }
      getNodeDataProviderData(e, n) {
        let r = JSON.parse(e), o = {};
        return r.results != null && r.results.results == null ? n && (o[n.id] = r) : o = r, o;
      }
      notifyRemoteNodeDataChanges() {
        let e = Object.values(this.runs()).filter((n) => n.remotePath != null).map((n) => n.remotePath);
        this.appService.remoteNodeDataPaths.set(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var gG = At * 0.5;
  var _G = pn;
  var fw = (() => {
    class i59 {
      nodeDataProviderExtensionService;
      curNodeDataProviderRun = It(() => this.webglRenderer ? this.nodeDataProviderExtensionService.getSelectedRunForModelGraph(this.webglRenderer.paneId, this.webglRenderer.curModelGraph) : void 0);
      curNodeDataProviderResults = It(() => (this.curNodeDataProviderRun()?.results || {})[this.webglRenderer.curModelGraph.id]);
      webglRenderer;
      webglRendererThreejsService;
      threejsService = M(Hi);
      nodeDataProviderDistributionBars = new ci(0);
      nodeDataProviderSummaryTexts = new di(this.threejsService);
      constructor(e) {
        this.nodeDataProviderExtensionService = e;
      }
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService;
      }
      renderNodeDataProviderDistributionBars() {
        let e = this.curNodeDataProviderRun() || {};
        if (Object.keys(e).length === 0) return;
        let n = this.curNodeDataProviderRun();
        if (!n) return;
        let r = this.genGroupIdToSortedValueInfos(), o = (n.nodeDataProviderData ?? {})[this.webglRenderer.curModelGraph.id]?.showExpandedSummaryOnGroupNode, s = [], a = [];
        for (let { node: l, index: c } of this.webglRenderer.nodesToRender) {
          if (!r[l.id]) continue;
          let d = l, u = d.width || 0, h = r[l.id], p = h.reduce((_, g) => _ + g.count, 0), f = 0, m = 0, v = 0;
          o && !d.expanded && (v = Ru * h.length + Sy + FE);
          for (let _ = 0; _ < h.length; _++) {
            let g = h[_], y = g.bgColor;
            if (y === "transparent") continue;
            let w = g.count, E = w / p * u, P = zE, S = f, A = this.webglRenderer.getNodeY(d) + this.webglRenderer.getNodeHeight(d) - v - zE + P / 2;
            if (s.push({ id: `${l.id}_${m}`, index: s.length, bound: { x: this.webglRenderer.getNodeX(d) + S + E / 2, y: A, width: E, height: P }, yOffset: At * c + gG, isRounded: false, borderColor: { r: 1, g: 1, b: 1 }, bgColor: new _G.Color(y), borderWidth: 0, opacity: 1 }), o && !d.expanded) {
              let W = A + Sy + P / 2 + _ * Ru + Ru / 2;
              s.push({ id: `${l.id}_${m}_summary`, index: s.length, bound: { x: this.webglRenderer.getNodeX(d) + 8, y: W, width: 3, height: Ru - 2 }, yOffset: At * c + gG, isRounded: false, borderColor: { r: 1, g: 1, b: 1 }, bgColor: new _G.Color(y), borderWidth: 0, opacity: 1 }), a.push({ id: `${l.id}_${m}_summary`, label: g.label, height: My, hAlign: "left", vAlign: "center", weight: Jt.MEDIUM, color: { r: 0, g: 0, b: 0 }, x: this.webglRenderer.getNodeX(d) + 12, y: 96, z: W }), a.push({ id: `${l.id}_${m}_summary_pct_count`, label: `${Math.floor(w / p * 100)}% (${w})`, height: My, hAlign: "right", vAlign: "center", weight: Jt.MEDIUM, color: { r: 0, g: 0, b: 0 }, x: this.webglRenderer.getNodeX(d) + this.webglRenderer.getNodeWidth(d) - 6, y: 96, z: W });
            }
            f += E, m++;
          }
        }
        this.nodeDataProviderDistributionBars.generateMesh(s), this.webglRendererThreejsService.addToScene(this.nodeDataProviderDistributionBars.mesh), this.nodeDataProviderSummaryTexts.generateMesh(a, false, true, true), this.webglRendererThreejsService.addToScene(this.nodeDataProviderSummaryTexts.mesh);
      }
      updateAnimationProgress(e) {
        this.nodeDataProviderDistributionBars.updateAnimationProgress(e), this.nodeDataProviderSummaryTexts.updateAnimationProgress(e);
      }
      genGroupIdToSortedValueInfos() {
        let e = this.curNodeDataProviderResults() || {}, n = {};
        for (let { node: r } of this.webglRenderer.nodesToRender) if (ct(r) && !r.expanded) {
          let o = If(r, this.webglRenderer.curModelGraph, e);
          o.length > 0 && (n[r.id] = o);
        }
        return n;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(Cr));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var tle = -At * 0.3;
  var nle = At * 0.3;
  var ile = pn;
  var mw = (() => {
    class i59 {
      appService;
      SEARCH_RESULTS_HIGHLIGHT_COLOR = new ile.Color("#f5d55a");
      searchResultsHighlightBorders = new ci(8);
      searchResultsNodeLabelHighlightBg = new ci(4);
      webglRenderer;
      webglRendererThreejsService;
      curSearchResults = void 0;
      constructor(e) {
        this.appService = e;
      }
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService, ht(() => {
          let n = this.appService.getPaneById(this.webglRenderer.paneId);
          !n || !n.modelGraph || this.curSearchResults !== n.searchResults && (this.curSearchResults = n.searchResults, this.renderSearchResults(), this.webglRendererThreejsService.render());
        });
      }
      renderSearchResults() {
        if (!this.curSearchResults) return;
        this.clearSearchResults();
        let e = /* @__PURE__ */ new Set();
        for (let s of Object.keys(this.curSearchResults.results)) {
          let a = this.webglRenderer.curModelGraph.nodesById[s];
          if (this.webglRenderer.isNodeRendered(s)) e.add(s);
          else {
            let l = a;
            for (; l && (l = this.webglRenderer.curModelGraph.nodesById[l.nsParentId || ""], !(!l || this.webglRenderer.isNodeRendered(l.id))); ) ;
            e.add(l.id);
          }
        }
        let n = [];
        for (let s of e) {
          let a = this.webglRenderer.curModelGraph.nodesById[s], l = this.webglRenderer.nodesToRenderMap[s].index, c = this.webglRenderer.getNodeX(a) - 2, d = this.webglRenderer.getNodeY(a) - 2, u = this.webglRenderer.getNodeWidth(a) + 4, h = this.webglRenderer.getNodeHeight(a) + 4;
          n.push({ id: s, index: n.length, bound: { x: c + u / 2, y: d + h / 2, width: u, height: h }, yOffset: At * l + tle, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: this.SEARCH_RESULTS_HIGHLIGHT_COLOR, borderWidth: 0, opacity: 1 });
        }
        this.searchResultsHighlightBorders.generateMesh(n), this.webglRendererThreejsService.addToScene(this.searchResultsHighlightBorders.mesh);
        let r = [], o = Eo / this.webglRenderer.texts.getFontSize();
        for (let s of Object.keys(this.curSearchResults.results)) {
          if (!this.webglRenderer.isNodeRendered(s)) continue;
          let a = this.curSearchResults.results[s];
          for (let l of a) if (l.type === _t.NODE_LABEL) {
            let c = this.webglRenderer.curModelGraph.nodesById[s], d = this.webglRenderer.nodesToRenderMap[s].index, u = this.webglRenderer.getNodeX(c) + this.webglRenderer.getNodeWidth(c) / 2, h = 0, p = 0, f = 0, m = Oc(c.label);
            if (m.length === 1) {
              let v = this.webglRenderer.texts.getLabelSizes(c.label, ct(c) ? Jt.BOLD : Jt.MEDIUM, Eo).sizes;
              f = (v.maxX - v.minX) * o + 4, p = (v.maxZ - v.minZ) * o + 4, h = this.webglRenderer.getNodeY(c) + this.webglRenderer.getNodeLabelRelativeY(c) - 2 * o;
            } else {
              let { minX: v, maxX: _ } = this.webglRenderer.getNodeLabelSizes(c);
              f = (_ - v) * o + 4, p = m.length * Ou + 4, h = this.webglRenderer.getNodeY(c) + p / 2 + 4.5 - 2 * o;
            }
            r.push({ id: s, index: n.length, bound: { x: u, y: h, width: f, height: p }, yOffset: At * d + nle, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: this.SEARCH_RESULTS_HIGHLIGHT_COLOR, borderWidth: 0, opacity: 1 });
          }
        }
        this.searchResultsNodeLabelHighlightBg.generateMesh(r), this.webglRendererThreejsService.addToScene(this.searchResultsNodeLabelHighlightBg.mesh), this.webglRenderer.animateIntoPositions((s) => {
          this.searchResultsHighlightBorders.updateAnimationProgress(s), this.searchResultsNodeLabelHighlightBg.updateAnimationProgress(s);
        });
      }
      clearSearchResults() {
        for (let e of [this.searchResultsHighlightBorders.mesh, this.searchResultsNodeLabelHighlightBg.mesh]) e && (e.geometry && e.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var vG = 320;
  var gw = (() => {
    class i59 {
      appService;
      destroyRef;
      webglRenderer;
      webglRendererThreejsService;
      constructor(e, n) {
        this.appService = e, this.destroyRef = n;
      }
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService, this.appService.addSnapshotClicked.pipe(wi(this.destroyRef)).subscribe((n) => {
          n.rendererId === this.webglRenderer.rendererId && this.addSnapshot();
        }), this.appService.curSnapshotToRestore.pipe(wi(this.destroyRef)).subscribe((n) => {
          n.rendererId === this.webglRenderer.rendererId && this.restoreSnapshot(n.snapshot);
        });
      }
      addSnapshot() {
        return $t(this, null, function* () {
          this.webglRenderer.flash();
          let e = yield this.takeSnapshot();
          this.webglRenderer.appService.addSnapshot(e, this.webglRenderer.curModelGraph.id, this.webglRenderer.paneId);
        });
      }
      takeSnapshot() {
        return $t(this, null, function* () {
          let e = this.webglRenderer.container.nativeElement, n = this.webglRendererThreejsService.convertScreenPosToScene(0, 0), r = this.webglRendererThreejsService.convertScreenPosToScene(e.clientWidth, e.clientHeight), o = { x: n.x, y: n.y, width: r.x - n.x, height: r.y - n.y }, s = [];
          Ef(void 0, this.webglRenderer.curModelGraph, s);
          let a = this.webglRenderer.canvas.nativeElement, l = this.webglRenderer.snapshotCanvas.nativeElement, c = vG, d = vG / a.width * a.height;
          this.webglRendererThreejsService.renderSnapshot(c, d);
          let u = window.devicePixelRatio, h = new OffscreenCanvas(c * u, d * u), p = h.getContext("2d");
          p.imageSmoothingQuality = "high", p.drawImage(l, 0, 0, l.width, l.height, 0, 0, h.width, h.height);
          let f = yield createImageBitmap(h), m = this.webglRenderer.appService.getFlattenLayers(this.webglRenderer.paneId);
          return { id: Li(), rect: o, imageBitmap: f, selectedNodeId: this.webglRenderer.selectedNodeId, deepestExpandedGroupNodeIds: s, showOnNodeItemTypes: le({}, this.webglRenderer.curShowOnNodeItemTypes), showOnEdgeItem: this.webglRenderer.curShowOnEdgeItem ? le({}, this.webglRenderer.curShowOnEdgeItem) : void 0, flattenLayers: m };
        });
      }
      restoreSnapshot(e) {
        e.showOnNodeItemTypes && (this.webglRenderer.curShowOnNodeItemTypes = le({}, e.showOnNodeItemTypes), this.webglRenderer.appService.setShowOnNode(this.webglRenderer.paneId, this.webglRenderer.rendererId, this.webglRenderer.curShowOnNodeItemTypes)), e.showOnEdgeItem && (this.webglRenderer.curShowOnEdgeItem = le({}, e.showOnEdgeItem), this.webglRenderer.appService.setShowOnEdge(this.webglRenderer.paneId, this.webglRenderer.rendererId, this.webglRenderer.curShowOnEdgeItem.type, this.webglRenderer.curShowOnEdgeItem.filterText, this.webglRenderer.curShowOnEdgeItem.outputMetadataKey, this.webglRenderer.curShowOnEdgeItem.inputMetadataKey, this.webglRenderer.curShowOnEdgeItem.sourceNodeAttrKey, this.webglRenderer.curShowOnEdgeItem.targetNodeAttrKey));
        let n = this.webglRenderer.appService.getFlattenLayers(this.webglRenderer.paneId), r = e.flattenLayers === true;
        n !== r ? (this.webglRenderer.appService.processGraph(this.webglRenderer.paneId, r, e), this.webglRenderer.appService.setFlattenLayersInCurrentPane(r)) : this.webglRenderer.sendRelayoutGraphRequest(e.selectedNodeId || "", e.deepestExpandedGroupNodeIds || [], false, e.rect, true, e.showOnNodeItemTypes);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt), Ze(pi));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var yG = { r: 1, g: 1, b: 1 };
  var _w = 14;
  var sle = pn;
  var vw = (() => {
    class i59 {
      appService;
      subgraphSelectionService;
      SUBGRAPH_SELECTED_NODE_MARKER_BG_COLOR = new sle.Color("#09B83E");
      webglRenderer;
      webglRendererThreejsService;
      threejsService = M(Hi);
      curSubgraphSelectedNodeIds = {};
      subgraphsSelectedNodeMarkerBgs = new ci(99);
      subgraphSelectedNodeMarkerTexts = new di(this.threejsService);
      constructor(e, n) {
        this.appService = e, this.subgraphSelectionService = n;
      }
      init(e) {
        this.webglRenderer = e, this.webglRendererThreejsService = e.webglRendererThreejsService, ht(() => {
          this.curSubgraphSelectedNodeIds = this.subgraphSelectionService.selectedNodeIds(), this.renderSubgraphSelectedNodeMarkers();
        });
      }
      renderSubgraphSelectedNodeMarkers() {
        if (!this.enableSubgraphSelection) return;
        let e = Object.keys(this.curSubgraphSelectedNodeIds), n = new Set(e);
        if (this.clearSubgraphSelectedNodeMarkers(), e.length === 0) {
          this.webglRendererThreejsService.render();
          return;
        }
        let r = [], o = /* @__PURE__ */ new Set();
        for (let a of e) {
          let c = this.webglRenderer.curModelGraph.nodesById[a];
          for (; ; ) {
            let d = this.webglRenderer.curModelGraph.nodesById[c.nsParentId || ""];
            if (d) o.add(d.id), c = d;
            else break;
          }
        }
        let s = [];
        for (let a of o) {
          if (!this.webglRenderer.isNodeRendered(a)) continue;
          let l = this.webglRenderer.curModelGraph.nodesById[a], c = this.webglRenderer.getNodeX(l) + this.webglRenderer.getNodeWidth(l), d = this.webglRenderer.getNodeY(l), u = (l.descendantsOpNodeIds || []).filter((f) => {
            let m = this.webglRenderer.curModelGraph.nodesById[f];
            return n.has(m.id);
          }).length;
          s.push({ id: `${a}_subgraph_count_label`, nodeId: a, label: `${u}`, height: 8, hAlign: "center", vAlign: "center", weight: Jt.MEDIUM, color: this.webglRenderer.NODE_LABEL_COLOR, x: c, y: 96, z: d + 1 });
          let h = _w * (u >= 1e3 ? 2 : 1.5), p = _w;
          r.push({ id: a, index: r.length, bound: { x: c, y: d, width: h, height: p }, yOffset: 95.5, isRounded: true, borderColor: this.SUBGRAPH_SELECTED_NODE_MARKER_BG_COLOR, bgColor: yG, borderWidth: 1.5, opacity: 1 });
        }
        for (let a of e) {
          if (!this.webglRenderer.isNodeRendered(a)) continue;
          let l = this.webglRenderer.curModelGraph.nodesById[a], c = this.webglRenderer.getNodeX(l) + this.webglRenderer.getNodeWidth(l), d = this.webglRenderer.getNodeY(l), u = _w, h = _w;
          r.push({ id: a, index: r.length, bound: { x: c, y: d, width: u, height: h }, yOffset: 95.5, isRounded: true, borderColor: this.SUBGRAPH_SELECTED_NODE_MARKER_BG_COLOR, bgColor: yG, borderWidth: 1.5, opacity: 1 }), s.push({ id: `${l.id}_checkmark`, nodeId: l.id, label: "0xe876", height: 24, hAlign: "center", vAlign: "center", weight: Jt.ICONS, color: this.SUBGRAPH_SELECTED_NODE_MARKER_BG_COLOR, x: c, y: 96, z: d + 14, treatLabelAsAWhole: true, weightLevel: 0.9 });
        }
        this.subgraphsSelectedNodeMarkerBgs.generateMesh(r, false, false, false, true), this.webglRendererThreejsService.addToScene(this.subgraphsSelectedNodeMarkerBgs.mesh), this.subgraphSelectedNodeMarkerTexts.generateMesh(s, false, true, true), this.webglRendererThreejsService.addToScene(this.subgraphSelectedNodeMarkerTexts.mesh), this.webglRenderer.animateIntoPositions((a) => {
          this.subgraphsSelectedNodeMarkerBgs.updateAnimationProgress(a), this.subgraphSelectedNodeMarkerTexts.updateAnimationProgress(a);
        });
      }
      get enableSubgraphSelection() {
        return this.appService.config()?.enableSubgraphSelection === true;
      }
      clearSubgraphSelectedNodeMarkers() {
        for (let e of [this.subgraphsSelectedNodeMarkerBgs.mesh, this.subgraphSelectedNodeMarkerTexts.mesh]) e && (e.geometry && e.geometry.dispose(), this.webglRendererThreejsService.removeFromScene(e));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt), Ze(Fo));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Sr = 500;
  var bG = 200;
  var zo = pn;
  var yw = (() => {
    class i59 {
      curScale = 1;
      fps = "";
      camera;
      raycaster;
      zoom = bI();
      webglRenderer;
      curTranslateX = 0;
      curTranslateY = 0;
      scene;
      renderer;
      snapshotRenderer;
      pngDownloaderRenderer;
      savedCenterX = null;
      savedCenterY = null;
      resizeTimeoutRef = -1;
      fpsStartTime = -1;
      frames = 0;
      init(e) {
        this.webglRenderer = e;
      }
      setupZoomAndPan(e, n = 0.1, r = 10) {
        let o = Ro(e), s = 0, a = 0;
        this.zoom.scaleExtent([n, r]).wheelDelta(() => -pt.deltaY * (pt.deltaMode ? 120 : 1) / 150).filter(() => {
          if (pt.type === "mousedown" && (s = this.curTranslateX, a = this.curTranslateY), pt.button === 2 || Mf && pt.ctrlKey && pt.button === 0 && pt.type === "mousedown") return false;
          if (pt.type === "dblclick") return pt.stopPropagation(), this.webglRenderer.handleDoubleClickOnGraph(pt.altKey, pt.shiftKey), false;
          if (pt.type === "wheel" && !pt.ctrlKey) {
            let l = 0.5 / this.curScale;
            return this.zoom.translateBy(o, -Number(pt.deltaX) * l, -Number(pt.deltaY) * l), pt.preventDefault(), false;
          }
          return true;
        }).on("zoom", () => {
          this.handleZoom();
        }).on("end", () => {
          this.handleZoomEnd(s, a);
        }), this.zoom.interpolate(Xc), o.call(this.zoom);
      }
      setupThreeJs() {
        let e = this.webglRenderer.canvas.nativeElement;
        this.scene = new zo.Scene(), this.scene.background = new zo.Color(16777215);
        let n = e.clientWidth / e.clientHeight;
        this.camera = new zo.OrthographicCamera(0, 2 * Sr * n, 0, -2 * Sr, 1e-3, 1e3), this.camera.position.y = bG, this.camera.lookAt(new zo.Vector3(0, 0, 0)), this.camera.updateMatrixWorld(), this.camera.updateProjectionMatrix(), this.renderer = new zo.WebGLRenderer({ canvas: e, powerPreference: "high-performance", precision: "highp", antialias: true, alpha: true });
        let r = Pc();
        this.renderer.setPixelRatio(r), this.renderer.setSize(e.clientWidth, e.clientHeight);
        let o = this.webglRenderer.snapshotCanvas.nativeElement;
        this.snapshotRenderer = new zo.WebGLRenderer({ canvas: o, powerPreference: "high-performance", precision: "highp", antialias: true, alpha: true, preserveDrawingBuffer: true }), this.snapshotRenderer.setPixelRatio(r), this.render(), new ResizeObserver(() => {
          requestAnimationFrame(() => {
            this.resizeRendererToDisplaySize();
          });
        }).observe(this.webglRenderer.container.nativeElement), this.raycaster = new zo.Raycaster(), this.raycaster.params.Points.threshold = 5.5;
      }
      clearScene(e = []) {
        for (let n = this.scene.children.length - 1; n >= 0; n--) {
          let r = this.scene.children[n];
          e.includes(r) || (r.geometry && r.geometry.dispose(), this.scene.remove(r));
        }
      }
      setupPngDownloaderRenderer(e, n, r, o) {
        this.pngDownloaderRenderer || (this.pngDownloaderRenderer = new zo.WebGLRenderer({ canvas: e, powerPreference: "high-performance", precision: "highp", antialias: true, alpha: true, preserveDrawingBuffer: true }), this.pngDownloaderRenderer.setPixelRatio(Pc())), n && (this.scene.background = null, this.pngDownloaderRenderer.setClearColor(0, 0)), this.pngDownloaderRenderer.setSize(r, o, false);
      }
      renderPngDownloader(e) {
        this.pngDownloaderRenderer.render(this.scene, e);
      }
      renderSnapshot(e, n) {
        this.snapshotRenderer.setSize(e, n, false), this.snapshotRenderer.render(this.scene, this.camera);
      }
      setSceneBackground(e) {
        this.scene.background = e;
      }
      createOrthographicCamera(e, n, r, o) {
        let s = new zo.OrthographicCamera(e, n, r, o, 1e-3, 1e3);
        return s.position.y = bG, s.lookAt(new zo.Vector3(0, 0, 0)), s.updateMatrixWorld(), s.updateProjectionMatrix(), s;
      }
      dispose() {
        this.renderer && (this.renderer.dispose(), this.renderer.forceContextLoss()), this.snapshotRenderer && (this.snapshotRenderer.dispose(), this.snapshotRenderer.forceContextLoss()), this.pngDownloaderRenderer && (this.pngDownloaderRenderer.dispose(), this.pngDownloaderRenderer.forceContextLoss());
      }
      render(e = false) {
        if (!(!this.renderer || !this.scene || !this.camera) && (this.renderer.render(this.scene, this.camera), this.webglRenderer.benchmark && e)) {
          this.fpsStartTime < 0 && (this.fpsStartTime = performance.now()), this.frames += 1;
          let n = performance.now() - this.fpsStartTime;
          n > 1e3 && (this.fps = (this.frames / n * 1e3).toFixed(1), this.fpsStartTime = -1, this.frames = 0, this.webglRenderer.changeDetectorRef.markForCheck());
        }
      }
      zoomFitGraph(e = 0.9, n = 200) {
        this.zoomFit({ x: this.webglRenderer.currentMinX, y: this.webglRenderer.currentMinZ, width: this.webglRenderer.currentMaxX - this.webglRenderer.currentMinX, height: this.webglRenderer.currentMaxZ - this.webglRenderer.currentMinZ }, e, n);
      }
      zoomFit(e, n = 0.9, r = 300, o = false, s = true, a = false) {
        if (!this.webglRenderer.container) return;
        let l = this.webglRenderer.container.nativeElement, c = l.clientWidth * n, d = l.clientHeight * n, u = e.width / e.height, h = c / d, p = o ? this.curScale : Math.abs(u > h ? this.convertXFromScreenToScene(c) / e.width : this.convertZFromScreenToScene(d) / e.height), f = e.x + e.width / 2, m = e.y + e.height / 2;
        if (!o && s) {
          let v = this.convertZFromScreenToScene(45) / 30;
          if (p = Math.min(v, p), a) {
            let _ = this.convertZFromScreenToScene(20) / 30;
            p < _ && (m = e.y + this.convertZFromScreenToScene(d / 2 - 60, _), p = Math.max(_, p));
          }
        }
        this.centerViewAt(f, m, p, r);
      }
      zoomFitOnNode(e, n, r) {
        e ? setTimeout(() => {
          let o = n.nodesById[e];
          this.zoomFit({ x: this.webglRenderer.getNodeX(o), y: this.webglRenderer.getNodeY(o), width: this.webglRenderer.getNodeWidth(o), height: this.webglRenderer.getNodeHeight(o) }, 0.9, r, false, true, true);
        }, 0) : setTimeout(() => {
          this.zoomFitGraph(0.9, r);
        });
      }
      zoomFitOnNodes(e, n, r) {
        e.length === 0 ? setTimeout(() => {
          this.zoomFitGraph(0.9, r);
        }) : setTimeout(() => {
          let o = 1 / 0, s = -1 / 0, a = 1 / 0, l = -1 / 0;
          for (let c of e) {
            let d = n.nodesById[c];
            d && (o = Math.min(o, this.webglRenderer.getNodeX(d)), s = Math.max(s, this.webglRenderer.getNodeX(d) + this.webglRenderer.getNodeWidth(d)), a = Math.min(a, this.webglRenderer.getNodeY(d)), l = Math.max(l, this.webglRenderer.getNodeY(d) + this.webglRenderer.getNodeHeight(d)));
          }
          this.zoomFit({ x: o, y: a, width: s - o, height: l - a }, 0.9, r, false, true, true);
        }, 0);
      }
      addToScene(e) {
        e && this.scene.add(e);
      }
      removeFromScene(e) {
        e && this.scene.remove(e);
      }
      convertXFromSceneToScreen(e) {
        if (!this.webglRenderer.container) return 0;
        let n = this.webglRenderer.container.nativeElement, r = n.clientWidth, o = r / n.clientHeight;
        return e / (Sr / 1 * o) / -2 * r;
      }
      convertZFromSceneToScreen(e) {
        if (!this.webglRenderer.container) return 0;
        let r = this.webglRenderer.container.nativeElement.clientHeight;
        return e * 1 * r / Sr / 2;
      }
      convertXFromScreenToScene(e) {
        if (!this.webglRenderer.container) return 0;
        let n = this.webglRenderer.container.nativeElement, r = n.clientWidth, o = r / n.clientHeight;
        return e / r * -2 * (Sr / 1 * o);
      }
      convertZFromScreenToScene(e, n = 1) {
        if (!this.webglRenderer.container) return 0;
        let o = this.webglRenderer.container.nativeElement.clientHeight;
        return e * Sr * 2 / n / o;
      }
      convertScenePosToScreen(e, n) {
        let r = this.webglRenderer.container.nativeElement, o = r.clientWidth, s = r.clientHeight, a = new zo.Vector3(e, 0, n);
        return a.project(this.camera), { x: a.x * o / 2 + o / 2, y: -(a.y * s / 2) + s / 2 };
      }
      convertScreenPosToScene(e, n) {
        let r = new zo.Vector3();
        r.set(e / this.webglRenderer.canvas.nativeElement.offsetWidth * 2 - 1, -(n / this.webglRenderer.canvas.nativeElement.offsetHeight) * 2 + 1, -1);
        let o = r.unproject(this.camera);
        return { x: o.x, y: o.z };
      }
      handleZoom() {
        this.curScale = pt.transform.k, this.curTranslateX = pt.transform.x, this.curTranslateY = pt.transform.y, requestAnimationFrame(() => {
          this.camera && (this.setCameraFrustum(), this.webglRenderer.updateNodeBgColorWhenFar(), this.render(), this.webglRenderer.handleHoveredGroupNodeIconChanged());
        });
      }
      handleZoomEnd(e, n) {
        if (pt.sourceEvent && pt.sourceEvent.type === "mouseup") {
          let r = Math.abs(this.curTranslateX - e), o = Math.abs(this.curTranslateY - n);
          r >= 0 && r <= 3 && o >= 0 && o <= 3 && this.webglRenderer.handleClickOnGraph(pt.sourceEvent.shiftKey);
        }
      }
      setCameraFrustum() {
        let e = this.webglRenderer.container.nativeElement, n = e.clientWidth, r = e.clientHeight, o = n / r, s = this.curTranslateX - n / 2, a = this.curTranslateY - r / 2;
        this.camera.left = -Sr / this.curScale * o - s / n * 2 * Sr / this.curScale * o, this.camera.right = Sr / this.curScale * o - s / n * 2 * Sr / this.curScale * o, this.camera.top = Sr / this.curScale + a * Sr / this.curScale / r * 2, this.camera.bottom = -Sr / this.curScale + a * Sr / this.curScale / r * 2, this.camera.updateProjectionMatrix();
      }
      resizeRendererToDisplaySize(e = true) {
        let n = this.webglRenderer.container.nativeElement, r = this.renderer.domElement, o = n.clientWidth, s = n.clientHeight;
        if (o === 0 || s === 0) return;
        if (r.width !== o || r.height !== s) {
          if (this.savedCenterX == null && this.savedCenterY == null) {
            let { x: l, y: c } = this.convertScreenPosToScene(o / 2, s / 2);
            this.savedCenterX = l, this.savedCenterY = c;
          }
          this.renderer.setSize(o, s, false), this.webglRenderer.canvas.nativeElement.style.width = "100%", this.webglRenderer.canvas.nativeElement.style.height = "100%", this.setCameraFrustum(), this.render(), this.zoomFit({ x: this.savedCenterX, y: this.savedCenterY, width: 1e-7, height: 1e-7 }, 0.9, 0, true), this.resizeTimeoutRef >= 0 && window.clearTimeout(this.resizeTimeoutRef), this.resizeTimeoutRef = window.setTimeout(() => {
            this.savedCenterX = null, this.savedCenterY = null;
          }, 500);
        }
      }
      centerViewAt(e, n, r, o = 300) {
        if (!this.webglRenderer.container) return;
        let s = this.webglRenderer.container.nativeElement, a = s.clientWidth, l = s.clientHeight, c = a / l, d = -2 * Sr * c / 2 / r + e, u = -n + Sr / r, h = id.scale(r).translate(this.convertXFromSceneToScreen(d), this.convertZFromSceneToScreen(u)), p = Ro(s);
        o === 0 ? p.call(this.zoom.transform, h) : p.transition().duration(this.webglRenderer.appService.testMode ? 0 : o).ease(tI).call(this.zoom.transform, h);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var hp = function(i59) {
    return i59.COLOR = "COLOR", i59.NUMBER = "NUMBER", i59;
  }(hp || {});
  var cle = { type: hp.COLOR, label: "Bg color", id: Is.NODE_BG_COLOR, defaultValue: "#ffffff" };
  var dle = { type: hp.COLOR, label: "Border color", id: Is.NODE_BORDER_COLOR, defaultValue: "#777777" };
  var ule = { type: hp.COLOR, label: "Text color", id: Is.NODE_TEXT_COLOR, defaultValue: "#041e49" };
  var wG = [cle, dle, ule];
  var xG = "model_explorer_node_styler_rules";
  var Ys = (() => {
    class i59 {
      appService;
      localStorageService;
      rules = gt([]);
      matchedNodes = gt({});
      hasNonEmptyNodeStylerRules = It(() => this.rules().filter((e) => ku(e.queries) && Object.keys(e.styles).length > 0).length > 0);
      constructor(e, n) {
        if (this.appService = e, this.localStorageService = n, ht(() => {
          let r = this.rules();
          this.appService.testMode || this.localStorageService.setItem(xG, JSON.stringify(r)), this.computeMatchedNodes(r);
        }), this.appService.testMode) {
          let r = new URLSearchParams(document.location.search), o = decodeURIComponent(r.get("test_node_styler_rules") || "");
          this.updateRules(o === "" ? [] : JSON.parse(o));
        } else {
          let r = this.localStorageService.getItem(xG) || "", o = r === "" ? [] : JSON.parse(r);
          this.updateRules(o);
        }
      }
      addNewRule() {
        this.rules.update((e) => {
          let n = [...e];
          return n.push({ queries: [{ type: Dn.NODE_TYPE, nodeType: _r.OP_NODES }, { type: Dn.REGEX, queryRegex: "", matchTypes: [_t.NODE_LABEL] }], nodeType: _r.OP_NODES, styles: {}, version: Py.V2 }), n;
        });
      }
      moveUpRule(e) {
        this.rules.update((n) => {
          let r = [...n], o = n[e];
          return r.splice(e, 1), r.splice(e - 1, 0, o), r;
        });
      }
      moveDownRule(e) {
        this.rules.update((n) => {
          let r = [...n], o = n[e];
          return r.splice(e, 1), r.splice(e + 1, 0, o), r;
        });
      }
      duplicateRule(e) {
        this.rules.update((n) => {
          let r = JSON.parse(JSON.stringify(n[e]));
          return [...n.slice(0, e), r, ...n.slice(e)];
        });
      }
      updateRules(e) {
        this.rules.set(this.convertOldRulesIfNecessary(e));
      }
      updateQueries(e, n) {
        this.rules.update((r) => {
          let o = r[e];
          return o.queries = n, [...r];
        });
      }
      toggleStyle(e, n, r) {
        this.rules.update((o) => {
          let s = o[e];
          return r == null ? s.styles[n.id] == null ? s.styles[n.id] = { id: n.id, value: n.defaultValue } : delete s.styles[n.id] : r ? s.styles[n.id] = { id: n.id, value: n.defaultValue } : delete s.styles[n.id], [...o];
        });
      }
      updateStyleValue(e, n, r) {
        this.rules.update((o) => {
          let s = o[e], a = s.styles[n.id];
          return a && (typeof a == "string" ? s.styles[n.id] = r : a.value = r), [...o];
        });
      }
      deleteRule(e) {
        this.rules.update((n) => {
          let r = [...n];
          return r.splice(e, 1), r;
        });
      }
      convertOldRulesIfNecessary(e) {
        return e.map((n) => {
          if (n.version == null && n.nodeType) {
            let r = { type: Dn.NODE_TYPE, nodeType: n.nodeType };
            n.queries.unshift(r), n.version = Py.V2;
          }
          return n;
        });
      }
      computeMatchedNodes(e) {
        let n = Ay(e), r = {};
        if (e.length > 0 && e.some((o) => ku(o.queries))) {
          let o = this.appService.panes();
          for (let s = 0; s < o.length; s++) {
            let a = o[s].modelGraph;
            if (a) for (let l of a.nodes) for (let c = 0; c < n.length; c++) {
              let d = n[c];
              if (ku(e[c].queries) && Tf(l, d.queries, a, this.appService.config())) {
                r[c] == null && (r[c] = {}), r[c][s] == null && (r[c][s] = []), r[c][s].push(l);
                break;
              }
            }
          }
        }
        this.matchedNodes.set(r);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(Ze(nt), Ze(Io));
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  function hle(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 1)(1, "button", 2), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.action());
      }), D(2), x()();
    }
    if (i59 & 2) {
      let e = T();
      C(2), Oe(" ", e.data.action, " ");
    }
  }
  var ple = ["label"];
  function fle(i59, t) {
  }
  var mle = Math.pow(2, 31) - 1;
  var Wg = class {
    _overlayRef;
    instance;
    containerInstance;
    _afterDismissed = new we();
    _afterOpened = new we();
    _onAction = new we();
    _durationTimeoutId;
    _dismissedByAction = false;
    constructor(t, e) {
      this._overlayRef = e, this.containerInstance = t, t._onExit.subscribe(() => this._finishDismiss());
    }
    dismiss() {
      this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId);
    }
    dismissWithAction() {
      this._onAction.closed || (this._dismissedByAction = true, this._onAction.next(), this._onAction.complete(), this.dismiss()), clearTimeout(this._durationTimeoutId);
    }
    closeWithAction() {
      this.dismissWithAction();
    }
    _dismissAfter(t) {
      this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(t, mle));
    }
    _open() {
      this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete());
    }
    _finishDismiss() {
      this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), this._afterDismissed.next({ dismissedByAction: this._dismissedByAction }), this._afterDismissed.complete(), this._dismissedByAction = false;
    }
    afterDismissed() {
      return this._afterDismissed;
    }
    afterOpened() {
      return this.containerInstance._onEnter;
    }
    onAction() {
      return this._onAction;
    }
  };
  var CG = new Ee("MatSnackBarData");
  var pp = class {
    politeness = "assertive";
    announcementMessage = "";
    viewContainerRef;
    duration = 0;
    panelClass;
    direction;
    data = null;
    horizontalPosition = "center";
    verticalPosition = "bottom";
  };
  var gle = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "matSnackBarLabel", ""]], hostAttrs: [1, "mat-mdc-snack-bar-label", "mdc-snackbar__label"] });
    }
    return i59;
  })();
  var _le = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "matSnackBarActions", ""]], hostAttrs: [1, "mat-mdc-snack-bar-actions", "mdc-snackbar__actions"] });
    }
    return i59;
  })();
  var vle = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "matSnackBarAction", ""]], hostAttrs: [1, "mat-mdc-snack-bar-action", "mdc-snackbar__action"] });
    }
    return i59;
  })();
  var yle = (() => {
    class i59 {
      snackBarRef = M(Wg);
      data = M(CG);
      constructor() {
      }
      action() {
        this.snackBarRef.dismissWithAction();
      }
      get hasAction() {
        return !!this.data.action;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["simple-snack-bar"]], hostAttrs: [1, "mat-mdc-simple-snack-bar"], exportAs: ["matSnackBar"], decls: 3, vars: 2, consts: [["matSnackBarLabel", ""], ["matSnackBarActions", ""], ["mat-button", "", "matSnackBarAction", "", 3, "click"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0), D(1), x(), X(2, hle, 3, 1, "div", 1)), n & 2 && (C(), Oe(" ", r.data.message, `
`), C(), he(r.hasAction ? 2 : -1));
      }, dependencies: [vr, gle, _le, vle], styles: [".mat-mdc-simple-snack-bar{display:flex}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var ble = { snackBarState: ki("state", [Zi("void, hidden", _n({ transform: "scale(0.8)", opacity: 0 })), Zi("visible", _n({ transform: "scale(1)", opacity: 1 })), Yn("* => visible", oi("150ms cubic-bezier(0, 0, 0.2, 1)")), Yn("* => void, * => hidden", oi("75ms cubic-bezier(0.4, 0.0, 1, 1)", _n({ opacity: 0 })))]) };
  var xle = (() => {
    class i59 extends js {
      _ngZone = M(We);
      _elementRef = M(He);
      _changeDetectorRef = M(Ge);
      _platform = M(Nn);
      snackBarConfig = M(pp);
      _document = M(yt);
      _trackedModals = /* @__PURE__ */ new Set();
      _announceDelay = 150;
      _announceTimeoutId;
      _destroyed = false;
      _portalOutlet;
      _onAnnounce = new we();
      _onExit = new we();
      _onEnter = new we();
      _animationState = "void";
      _live;
      _label;
      _role;
      _liveElementId = M(kn).getId("mat-snack-bar-container-live-");
      constructor() {
        super();
        let e = this.snackBarConfig;
        e.politeness === "assertive" && !e.announcementMessage ? this._live = "assertive" : e.politeness === "off" ? this._live = "off" : this._live = "polite", this._platform.FIREFOX && (this._live === "polite" && (this._role = "status"), this._live === "assertive" && (this._role = "alert"));
      }
      attachComponentPortal(e) {
        this._assertNotAttached();
        let n = this._portalOutlet.attachComponentPortal(e);
        return this._afterPortalAttached(), n;
      }
      attachTemplatePortal(e) {
        this._assertNotAttached();
        let n = this._portalOutlet.attachTemplatePortal(e);
        return this._afterPortalAttached(), n;
      }
      attachDomPortal = (e) => {
        this._assertNotAttached();
        let n = this._portalOutlet.attachDomPortal(e);
        return this._afterPortalAttached(), n;
      };
      onAnimationEnd(e) {
        let { fromState: n, toState: r } = e;
        if ((r === "void" && n !== "void" || r === "hidden") && this._completeExit(), r === "visible") {
          let o = this._onEnter;
          this._ngZone.run(() => {
            o.next(), o.complete();
          });
        }
      }
      enter() {
        this._destroyed || (this._animationState = "visible", this._changeDetectorRef.markForCheck(), this._changeDetectorRef.detectChanges(), this._screenReaderAnnounce());
      }
      exit() {
        return this._ngZone.run(() => {
          this._animationState = "hidden", this._changeDetectorRef.markForCheck(), this._elementRef.nativeElement.setAttribute("mat-exit", ""), clearTimeout(this._announceTimeoutId);
        }), this._onExit;
      }
      ngOnDestroy() {
        this._destroyed = true, this._clearFromModals(), this._completeExit();
      }
      _completeExit() {
        queueMicrotask(() => {
          this._onExit.next(), this._onExit.complete();
        });
      }
      _afterPortalAttached() {
        let e = this._elementRef.nativeElement, n = this.snackBarConfig.panelClass;
        n && (Array.isArray(n) ? n.forEach((s) => e.classList.add(s)) : e.classList.add(n)), this._exposeToModals();
        let r = this._label.nativeElement, o = "mdc-snackbar__label";
        r.classList.toggle(o, !r.querySelector(`.${o}`));
      }
      _exposeToModals() {
        let e = this._liveElementId, n = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
        for (let r = 0; r < n.length; r++) {
          let o = n[r], s = o.getAttribute("aria-owns");
          this._trackedModals.add(o), s ? s.indexOf(e) === -1 && o.setAttribute("aria-owns", s + " " + e) : o.setAttribute("aria-owns", e);
        }
      }
      _clearFromModals() {
        this._trackedModals.forEach((e) => {
          let n = e.getAttribute("aria-owns");
          if (n) {
            let r = n.replace(this._liveElementId, "").trim();
            r.length > 0 ? e.setAttribute("aria-owns", r) : e.removeAttribute("aria-owns");
          }
        }), this._trackedModals.clear();
      }
      _assertNotAttached() {
        this._portalOutlet.hasAttached();
      }
      _screenReaderAnnounce() {
        this._announceTimeoutId || this._ngZone.runOutsideAngular(() => {
          this._announceTimeoutId = setTimeout(() => {
            let e = this._elementRef.nativeElement.querySelector("[aria-hidden]"), n = this._elementRef.nativeElement.querySelector("[aria-live]");
            if (e && n) {
              let r = null;
              this._platform.isBrowser && document.activeElement instanceof HTMLElement && e.contains(document.activeElement) && (r = document.activeElement), e.removeAttribute("aria-hidden"), n.appendChild(e), r?.focus(), this._onAnnounce.next(), this._onAnnounce.complete();
            }
          }, this._announceDelay);
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-snack-bar-container"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Bo, 7), Fe(ple, 7)), n & 2) {
          let o;
          Ie(o = De()) && (r._portalOutlet = o.first), Ie(o = De()) && (r._label = o.first);
        }
      }, hostAttrs: [1, "mdc-snackbar", "mat-mdc-snack-bar-container"], hostVars: 1, hostBindings: function(n, r) {
        n & 1 && xM("@state.done", function(s) {
          return r.onAnimationEnd(s);
        }), n & 2 && cf("@state", r._animationState);
      }, features: [Zt], decls: 6, vars: 3, consts: [["label", ""], [1, "mdc-snackbar__surface", "mat-mdc-snackbar-surface"], [1, "mat-mdc-snack-bar-label"], ["aria-hidden", "true"], ["cdkPortalOutlet", ""]], template: function(n, r) {
        n & 1 && (b(0, "div", 1)(1, "div", 2, 0)(3, "div", 3), X(4, fle, 0, 0, "ng-template", 4), x(), ae(5, "div"), x()()), n & 2 && (C(5), Ke("aria-live", r._live)("role", r._role)("id", r._liveElementId));
      }, dependencies: [Bo], styles: [".mat-mdc-snack-bar-container{display:flex;align-items:center;justify-content:center;box-sizing:border-box;-webkit-tap-highlight-color:rgba(0,0,0,0);margin:8px}.mat-mdc-snack-bar-handset .mat-mdc-snack-bar-container{width:100vw}.mat-mdc-snackbar-surface{box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);display:flex;align-items:center;justify-content:flex-start;box-sizing:border-box;padding-left:0;padding-right:8px}[dir=rtl] .mat-mdc-snackbar-surface{padding-right:0;padding-left:8px}.mat-mdc-snack-bar-container .mat-mdc-snackbar-surface{min-width:344px;max-width:672px}.mat-mdc-snack-bar-handset .mat-mdc-snackbar-surface{width:100%;min-width:0}@media(forced-colors: active){.mat-mdc-snackbar-surface{outline:solid 1px}}.mat-mdc-snack-bar-container .mat-mdc-snackbar-surface{color:var(--mdc-snackbar-supporting-text-color, var(--mat-sys-inverse-on-surface));border-radius:var(--mdc-snackbar-container-shape, var(--mat-sys-corner-extra-small));background-color:var(--mdc-snackbar-container-color, var(--mat-sys-inverse-surface))}.mdc-snackbar__label{width:100%;flex-grow:1;box-sizing:border-box;margin:0;padding:14px 8px 14px 16px}[dir=rtl] .mdc-snackbar__label{padding-left:8px;padding-right:16px}.mat-mdc-snack-bar-container .mdc-snackbar__label{font-family:var(--mdc-snackbar-supporting-text-font, var(--mat-sys-body-medium-font));font-size:var(--mdc-snackbar-supporting-text-size, var(--mat-sys-body-medium-size));font-weight:var(--mdc-snackbar-supporting-text-weight, var(--mat-sys-body-medium-weight));line-height:var(--mdc-snackbar-supporting-text-line-height, var(--mat-sys-body-medium-line-height))}.mat-mdc-snack-bar-actions{display:flex;flex-shrink:0;align-items:center;box-sizing:border-box}.mat-mdc-snack-bar-handset,.mat-mdc-snack-bar-container,.mat-mdc-snack-bar-label{flex:1 1 auto}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled).mat-unthemed{color:var(--mat-snack-bar-button-color, var(--mat-sys-inverse-primary))}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled){--mat-text-button-state-layer-color:currentColor;--mat-text-button-ripple-color:currentColor}.mat-mdc-snack-bar-container .mat-mdc-button.mat-mdc-snack-bar-action:not(:disabled) .mat-ripple-element{opacity:.1}"], encapsulation: 2, data: { animation: [ble.snackBarState] } });
    }
    return i59;
  })();
  function wle() {
    return new pp();
  }
  var Cle = new Ee("mat-snack-bar-default-options", { providedIn: "root", factory: wle });
  var Gl = (() => {
    class i59 {
      _overlay = M(fn);
      _live = M(ub);
      _injector = M(mt);
      _breakpointObserver = M(Jy);
      _parentSnackBar = M(i59, { optional: true, skipSelf: true });
      _defaultConfig = M(Cle);
      _snackBarRefAtThisLevel = null;
      simpleSnackBarComponent = yle;
      snackBarContainerComponent = xle;
      handsetCssClass = "mat-mdc-snack-bar-handset";
      get _openedSnackBarRef() {
        let e = this._parentSnackBar;
        return e ? e._openedSnackBarRef : this._snackBarRefAtThisLevel;
      }
      set _openedSnackBarRef(e) {
        this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = e : this._snackBarRefAtThisLevel = e;
      }
      constructor() {
      }
      openFromComponent(e, n) {
        return this._attach(e, n);
      }
      openFromTemplate(e, n) {
        return this._attach(e, n);
      }
      open(e, n = "", r) {
        let o = le(le({}, this._defaultConfig), r);
        return o.data = { message: e, action: n }, o.announcementMessage === e && (o.announcementMessage = void 0), this.openFromComponent(this.simpleSnackBarComponent, o);
      }
      dismiss() {
        this._openedSnackBarRef && this._openedSnackBarRef.dismiss();
      }
      ngOnDestroy() {
        this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss();
      }
      _attachSnackBarContainer(e, n) {
        let r = n && n.viewContainerRef && n.viewContainerRef.injector, o = mt.create({ parent: r || this._injector, providers: [{ provide: pp, useValue: n }] }), s = new Ui(this.snackBarContainerComponent, n.viewContainerRef, o), a = e.attach(s);
        return a.instance.snackBarConfig = n, a.instance;
      }
      _attach(e, n) {
        let r = le(le(le({}, new pp()), this._defaultConfig), n), o = this._createOverlay(r), s = this._attachSnackBarContainer(o, r), a = new Wg(s, o);
        if (e instanceof ni) {
          let l = new go(e, null, { $implicit: r.data, snackBarRef: a });
          a.instance = s.attachTemplatePortal(l);
        } else {
          let l = this._createInjector(r, a), c = new Ui(e, void 0, l), d = s.attachComponentPortal(c);
          a.instance = d.instance;
        }
        return this._breakpointObserver.observe(J2.HandsetPortrait).pipe(Je(o.detachments())).subscribe((l) => {
          o.overlayElement.classList.toggle(this.handsetCssClass, l.matches);
        }), r.announcementMessage && s._onAnnounce.subscribe(() => {
          this._live.announce(r.announcementMessage, r.politeness);
        }), this._animateSnackBar(a, r), this._openedSnackBarRef = a, this._openedSnackBarRef;
      }
      _animateSnackBar(e, n) {
        e.afterDismissed().subscribe(() => {
          this._openedSnackBarRef == e && (this._openedSnackBarRef = null), n.announcementMessage && this._live.clear();
        }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => {
          e.containerInstance.enter();
        }), this._openedSnackBarRef.dismiss()) : e.containerInstance.enter(), n.duration && n.duration > 0 && e.afterOpened().subscribe(() => e._dismissAfter(n.duration));
      }
      _createOverlay(e) {
        let n = new Gi();
        n.direction = e.direction;
        let r = this._overlay.position().global(), o = e.direction === "rtl", s = e.horizontalPosition === "left" || e.horizontalPosition === "start" && !o || e.horizontalPosition === "end" && o, a = !s && e.horizontalPosition !== "center";
        return s ? r.left("0") : a ? r.right("0") : r.centerHorizontally(), e.verticalPosition === "top" ? r.top("0") : r.bottom("0"), n.positionStrategy = r, this._overlay.create(n);
      }
      _createInjector(e, n) {
        let r = e && e.viewContainerRef && e.viewContainerRef.injector;
        return mt.create({ parent: r || this._injector, providers: [{ provide: Wg, useValue: n }, { provide: CG, useValue: e.data }] });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var dn = function(i59) {
    return i59.DISABLED = "disabled", i59.MATCH_NODE_ID = "match_node_id", i59.VISUALIZER_CONFIG = "visualizer_config", i59.UPLOAD_MAPPING_FROM_COMPUTER = "from_computer", i59.LOAD_MAPPING_FROM_CNS = "from_cns", i59;
  }(dn || {});
  var MG = { [dn.DISABLED]: "Disabled", [dn.MATCH_NODE_ID]: "Match node id", [dn.UPLOAD_MAPPING_FROM_COMPUTER]: "Upload mapping from computer", [dn.LOAD_MAPPING_FROM_CNS]: "Load mapping from CNS", [dn.VISUALIZER_CONFIG]: "From Visualizer Config" };
  var Xs = (() => {
    class i59 {
      mode = gt(dn.DISABLED);
      navigationSourceChanged$ = new we();
      loadingFromCns = gt(false);
      syncNavigationModeChanged$ = new we();
      showNoMappedNodeMessageTrigger$ = new we();
      savedProcessedSyncNavigationData = {};
      updateNavigationSource(e) {
        this.mode() !== dn.DISABLED && this.navigationSourceChanged$.next(e);
      }
      updateSyncNavigationData(e, n) {
        let r = xt(le({}, n), { leftToRightMapping: {}, rightToLeftMapping: {}, leftRelatedNodes: {}, rightRelatedNodes: {} });
        if (n.mappingEntries) for (let o of n.mappingEntries) {
          for (let s of o.leftNodeIds) r.leftToRightMapping[s] = o.rightNodeIds, r.leftRelatedNodes[s] = o.leftNodeIds;
          for (let s of o.rightNodeIds) r.rightToLeftMapping[s] = o.leftNodeIds, r.rightRelatedNodes[s] = o.rightNodeIds;
        }
        else if (n.mapping) for (let o of Object.keys(n.mapping)) {
          let s = n.mapping[o];
          r.leftToRightMapping[o] = [s], r.rightToLeftMapping[s] = [o], r.leftRelatedNodes[o] = [o], r.rightRelatedNodes[s] = [s];
        }
        this.savedProcessedSyncNavigationData[e] = r;
      }
      getMappedNodeIds(e, n) {
        let r = this.mode(), o = this.savedProcessedSyncNavigationData[r];
        switch (r) {
          case dn.MATCH_NODE_ID:
            return [n];
          case dn.VISUALIZER_CONFIG:
          case dn.UPLOAD_MAPPING_FROM_COMPUTER:
          case dn.LOAD_MAPPING_FROM_CNS: {
            let s = o?.leftToRightMapping ?? {}, a = o?.rightToLeftMapping ?? {}, c = (e === 0 ? s : a)[n] ?? [];
            return c.length > 0 ? c : o?.disableMappingFallback ? [] : [n];
          }
          default:
            return [n];
        }
      }
      getRelatedNodeIdsFromTheSameSide(e, n) {
        let r = this.mode(), o = this.savedProcessedSyncNavigationData[r];
        switch (r) {
          case dn.MATCH_NODE_ID:
            return [n];
          case dn.VISUALIZER_CONFIG:
          case dn.UPLOAD_MAPPING_FROM_COMPUTER:
          case dn.LOAD_MAPPING_FROM_CNS:
            return e === 0 ? o?.leftRelatedNodes[n] ?? [] : o?.rightRelatedNodes[n] ?? [];
          default:
            return [n];
        }
      }
      getSyncNavigationData() {
        let e = this.mode();
        return this.savedProcessedSyncNavigationData[e];
      }
      loadFromCns(e) {
        return $t(this, null, function* () {
          this.loadingFromCns.set(true);
          let n = `/read_file?path=${e}`, r = yield fetch(n);
          if (!r.ok) return this.loadingFromCns.set(false), `Failed to load JSON file "${e}"`;
          let o = JSON.parse((yield r.text()).replace(`)]}'
`, "")), s = this.processJsonData(o.content, dn.LOAD_MAPPING_FROM_CNS);
          return this.loadingFromCns.set(false), s;
        });
      }
      loadSyncNavigationDataFromEvent(e) {
        return $t(this, null, function* () {
          this.mode.set(e.mode);
        });
      }
      processJsonData(e, n) {
        try {
          let r = JSON.parse(e);
          this.updateSyncNavigationData(n, r);
        } catch (r) {
          return `Failed to parse JSON file. ${r}`;
        }
        return "";
      }
      setShowNoMappedNodeMessage(e) {
        this.showNoMappedNodeMessageTrigger$.next(e ? {} : void 0);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Sle = ["container"];
  var Mle = ["canvas"];
  var Ele = ["snapshotCanvas"];
  var Tle = ["pngDownloaderCanvas"];
  var Ile = ["hoverToolbar"];
  var Dle = ["ioPicker"];
  var Ple = ["subgraphMenuTrigger"];
  var Rle = ["groupNodeIconMatTooltip"];
  var Ole = ["ioPickerMatTooltip"];
  var Ale = ["moreActionsMenuTrigger"];
  var Nle = ["rangeZoomDragArea"];
  var kle = ["dragToSelectDragArea"];
  function Lle(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 34), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickCollapseAll(r.hoveredNodeIdWhenClickingMoreActions));
      }), b(1, "mat-icon"), D(2, "unfold_less_double"), x(), D(3, " Collapse layer & all sub-layers "), x();
    }
  }
  function Fle(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 35), Z("click", function(r) {
        q(e);
        let o = T();
        return Y(o.handleClickOpenGroupNodeInPopup(r, o.hoveredNodeIdWhenClickingMoreActions));
      }), b(1, "mat-icon"), D(2, "open_in_new"), x(), D(3, " Open layer in popup "), x();
    }
  }
  function Ble(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 36), Z("click", function(r) {
        let o = q(e).$implicit, s = T();
        return Y(s.handleClickSubgraphId(o, r));
      }), b(1, "mat-icon"), D(2, "subdirectory_arrow_right"), x(), D(3), x();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      C(3), Oe(" ", e, " ");
    }
  }
  function Vle(i59, t) {
    if (i59 & 1 && (b(0, "div", 33), D(1), x()), i59 & 2) {
      let e = T();
      C(), Oe("FPS: ", e.fps, "");
    }
  }
  var zle = 1.2;
  var Ule = 2;
  var EG = 1.5;
  var Gle = 200;
  var xw = 400;
  var Hle = 1;
  var TG = 14;
  var jle = 5e3;
  var Wle = -At * 0.5;
  var VD = At * 0.4;
  var IG = At * 0.3;
  var $le = At * 0.4;
  var qle = "______";
  var mn = pn;
  var ww = function(i59) {
    return i59[i59.NODE = 0] = "NODE", i59[i59.EDGE = 1] = "EDGE", i59;
  }(ww || {});
  var Cw = (() => {
    class i59 {
      changeDetectorRef;
      destroyRef;
      ngZone;
      nodeDataProviderExtensionService;
      nodeStylerService;
      overlay;
      snackBar;
      splitPaneService;
      subgraphSelectionService;
      syncNavigationService;
      uiStateService;
      viewContainerRef;
      webglRendererAttrsTableService;
      webglRendererEdgeTextsService;
      webglRendererEdgeOverlaysService;
      webglRendererHighlightNodesService;
      webglRendererIdenticalLayerService;
      webglRendererIoHighlightService;
      webglRendererIoTracingService;
      webglRendererNdpService;
      webglRendererSearchResultsService;
      webglRendererSnapshotService;
      webglRendererSubgraphSelectionService;
      webglRendererThreejsService;
      workerService;
      modelGraph;
      rendererId;
      paneId;
      rootNodeId;
      inPopup = false;
      benchmark = false;
      openInPopupClicked = new Ue();
      container;
      canvas;
      snapshotCanvas;
      pngDownloaderCanvas;
      hoverToolbar;
      ioPicker;
      subgraphMenuTrigger;
      groupNodeIconMatTooltip;
      ioPickerMatTooltip;
      moreActionsMenuTrigger;
      rangeZoomDragArea;
      dragToSelectDragArea;
      appService = M(nt);
      threejsService = M(Hi);
      SELECTED_NODE_BORDER_COLOR = new mn.Color("#1A73E8");
      SELECTED_NODE_BG_COLOR = new mn.Color("#C2E7FF");
      HOVERED_NODE_BORDER_COLOR = new mn.Color("#000");
      HOVERED_GROUP_NODE_BORDER_COLOR = new mn.Color("#666");
      IDENTICAL_GROUPS_BG_COLOR = new mn.Color("#e2edff");
      NODE_LABEL_COLOR = new mn.Color("#041E49");
      OP_NODE_BORDER_COLOR = new mn.Color("#777");
      GROUP_NODE_BORDER_COLOR = new mn.Color("#aaa");
      GROUP_NODE_LABEL_SEPARATOR_COLOR = new mn.Color("#DADCE0");
      GROUP_NODE_ICON_COLOR = new mn.Color("#444746");
      GROUP_NODE_PIN_TO_TOP_SEPARATOR_COLOR = new mn.Color("#bbb");
      EDGE_COLOR = new mn.Color(this.appService.config()?.edgeColor || "#aaa");
      EDGE_COLOR_INCOMING = new mn.Color("#009e73");
      EDGE_TEXT_COLOR_INCOMING = new mn.Color("#125341");
      EDGE_COLOR_OUTGOING = new mn.Color("#d55e00");
      EDGE_TEXT_COLOR_OUTGOING = new mn.Color("#994d11");
      ARTIFCIAL_GROUPS_BORDER_COLOR = new mn.Color("#800080");
      SUBGRAPH_INDICATOR_BORDER_COLOR = new mn.Color("#135cbb");
      SUBGRAPH_INDICATOR_BG_COLOR = new mn.Color("#d5e7ff");
      GROUP_NODE_BG_COLORS = (() => {
        let s = [];
        for (let a = 0; a < 6; a++) {
          let l = 96 + a * -2.4;
          s.push(new mn.Color(`hsl(212, 40%, ${Math.round(l)}%)`));
        }
        return s;
      })();
      graphId = "";
      curModelGraph;
      tracing = false;
      showBusySpinner = false;
      selectedNodeId = "";
      flashing = false;
      hoveredNodeIdWhenClickingMoreActions = "";
      currentMinX = 0;
      currentMaxX = 0;
      currentMinZ = 0;
      currentMaxZ = 0;
      groupNodeIcon = { top: -1e3, left: -1e3, width: 0, height: 0 };
      ioPickerTop = -1e3;
      ioPickerLeft = -1e3;
      ioPickerWidth = 0;
      ioPickerHeight = 0;
      ioPickerTooltip = "";
      subgraphIndicatorTop = -1e3;
      subgraphIndicatorLeft = -1e3;
      subgraphIndicatorWidth = 0;
      subgraphIndicatorHeight = 0;
      curSubgraphIdsForMenu = [];
      curShowOnNodeItemTypes = {};
      curShowOnEdgeItem;
      nodesToRender = [];
      nodesToRenderMap = {};
      edgesToRender = [];
      curNodeDataProviderRuns = {};
      curHiddenInputOpNodeIds = {};
      curHiddenOutputIds = {};
      elementsToRender = [];
      updateNodesStylesSavedSelectedNodeId = "";
      updateNodesStylesSavedIoTracingData;
      curSelectedRenderer;
      portal = null;
      showBusySpinnerTimeoutRef = -1;
      prevNodeDataProviderData = void 0;
      prevNodeDataProviderRun = void 0;
      nodeBodies = new ci(6);
      groupNodeIcons = new di(this.threejsService);
      groupNodeIconBgs = new ci(99);
      artificialGroupBorders = new ci(6);
      subgraphIndicatorBgs = new ci(3);
      subgraphIndicatorIcons = new di(this.threejsService);
      edges = new ja(this.EDGE_COLOR, Hle);
      texts = new di(this.threejsService);
      mousePos = new mn.Vector2();
      draggingArea = false;
      hoveredNodeId = "";
      hoveredGroupNodeIconId = "";
      nodeIdForHoveredGroupNodeIcon = "";
      hoveredIoPickerId = "";
      hoveredSubgraphIndicatorId = "";
      savedUpdateNodeBgWhenFarProgress = -1;
      curNodeStylerRules = [];
      curProcessedNodeStylerRules = [];
      renderedEdgeIdsToHide = [];
      relayoutDoneFn;
      selectedNodeInfo = It(() => {
        let e = this.appService.getPaneById(this.paneId);
        if (e) return e.selectedNodeInfo;
      });
      messageEventListener = (e) => {
        this.hideBusySpinner();
        let n = e.data;
        switch (n.eventType) {
          case Qi.EXPAND_OR_COLLAPSE_GROUP_NODE_RESP:
            this.rendererId === n.rendererId && this.handleExpandOrCollapseGroupNodeDone(n.modelGraph, n.rendererId, n.groupNodeId, n.expanded, n.deepestExpandedGroupNodeIds);
            break;
          case Qi.RELAYOUT_GRAPH_RESP:
            this.rendererId === n.rendererId && this.handleReLayoutGraphDone(n.rendererId, n.modelGraph, n.selectedNodeId, n.forRestoringUiState, n.rectToZoomFit, n.forRestoringSnapshotAfterTogglingFlattenLayers, n.targetDeepestGroupNodeIdsToExpand, n.triggerNavigationSync);
            break;
          case Qi.LOCATE_NODE_RESP:
            this.rendererId === n.rendererId && this.handleLocateNodeDone(n.rendererId, n.modelGraph, n.nodeId, n.deepestExpandedGroupNodeIds, n.noNodeShake === true, n.select === true);
            break;
          case Qi.PREPARE_POPUP_RESP:
            this.paneId === n.paneId && this.openInPopupClicked.emit({ id: n.rendererId, groupNode: n.modelGraph.nodesById[n.groupNodeId], initialPosition: n.initialPosition, curModelGraph: n.modelGraph });
            break;
          default:
            break;
        }
      };
      constructor(e, n, r, o, s, a, l, c, d, u, h, p, f, m, v, _, g, y, w, E, P, S, A, W, H) {
        this.changeDetectorRef = e, this.destroyRef = n, this.ngZone = r, this.nodeDataProviderExtensionService = o, this.nodeStylerService = s, this.overlay = a, this.snackBar = l, this.splitPaneService = c, this.subgraphSelectionService = d, this.syncNavigationService = u, this.uiStateService = h, this.viewContainerRef = p, this.webglRendererAttrsTableService = f, this.webglRendererEdgeTextsService = m, this.webglRendererEdgeOverlaysService = v, this.webglRendererHighlightNodesService = _, this.webglRendererIdenticalLayerService = g, this.webglRendererIoHighlightService = y, this.webglRendererIoTracingService = w, this.webglRendererNdpService = E, this.webglRendererSearchResultsService = P, this.webglRendererSnapshotService = S, this.webglRendererSubgraphSelectionService = A, this.webglRendererThreejsService = W, this.workerService = H, this.webglRendererAttrsTableService.init(this), this.webglRendererEdgeTextsService.init(this), this.webglRendererEdgeOverlaysService.init(this), this.webglRendererHighlightNodesService.init(this), this.webglRendererIdenticalLayerService.init(this), this.webglRendererIoHighlightService.init(this), this.webglRendererIoTracingService.init(this), this.webglRendererNdpService.init(this), this.webglRendererSearchResultsService.init(this), this.webglRendererSnapshotService.init(this), this.webglRendererSubgraphSelectionService.init(this), this.webglRendererThreejsService.init(this), this.workerService.worker.addEventListener("message", this.messageEventListener), ht(() => {
          this.curSelectedRenderer = this.appService.curSelectedRenderer();
        }), this.appService.spaceKeyToZoomFitClicked.pipe(wi(this.destroyRef)).subscribe((O) => {
          this.rendererId === this.curSelectedRenderer?.id && this.webglRendererThreejsService.zoomFitGraph();
        }), ht(() => {
          let O = this.appService.curToLocateNodeInfo();
          O?.rendererId === this.rendererId && (O && this.sendLocateNodeRequest(O.nodeId, O.rendererId, O.noNodeShake, O.select), this.appService.curToLocateNodeInfo.set(void 0));
        }), ht(() => {
          let O = this.appService.getPaneById(this.paneId);
          if (!O || !O.modelGraph) return;
          let I = O.nodeIdToReveal;
          if (!I) return;
          this.revealNode(I) && this.appService.setNodeToReveal(this.paneId, void 0);
        }), ht(() => {
          let O = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph);
          this.curNodeDataProviderRuns = {};
          for (let I of O) this.curNodeDataProviderRuns[I.runId] = I;
        }), ht(() => {
          let O = this.webglRendererNdpService.curNodeDataProviderResults(), I = this.webglRendererNdpService.curNodeDataProviderRun();
          O !== this.prevNodeDataProviderData && (this.handleCurNodeDataProviderResultsChanged(this.prevNodeDataProviderRun, I), this.prevNodeDataProviderData = O, this.prevNodeDataProviderRun = I);
        }), ht(() => {
          if (!this.appService.getPaneById(this.paneId)) return;
          let I = this.appService.getShowOnNodeItemTypes(this.paneId, this.rendererId);
          JSON.stringify(I) !== JSON.stringify(this.curShowOnNodeItemTypes) && (this.curShowOnNodeItemTypes = I, this.sendRelayoutGraphRequest(this.selectedNodeId));
        }), this.appService.expandOrCollapseAllGraphLayersClicked.pipe(wi(this.destroyRef)).subscribe((O) => {
          O.rendererId === this.rendererId && this.sendExpandOrCollapseGroupNodeRequest(void 0, true, O.expandOrCollapse);
        }), ht(() => {
          let O = this.selectedNodeInfo();
          if (O?.rendererId !== this.rendererId) return;
          let I = O?.nodeId || "", F = this.selectedNodeId !== I;
          if (this.selectedNodeId = I, this.tracing && (this.selectedNodeId && dt(this.curModelGraph.nodesById[this.selectedNodeId]) ? this.webglRendererIoTracingService.genTracingData() : this.webglRendererIoTracingService.clearTracingData()), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.webglRendererEdgeOverlaysService.updateOverlaysData(), this.updateNodesStyles(), this.webglRendererThreejsService.render(), F && O.triggerNavigationSync && this.syncNavigationService.updateNavigationSource({ paneIndex: this.appService.getPaneIndexById(this.paneId) || 0, nodeId: this.selectedNodeId }), this.webglRendererEdgeOverlaysService.curOverlays.length > 0) {
            let j = this.webglRendererEdgeOverlaysService.getDeepestExpandedGroupNodeIds();
            j.length > 0 ? this.sendRelayoutGraphRequest(this.selectedNodeId, j) : (this.webglRendererEdgeOverlaysService.updateOverlaysEdges(), this.webglRendererThreejsService.render());
          } else this.webglRendererEdgeOverlaysService.clearOverlaysEdges(), this.webglRendererThreejsService.render();
        }), ht(() => {
          if (this.webglRendererEdgeOverlaysService.edgeOverlaysService.selectedOverlayIds(), this.webglRendererEdgeOverlaysService.updateOverlaysData(), this.selectedNodeId !== "") if (this.webglRendererEdgeOverlaysService.curOverlays.length > 0) {
            let O = this.webglRendererEdgeOverlaysService.getDeepestExpandedGroupNodeIds();
            O.length > 0 ? this.sendRelayoutGraphRequest(this.selectedNodeId, O) : (this.webglRendererEdgeOverlaysService.updateOverlaysEdges(), this.webglRendererThreejsService.render());
          } else this.webglRendererEdgeOverlaysService.clearOverlaysEdges(), this.webglRendererThreejsService.render();
        }), this.appService.downloadAsPngClicked.pipe(wi(this.destroyRef)).subscribe((O) => {
          O.rendererId === this.rendererId && this.handleDownloadAsPng(O.fullGraph, O.transparentBackground);
        }), ht(() => {
          let O = this.nodeStylerService.rules().filter((F) => ku(F.queries) && Object.keys(F.styles).length > 0), I = JSON.stringify(O);
          JSON.stringify(this.curNodeStylerRules) !== I && (this.curNodeStylerRules = JSON.parse(I), this.curProcessedNodeStylerRules = Ay(this.curNodeStylerRules), this.renderGraph(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.updateNodesStyles(), this.webglRendererThreejsService.render());
        }), ht(() => {
          if (!this.appService.getPaneById(this.paneId)) return;
          let I = this.appService.getShowOnEdgeItem(this.paneId, this.rendererId);
          JSON.stringify(I) !== JSON.stringify(this.curShowOnEdgeItem) && (this.curShowOnEdgeItem = I, this.renderGraph(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.updateNodesStyles(), this.webglRendererThreejsService.render());
        }), ht(() => {
          this.curHiddenInputOpNodeIds = this.splitPaneService.hiddenInputOpNodeIds(), this.curHiddenOutputIds = this.splitPaneService.hiddenOutputIds(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.updateNodesStyles(), this.webglRendererThreejsService.render();
        }), this.syncNavigationService.navigationSourceChanged$.pipe(wi(this.destroyRef)).subscribe((O) => {
          if (O) if (this.webglRendererHighlightNodesService.setHighlightNodeIds([]), O.paneIndex !== this.appService.getPaneIndexById(this.paneId)) if (O.nodeId === "") this.syncNavigationService.setShowNoMappedNodeMessage(false);
          else {
            let I = this.syncNavigationService.getMappedNodeIds(O.paneIndex, O.nodeId);
            if (I.length < 2) {
              let F = I[0] ?? "", j = this.curModelGraph.nodesById[F], $ = dt(j) && j.hideInLayout;
              j && j.id !== this.selectedNodeId && !$ ? (this.revealNode(F, false), this.syncNavigationService.setShowNoMappedNodeMessage(false)) : !j || $ ? this.syncNavigationService.setShowNoMappedNodeMessage(true) : this.syncNavigationService.setShowNoMappedNodeMessage(false);
            } else this.revealAndHighlightNodes(I, I.length > 0 ? I[0] : "", true);
          }
          else {
            let I = O.nodeId, F = this.syncNavigationService.getRelatedNodeIdsFromTheSameSide(O.paneIndex, I);
            F.length > 1 && this.revealAndHighlightNodes(F, I, false);
          }
        });
      }
      ngOnInit() {
        this.graphId = this.modelGraph.id, this.curModelGraph = this.modelGraph, this.appService.updateCurrentModelGraph(this.paneId, this.curModelGraph), this.inPopup || (this.curShowOnNodeItemTypes = this.appService.getSavedShowOnNodeItemTypes(), this.curShowOnEdgeItem = this.appService.getSavedShowOnEdgeItem()), this.webglRendererThreejsService.setupZoomAndPan(this.container.nativeElement, 1e-4, 20), this.webglRendererThreejsService.setupThreeJs(), this.ngZone.runOutsideAngular(() => {
          this.canvas.nativeElement.addEventListener("mousemove", (s) => {
            this.handleMouseMove(s);
          });
        });
        let e = this.appService.curInitialUiState(), n = (s) => {
          this.updateNodesAndEdgesToRender(), this.renderGraph(), this.webglRendererThreejsService.zoomFitGraph(0.9, 0);
          let a = this.appService.getPaneById(this.paneId);
          if (a?.snapshotToRestore != null) {
            let l = a.snapshotToRestore;
            this.curShowOnNodeItemTypes = a.snapshotToRestore.showOnNodeItemTypes || {}, this.appService.setShowOnNode(this.paneId, this.rendererId, this.curShowOnNodeItemTypes), this.sendRelayoutGraphRequest(l.selectedNodeId || "", l.deepestExpandedGroupNodeIds || [], false, l.rect, true, l.showOnNodeItemTypes, true, false), a.snapshotToRestore = void 0;
          } else s != null && s !== "" && setTimeout(() => {
            this.appService.curToLocateNodeInfo.set({ nodeId: s, rendererId: this.rendererId, isGroupNode: false, noNodeShake: true });
          });
          this.sendExpandGroupNodeRequest(this.rootNodeId || "");
        };
        if (!e || e.paneStates.length === 0 || this.inPopup) {
          let s = this.inPopup ? void 0 : this.appService.getPaneById(this.paneId)?.selectedNodeInfo?.nodeId;
          n(s);
        } else {
          let s = this.appService.getPaneIndexById(this.paneId), a = e.paneStates[s];
          if (!a) n();
          else {
            let l = a.deepestExpandedGroupNodeIds;
            if (l.length === 1 && l[0] === "___all___") {
              let c = [];
              Ef(void 0, this.curModelGraph, c, true), l = c;
            } else {
              let c = this.curModelGraph.nodesById[a.selectedNodeId], d = c?.nsParentId || "";
              c && d && !l.includes(d) && l.push(d);
            }
            a.selectedNodeId !== "" || l.length > 0 ? this.sendRelayoutGraphRequest(a.selectedNodeId, l, true, void 0, false, void 0, false, false) : n(), this.uiStateService.setDeepestExpandedGroupNodeIds(a.deepestExpandedGroupNodeIds, s);
          }
        }
        let r = window;
        r[Ey] == null && (r[Ey] = { renderers: {} });
        let o = this.inPopup ? -1 : this.appService.getPaneIndexById(this.paneId);
        r[Ey].renderers[o] = this, this.benchmark && this.startBenchmark();
      }
      ngOnDestroy() {
        this.workerService.worker.removeEventListener("message", this.messageEventListener), this.webglRendererThreejsService.dispose(), document.body.style.cursor = "default";
      }
      getActiveSelectedNodeInfo() {
        if (this.selectedNodeId) return { nodeId: this.selectedNodeId, rendererId: this.rendererId, isGroupNode: ct(this.curModelGraph.nodesById[this.selectedNodeId]) };
      }
      toggleIoTrace() {
        this.tracing = !this.tracing, this.tracing ? this.webglRendererIoTracingService.genTracingData() : this.webglRendererIoTracingService.clearTracingData(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.updateNodesStyles(), this.webglRendererThreejsService.render();
      }
      setZoomFactor(e) {
        let n = this.container.nativeElement, r = this.webglRendererThreejsService.convertScreenPosToScene(0, 0), o = this.webglRendererThreejsService.convertScreenPosToScene(n.offsetWidth, n.offsetHeight), s = Math.min(r.x, o.x), a = Math.max(r.x, o.x), l = Math.min(r.y, o.y), c = Math.max(r.y, o.y), d = a - s, u = c - l, h = (s + a) / 2, p = (l + c) / 2, f = h - d / 2 / e, m = h + d / 2 / e, v = p - u / 2 / e, _ = p + u / 2 / e;
        this.webglRendererThreejsService.zoomFit({ x: f, y: v, width: m - f, height: _ - v }, 0.9, 0, false, false);
      }
      handleMouseDownCanvas(e) {
        Mf && (e.metaKey || e.ctrlKey) || !Mf && e.ctrlKey ? (this.draggingArea = true, this.rangeZoomDragArea.start(e, (n, r, o, s, a) => {
          let l = this.webglRendererThreejsService.convertScreenPosToScene(r, o), c = this.webglRendererThreejsService.convertScreenPosToScene(s, a), d = Math.min(l.x, c.x), u = Math.max(l.x, c.x), h = Math.min(l.y, c.y), p = Math.max(l.y, c.y);
          this.webglRendererThreejsService.zoomFit({ x: d, y: h, width: u - d, height: p - h }, 0.9, 200, false, false), this.draggingArea = false;
        })) : e.shiftKey && this.webglRendererSubgraphSelectionService.enableSubgraphSelection && (this.draggingArea = true, this.dragToSelectDragArea.start(e, (n, r, o, s, a) => {
          if (this.draggingArea = false, n) this.hoveredNodeId ? this.curModelGraph.nodesById[this.hoveredNodeId] && this.handleShiftSelectNode(this.hoveredNodeId) : this.handleClearSubgraphSelectedNodes();
          else {
            let l = this.webglRendererThreejsService.convertScreenPosToScene(r, o), c = this.webglRendererThreejsService.convertScreenPosToScene(s, a), d = Math.min(l.x, c.x), u = Math.max(l.x, c.x), h = Math.min(l.y, c.y), p = Math.max(l.y, c.y), f = [];
            for (let { node: m } of this.nodesToRender) {
              let v = this.getNodeX(m), _ = this.getNodeY(m), g = this.getNodeWidth(m), y = this.getNodeHeight(m), w = v, E = _, P = v + g, S = _ + y, A = u < w, W = d > P, H = h > S, O = p < E;
              !(A || W || H || O) && f.push(m.id);
            }
            this.subgraphSelectionService.toggleNodes(f);
          }
        }));
      }
      handleMouseLeaveRenderer(e) {
        let n = e.relatedTarget;
        n != null && n.classList.contains("cdk-overlay-backdrop") || (this.setHoveredNodeId(""), this.updateNodesStyles(), this.handleHoveredGroupNodeIconChanged(), this.webglRendererThreejsService.render());
      }
      handleClickToggleExpandCollapse(e = false) {
        if (!this.hoveredNodeId) return;
        this.handleSelectNode(this.hoveredNodeId);
        let n = this.curModelGraph.nodesById[this.hoveredNodeId];
        this.handleToggleExpandCollapse(n, e);
      }
      handleClickExpandAll(e) {
        let n = e ?? this.hoveredNodeId;
        n && (this.handleSelectNode(n), this.handleToggleExpandCollapse(this.curModelGraph.nodesById[n], true, true));
      }
      handleClickCollapseAll(e) {
        let n = e ?? this.hoveredNodeId;
        n && (this.handleSelectNode(n), this.handleToggleExpandCollapse(this.curModelGraph.nodesById[n], true, false));
      }
      handleClickOpenGroupNodeInPopup(e, n) {
        let r = n ?? this.hoveredNodeId, o = this.curModelGraph.nodesById[r], s = 0, a = this.getNodeX(o), l = this.getNodeWidth(o);
        if (o.expanded) {
          let d = this.texts.getLabelSizes(this.getNodeLabel(o), Jt.BOLD, Eo).sizes, u = Eo / this.texts.getFontSize(), h = (d.maxX - d.minX) * u, p = a + l / 2 + h / 2;
          s = this.webglRendererThreejsService.convertScenePosToScreen(p + 22, 0).x;
        } else s = this.webglRendererThreejsService.convertScenePosToScreen(a + l + 1, 0).x;
        let c = { eventType: Qi.PREPARE_POPUP_REQ, modelGraphId: this.curModelGraph.id, paneId: this.paneId, rendererId: Li(), groupNodeId: o.id, initialPosition: { x: s, y: this.webglRendererThreejsService.convertScenePosToScreen(0, this.getNodeY(o)).y } };
        this.workerService.worker.postMessage(c);
      }
      handleClickGroupNodeIcon(e) {
        e.stopPropagation(), this.hoveredGroupNodeIconId.includes("_left") ? (this.handleSelectNode(this.nodeIdForHoveredGroupNodeIcon), this.handleToggleExpandCollapse(this.curModelGraph.nodesById[this.nodeIdForHoveredGroupNodeIcon])) : this.hoveredGroupNodeIconId.includes("_right") && (this.hoveredNodeIdWhenClickingMoreActions = this.nodeIdForHoveredGroupNodeIcon, this.moreActionsMenuTrigger.openMenu());
      }
      handleClickIoPicker(e) {
        e.stopPropagation();
        let n = this.hoveredIoPickerId.endsWith("input"), r = this.hoveredIoPickerId.split(dw)[0];
        this.webglRendererIoHighlightService.handleClickIoPicker(n, r);
      }
      handleClickSubgraphIndicator(e) {
        if (!this.hoveredSubgraphIndicatorId) return;
        let n = this.curModelGraph.nodesById[this.hoveredSubgraphIndicatorId];
        if (!dt(n)) return;
        let r = n.subgraphIds;
        r.length === 1 ? this.clickSubgraph(r[0], e) : r.length > 1 && (this.curSubgraphIdsForMenu = r, this.subgraphMenuTrigger.openMenu());
      }
      handleClickSubgraphId(e, n) {
        this.clickSubgraph(e, n);
      }
      handleDoubleClickOnGraph(e, n) {
        if (this.selectedNodeId !== "" && !n) {
          let r = this.curModelGraph.nodesById[this.selectedNodeId];
          this.appService.updateDoubleClickedNode(this.selectedNodeId, this.curModelGraph.id, this.curModelGraph.collectionLabel || "", r), this.handleToggleExpandCollapse(r, e);
        }
      }
      handleClickOnGraph(e) {
        this.hoveredNodeId ? this.curModelGraph.nodesById[this.hoveredNodeId] && (e || this.handleSelectNode(this.hoveredNodeId)) : this.handleSelectNode("");
      }
      handleMouseEnterGroupNodeIcon() {
        this.groupNodeIconMatTooltip.show();
      }
      handleMouseLeaveGroupNodeIcon() {
        this.groupNodeIconMatTooltip.hide();
      }
      handleMouseEnterIoPicker() {
        this.ioPickerMatTooltip.show();
      }
      handleMouseLeaveIoPicker() {
        this.ioPickerMatTooltip.hide();
      }
      handleHoveredGroupNodeIconChanged(e) {
        if (this.groupNodeIcon.top = -1e3, this.groupNodeIcon.left = -1e3, this.groupNodeIcon.width = 0, this.groupNodeIcon.height = 0, this.groupNodeIcon.tooltip = void 0, this.hoveredGroupNodeIconId !== "" && e != null) {
          let { x: n, y: r } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x - e.bound.width / 2, e.bound.y - e.bound.height / 2), { x: o, y: s } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x + e.bound.width / 2, e.bound.y + e.bound.height / 2);
          if (this.groupNodeIcon.top = r, this.groupNodeIcon.left = n, this.groupNodeIcon.width = o - n, this.groupNodeIcon.height = s - r, e.id.includes("_left")) {
            let a = this.curModelGraph.nodesById[e.nodeId];
            this.groupNodeIcon.tooltip = a.expanded ? "Collapse layer" : "Expand layer";
          } else e.id.includes("_right") && (this.groupNodeIcon.tooltip = "More actions");
        }
        this.changeDetectorRef.detectChanges();
      }
      isNodeRendered(e) {
        return this.nodesToRenderMap[e] != null;
      }
      sendLocateNodeRequest(e, n, r = false, o = false) {
        if (this.showBusySpinnerWithDelay(), this.isNodeRendered(e)) this.hideBusySpinner(), this.handleLocateNodeDone(n, this.curModelGraph, e, [], r, o, true);
        else {
          let s = { eventType: Qi.LOCATE_NODE_REQ, modelGraphId: this.curModelGraph.id, showOnNodeItemTypes: this.curShowOnNodeItemTypes, nodeDataProviderRuns: this.curNodeDataProviderRuns, selectedNodeDataProviderRunId: this.nodeDataProviderExtensionService.getSelectedRunForModelGraph(this.paneId, this.curModelGraph)?.runId, nodeId: e, rendererId: n, noNodeShake: r, select: o, config: this.appService.config() };
          this.workerService.worker.postMessage(s);
        }
      }
      sendRelayoutGraphRequest(e, n, r = false, o, s = false, a, l, c = true) {
        this.showBusySpinnerWithDelay();
        let d = { eventType: Qi.RELAYOUT_GRAPH_REQ, modelGraphId: this.curModelGraph.id, showOnNodeItemTypes: a || this.curShowOnNodeItemTypes, nodeDataProviderRuns: this.curNodeDataProviderRuns, selectedNodeDataProviderRunId: this.nodeDataProviderExtensionService.getSelectedRunForModelGraph(this.paneId, this.curModelGraph)?.runId, selectedNodeId: e, targetDeepestGroupNodeIdsToExpand: n, rendererId: this.rendererId, forRestoringUiState: r, rectToZoomFit: o, clearAllExpandStates: s, forRestoringSnapshotAfterTogglingFlattenLayers: l, triggerNavigationSync: c, config: this.appService.config() };
        this.workerService.worker.postMessage(d);
      }
      animateIntoPositions(e = (n) => {
        this.updateAnimatinProgress(n);
      }) {
        let n = Date.now(), r = () => {
          let o = Date.now() - n, s = this.appService.testMode ? 1 : Math.min(1, o / Gle);
          if (s = Math.sin(s * Math.PI / 2), e(s), this.webglRendererThreejsService.render(), s >= 1) {
            e(s), this.webglRendererThreejsService.render();
            return;
          }
          requestAnimationFrame(r);
        };
        r();
      }
      flash() {
        this.flashing = true, this.changeDetectorRef.detectChanges(), setTimeout(() => {
          this.flashing = false, this.changeDetectorRef.detectChanges();
        }, 300);
      }
      updateNodeBgColorWhenFar() {
        let e = this.webglRendererThreejsService.convertZFromSceneToScreen(30) * this.webglRendererThreejsService.curScale, n = 7.5, o = Math.max(0, Math.min(1, (n - e) / (n - 7)));
        Math.abs(o - this.savedUpdateNodeBgWhenFarProgress) < 1e-5 || (this.savedUpdateNodeBgWhenFarProgress = o, this.nodeBodies.setBgColorWhenFar(this.NODE_LABEL_COLOR, o / 3));
      }
      showIoTree(e, n, r) {
        let o = this.createOverlay(e), s = o.attach(this.portal), a = Ha(n, [], r);
        s.instance.solidBackground = true, s.instance.rendererId = this.rendererId, s.instance.updateData(a), s.instance.onClose.subscribe(() => {
          o.dispose();
        });
      }
      getNodeX(e) {
        return (e.x || 0) + (e.globalX || 0);
      }
      getNodeY(e) {
        return (e.y || 0) + (e.globalY || 0);
      }
      getNodeWidth(e) {
        return e.width || 0;
      }
      getNodeHeight(e) {
        return e.height || 0;
      }
      getNodeRect(e) {
        return { x: this.getNodeX(e), y: this.getNodeY(e), width: this.getNodeWidth(e), height: this.getNodeHeight(e) };
      }
      getNodeLabelRelativeY(e) {
        return 14;
      }
      getNodeLabelSizes(e) {
        let n = Eo / this.texts.getFontSize(), r = Number.POSITIVE_INFINITY, o = Number.NEGATIVE_INFINITY, s = 0, a = Oc(this.getNodeLabel(e));
        for (let l = 0; l < a.length; l++) {
          let c = a[l], d = this.texts.getLabelSizes(c, Jt.BOLD, Eo).sizes;
          r = Math.min(r, d.minX), o = Math.max(o, d.maxX), l === 0 && (s = (d.maxZ - d.minZ) * n);
        }
        return { minX: r, maxX: o, firstLineLabelHeight: s };
      }
      getNodeTitleScreenPositionRelativeToCenter(e) {
        e = e.replaceAll("%%%", `
`);
        let n = this.curModelGraph.nodesById[e], r = this.getNodeX(n) + this.getNodeWidth(n) / 2, o = this.getNodeY(n) + 5, s = this.webglRendererThreejsService.convertScenePosToScreen(r, o), a = this.container.nativeElement;
        return { x: Math.floor(s.x - a.clientWidth / 2), y: Math.floor(s.y - a.clientHeight / 2) };
      }
      getNodeIoChipScreenPositionRelativeToCenter(e) {
        let n = this.curModelGraph.nodesById[e], r = this.getNodeX(n) + 5, o = this.getNodeY(n) - 3, s = this.webglRendererThreejsService.convertScenePosToScreen(r, o), a = this.container.nativeElement;
        return { x: Math.floor(s.x - a.clientWidth / 2), y: Math.floor(s.y - a.clientHeight / 2) };
      }
      getNodeExpandIconPositionRelativeToCenter(e) {
        let n = this.curModelGraph.nodesById[e], r = this.getNodeX(n), o = this.getNodeY(n), s = this.getNodeWidth(n), { minX: a, maxX: l } = this.getNodeLabelSizes(n), c = Eo / this.texts.getFontSize(), d = (l - a) * c, u = r + s / 2 - d / 2, h = n.expanded ? u - 13 : (r + u + 1) / 2 + 1, p = o + this.getNodeLabelRelativeY(n), f = this.webglRendererThreejsService.convertScenePosToScreen(h, p), m = this.container.nativeElement;
        return { x: Math.floor(f.x - m.clientWidth / 2), y: Math.floor(f.y - m.clientHeight / 2) };
      }
      getNodeOverflowIconPositionRelativeToCenter(e) {
        let n = this.curModelGraph.nodesById[e], r = this.getNodeX(n), o = this.getNodeY(n), s = this.getNodeWidth(n), { minX: a, maxX: l } = this.getNodeLabelSizes(n), c = Eo / this.texts.getFontSize(), d = (l - a) * c, u = r + s / 2 + d / 2, h = n.expanded ? u + 12 : (r + s + u - 1) / 2 - 1, p = o + this.getNodeLabelRelativeY(n), f = this.webglRendererThreejsService.convertScenePosToScreen(h, p), m = this.container.nativeElement;
        return { x: Math.floor(f.x - m.clientWidth / 2), y: Math.floor(f.y - m.clientHeight / 2) };
      }
      getSubgraphIndicatorScreenPositionRelativeToCenter(e) {
        let n = this.curModelGraph.nodesById[e], r = this.getNodeX(n) + this.getNodeWidth(n) + 10, o = this.getNodeY(n) + 5, s = this.webglRendererThreejsService.convertScenePosToScreen(r, o), a = this.container.nativeElement;
        return { x: Math.floor(s.x - a.clientWidth / 2), y: Math.floor(s.y - a.clientHeight / 2) };
      }
      getShowCollapseAllButton(e) {
        let n = e ?? this.hoveredNodeId, r = this.curModelGraph.nodesById[n];
        return r != null && ct(r) ? r.expanded : false;
      }
      get expandCollapseIcon() {
        let e = this.curModelGraph.nodesById[this.hoveredNodeId];
        return e != null && ct(e) && e.expanded ? "unfold_less" : "unfold_more";
      }
      get expandCollapseIconTooltip() {
        let e = this.curModelGraph.nodesById[this.hoveredNodeId];
        return e != null && ct(e) ? `${e.expanded ? "Collapse layer" : "Expand layer"}
(shortcut: double click on layer)` : "";
      }
      get showOpenInPopupButton() {
        return !this.inPopup;
      }
      get fps() {
        return this.webglRendererThreejsService.fps;
      }
      get subgraphIndicatorTooltip() {
        if (!this.hoveredSubgraphIndicatorId) return "";
        let e = this.curModelGraph.nodesById[this.hoveredSubgraphIndicatorId];
        if (!dt(e)) return "";
        let n = e.subgraphIds;
        return n.length === 1 ? `Jump to subgraph "${n[0]}"
(alt-click to open in split pane)` : "Jump to subgraph";
      }
      handleSelectNode(e, n = true) {
        this.appService.selectNode(this.paneId, { nodeId: e, rendererId: this.rendererId, isGroupNode: e === "" ? false : ct(this.curModelGraph.nodesById[e]), triggerNavigationSync: n });
      }
      handleExpandOrCollapseGroupNodeDone(e, n, r, o, s) {
        this.updateCurModelGraph(e), this.updateNodesAndEdgesToRender(), this.selectedNodeId && !this.isNodeRendered(this.selectedNodeId) && this.appService.selectNode(this.paneId, { nodeId: "", rendererId: this.rendererId, isGroupNode: false }), this.renderGraph(), r != null ? this.webglRendererThreejsService.zoomFitOnNode(r, e, xw) : this.webglRendererThreejsService.zoomFitGraph(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.updateNodesStyles(), this.webglRendererThreejsService.render(), this.inPopup || this.uiStateService.setDeepestExpandedGroupNodeIds(s, this.appService.getPaneIndexById(this.paneId));
      }
      handleToggleExpandCollapse(e, n = false, r) {
        e.nodeType !== Ds.GROUP_NODE || (e.nsChildrenIds || []).length === 0 || this.sendExpandOrCollapseGroupNodeRequest(e, n, r);
      }
      handleReLayoutGraphDone(e, n, r, o, s, a, l, c) {
        if (this.updateCurModelGraph(n), this.updateNodesAndEdgesToRender(), this.renderGraph(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.webglRendererEdgeOverlaysService.updateOverlaysEdges(), this.updateNodesStyles(), s) {
          let d = () => {
            this.webglRendererThreejsService.zoomFit(s, 1, 200, false, false);
          };
          a ? setTimeout(() => {
            d();
          }) : d();
        } else r !== qle && this.webglRendererThreejsService.zoomFitOnNode(r, n, o ? 0 : xw);
        this.selectedNodeId !== r && this.handleSelectNode(r || "", c), this.inPopup || this.uiStateService.setDeepestExpandedGroupNodeIds(l || [], this.appService.getPaneIndexById(this.paneId)), this.relayoutDoneFn && (this.relayoutDoneFn(), this.relayoutDoneFn = void 0);
      }
      handleCurNodeDataProviderResultsChanged(e, n) {
        let r = e?.nodeDataProviderData?.[this.curModelGraph.id]?.showExpandedSummaryOnGroupNode, o = n?.nodeDataProviderData?.[this.curModelGraph.id]?.showExpandedSummaryOnGroupNode;
        r !== o ? this.sendRelayoutGraphRequest(this.selectedNodeId) : (this.renderGraph(), this.updateNodesStyles(), this.webglRendererThreejsService.render());
      }
      handleLocateNodeDone(e, n, r, o, s, a, l = false) {
        this.updateCurModelGraph(n), this.updateNodesAndEdgesToRender(), a && this.appService.selectNode(this.paneId, { nodeId: r, rendererId: e, isGroupNode: ct(this.curModelGraph.nodesById[r]) }), this.webglRendererThreejsService.zoomFitOnNode(r, n, xw), l || (this.renderGraph(), this.webglRendererIoHighlightService.updateIncomingAndOutgoingHighlights(), this.webglRendererIdenticalLayerService.updateIdenticalLayerIndicators(), this.updateNodesStyles(), this.webglRendererThreejsService.render(), this.inPopup || this.uiStateService.setDeepestExpandedGroupNodeIds(o, this.appService.getPaneIndexById(this.paneId))), s || setTimeout(() => {
          this.shakeNode(r);
        }, 250);
      }
      sendExpandGroupNodeRequest(e) {
        let n = this.curModelGraph.nodesById[e];
        n != null && !n.expanded && this.sendExpandOrCollapseGroupNodeRequest(n, false, true);
      }
      sendExpandOrCollapseGroupNodeRequest(e, n = false, r) {
        this.showBusySpinnerWithDelay();
        let o = { eventType: Qi.EXPAND_OR_COLLAPSE_GROUP_NODE_REQ, modelGraphId: this.curModelGraph.id, groupNodeId: e?.id, expand: r ?? !e?.expanded, showOnNodeItemTypes: this.curShowOnNodeItemTypes, nodeDataProviderRuns: this.curNodeDataProviderRuns, selectedNodeDataProviderRunId: this.nodeDataProviderExtensionService.getSelectedRunForModelGraph(this.paneId, this.curModelGraph)?.runId, rendererId: this.rendererId, paneId: this.paneId, all: n, ts: Date.now(), config: this.appService.config() };
        this.workerService.worker.postMessage(o);
      }
      renderGraph() {
        this.clearScene(), this.renderEdges(), this.renderTexts();
        let e = Df(this.curShowOnEdgeItem);
        (e.outputMetadataKey != null || e.inputMetadataKey != null || e.sourceNodeAttrKey != null || e.targetNodeAttrKey != null) && this.webglRendererEdgeTextsService.renderEdgeTexts({ outputMetadataKey: e.outputMetadataKey, inputMetadataKey: e.inputMetadataKey, sourceNodeAttrKey: e.sourceNodeAttrKey, targetNodeAttrKey: e.targetNodeAttrKey }), this.webglRendererAttrsTableService.renderAttrsTable(), this.renderNodes(), this.webglRendererNdpService.renderNodeDataProviderDistributionBars(), this.renderArtificialGroupBorders(), this.webglRendererSearchResultsService.renderSearchResults(), this.webglRendererSubgraphSelectionService.renderSubgraphSelectedNodeMarkers(), this.updateNodeBgColorWhenFar(), this.animateIntoPositions();
      }
      renderNodes() {
        this.currentMinX = Number.POSITIVE_INFINITY, this.currentMinZ = Number.POSITIVE_INFINITY, this.currentMaxX = Number.NEGATIVE_INFINITY, this.currentMaxZ = Number.NEGATIVE_INFINITY;
        let e = this.nodesToRender.length, n = [], r = [], o = [], s = [], a = [], l = Eo / this.texts.getFontSize();
        for (let c = 0; c < e; c++) {
          let d = this.nodesToRender[c].node, u = this.nodesToRender[c].index, h = this.getNodeX(d), p = this.getNodeY(d), f = this.getNodeWidth(d), m = this.getNodeHeight(d), v = ct(d), _ = v ? this.getGroupNodeBgColor(d) : { r: 1, g: 1, b: 1 }, g = this.threeColorToRgb(v ? this.GROUP_NODE_BORDER_COLOR : this.OP_NODE_BORDER_COLOR);
          dt(d) && d.style && (d.style.backgroundColor && (_ = new mn.Color(d.style.backgroundColor)), d.style.borderColor && (g = new mn.Color(d.style.borderColor)));
          let y = this.GROUP_NODE_ICON_COLOR;
          for (let E of this.curProcessedNodeStylerRules) if (Tf(d, E.queries, this.curModelGraph, this.appService.config())) {
            let P = Rc(E, Is.NODE_BG_COLOR);
            P !== "" && (_ = new mn.Color(P));
            let S = Rc(E, Is.NODE_BORDER_COLOR);
            S !== "" && (g = new mn.Color(S));
            let A = Rc(E, Is.NODE_TEXT_COLOR);
            A !== "" && (y = new mn.Color(A));
            break;
          }
          let w = true;
          if (ct(d) && d.sectionContainer && (w = false), n.push({ id: d.id, index: n.length, bound: { x: h + f / 2, y: p + m / 2, width: f, height: m }, yOffset: At * u, isRounded: w, borderColor: g, bgColor: _, borderWidth: zle, opacity: 1, changeColorWhenFar: (dt(d) || !d.expanded) && _.r === 1 && _.g === 1 && _.b === 1 }), ct(d) && d.expanded && d.pinToTopOpNode && n.push({ id: `${d.id}_pin_to_top_separator`, index: n.length, bound: { x: h + f / 2, y: (d.pinToTopOpNode.globalY || 0) + (d.pinToTopOpNode.height || 0) / 2 + 12.5, width: f - UE * 2, height: 1 }, yOffset: At * u + 0.1, isRounded: true, borderColor: this.GROUP_NODE_PIN_TO_TOP_SEPARATOR_COLOR, bgColor: this.GROUP_NODE_PIN_TO_TOP_SEPARATOR_COLOR, borderWidth: 1, opacity: 1 }), dt(d) && d.subgraphIds) {
            let E = TG, P = TG;
            s.push({ id: `${d.id}`, index: s.length, bound: { x: this.getNodeX(d) + this.getNodeWidth(d) + 2 + E / 2, y: this.getNodeY(d) + P / 2, width: E, height: P }, yOffset: At * this.nodesToRenderMap[d.id].index, isRounded: true, borderColor: this.SUBGRAPH_INDICATOR_BORDER_COLOR, bgColor: this.SUBGRAPH_INDICATOR_BG_COLOR, borderWidth: 1, opacity: 1 }), a.push({ id: d.id, nodeId: d.id, label: "0xe5da", height: 28, hAlign: "center", vAlign: "center", weight: Jt.ICONS, color: this.SUBGRAPH_INDICATOR_BORDER_COLOR, x: this.getNodeX(d) + this.getNodeWidth(d) + 2 + E / 2 + 1, y: this.nodesToRenderMap[d.id].index * At + $le, z: this.getNodeY(d) + P / 2 + 16, treatLabelAsAWhole: true });
          }
          if (ct(d)) {
            let { minX: E, maxX: P, firstLineLabelHeight: S } = this.getNodeLabelSizes(d), A = (P - E) * l, W = h + f / 2 - A / 2, H = h + f / 2 + A / 2, O = p + this.getNodeLabelRelativeY(d) + S + 7.5, I = d.expanded ? W - 13 : (h + W + 1) / 2 + 1, F = d.expanded ? H + 12 : (h + f + H - 1) / 2 - 1;
            r.push({ id: d.id, nodeId: d.id, label: d.expanded ? "0xe5d6" : "0xe5d7", height: 32, hAlign: "center", vAlign: "center", weight: Jt.ICONS, color: y, x: I, y: At * u + VD, z: O, treatLabelAsAWhole: true }), r.push({ id: d.id, nodeId: d.id, label: "0xe5d4", height: 32, hAlign: "center", vAlign: "center", weight: Jt.ICONS, color: y, x: F, y: At * u + VD, z: O, treatLabelAsAWhole: true });
            let j = p + this.getNodeLabelRelativeY(d) - 1;
            o.push({ id: this.getGroupNodeLabelSeparatorId(d.id, "left"), nodeId: d.id, index: o.length, bound: { x: I, y: j, width: 16, height: 16 }, yOffset: At * u + IG, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: { r: 0, g: 0, b: 0 }, borderWidth: 0, opacity: 0 }), o.push({ id: this.getGroupNodeLabelSeparatorId(d.id, "right"), nodeId: d.id, index: o.length, bound: { x: F, y: j, width: 16, height: 16 }, yOffset: At * u + IG, isRounded: true, borderColor: { r: 1, g: 1, b: 1 }, bgColor: { r: 0, g: 0, b: 0 }, borderWidth: 0, opacity: 0 });
          }
          this.currentMinX = Math.min(this.currentMinX, h), this.currentMaxX = Math.max(this.currentMaxX, h + f), this.currentMinZ = Math.min(this.currentMinZ, p), this.currentMaxZ = Math.max(this.currentMaxZ, p + m);
        }
        this.nodeBodies.generateMesh(n, true), this.webglRendererThreejsService.addToScene(this.nodeBodies.mesh), this.webglRendererThreejsService.addToScene(this.nodeBodies.meshForRayCasting), this.groupNodeIcons.generateMesh(r), this.webglRendererThreejsService.addToScene(this.groupNodeIcons.mesh), this.groupNodeIconBgs.generateMesh(o, true), this.webglRendererThreejsService.addToScene(this.groupNodeIconBgs.mesh), this.webglRendererThreejsService.addToScene(this.groupNodeIconBgs.meshForRayCasting), this.subgraphIndicatorBgs.generateMesh(s, true), this.webglRendererThreejsService.addToScene(this.subgraphIndicatorBgs.mesh), this.subgraphIndicatorIcons.generateMesh(a), this.webglRendererThreejsService.addToScene(this.subgraphIndicatorIcons.mesh);
      }
      renderEdges() {
        if (this.renderedEdgeIdsToHide = [], this.edgesToRender.length > 0) {
          if (this.appService.config()?.showOpNodeOutOfLayerEdgesWithoutSelecting) {
            for (let { node: e } of this.nodesToRender) if (dt(e) && e.nsParentId) {
              let { overlayEdges: n, renderedEdges: r } = this.webglRendererIoHighlightService.getHighlightedIncomingNodesAndEdges(this.curHiddenInputOpNodeIds, e, { ignoreEdgesWithinSameNamespace: true, reuseRenderedEdgeCurvePoints: true });
              if (n.length > 0) {
                this.renderedEdgeIdsToHide.push(...r.map((a) => a.id));
                for (let a of n) this.edgesToRender.push({ edge: a, index: 92 / At });
              }
              let { overlayEdges: o, renderedEdges: s } = this.webglRendererIoHighlightService.getHighlightedOutgoingNodesAndEdges(this.curHiddenOutputIds, e, { ignoreEdgesWithinSameNamespace: true, reuseRenderedEdgeCurvePoints: true });
              if (o.length > 0) {
                this.renderedEdgeIdsToHide.push(...s.map((a) => a.id));
                for (let a of o) this.edgesToRender.push({ edge: a, index: 92 / At });
              }
            }
          }
          this.edges.generateMesh(this.edgesToRender, this.curModelGraph), this.webglRendererThreejsService.addToScene(this.edges.edgesMesh), this.webglRendererThreejsService.addToScene(this.edges.arrowHeadsMesh);
        }
      }
      renderTexts() {
        let e = [];
        for (let { node: n, index: r } of this.nodesToRender) {
          let o = this.NODE_LABEL_COLOR;
          for (let a of this.curProcessedNodeStylerRules) if (Tf(n, a.queries, this.curModelGraph, this.appService.config())) {
            let l = Rc(a, Is.NODE_TEXT_COLOR);
            l !== "" && (o = new mn.Color(l));
            break;
          }
          let s = Oc(this.getNodeLabel(n));
          for (let a = 0; a < s.length; a++) {
            let l = s[a];
            e.push({ id: `${n.id}_label_line${a}`, nodeId: n.id, label: l, height: Eo, hAlign: "center", vAlign: "center", weight: dt(n) ? Jt.MEDIUM : Jt.BOLD, x: this.getNodeX(n) + this.getNodeWidth(n) / 2, y: r * At + VD, z: this.getNodeY(n) + this.getNodeLabelRelativeY(n) + Ou * a, color: o });
          }
        }
        this.texts.generateMesh(e), this.webglRendererThreejsService.addToScene(this.texts.mesh);
      }
      renderArtificialGroupBorders() {
        let e = [];
        for (let n of this.curModelGraph.artificialGroupNodeIds || []) {
          if (!this.isNodeRendered(n)) continue;
          let r = this.curModelGraph.nodesById[n], o = this.nodesToRenderMap[n].index, s = this.getNodeX(r) - 1, a = this.getNodeY(r) - 1, l = this.getNodeWidth(r) + 2, c = this.getNodeHeight(r) + 2;
          e.push({ id: n, index: e.length, bound: { x: s + l / 2, y: a + c / 2, width: l, height: c }, yOffset: At * o + Wle, isRounded: false, borderColor: { r: 1, g: 1, b: 1 }, bgColor: this.ARTIFCIAL_GROUPS_BORDER_COLOR, borderWidth: 0, opacity: 1 });
        }
        this.artificialGroupBorders.generateMesh(e, false, false, true), this.webglRendererThreejsService.addToScene(this.artificialGroupBorders.mesh);
      }
      updateAnimatinProgress(e) {
        this.nodeBodies.updateAnimationProgress(e), this.groupNodeIcons.updateAnimationProgress(e), this.groupNodeIconBgs.updateAnimationProgress(e), this.subgraphIndicatorBgs.updateAnimationProgress(e), this.subgraphIndicatorIcons.updateAnimationProgress(e), this.texts.updateAnimationProgress(e), this.webglRendererEdgeTextsService.updateAnimationProgress(e), this.webglRendererAttrsTableService.updateAnimationProgress(e), this.webglRendererNdpService.updateAnimationProgress(e), this.artificialGroupBorders.updateAnimationProgress(e), this.edges.updateAnimationProgress(e);
      }
      handleMouseMove(e) {
        if (this.draggingArea) return;
        let n = this.canvas.nativeElement;
        this.mousePos.x = e.offsetX / n.offsetWidth * 2 - 1, this.mousePos.y = -(e.offsetY / n.offsetHeight) * 2 + 1, this.webglRendererThreejsService.raycaster.setFromCamera(this.mousePos, this.webglRendererThreejsService.camera), this.nodeBodies.raycast(this.webglRendererThreejsService.raycaster, (r) => {
          this.setHoveredNodeId(r), this.updateNodesStyles(), this.webglRendererThreejsService.render();
        }), this.groupNodeIconBgs.raycast(this.webglRendererThreejsService.raycaster, (r, o) => {
          this.hoveredGroupNodeIconId = r, this.nodeIdForHoveredGroupNodeIcon = o?.nodeId || "", this.updateNodesStyles(), this.handleHoveredGroupNodeIconChanged(o), this.webglRendererThreejsService.render();
        }, false), this.webglRendererIoHighlightService.ioPickerBgs.raycast(this.webglRendererThreejsService.raycaster, (r, o) => {
          this.hoveredIoPickerId = r, this.handleHoveredIoPickerChanged(o);
        }), this.subgraphIndicatorBgs.raycast(this.webglRendererThreejsService.raycaster, (r, o) => {
          this.hoveredSubgraphIndicatorId = r, this.handleHoveredSubgraphIndicatorChanged(o);
        });
      }
      handleHoveredIoPickerChanged(e) {
        this.ioPickerTop = -1e3, this.ioPickerLeft = -1e3, this.ioPickerTooltip = "";
        let n = this.hoveredIoPickerId.endsWith("input");
        if (this.hoveredIoPickerId !== "") {
          let { x: r, y: o } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x - e.bound.width / 2, e.bound.y - e.bound.height / 2), { x: s, y: a } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x + e.bound.width / 2, e.bound.y + e.bound.height / 2);
          this.ioPickerTop = o, this.ioPickerLeft = r, this.ioPickerWidth = s - r, this.ioPickerHeight = a - o, this.ioPickerTooltip = `Click to reveal ${n ? "input" : "output"} node(s)`;
        }
        this.changeDetectorRef.detectChanges();
      }
      handleHoveredSubgraphIndicatorChanged(e) {
        if (this.subgraphIndicatorTop = -1e3, this.subgraphIndicatorLeft = -1e3, this.hoveredSubgraphIndicatorId !== "") {
          let { x: n, y: r } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x - e.bound.width / 2, e.bound.y - e.bound.height / 2), { x: o, y: s } = this.webglRendererThreejsService.convertScenePosToScreen(e.bound.x + e.bound.width / 2, e.bound.y + e.bound.height / 2);
          this.subgraphIndicatorTop = r, this.subgraphIndicatorLeft = n, this.subgraphIndicatorWidth = o - n, this.subgraphIndicatorHeight = s - r;
        }
        this.changeDetectorRef.detectChanges();
      }
      updateNodesStyles() {
        let e = false;
        this.selectedNodeId !== this.updateNodesStylesSavedSelectedNodeId && (this.updateNodesStylesSavedSelectedNodeId = this.selectedNodeId, e = true);
        let n = false;
        this.webglRendererIoTracingService.curIoTracingData !== this.updateNodesStylesSavedIoTracingData && (this.updateNodesStylesSavedIoTracingData = this.webglRendererIoTracingService.curIoTracingData, n = true), this.nodeBodies.restoreBorderColors(), this.nodeBodies.restoreBgColors(), this.nodeBodies.restoreBorderWidths(), this.nodeBodies.restoreOpacities(), this.groupNodeIconBgs.restoreOpacities(), this.texts.restoreOpacities(), this.texts.restoreColors(), this.webglRendererEdgeTextsService.edgeTexts.restoreOpacities(), this.groupNodeIcons.restoreOpacities(), this.webglRendererAttrsTableService.attrsTableTexts.restoreOpacities(), (e || n) && this.edges.restoreColors(), this.edges.restoreYOffsets();
        let r = this.curModelGraph.nodesById[this.selectedNodeId];
        if (r != null && ct(r)) {
          let u = r.identicalGroupIndex;
          if (u != null) {
            let h = this.nodesToRender.filter(({ node: p }) => ct(p) && p.identicalGroupIndex === u).map(({ node: p }) => p.id);
            this.nodeBodies.updateBgColor(h, this.IDENTICAL_GROUPS_BG_COLOR);
          }
        }
        let o = this.curModelGraph.nodesById[this.hoveredNodeId], s = ct(o) ? this.HOVERED_GROUP_NODE_BORDER_COLOR : this.HOVERED_NODE_BORDER_COLOR;
        dt(o) && o.style?.hoveredBorderColor && (s = new mn.Color(o.style.hoveredBorderColor)), this.nodeBodies.updateBorderColor([this.hoveredNodeId], s), this.selectedNodeId && r != null && (this.nodeBodies.updateBorderColor([this.selectedNodeId], this.SELECTED_NODE_BORDER_COLOR), this.nodeBodies.updateBorderWidth([this.selectedNodeId], Ule), this.nodeBodies.updateBgColor([this.selectedNodeId], this.SELECTED_NODE_BG_COLOR, dt(r))), this.groupNodeIconBgs.updateOpacity([this.hoveredGroupNodeIconId], 0.07);
        let a = Object.keys(this.webglRendererIoHighlightService.inputsByHighlightedNode);
        if (a.length > 0) {
          this.nodeBodies.updateBorderColor(a, new mn.Color(this.EDGE_COLOR_INCOMING.r, this.EDGE_COLOR_INCOMING.g, this.EDGE_COLOR_INCOMING.b));
          for (let u of a) this.nodeBodies.updateBorderWidth([u], EG);
        }
        let l = Object.keys(this.webglRendererIoHighlightService.outputsByHighlightedNode);
        if (l.length > 0) {
          this.nodeBodies.updateBorderColor(l, new mn.Color(this.EDGE_COLOR_OUTGOING.r, this.EDGE_COLOR_OUTGOING.g, this.EDGE_COLOR_OUTGOING.b));
          for (let u of l) this.nodeBodies.updateBorderWidth([u], EG);
        }
        let c = [...this.webglRendererIoHighlightService.inputsRenderedEdges, ...this.webglRendererIoHighlightService.outputsRenderedEdges].map((u) => u.id);
        c.push(...this.renderedEdgeIdsToHide), this.edges.updateYOffsets(c, 1e3);
        let d = this.webglRendererNdpService.curNodeDataProviderResults() || {};
        for (let u of Object.keys(d)) {
          if (!this.isNodeRendered(u) || !dt(this.curModelGraph.nodesById[u])) continue;
          let h = d[u].bgColor;
          h && h !== "transparent" && this.nodeBodies.updateBgColor([u], new mn.Color(h));
          let p = d[u].textColor;
          p && this.texts.updateColorInNode([u], new mn.Color(p));
        }
        if (this.webglRendererIoTracingService.curIoTracingData != null) {
          let u = Object.keys(this.curModelGraph.nodesById).filter((p) => !this.webglRendererIoTracingService.curIoTracingData.visibleNodeIds.has(p) && this.isNodeRendered(p));
          this.nodeBodies.updateOpacity(u, 0.2), this.texts.updateOpacityInNode(u, 0.3), this.groupNodeIcons.updateOpacityInNode(u, 0.3), this.webglRendererAttrsTableService.attrsTableTexts.updateOpacityInNode(u, 0.3), this.webglRendererEdgeTextsService.edgeTexts.updateOpacityInNode(u, 0.3);
          let h = this.edgesToRender.filter(({ edge: p }) => !this.webglRendererIoTracingService.curIoTracingData.visibleNodeIds.has(p.fromNodeId) || !this.webglRendererIoTracingService.curIoTracingData.visibleNodeIds.has(p.toNodeId)).map(({ edge: p }) => p.id);
          this.edges.updateColors(h, { r: 0.92, g: 0.92, b: 0.92 });
        }
      }
      shakeNode(e) {
        if (this.appService.testMode) return;
        let n = Date.now(), r = () => {
          let o = Date.now() - n, s = Math.min(1, o / 1100);
          s = -(Math.cos(Math.PI * s) - 1) / 2;
          let a = Math.sin(s * Math.PI * 9) * 8;
          if (this.nodeBodies.updateAngle(e, a), this.webglRendererSearchResultsService.searchResultsHighlightBorders.updateAngle(e, a), this.webglRendererThreejsService.render(), s >= 1) {
            this.nodeBodies.updateAngle(e, 0), this.webglRendererSearchResultsService.searchResultsHighlightBorders.updateAngle(e, 0), this.webglRendererThreejsService.render();
            return;
          }
          requestAnimationFrame(r);
        };
        r();
      }
      clearScene() {
        let e = [this.webglRendererSearchResultsService.searchResultsHighlightBorders.mesh, this.webglRendererSearchResultsService.searchResultsNodeLabelHighlightBg.mesh];
        this.webglRendererThreejsService.clearScene(e), this.updateNodesStylesSavedSelectedNodeId = "", this.updateNodesStylesSavedIoTracingData = void 0;
      }
      handleDownloadAsPng(e, n) {
        return $t(this, null, function* () {
          let r = this.container.nativeElement.offsetWidth / Pc(), o = this.container.nativeElement.offsetHeight / Pc(), s = this.webglRendererThreejsService.camera;
          if (e) {
            let d = this.currentMaxX + 20, u = this.currentMinX - 20, h = this.currentMaxZ + 20, p = this.currentMinZ - 20;
            r = d - u, o = h - p;
            let f = jle / Pc();
            r > f && (o = o * f / r, r = f), o > f && (r = r * f / o, o = f), s = this.webglRendererThreejsService.createOrthographicCamera(u, d, -p, -h);
          }
          let a = this.pngDownloaderCanvas.nativeElement;
          this.webglRendererThreejsService.setupPngDownloaderRenderer(a, n, r, o), this.nodeBodies.setBgColorWhenFar(this.NODE_LABEL_COLOR, 0), this.webglRendererThreejsService.renderPngDownloader(s), this.nodeBodies.setBgColorWhenFar(this.NODE_LABEL_COLOR, this.savedUpdateNodeBgWhenFarProgress / 3);
          let l = document.createElement("a");
          l.download = "model_explorer_graph.png", qs(l, a.toDataURL()), l.click(), this.webglRendererThreejsService.setSceneBackground(new mn.Color(16777215));
        });
      }
      openSubgraph(e) {
        return $t(this, null, function* () {
          let n = this.appService.getGraphById(e);
          if (!n) {
            let r = `No graph found for subgraph id: "${e}"`;
            console.warn(r), this.snackBar.open(r, "Dismiss");
            return;
          }
          this.appService.addSubgraphBreadcrumbItem(this.paneId, this.curModelGraph.id, e, yield this.webglRendererSnapshotService.takeSnapshot()), this.appService.selectNode(this.paneId, void 0), this.appService.setFlattenLayersInCurrentPane(false), this.appService.curInitialUiState.set(void 0), this.appService.curToLocateNodeInfo.set(void 0), this.appService.selectGraphInCurrentPane(n);
        });
      }
      getGroupNodeLabelSeparatorId(e, n) {
        return `${e}_${n}`;
      }
      getGroupNodeBgColor(e) {
        let r = (e.namespace || "").split("/").filter((s) => s !== "").length, o = this.GROUP_NODE_BG_COLORS[Math.min(this.GROUP_NODE_BG_COLORS.length - 1, r)];
        return this.threeColorToRgb(o);
      }
      threeColorToRgb(e) {
        return { r: e.r, g: e.g, b: e.b };
      }
      startBenchmark() {
        let e = () => {
          this.webglRendererThreejsService.render(true), requestAnimationFrame(e);
        };
        e();
      }
      handleShiftSelectNode(e) {
        this.webglRendererSubgraphSelectionService.enableSubgraphSelection && this.subgraphSelectionService.toggleNode(e);
      }
      handleClearSubgraphSelectedNodes() {
        this.webglRendererSubgraphSelectionService.enableSubgraphSelection && this.subgraphSelectionService.clearSelection();
      }
      createOverlay(e) {
        let n = new Gi({ positionStrategy: this.overlay.position().flexibleConnectedTo(e).withPositions([{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }]).withDefaultOffsetX(e.clientWidth).withViewportMargin(20), hasBackdrop: true, backdropClass: "cdk-overlay-transparent-backdrop", maxHeight: "400px", panelClass: "io-tree-popup-container" }), r = this.overlay.create(n);
        return this.portal = new Ui(Ul, this.viewContainerRef), r.backdropClick().subscribe(() => {
          r.dispose();
        }), r;
      }
      showBusySpinnerWithDelay() {
        this.hideBusySpinner(), this.showBusySpinnerTimeoutRef = window.setTimeout(() => {
          this.showBusySpinnerTimeoutRef < 0 || (this.snackBar.open("Processing. Please wait..."), this.showBusySpinner = true, this.changeDetectorRef.detectChanges());
        }, 1e3);
      }
      hideBusySpinner() {
        this.showBusySpinnerTimeoutRef >= 0 && (clearTimeout(this.showBusySpinnerTimeoutRef), this.showBusySpinnerTimeoutRef = -1), this.snackBar.dismiss(), this.showBusySpinner = false, this.changeDetectorRef.detectChanges();
      }
      revealNode(e, n = true) {
        let r = this.curModelGraph.nodesById[e];
        return r ? (this.sendRelayoutGraphRequest(e, r.nsParentId ? [r.nsParentId] : [], false, void 0, false, void 0, false, n), true) : false;
      }
      updateCurModelGraph(e) {
        let n = this.curModelGraph.edgesByGroupNodeIds;
        this.curModelGraph = xt(le({}, e), { edgesByGroupNodeIds: le(le({}, n), e.edgesByGroupNodeIds) }), this.appService.updateCurrentModelGraph(this.paneId, this.curModelGraph);
      }
      updateNodesAndEdgesToRender() {
        if (!this.curModelGraph) return;
        this.elementsToRender = [], this.nodesToRender = [], this.nodesToRenderMap = {}, this.edgesToRender = [];
        let e = true, n = false, r = (o) => {
          let s = this.curModelGraph.nodesById[o || ""];
          if (e && s) {
            this.elementsToRender.push({ type: ww.NODE, id: s.id, node: s });
            let l = { node: s, index: this.elementsToRender.length - 1 };
            this.nodesToRender.push(l), this.nodesToRenderMap[l.node.id] = l, ct(s) && s.sectionContainer && (n = true);
          }
          if (e = false, o && s && s.expanded || !o) for (let l of this.curModelGraph.edgesByGroupNodeIds[o || ""] || []) this.elementsToRender.push({ type: ww.EDGE, id: l.id, edge: l }), this.edgesToRender.push({ edge: l, index: this.elementsToRender.length - 1 });
          let a = [];
          o ? s.expanded && (a = (s.nsChildrenIds || []).map((l) => this.curModelGraph.nodesById[l])) : a = this.curModelGraph.rootNodes;
          for (let l of a) {
            let c = { type: ww.NODE, id: l.id, node: l };
            !n && ct(l) && l.sectionContainer && (n = true), this.elementsToRender.push(c);
            let d = { node: l, index: this.elementsToRender.length - 1 };
            this.nodesToRender.push(d), this.nodesToRenderMap[d.node.id] = d, ct(l) && l.expanded && r(l.id);
          }
        };
        r(this.rootNodeId), this.appService.setPaneHasArtificialLayers(this.paneId, n);
      }
      getNodeLabel(e) {
        return dt(e) ? e.label === "Placeholder" ? e.id : e.label : ct(e) ? e.label : "-";
      }
      setHoveredNodeId(e) {
        this.hoveredNodeId = e, this.appService.updateHoveredNode(e, this.curModelGraph.id, this.curModelGraph.collectionLabel || "", this.curModelGraph.nodesById[e]);
      }
      revealAndHighlightNodes(e, n, r) {
        let o = () => {
          this.webglRendererThreejsService.zoomFitOnNodes(e, this.curModelGraph, xw), n && this.appService.selectNode(this.paneId, { nodeId: n, rendererId: this.rendererId, isGroupNode: ct(this.curModelGraph.nodesById[n]), triggerNavigationSync: false }), this.webglRendererHighlightNodesService.setHighlightNodeIds(e);
        }, s = this.getDeepestExpandedGroupNodeIdsForNodes(e);
        s.length > 0 ? (this.relayoutDoneFn = o, this.sendRelayoutGraphRequest("", s), r && this.syncNavigationService.setShowNoMappedNodeMessage(false)) : e.length > 0 && s.length === 0 ? (o(), r && this.syncNavigationService.setShowNoMappedNodeMessage(false)) : r && this.syncNavigationService.setShowNoMappedNodeMessage(true);
      }
      getDeepestExpandedGroupNodeIdsForNodes(e) {
        let n = /* @__PURE__ */ new Set();
        for (let r of e) {
          let o = this.curModelGraph.nodesById[r];
          if (!(dt(o) && o.hideInLayout) && o?.nsParentId) {
            let s = this.curModelGraph.nodesById[o.nsParentId];
            (!s.expanded || !this.isNodeRendered(s.id)) && n.add(o.nsParentId);
          }
        }
        return [...n];
      }
      clickSubgraph(e, n) {
        if (!n.altKey) this.openSubgraph(e);
        else {
          let r = this.appService.getGraphById(e);
          if (r) {
            let o = this.appService.getIsGraphInRightPane(this.curModelGraph.id);
            this.appService.openGraphInSplitPane(r, false, true, o);
          }
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge), K(pi), K(We), K(Cr), K(Ys), K(fn), K(Gl), K(Fl), K(Fo), K(Xs), K(al), K(un), K(sw), K(lw), K(aw), K(cw), K(hw), K(uw), K(pw), K(fw), K(mw), K(gw), K(vw), K(yw), K(ll));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["webgl-renderer"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Sle, 7), Fe(Mle, 7), Fe(Ele, 7), Fe(Tle, 7), Fe(Ile, 7), Fe(Dle, 7), Fe(Ple, 7), Fe(Rle, 5), Fe(Ole, 5), Fe(Ale, 7), Fe(Nle, 7), Fe(kle, 7)), n & 2) {
          let o;
          Ie(o = De()) && (r.container = o.first), Ie(o = De()) && (r.canvas = o.first), Ie(o = De()) && (r.snapshotCanvas = o.first), Ie(o = De()) && (r.pngDownloaderCanvas = o.first), Ie(o = De()) && (r.hoverToolbar = o.first), Ie(o = De()) && (r.ioPicker = o.first), Ie(o = De()) && (r.subgraphMenuTrigger = o.first), Ie(o = De()) && (r.groupNodeIconMatTooltip = o.first), Ie(o = De()) && (r.ioPickerMatTooltip = o.first), Ie(o = De()) && (r.moreActionsMenuTrigger = o.first), Ie(o = De()) && (r.rangeZoomDragArea = o.first), Ie(o = De()) && (r.dragToSelectDragArea = o.first);
        }
      }, inputs: { modelGraph: "modelGraph", rendererId: "rendererId", paneId: "paneId", rootNodeId: "rootNodeId", inPopup: "inPopup", benchmark: "benchmark" }, outputs: { openInPopupClicked: "openInPopupClicked" }, features: [Bt([sw, lw, aw, cw, hw, uw, pw, fw, mw, gw, vw, yw])], decls: 41, vars: 60, consts: [["container", ""], ["canvas", ""], ["snapshotCanvas", ""], ["pngDownloaderCanvas", ""], ["groupNodeIconMatTooltip", "matTooltip"], ["moreActionsMenuTrigger", "matMenuTrigger"], ["moreActionsMenu", "matMenu"], ["ioPicker", ""], ["ioPickerMatTooltip", "matTooltip"], ["subgraphIndicator", ""], ["subgraphMenuTrigger", "matMenuTrigger"], ["menu", "matMenu"], ["rangeZoomDragArea", ""], ["dragToSelectDragArea", ""], [1, "container", 3, "mouseleave"], [1, "main", 3, "mousedown", "contextmenu"], [1, "snapshot"], [1, "download-png"], [1, "group-node-icon", 3, "mouseenter", "mouseleave", "mousedown"], ["matTooltipPosition", "above", 1, "group-node-icon-tooltip", 3, "matTooltip", "matTooltipShowDelay", "matTooltipDisabled"], [1, "more-actions-menu-trigger", 3, "matMenuTriggerFor"], [1, "model-explorer-menu-item-with-icon", "expand-all", 3, "click"], ["class", "model-explorer-menu-item-with-icon collapse-all", 3, "click", 4, "ngIf"], ["class", "model-explorer-menu-item-with-icon open-in-popup", 3, "click", 4, "ngIf"], [1, "io-picker", 3, "mousedown", "mouseenter", "mouseleave"], ["matTooltipPosition", "above", 1, "io-picker-tooltip", 3, "matTooltip"], ["matTooltipClass", "multiline-tooltip-left", "matTooltipPosition", "above", 1, "subgraph-indicator", 3, "mousedown", "click", "matTooltip"], [1, "subgraph-indicator-menu-trigger", 3, "matMenuTriggerFor"], [1, "model-explorer-menu-item-with-icon"], [1, "model-explorer-alt-click-info"], ["bgColor", "rgba(97, 175, 252, 0.2)", "borderColor", "#1976d2"], ["bgColor", "rgba(9, 184, 62, 0.2)", "borderColor", "#09b83e"], [1, "flash"], [1, "fps"], [1, "model-explorer-menu-item-with-icon", "collapse-all", 3, "click"], [1, "model-explorer-menu-item-with-icon", "open-in-popup", 3, "click"], [1, "model-explorer-menu-item-with-icon", 3, "click"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 14, 0), Z("mouseleave", function(a) {
            return q(o), Y(r.handleMouseLeaveRenderer(a));
          }), b(2, "canvas", 15, 1), Z("mousedown", function(a) {
            return q(o), Y(r.handleMouseDownCanvas(a));
          })("contextmenu", function(a) {
            return q(o), Y(a.preventDefault());
          }), x(), ae(4, "canvas", 16, 2)(6, "canvas", 17, 3), b(8, "div", 18), Z("mouseenter", function() {
            return q(o), Y(r.handleMouseEnterGroupNodeIcon());
          })("mouseleave", function() {
            return q(o), Y(r.handleMouseLeaveGroupNodeIcon());
          })("mousedown", function(a) {
            return q(o), Y(r.handleClickGroupNodeIcon(a));
          }), x(), ae(9, "div", 19, 4)(11, "div", 20, 5), b(13, "mat-menu", null, 6)(15, "div", 21), Z("click", function() {
            return q(o), Y(r.handleClickExpandAll(r.hoveredNodeIdWhenClickingMoreActions));
          }), b(16, "mat-icon"), D(17, "unfold_more_double"), x(), D(18, " Expand layer & all sub-layers "), x(), X(19, Lle, 4, 0, "div", 22)(20, Fle, 4, 0, "div", 23), x(), b(21, "div", 24, 7), Z("mousedown", function(a) {
            return q(o), Y(r.handleClickIoPicker(a));
          })("mouseenter", function() {
            return q(o), Y(r.handleMouseEnterIoPicker());
          })("mouseleave", function() {
            return q(o), Y(r.handleMouseLeaveIoPicker());
          }), x(), ae(23, "div", 25, 8), b(25, "div", 26, 9), Z("mousedown", function(a) {
            return q(o), Y(a.stopPropagation());
          })("click", function(a) {
            return q(o), Y(r.handleClickSubgraphIndicator(a));
          }), x(), ae(27, "div", 27, 10), b(29, "mat-menu", null, 11), Qt(31, Ble, 4, 1, "div", 28, mr), b(33, "div", 29), D(34, " Alt-click to open in split pane "), x()(), ae(35, "drag-area", 30, 12)(37, "drag-area", 31, 13)(39, "div", 32), X(40, Vle, 2, 1, "div", 33), x();
        }
        if (n & 2) {
          let o = Ce(14), s = Ce(30);
          C(8), sn("top", r.groupNodeIcon.top, "px")("left", r.groupNodeIcon.left, "px")("width", r.groupNodeIcon.width, "px")("height", r.groupNodeIcon.height, "px"), C(), sn("top", r.groupNodeIcon.top, "px")("left", r.groupNodeIcon.left, "px")("width", r.groupNodeIcon.width, "px")("height", r.groupNodeIcon.height, "px"), U("matTooltip", r.groupNodeIcon.tooltip || "")("matTooltipShowDelay", 200)("matTooltipDisabled", r.groupNodeIcon.tooltip == null), C(2), sn("top", r.groupNodeIcon.top + r.groupNodeIcon.height, "px")("left", r.groupNodeIcon.left, "px"), U("matMenuTriggerFor", o), C(8), U("ngIf", r.getShowCollapseAllButton(r.hoveredNodeIdWhenClickingMoreActions)), C(), U("ngIf", r.showOpenInPopupButton), C(), sn("top", r.ioPickerTop, "px")("left", r.ioPickerLeft, "px")("width", r.ioPickerWidth, "px")("height", r.ioPickerHeight, "px"), C(2), sn("top", r.ioPickerTop, "px")("left", r.ioPickerLeft, "px")("width", r.ioPickerWidth, "px")("height", r.ioPickerHeight, "px"), U("matTooltip", r.ioPickerTooltip), C(2), sn("top", r.subgraphIndicatorTop, "px")("left", r.subgraphIndicatorLeft, "px")("width", r.subgraphIndicatorWidth, "px")("height", r.subgraphIndicatorHeight, "px"), U("matTooltip", r.subgraphIndicatorTooltip), C(2), sn("top", r.subgraphIndicatorTop + r.subgraphIndicatorHeight, "px")("left", r.subgraphIndicatorLeft, "px"), U("matMenuTriggerFor", s), C(4), Kt(r.curSubgraphIdsForMenu), C(8), ye("flashing", r.flashing), C(), he(r.benchmark ? 40 : -1);
        }
      }, dependencies: [et, In, qU, vt, St, Vl, $s, cp, tn, $n], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;overflow:hidden;position:relative}.container[_ngcontent-%COMP%]   canvas.main[_ngcontent-%COMP%]{width:100%!important;height:100%!important;box-sizing:border-box}.container[_ngcontent-%COMP%]   canvas.snapshot[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   canvas.download-png[_ngcontent-%COMP%]{position:absolute;left:0;bottom:0;width:400px;height:300px;border:1px solid red;box-sizing:border-box;background-color:#fff;display:none}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]{position:absolute;width:50px;height:40px;box-sizing:border-box;display:flex;transition:opacity .15s;opacity:1;pointer-events:none}.container[_ngcontent-%COMP%]   .hover-toolbar.hide[_ngcontent-%COMP%]{transition:none;opacity:0}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .main-content-wrapper[_ngcontent-%COMP%]{height:100%;display:flex;align-items:center;justify-content:center;pointer-events:all}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .main-content[_ngcontent-%COMP%]{font-size:12px;border:1px solid #ccc;background-color:#fafafae6;border-radius:99px;padding:0 8px;box-sizing:border-box;box-shadow:0 1px 3px #0000001a,0 1px 2px -1px #0000001a;display:flex;align-items:center}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .main-content[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:.8;width:24px;padding:4px 0}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .main-content[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1;background-color:#eee}.container[_ngcontent-%COMP%]   .hover-toolbar[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .main-content[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;font-weight:700;width:16px;height:16px;line-height:16px;color:#ea8600}.container[_ngcontent-%COMP%]   .io-picker[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .group-node-icon[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .subgraph-indicator[_ngcontent-%COMP%]{position:absolute;box-sizing:border-box;display:flex;background-color:transparent}.container[_ngcontent-%COMP%]   .group-node-icon[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .io-picker[_ngcontent-%COMP%]{z-index:100}.container[_ngcontent-%COMP%]   .group-node-icon-tooltip[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .io-picker-tooltip[_ngcontent-%COMP%]{position:absolute;z-index:50}.container[_ngcontent-%COMP%]   .subgraph-indicator-menu-trigger[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .more-actions-menu-trigger[_ngcontent-%COMP%]{position:absolute;visibility:hidden}.container[_ngcontent-%COMP%]   .flash[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;z-index:5000;box-sizing:border-box;border:5px solid #1976d2;pointer-events:none;opacity:0}@keyframes _ngcontent-%COMP%_flashing{5%{opacity:1}to{opacity:0}}.container[_ngcontent-%COMP%]   .flashing[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_flashing .3s ease-out}.container[_ngcontent-%COMP%]   .fps[_ngcontent-%COMP%]{position:absolute;top:12px;left:12px;z-index:100;font-size:32px;border:1px solid #777;padding:8px;border-radius:4px;background-color:#fff}  .multiline-tooltip{white-space:pre-line}  .multiline-tooltip-left{white-space:pre-line}  .multiline-tooltip-left>div{text-align:left}  .model-explorer-menu-item-with-icon{font-family:Google Sans Text,Arial,Helvetica,sans-serif;display:flex;align-items:center;font-size:12px;padding:5px 8px;line-height:15px;letter-spacing:normal}  .model-explorer-menu-item-with-icon mat-icon{font-size:16px;width:16px;height:16px;margin-right:4px;color:#999}  .model-explorer-menu-item-with-icon:hover{background-color:#0000000a}  .model-explorer-alt-click-info{height:32px;min-height:32px;background-color:#f6f6f6;border-top:1px solid #ddd;box-sizing:border-box;padding:0 10px;font-size:12px;display:flex;align-items:center;color:#777;margin-bottom:-8px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function Yle(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "button", 10), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickStart());
      }), D(1, " Start "), x();
    }
  }
  function Xle(i59, t) {
    i59 & 1 && (b(0, "div", 9), D(1, "Generating graph. Please wait..."), x());
  }
  function Zle(i59, t) {
    if (i59 & 1 && (b(0, "div", 2)(1, "div", 4)(2, "div", 5), D(3, "Node count"), x(), ae(4, "input", 6), x(), b(5, "div", 4)(6, "div", 5), D(7, "Edge count"), x(), ae(8, "input", 6), x(), b(9, "div", 4)(10, "div", 5), D(11, "Colorize"), x(), ae(12, "input", 7), x(), X(13, Yle, 2, 0, "button", 8)(14, Xle, 2, 0, "div", 9), x()), i59 & 2) {
      let e = T();
      C(4), U("formControl", e.curNodeCount), C(4), U("formControl", e.curEdgeCount), C(4), U("formControl", e.curColorize), C(), he(e.generating ? 14 : 13);
    }
  }
  function Qle(i59, t) {
    if (i59 & 1 && ae(0, "webgl-renderer", 3), i59 & 2) {
      let e = T();
      U("modelGraph", e.modelGraph)("benchmark", true);
    }
  }
  var Kle = pn;
  var DG = (() => {
    class i59 {
      changeDetectorRef;
      curNodeCount = new qr(1e4);
      curEdgeCount = new qr(5e3);
      curColorize = new qr(false);
      generating = false;
      modelGraph;
      constructor(e) {
        this.changeDetectorRef = e;
      }
      handleClickStart() {
        this.generating = true, this.changeDetectorRef.detectChanges(), setTimeout(() => {
          this.genModelGraph();
        }, 100);
      }
      genModelGraph() {
        let e = this.curNodeCount.value, n = this.curEdgeCount.value, r = Math.max(500, Math.floor(Math.sqrt(e) * 300)), o = [];
        for (let l = 0; l < e; l++) {
          let c = `n${l}`, d = Math.random() * r, u = Math.random() * r, h = 150 + (Math.random() - 0.5) * 60, p = 50 + (Math.random() - 0.5) * 30, f = { nodeType: Ds.OP_NODE, id: c, label: c, namespace: "", level: 0, x: d, y: u, globalX: 0, globalY: 0, width: h, height: p };
          this.curColorize.value && (f.style = { backgroundColor: `rgb(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)})` }), o.push(f);
        }
        let s = {};
        for (let l of o) s[l.id] = l;
        let a = { "": [] };
        for (let l = 0; l < n; l++) {
          let c = `n${Math.floor(Math.random() * e)}`, d = `n${Math.floor(Math.random() * e)}`, u = s[c], h = s[d], p = `${c}_${d}`, f = u.x + u.width / 2, m = u.y + u.height / 2, v = h.x + h.width / 2, _ = h.y + h.height / 2, g = [{ x: f, y: m }, { x: (f + v) / 2 + (Math.random() - 0.5) * 100, y: (m + _) / 2 + (Math.random() - 0.5) * 100 }, { x: v, y: _ }], y = Nu(g, nh, ih, Kle), w = { id: p, fromNodeId: c, toNodeId: d, points: g, curvePoints: y };
          a[""].push(w);
        }
        this.modelGraph = { id: "benchmark_graph", collectionLabel: "benchmark_collection", nodes: o, nodesById: s, rootNodes: o, edgesByGroupNodeIds: a, maxDescendantOpNodeCount: 0, minDescendantOpNodeCount: 0, layoutGraphEdges: {} }, this.changeDetectorRef.detectChanges();
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["benchmark-runner"]], features: [Bt([Gs, Fo, Fl])], decls: 6, vars: 1, consts: [[1, "container"], [1, "title"], [1, "form"], ["rendererId", "benchmark", "paneId", "benchmark", 3, "modelGraph", "benchmark"], [1, "row"], [1, "label"], ["type", "text", 3, "formControl"], ["type", "checkbox", 3, "formControl"], ["mat-flat-button", "", "color", "primary"], [1, "gen-msg"], ["mat-flat-button", "", "color", "primary", 3, "click"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0)(1, "div", 1), ae(2, "me-logo"), D(3, " Model Explorer Benchmark Test "), x(), X(4, Zle, 15, 4, "div", 2)(5, Qle, 1, 2, "webgl-renderer", 3), x()), n & 2 && (C(4), he(r.modelGraph ? 5 : 4));
      }, dependencies: [et, Hx, Hn, vr, Do, ul, kf, Ps, Jo, Cw], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;flex-direction:column;position:relative}.container[_ngcontent-%COMP%]   .form[_ngcontent-%COMP%]{margin:12px}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-weight:400;cursor:pointer;color:#444746;font-size:20px;display:flex;align-items:center;padding:8px 8px 8px 12px;border-bottom:1px solid #ddd}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   me-logo[_ngcontent-%COMP%]{margin-right:6px}.container[_ngcontent-%COMP%]   .row[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin-top:12px}.container[_ngcontent-%COMP%]   .row[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{font-size:12px;color:#777}.container[_ngcontent-%COMP%]   .row[_ngcontent-%COMP%]   input[type=text][_ngcontent-%COMP%]{width:200px;font-size:13px}.container[_ngcontent-%COMP%]   .row[_ngcontent-%COMP%]   input[type=checkbox][_ngcontent-%COMP%]{width:fit-content}.container[_ngcontent-%COMP%]   .row[_ngcontent-%COMP%]:first-child{margin-top:0}.container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{margin-top:12px}.container[_ngcontent-%COMP%]   .gen-msg[_ngcontent-%COMP%]{font-size:12px;margin-top:12px}.container[_ngcontent-%COMP%]   webgl-renderer[_ngcontent-%COMP%]{position:absolute;top:48px;bottom:0;width:100%}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Jle = "http://localhost:5000";
  var PG = (() => {
    class i59 {
      extensionServerAddress = Jle;
      extensions = {};
      loadExtensions() {
        return $t(this, null, function* () {
          let e = (yield this.sendGetRequest("api_list_extensions")) || [];
          e.sort((n, r) => n.name.localeCompare(r.name));
          for (let n of e) this.extensions[n.id] = n;
          return e;
        });
      }
      sendCommandToExtension(e) {
        return $t(this, null, function* () {
          return yield this.sendGetRequest("api_cmd", e);
        });
      }
      updateExtensionServerAddress(e) {
        this.extensionServerAddress = e;
      }
      sendGetRequest(e, n) {
        return $t(this, null, function* () {
          let r = `${this.extensionServerAddress}/${e}`;
          n && (r = `${r}?cmd=${encodeURIComponent(JSON.stringify(n))}`);
          try {
            let o = yield fetch(r, { credentials: "include" });
            return o.ok ? yield o.json() : void 0;
          } catch (o) {
            console.warn(o);
            return;
          }
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var ece = ["determinateSpinner"];
  function tce(i59, t) {
    if (i59 & 1 && (to(), b(0, "svg", 11), ae(1, "circle", 12), x()), i59 & 2) {
      let e = T();
      Ke("viewBox", e._viewBox()), C(), sn("stroke-dasharray", e._strokeCircumference(), "px")("stroke-dashoffset", e._strokeCircumference() / 2, "px")("stroke-width", e._circleStrokeWidth(), "%"), Ke("r", e._circleRadius());
    }
  }
  var nce = new Ee("mat-progress-spinner-default-options", { providedIn: "root", factory: ice });
  function ice() {
    return { diameter: RG };
  }
  var RG = 100;
  var rce = 10;
  var fp = (() => {
    class i59 {
      _elementRef = M(He);
      _noopAnimations;
      get color() {
        return this._color || this._defaultColor;
      }
      set color(e) {
        this._color = e;
      }
      _color;
      _defaultColor = "primary";
      _determinateCircle;
      constructor() {
        let e = M(An, { optional: true }), n = M(nce);
        this._noopAnimations = e === "NoopAnimations" && !!n && !n._forceAnimations, this.mode = this._elementRef.nativeElement.nodeName.toLowerCase() === "mat-spinner" ? "indeterminate" : "determinate", n && (n.color && (this.color = this._defaultColor = n.color), n.diameter && (this.diameter = n.diameter), n.strokeWidth && (this.strokeWidth = n.strokeWidth));
      }
      mode;
      get value() {
        return this.mode === "determinate" ? this._value : 0;
      }
      set value(e) {
        this._value = Math.max(0, Math.min(100, e || 0));
      }
      _value = 0;
      get diameter() {
        return this._diameter;
      }
      set diameter(e) {
        this._diameter = e || 0;
      }
      _diameter = RG;
      get strokeWidth() {
        return this._strokeWidth ?? this.diameter / 10;
      }
      set strokeWidth(e) {
        this._strokeWidth = e || 0;
      }
      _strokeWidth;
      _circleRadius() {
        return (this.diameter - rce) / 2;
      }
      _viewBox() {
        let e = this._circleRadius() * 2 + this.strokeWidth;
        return `0 0 ${e} ${e}`;
      }
      _strokeCircumference() {
        return 2 * Math.PI * this._circleRadius();
      }
      _strokeDashOffset() {
        return this.mode === "determinate" ? this._strokeCircumference() * (100 - this._value) / 100 : null;
      }
      _circleStrokeWidth() {
        return this.strokeWidth / this.diameter * 100;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-progress-spinner"], ["mat-spinner"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(ece, 5), n & 2) {
          let o;
          Ie(o = De()) && (r._determinateCircle = o.first);
        }
      }, hostAttrs: ["role", "progressbar", "tabindex", "-1", 1, "mat-mdc-progress-spinner", "mdc-circular-progress"], hostVars: 18, hostBindings: function(n, r) {
        n & 2 && (Ke("aria-valuemin", 0)("aria-valuemax", 100)("aria-valuenow", r.mode === "determinate" ? r.value : null)("mode", r.mode), io("mat-" + r.color), sn("width", r.diameter, "px")("height", r.diameter, "px")("--mdc-circular-progress-size", r.diameter + "px")("--mdc-circular-progress-active-indicator-width", r.diameter + "px"), ye("_mat-animation-noopable", r._noopAnimations)("mdc-circular-progress--indeterminate", r.mode === "indeterminate"));
      }, inputs: { color: "color", mode: "mode", value: [2, "value", "value", Gn], diameter: [2, "diameter", "diameter", Gn], strokeWidth: [2, "strokeWidth", "strokeWidth", Gn] }, exportAs: ["matProgressSpinner"], features: [on], decls: 14, vars: 11, consts: [["circle", ""], ["determinateSpinner", ""], ["aria-hidden", "true", 1, "mdc-circular-progress__determinate-container"], ["xmlns", "http://www.w3.org/2000/svg", "focusable", "false", 1, "mdc-circular-progress__determinate-circle-graphic"], ["cx", "50%", "cy", "50%", 1, "mdc-circular-progress__determinate-circle"], ["aria-hidden", "true", 1, "mdc-circular-progress__indeterminate-container"], [1, "mdc-circular-progress__spinner-layer"], [1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-left"], [3, "ngTemplateOutlet"], [1, "mdc-circular-progress__gap-patch"], [1, "mdc-circular-progress__circle-clipper", "mdc-circular-progress__circle-right"], ["xmlns", "http://www.w3.org/2000/svg", "focusable", "false", 1, "mdc-circular-progress__indeterminate-circle-graphic"], ["cx", "50%", "cy", "50%"]], template: function(n, r) {
        if (n & 1 && (X(0, tce, 2, 8, "ng-template", null, 0, Tt), b(2, "div", 2, 1), to(), b(4, "svg", 3), ae(5, "circle", 4), x()(), Av(), b(6, "div", 5)(7, "div", 6)(8, "div", 7), fi(9, 8), x(), b(10, "div", 9), fi(11, 8), x(), b(12, "div", 10), fi(13, 8), x()()()), n & 2) {
          let o = Ce(1);
          C(4), Ke("viewBox", r._viewBox()), C(), sn("stroke-dasharray", r._strokeCircumference(), "px")("stroke-dashoffset", r._strokeDashOffset(), "px")("stroke-width", r._circleStrokeWidth(), "%"), Ke("r", r._circleRadius()), C(4), U("ngTemplateOutlet", o), C(2), U("ngTemplateOutlet", o), C(2), U("ngTemplateOutlet", o);
        }
      }, dependencies: [Ss], styles: [".mat-mdc-progress-spinner{display:block;overflow:hidden;line-height:0;position:relative;direction:ltr;transition:opacity 250ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-progress-spinner circle{stroke-width:var(--mdc-circular-progress-active-indicator-width, 4px)}.mat-mdc-progress-spinner._mat-animation-noopable,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__determinate-circle{transition:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__spinner-layer,.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container{animation:none !important}.mat-mdc-progress-spinner._mat-animation-noopable .mdc-circular-progress__indeterminate-container circle{stroke-dasharray:0 !important}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic,.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle{stroke:currentColor;stroke:CanvasText}}.mdc-circular-progress__determinate-container,.mdc-circular-progress__indeterminate-circle-graphic,.mdc-circular-progress__indeterminate-container,.mdc-circular-progress__spinner-layer{position:absolute;width:100%;height:100%}.mdc-circular-progress__determinate-container{transform:rotate(-90deg)}.mdc-circular-progress--indeterminate .mdc-circular-progress__determinate-container{opacity:0}.mdc-circular-progress__indeterminate-container{font-size:0;letter-spacing:0;white-space:nowrap;opacity:0}.mdc-circular-progress--indeterminate .mdc-circular-progress__indeterminate-container{opacity:1;animation:mdc-circular-progress-container-rotate 1568.2352941176ms linear infinite}.mdc-circular-progress__determinate-circle-graphic,.mdc-circular-progress__indeterminate-circle-graphic{fill:rgba(0,0,0,0)}.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:var(--mdc-circular-progress-active-indicator-color, var(--mat-sys-primary))}@media(forced-colors: active){.mat-mdc-progress-spinner .mdc-circular-progress__determinate-circle,.mat-mdc-progress-spinner .mdc-circular-progress__indeterminate-circle-graphic{stroke:CanvasText}}.mdc-circular-progress__determinate-circle{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1)}.mdc-circular-progress__gap-patch{position:absolute;top:0;left:47.5%;box-sizing:border-box;width:5%;height:100%;overflow:hidden}.mdc-circular-progress__gap-patch .mdc-circular-progress__indeterminate-circle-graphic{left:-900%;width:2000%;transform:rotate(180deg)}.mdc-circular-progress__circle-clipper .mdc-circular-progress__indeterminate-circle-graphic{width:200%}.mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{left:-100%}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-left .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress--indeterminate .mdc-circular-progress__circle-right .mdc-circular-progress__indeterminate-circle-graphic{animation:mdc-circular-progress-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}.mdc-circular-progress__circle-clipper{display:inline-flex;position:relative;width:50%;height:100%;overflow:hidden}.mdc-circular-progress--indeterminate .mdc-circular-progress__spinner-layer{animation:mdc-circular-progress-spinner-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both}@keyframes mdc-circular-progress-container-rotate{to{transform:rotate(360deg)}}@keyframes mdc-circular-progress-spinner-layer-rotate{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes mdc-circular-progress-left-spin{from{transform:rotate(265deg)}50%{transform:rotate(130deg)}to{transform:rotate(265deg)}}@keyframes mdc-circular-progress-right-spin{from{transform:rotate(-265deg)}50%{transform:rotate(-130deg)}to{transform:rotate(-265deg)}}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var Zs = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt] });
    }
    return i59;
  })();
  var oce = ["item"];
  function sce(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 3), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T();
      C(6), Qe(e.opLabel);
    }
  }
  function ace(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 5), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T();
      C(6), Qe(e.layerLabel);
    }
  }
  function lce(i59, t) {
    i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 6), x(), b(4, "td")(5, "div", 4), D(6, "Artificial layer to reduce layout load"), x()()());
  }
  function cce(i59, t) {
    if (i59 & 1 && X(0, lce, 7, 0, "tr", 2), i59 & 2) {
      let e = T();
      U("ngIf", e.hasArtificialLayers);
    }
  }
  function dce(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 7), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T();
      C(3), ye("group", e.isSelectedNodeGroup), C(3), Oe(" ", e.selectedItemLabel, " ");
    }
  }
  function uce(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 8), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T(2);
      C(6), Qe(e.identicalLayerLabel);
    }
  }
  function hce(i59, t) {
    if (i59 & 1 && X(0, uce, 7, 1, "tr", 2), i59 & 2) {
      let e = T();
      U("ngIf", e.showSelectedNodeKey && e.isSelectedNodeGroup);
    }
  }
  function pce(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 9), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T(2);
      C(6), Oe("", e.inputsLabel, " (if any)");
    }
  }
  function fce(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 0)(2, "td"), ae(3, "div", 10), x(), b(4, "td")(5, "div", 4), D(6), x()()()), i59 & 2) {
      let e = T(2);
      C(6), Oe("", e.outputsLabel, " (if any)");
    }
  }
  function mce(i59, t) {
    if (i59 & 1 && (bc(0), X(1, pce, 7, 1, "tr")(2, fce, 7, 1, "tr"), xc()), i59 & 2) {
      let e = T();
      C(), he(e.hideInputs ? -1 : 1), C(), he(e.hideOutputs ? -1 : 2);
    }
  }
  function gce(i59, t) {
    i59 & 1 && (b(0, "tr")(1, "td", 13), ae(2, "div", 14), x()());
  }
  function _ce(i59, t) {
    if (i59 & 1 && (X(0, gce, 3, 0, "tr"), b(1, "tr")(2, "td")(3, "div", 11), D(4, "Zoom"), x()(), b(5, "td")(6, "div", 12), D(7, "Ctrl+Scroll"), x()()(), b(8, "tr")(9, "td")(10, "div", 11), D(11, "Pan"), x()(), b(12, "td")(13, "div", 12), D(14, "Drag or scroll"), x()()()), i59 & 2) {
      let e = T();
      he(e.showDivider() ? 0 : -1);
    }
  }
  var OG = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      paneId;
      legendItems = _N("item");
      showSelectedNodeKey = false;
      isSelectedNodeGroup = false;
      hasArtificialLayers = false;
      showPanel = gt(true);
      showDivider = gt(true);
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n, ht(() => {
          let r = this.appService.getPaneById(this.paneId);
          if (!r) return;
          this.hasArtificialLayers = r.hasArtificialLayers === true;
          let o = r.selectedNodeInfo;
          if (!o) {
            this.showSelectedNodeKey = false, this.changeDetectorRef.markForCheck();
            return;
          }
          this.showSelectedNodeKey = o.nodeId !== "", this.isSelectedNodeGroup = o.isGroupNode, this.changeDetectorRef.markForCheck();
        }), ht(() => {
          let r = this.legendItems();
          this.showDivider.set(r.length > 0), this.showPanel.set(r.length > 0 || !this.hideShortcuts);
        });
      }
      get opLabel() {
        return this.appService.config()?.legendConfig?.renameOpTo ?? "Op";
      }
      get layerLabel() {
        return this.appService.config()?.legendConfig?.renameLayerTo ?? "Layer";
      }
      get inputsLabel() {
        return this.appService.config()?.legendConfig?.renameInputsTo ?? "Inputs";
      }
      get outputsLabel() {
        return this.appService.config()?.legendConfig?.renameOutputsTo ?? "Outputs";
      }
      get selectedItemLabel() {
        let e = this.appService.config();
        return this.isSelectedNodeGroup ? `Selected ${e?.legendConfig?.renameLayerTo ?? "layer"}` : `Selected ${e?.legendConfig?.renameOpTo ?? "op"}`;
      }
      get identicalLayerLabel() {
        return `Identical ${this.appService.config()?.legendConfig?.renameLayerTo ?? "layer"} (if any)`;
      }
      get hideOp() {
        return this.appService.config()?.legendConfig?.hideOp ?? false;
      }
      get hideLayer() {
        return this.appService.config()?.legendConfig?.hideLayer ?? false;
      }
      get hideArtificialLayers() {
        return this.appService.config()?.legendConfig?.hideArtificialLayers ?? false;
      }
      get hideSelectedOp() {
        return this.appService.config()?.legendConfig?.hideSelectedOp ?? false;
      }
      get hideSelectedLayer() {
        return this.appService.config()?.legendConfig?.hideSelectedLayer ?? false;
      }
      get hideIdenticalLayers() {
        return this.appService.config()?.legendConfig?.hideIdenticalLayers ?? false;
      }
      get hideInputs() {
        return this.appService.config()?.legendConfig?.hideInputs ?? false;
      }
      get hideOutputs() {
        return this.appService.config()?.legendConfig?.hideOutputs ?? false;
      }
      get hideShortcuts() {
        return this.appService.config()?.legendConfig?.hideShortcuts ?? false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["legends-panel"]], viewQuery: function(n, r) {
        n & 1 && Hv(r.legendItems, oce, 5), n & 2 && wu();
      }, inputs: { paneId: "paneId" }, decls: 9, vars: 9, consts: [["item", ""], [1, "container"], [4, "ngIf"], [1, "key", "op-node-key"], [1, "label"], [1, "key", "group-node-key"], [1, "key", "artificial-layer-key"], [1, "key", "selected-node-key"], [1, "key", "identical-group-key"], [1, "key", "input-key"], [1, "key", "output-key"], [1, "key", "shortcut"], [1, "label", "shortcut"], ["colspan", "2"], [1, "divider"]], template: function(n, r) {
        n & 1 && (b(0, "div", 1)(1, "table"), X(2, sce, 7, 1, "tr")(3, ace, 7, 1, "tr")(4, cce, 1, 1, "tr")(5, dce, 7, 3, "tr")(6, hce, 1, 1, "tr")(7, mce, 3, 2, "ng-container", 2)(8, _ce, 15, 1), x()()), n & 2 && (ye("hide", !r.showPanel()), C(2), he(r.hideOp ? -1 : 2), C(), he(r.hideLayer ? -1 : 3), C(), he(r.hideArtificialLayers ? -1 : 4), C(), he(r.showSelectedNodeKey && (r.isSelectedNodeGroup && !r.hideSelectedLayer || !r.isSelectedNodeGroup && !r.hideSelectedOp) ? 5 : -1), C(), he(r.hideIdenticalLayers ? -1 : 6), C(), U("ngIf", r.showSelectedNodeKey && !r.isSelectedNodeGroup), C(), he(r.hideShortcuts ? -1 : 8));
      }, dependencies: [et, In, vt], styles: [`.container[_ngcontent-%COMP%]{height:fit-content;background-color:#ffffffe6;padding:8px}.container.hide[_ngcontent-%COMP%]{display:none}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{border-spacing:0;border-collapse:collapse;padding:0;font-size:11px}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .key[_ngcontent-%COMP%]{margin-right:4px;box-sizing:border-box}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .op-node-key[_ngcontent-%COMP%]{width:30px;height:14px;border-radius:5px;border:1px solid #666;background-color:#fff}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .group-node-key[_ngcontent-%COMP%]{width:30px;height:14px;border:1px solid #777;border-radius:5px;background-color:#eaeaf2}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .artificial-layer-key[_ngcontent-%COMP%]{border:1px solid #800080;width:30px;height:14px;background-color:#f1f1f1}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .selected-node-key[_ngcontent-%COMP%]{width:30px;height:14px;border:2px solid #1a73e8;border-radius:5px;background-color:#c2e7ff}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .identical-group-key[_ngcontent-%COMP%]{width:30px;height:14px;border:1px solid #777;background-color:#e2edff}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .input-key[_ngcontent-%COMP%]{width:30px;height:14px;border-radius:5px;border:2px solid #009e73}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .output-key[_ngcontent-%COMP%]{width:30px;height:14px;border-radius:5px;border:2px solid #d55e00}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .shortcut[_ngcontent-%COMP%]{color:#777;font-size:10px;line-height:10px}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{height:1px;border-top:1px solid #ccc;margin:8px 0 4px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var AG = 48;
  var NG = 48;
  var Sw = class {
    rootEle;
    constructor(t) {
      this.rootEle = t;
    }
    drag(t) {
      let e = t.clientX, n = t.clientY, r = t.offsetX, o = Number(this.rootEle.style.top.replace("px", "")), s = Number(this.rootEle.style.left.replace("px", "")), a = Number(this.rootEle.style.width.replace("px", "")), l = Number(this.rootEle.style.height.replace("px", "")), c = zn(document, "mousemove"), d = zn(window, "mouseup"), u = t.target.dataset.position, h = this.rootEle.parentElement.offsetHeight, p = this.rootEle.parentElement.offsetWidth;
      cr([c]).pipe(Je(d)).subscribe({ next: ([f]) => {
        f.preventDefault();
        let m = f.clientX - e, v = f.clientY - n;
        if (!(m === 0 && v === 0)) if (u == null) this.rootEle.style.top = `${Math.min(h - 28, Math.max(o + v, 0))}px`, this.rootEle.style.left = `${Math.min(p - r, Math.max(-r, s + m))}px`;
        else {
          if (u.includes("right") && (this.rootEle.style.width = `${Math.max(AG, a + m)}px`), u.includes("bottom") && (this.rootEle.style.height = `${Math.max(NG, l + v)}px`), u.includes("left")) {
            let _ = Math.max(AG, a - m);
            this.rootEle.style.width = `${_}px`, this.rootEle.style.left = `${s + (a - _)}px`;
          }
          if (u.includes("top")) {
            let _ = Math.max(NG, l - v);
            this.rootEle.style.height = `${_}px`, this.rootEle.style.top = `${o + (l - _)}px`;
          }
        }
      }, complete: () => {
      } });
    }
  };
  var Xr = (() => {
    class i59 extends rw {
      constructor(e, n, r, o, s, a, l) {
        super(e, n, r, o, s, a, l), this.attachMouseEventListeners(r.nativeElement);
      }
      ngOnInit() {
        super.ngOnInit(), this.listenForOpenEvents();
      }
      listenForOpenEvents() {
        this.openStatusChange.pipe(Je(this.destroyed)).subscribe((e) => {
          e ? this.openDialog() : this.closeDialog();
        });
      }
      attachMouseEventListeners(e) {
        this.ngZone.runOutsideAngular(() => {
          zn(e, "click").pipe(Je(this.destroyed)).subscribe((n) => {
            n.target.closest("[bubbleClose]") ? this.closingDialog() : this.openingDialog();
          }), this.overlayRef?.backdropClick().pipe(Je(this.destroyed)).subscribe(() => {
            this.closingDialog();
          });
        });
      }
      attachKeyboardCloseEventListeners(e) {
        this.ngZone.runOutsideAngular(() => {
          zn(e, "keyup").pipe(Je(this.destroyed)).subscribe((n) => {
            let r = n.keyCode, o = n.target;
            switch (r) {
              case 27:
                this.closingDialog();
                return;
              case 32:
                o.closest("[bubbleClose]") && this.closingDialog();
                return;
              default:
                return;
            }
          }), zn(e, "keydown").pipe(Je(this.destroyed)).subscribe((n) => {
            let r = n.keyCode, o = n.target;
            switch (r) {
              case 13:
                o.closest("[bubbleClose]") && this.closingDialog();
                return;
              default:
                return;
            }
          });
        });
      }
      openingDialog() {
        this.disabled || this.openStatusChange.next(true);
      }
      closingDialog() {
        this.openStatusChange.next(false);
      }
      createOverlayConfig(e) {
        return new Gi(xt(le({}, this.overlayDimensions), { positionStrategy: super.createPositionStrategy(e), scrollStrategy: this.createScrollStrategy(), hasBackdrop: true, backdropClass: "cdk-overlay-transparent-backdrop", panelClass: this.panelClassInternal }));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(We), K(fn), K(He), K(un), K(yt), K($u), K(mt));
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "bubbleClick", ""]], hostAttrs: [1, "bubble-click"], inputs: { dialog: [0, "bubbleClick", "dialog"], disabled: [0, "bubbleDisabled", "disabled"] }, exportAs: ["bubbleClick"], features: [Zt] });
    }
    return i59;
  })();
  var kG = (i59, t) => t.id;
  function vce(i59, t) {
    i59 & 1 && (b(0, "div", 6), D(1, " Show custom edge overlays on graph "), x());
  }
  function yce(i59, t) {
    i59 & 1 && (b(0, "div", 13), D(1, " No loaded edge overlays "), x());
  }
  function bce(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 24), Z("click", function() {
        q(e);
        let r = T().$implicit, o = T(4);
        return Y(o.handleClickViewOverlay(r));
      }), D(1, " View "), x();
    }
  }
  function xce(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 21)(1, "label")(2, "input", 22), Z("change", function() {
        let r = q(e).$implicit, o = T(4);
        return Y(o.toggleOverlaySelection(r));
      }), x(), D(3), x(), X(4, bce, 2, 0, "div", 23), x();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      C(2), U("checked", e.selected), C(), Oe(" ", e.name, " "), C(), he(e.selected ? 4 : -1);
    }
  }
  function wce(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 18)(1, "div", 19), D(2), b(3, "div", 20), Z("click", function() {
        let r = q(e).$implicit, o = T(3);
        return Y(o.handleDeleteOverlaySet(r));
      }), b(4, "mat-icon"), D(5, "delete"), x()()(), Qt(6, xce, 5, 3, "div", 21, kG), x();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      C(2), Oe(" ", e.name, " "), C(4), Kt(e.overlays);
    }
  }
  function Cce(i59, t) {
    if (i59 & 1 && Qt(0, wce, 8, 1, "div", 18, kG), i59 & 2) {
      let e = T(2);
      Kt(e.overlaysSets());
    }
  }
  function Sce(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 7)(1, "div", 8)(2, "div"), D(3, "Edge overlays"), x(), b(4, "div", 9)(5, "a", 10), D(6, " Guide "), x(), b(7, "div", 11)(8, "mat-icon"), D(9, "close"), x()()()(), b(10, "div", 12), X(11, yce, 2, 0, "div", 13)(12, Cce, 2, 0), x(), b(13, "div", 14)(14, "div", 15), D(15, "Load from computer"), x(), b(16, "button", 16), Z("click", function() {
        q(e);
        let r = Ce(19);
        return Y(r.click());
      }), D(17, " Upload "), x()(), b(18, "input", 17, 2), Z("change", function() {
        q(e);
        let r = Ce(19), o = T();
        return Y(o.handleClickUpload(r));
      }), x()();
    }
    if (i59 & 2) {
      let e = T();
      C(11), he(e.overlaysSets().length === 0 ? 11 : 12);
    }
  }
  var LG = (() => {
    class i59 {
      paneId;
      rendererId;
      popup;
      appService = M(nt);
      localStorageService = M(Io);
      changeDetectorRef = M(Ge);
      edgeOverlaysService = M(Gs);
      snackBar = M(Gl);
      overlaysSets = It(() => this.edgeOverlaysService.loadedEdgeOverlays().map((n) => ({ id: n.id, name: n.name, overlays: n.processedOverlays.map((r) => ({ id: r.id, name: r.name, selected: this.edgeOverlaysService.selectedOverlayIds().includes(r.id), processedOverlay: r })) })));
      helpPopupSize = { minWidth: 0, minHeight: 0 };
      edgeOverlaysPopupSize = { minWidth: 280, minHeight: 0 };
      remoteSourceLoading = this.edgeOverlaysService.remoteSourceLoading;
      opened = false;
      constructor() {
      }
      handleClickOnEdgeOverlaysButton() {
        this.opened && this.popup.closeDialog();
      }
      handleClickUpload(e) {
        let n = e.files;
        if (!n || n.length === 0) return;
        let r = n[0], o = new FileReader();
        o.onload = (s) => {
          let a = this.edgeOverlaysService.addEdgeOverlayDataFromJsonData(s.target?.result);
          a && this.showError(a);
        }, o.readAsText(r), e.value = "";
      }
      handleDeleteOverlaySet(e) {
        this.edgeOverlaysService.deleteOverlayData(e.id);
      }
      toggleOverlaySelection(e) {
        this.edgeOverlaysService.toggleOverlaySelection(e.id);
      }
      handleClickViewOverlay(e) {
        let n = e.processedOverlay.edges;
        if (n.length === 0) return;
        let r = n[0].sourceNodeId;
        this.appService.setNodeToReveal(this.paneId, r);
      }
      showError(e) {
        console.error(e), this.snackBar.open(e, "Dismiss", { duration: 5e3 });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["edge-overlays-dropdown"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Xr, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.popup = o.first);
        }
      }, inputs: { paneId: "paneId", rendererId: "rendererId" }, decls: 8, vars: 5, consts: [["help", ""], ["edgeOverlaysPopup", ""], ["input", ""], [1, "container", 3, "bubble", "overlaySize", "hoverDelayMs"], [1, "mat-icon-container", "view", 3, "opened", "closed", "click", "bubbleClick", "overlaySize"], [1, "toolbar-icon"], [1, "model-explorer-help-popup"], [1, "model-explorer-edge-overlays-popup"], [1, "label"], [1, "right-wrapper"], ["href", "https://github.com/google-ai-edge/model-explorer/wiki/2.-User-Guide#edge-overlays", "target", "_blank"], ["bubbleClose", "", 1, "icon-container", "close"], [1, "loaded-overlays-container"], [1, "no-overlays-label"], [1, "upload-container"], [1, "description"], ["mat-flat-button", "", "color", "primary", 1, "upload-json-file-button", "upload", 3, "click"], ["type", "file", "multiple", "", "accept", ".json", 1, "upload-json-file-input", 3, "change"], [1, "overlay-set-container"], [1, "overlay-set-label"], [1, "icon-container", "delete", 3, "click"], [1, "overlay-item"], ["type", "checkbox", 3, "change", "checked"], [1, "view-label"], [1, "view-label", 3, "click"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 3)(1, "div", 4), Z("opened", function() {
            return q(o), Y(r.opened = true);
          })("closed", function() {
            return q(o), Y(r.opened = false);
          })("click", function() {
            return q(o), Y(r.handleClickOnEdgeOverlaysButton());
          }), b(2, "mat-icon", 5), D(3, "polyline"), x()()(), X(4, vce, 2, 0, "ng-template", null, 0, Tt)(6, Sce, 20, 1, "ng-template", null, 1, Tt);
        }
        if (n & 2) {
          let o = Ce(5), s = Ce(7);
          U("bubble", o)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(), U("bubbleClick", s)("overlaySize", r.edgeOverlaysPopupSize);
        }
      }, dependencies: [Bn, Xr, et, Hn, vr, vt, St, tn], styles: [`.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{width:20px;height:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:.6}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]:hover{opacity:.9}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px}  bubble-container:has(.model-explorer-edge-overlays-popup){border-top-left-radius:0;border-top-right-radius:0}  .model-explorer-edge-overlays-popup{padding:10px 12px 12px;font-size:12px;background-color:#fff;display:flex;flex-direction:column}  .model-explorer-edge-overlays-popup .icon-container{cursor:pointer;opacity:.8;display:flex;align-items:center;justify-content:center}  .model-explorer-edge-overlays-popup .icon-container:hover{opacity:1}  .model-explorer-edge-overlays-popup .icon-container mat-icon{font-size:16px;width:16px;height:16px;color:#777}  .model-explorer-edge-overlays-popup .label{font-weight:500;font-size:11px;text-transform:uppercase;margin-bottom:6px;display:flex;align-items:center;justify-content:space-between;min-width:170px}  .model-explorer-edge-overlays-popup .label:not(:first-child){margin-top:12px}  .model-explorer-edge-overlays-popup .label .right-wrapper{display:flex;align-items:center;gap:4px}  .model-explorer-edge-overlays-popup .loaded-overlays-container{display:flex;flex-direction:column;padding-bottom:8px;border-bottom:1px solid #ccc;gap:8px}  .model-explorer-edge-overlays-popup .loaded-overlays-container .no-overlays-label{color:#999}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-set-label{display:flex;align-items:center;justify-content:space-between;font-weight:700;line-height:15px;word-break:break-all;margin-bottom:4px}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-item{display:flex;align-items:center;justify-content:space-between}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-item label{display:flex;align-items:center;cursor:pointer;line-height:15px;word-break:break-all;gap:4px;-webkit-user-select:none;user-select:none}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-item label input{cursor:pointer}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-item .view-label{cursor:pointer;color:#00639b;opacity:.8;-webkit-user-select:none;user-select:none;line-height:15px}  .model-explorer-edge-overlays-popup .loaded-overlays-container .overlay-item .view-label:hover{opacity:1}  .model-explorer-edge-overlays-popup .upload-container{display:flex;flex-direction:column;align-items:flex-start;padding:0 16px 0 0;margin-top:12px}  .model-explorer-edge-overlays-popup .upload-json-file-button{margin:4px 0;width:90px;height:30px;font-size:12px!important;letter-spacing:normal!important}  .model-explorer-edge-overlays-popup .upload-json-file-button.upload{margin-top:2px}  .model-explorer-edge-overlays-popup .upload-json-file-button   .mat-mdc-button-touch-target{display:none}  .model-explorer-edge-overlays-popup .or-divider{height:1px;border-top:1px solid #eee;position:relative;margin-top:12px}  .model-explorer-edge-overlays-popup .or-divider .or-label{font-size:10px;top:-12px;color:#aaa;position:absolute;padding:2px;background-color:#fff;display:flex;align-items:center;justify-content:center;width:16px;left:calc(50% - 8px)}  .model-explorer-edge-overlays-popup .upload-json-file-input{display:none}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Ece = ["input"];
  var Tce = ["label"];
  var Ice = ["*"];
  var Dce = new Ee("mat-checkbox-default-options", { providedIn: "root", factory: BG });
  function BG() {
    return { color: "accent", clickAction: "check-indeterminate", disabledInteractive: false };
  }
  var Mr = function(i59) {
    return i59[i59.Init = 0] = "Init", i59[i59.Checked = 1] = "Checked", i59[i59.Unchecked = 2] = "Unchecked", i59[i59.Indeterminate = 3] = "Indeterminate", i59;
  }(Mr || {});
  var Pce = { provide: kc, useExisting: Gr(() => VG), multi: true };
  var UD = class {
    source;
    checked;
  };
  var FG = BG();
  var VG = (() => {
    class i59 {
      _elementRef = M(He);
      _changeDetectorRef = M(Ge);
      _ngZone = M(We);
      _animationMode = M(An, { optional: true });
      _options = M(Dce, { optional: true });
      focus() {
        this._inputElement.nativeElement.focus();
      }
      _createChangeEvent(e) {
        let n = new UD();
        return n.source = this, n.checked = e, n;
      }
      _getAnimationTargetElement() {
        return this._inputElement?.nativeElement;
      }
      _animationClasses = { uncheckedToChecked: "mdc-checkbox--anim-unchecked-checked", uncheckedToIndeterminate: "mdc-checkbox--anim-unchecked-indeterminate", checkedToUnchecked: "mdc-checkbox--anim-checked-unchecked", checkedToIndeterminate: "mdc-checkbox--anim-checked-indeterminate", indeterminateToChecked: "mdc-checkbox--anim-indeterminate-checked", indeterminateToUnchecked: "mdc-checkbox--anim-indeterminate-unchecked" };
      ariaLabel = "";
      ariaLabelledby = null;
      ariaDescribedby;
      ariaExpanded;
      ariaControls;
      ariaOwns;
      _uniqueId;
      id;
      get inputId() {
        return `${this.id || this._uniqueId}-input`;
      }
      required;
      labelPosition = "after";
      name = null;
      change = new Ue();
      indeterminateChange = new Ue();
      value;
      disableRipple;
      _inputElement;
      _labelElement;
      tabIndex;
      color;
      disabledInteractive;
      _onTouched = () => {
      };
      _currentAnimationClass = "";
      _currentCheckState = Mr.Init;
      _controlValueAccessorChangeFn = () => {
      };
      _validatorChangeFn = () => {
      };
      constructor() {
        M(mi).load(ts);
        let e = M(new Tr("tabindex"), { optional: true });
        this._options = this._options || FG, this.color = this._options.color || FG.color, this.tabIndex = e == null ? 0 : parseInt(e) || 0, this.id = this._uniqueId = M(kn).getId("mat-mdc-checkbox-"), this.disabledInteractive = this._options?.disabledInteractive ?? false;
      }
      ngOnChanges(e) {
        e.required && this._validatorChangeFn();
      }
      ngAfterViewInit() {
        this._syncIndeterminate(this._indeterminate);
      }
      get checked() {
        return this._checked;
      }
      set checked(e) {
        e != this.checked && (this._checked = e, this._changeDetectorRef.markForCheck());
      }
      _checked = false;
      get disabled() {
        return this._disabled;
      }
      set disabled(e) {
        e !== this.disabled && (this._disabled = e, this._changeDetectorRef.markForCheck());
      }
      _disabled = false;
      get indeterminate() {
        return this._indeterminate;
      }
      set indeterminate(e) {
        let n = e != this._indeterminate;
        this._indeterminate = e, n && (this._indeterminate ? this._transitionCheckState(Mr.Indeterminate) : this._transitionCheckState(this.checked ? Mr.Checked : Mr.Unchecked), this.indeterminateChange.emit(this._indeterminate)), this._syncIndeterminate(this._indeterminate);
      }
      _indeterminate = false;
      _isRippleDisabled() {
        return this.disableRipple || this.disabled;
      }
      _onLabelTextChange() {
        this._changeDetectorRef.detectChanges();
      }
      writeValue(e) {
        this.checked = !!e;
      }
      registerOnChange(e) {
        this._controlValueAccessorChangeFn = e;
      }
      registerOnTouched(e) {
        this._onTouched = e;
      }
      setDisabledState(e) {
        this.disabled = e;
      }
      validate(e) {
        return this.required && e.value !== true ? { required: true } : null;
      }
      registerOnValidatorChange(e) {
        this._validatorChangeFn = e;
      }
      _transitionCheckState(e) {
        let n = this._currentCheckState, r = this._getAnimationTargetElement();
        if (!(n === e || !r) && (this._currentAnimationClass && r.classList.remove(this._currentAnimationClass), this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(n, e), this._currentCheckState = e, this._currentAnimationClass.length > 0)) {
          r.classList.add(this._currentAnimationClass);
          let o = this._currentAnimationClass;
          this._ngZone.runOutsideAngular(() => {
            setTimeout(() => {
              r.classList.remove(o);
            }, 1e3);
          });
        }
      }
      _emitChangeEvent() {
        this._controlValueAccessorChangeFn(this.checked), this.change.emit(this._createChangeEvent(this.checked)), this._inputElement && (this._inputElement.nativeElement.checked = this.checked);
      }
      toggle() {
        this.checked = !this.checked, this._controlValueAccessorChangeFn(this.checked);
      }
      _handleInputClick() {
        let e = this._options?.clickAction;
        !this.disabled && e !== "noop" ? (this.indeterminate && e !== "check" && Promise.resolve().then(() => {
          this._indeterminate = false, this.indeterminateChange.emit(this._indeterminate);
        }), this._checked = !this._checked, this._transitionCheckState(this._checked ? Mr.Checked : Mr.Unchecked), this._emitChangeEvent()) : (this.disabled && this.disabledInteractive || !this.disabled && e === "noop") && (this._inputElement.nativeElement.checked = this.checked, this._inputElement.nativeElement.indeterminate = this.indeterminate);
      }
      _onInteractionEvent(e) {
        e.stopPropagation();
      }
      _onBlur() {
        Promise.resolve().then(() => {
          this._onTouched(), this._changeDetectorRef.markForCheck();
        });
      }
      _getAnimationClassForCheckStateTransition(e, n) {
        if (this._animationMode === "NoopAnimations") return "";
        switch (e) {
          case Mr.Init:
            if (n === Mr.Checked) return this._animationClasses.uncheckedToChecked;
            if (n == Mr.Indeterminate) return this._checked ? this._animationClasses.checkedToIndeterminate : this._animationClasses.uncheckedToIndeterminate;
            break;
          case Mr.Unchecked:
            return n === Mr.Checked ? this._animationClasses.uncheckedToChecked : this._animationClasses.uncheckedToIndeterminate;
          case Mr.Checked:
            return n === Mr.Unchecked ? this._animationClasses.checkedToUnchecked : this._animationClasses.checkedToIndeterminate;
          case Mr.Indeterminate:
            return n === Mr.Checked ? this._animationClasses.indeterminateToChecked : this._animationClasses.indeterminateToUnchecked;
        }
        return "";
      }
      _syncIndeterminate(e) {
        let n = this._inputElement;
        n && (n.nativeElement.indeterminate = e);
      }
      _onInputClick() {
        this._handleInputClick();
      }
      _onTouchTargetClick() {
        this._handleInputClick(), this.disabled || this._inputElement.nativeElement.focus();
      }
      _preventBubblingFromLabel(e) {
        e.target && this._labelElement.nativeElement.contains(e.target) && e.stopPropagation();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-checkbox"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Ece, 5), Fe(Tce, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r._inputElement = o.first), Ie(o = De()) && (r._labelElement = o.first);
        }
      }, hostAttrs: [1, "mat-mdc-checkbox"], hostVars: 16, hostBindings: function(n, r) {
        n & 2 && (gr("id", r.id), Ke("tabindex", null)("aria-label", null)("aria-labelledby", null), io(r.color ? "mat-" + r.color : "mat-accent"), ye("_mat-animation-noopable", r._animationMode === "NoopAnimations")("mdc-checkbox--disabled", r.disabled)("mat-mdc-checkbox-disabled", r.disabled)("mat-mdc-checkbox-checked", r.checked)("mat-mdc-checkbox-disabled-interactive", r.disabledInteractive));
      }, inputs: { ariaLabel: [0, "aria-label", "ariaLabel"], ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"], ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"], ariaExpanded: [2, "aria-expanded", "ariaExpanded", tt], ariaControls: [0, "aria-controls", "ariaControls"], ariaOwns: [0, "aria-owns", "ariaOwns"], id: "id", required: [2, "required", "required", tt], labelPosition: "labelPosition", name: "name", value: "value", disableRipple: [2, "disableRipple", "disableRipple", tt], tabIndex: [2, "tabIndex", "tabIndex", (e) => e == null ? void 0 : Gn(e)], color: "color", disabledInteractive: [2, "disabledInteractive", "disabledInteractive", tt], checked: [2, "checked", "checked", tt], disabled: [2, "disabled", "disabled", tt], indeterminate: [2, "indeterminate", "indeterminate", tt] }, outputs: { change: "change", indeterminateChange: "indeterminateChange" }, exportAs: ["matCheckbox"], features: [Bt([Pce, { provide: Lc, useExisting: i59, multi: true }]), on, yn], ngContentSelectors: Ice, decls: 15, vars: 23, consts: [["checkbox", ""], ["input", ""], ["label", ""], ["mat-internal-form-field", "", 3, "click", "labelPosition"], [1, "mdc-checkbox"], [1, "mat-mdc-checkbox-touch-target", 3, "click"], ["type", "checkbox", 1, "mdc-checkbox__native-control", 3, "blur", "click", "change", "checked", "indeterminate", "disabled", "id", "required", "tabIndex"], [1, "mdc-checkbox__ripple"], [1, "mdc-checkbox__background"], ["focusable", "false", "viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-checkbox__checkmark"], ["fill", "none", "d", "M1.73,12.91 8.1,19.28 22.79,4.59", 1, "mdc-checkbox__checkmark-path"], [1, "mdc-checkbox__mixedmark"], ["mat-ripple", "", 1, "mat-mdc-checkbox-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mdc-label", 3, "for"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          Tn(), b(0, "div", 3), Z("click", function(a) {
            return q(o), Y(r._preventBubblingFromLabel(a));
          }), b(1, "div", 4, 0)(3, "div", 5), Z("click", function() {
            return q(o), Y(r._onTouchTargetClick());
          }), x(), b(4, "input", 6, 1), Z("blur", function() {
            return q(o), Y(r._onBlur());
          })("click", function() {
            return q(o), Y(r._onInputClick());
          })("change", function(a) {
            return q(o), Y(r._onInteractionEvent(a));
          }), x(), ae(6, "div", 7), b(7, "div", 8), to(), b(8, "svg", 9), ae(9, "path", 10), x(), Av(), ae(10, "div", 11), x(), ae(11, "div", 12), x(), b(12, "label", 13, 2), zt(14), x()();
        }
        if (n & 2) {
          let o = Ce(2);
          U("labelPosition", r.labelPosition), C(4), ye("mdc-checkbox--selected", r.checked), U("checked", r.checked)("indeterminate", r.indeterminate)("disabled", r.disabled && !r.disabledInteractive)("id", r.inputId)("required", r.required)("tabIndex", r.disabled && !r.disabledInteractive ? -1 : r.tabIndex), Ke("aria-label", r.ariaLabel || null)("aria-labelledby", r.ariaLabelledby)("aria-describedby", r.ariaDescribedby)("aria-checked", r.indeterminate ? "mixed" : null)("aria-controls", r.ariaControls)("aria-disabled", r.disabled && r.disabledInteractive ? true : null)("aria-expanded", r.ariaExpanded)("aria-owns", r.ariaOwns)("name", r.name)("value", r.value), C(7), U("matRippleTrigger", o)("matRippleDisabled", r.disableRipple || r.disabled)("matRippleCentered", true), C(), U("for", r.inputId);
        }
      }, dependencies: [ba, qu], styles: ['.mdc-checkbox{display:inline-block;position:relative;flex:0 0 18px;box-sizing:content-box;width:18px;height:18px;line-height:0;white-space:nowrap;cursor:pointer;vertical-align:bottom;padding:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);margin:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox:hover>.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:hover>.mat-mdc-checkbox-ripple>.mat-ripple-element{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control:focus~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-unselected-pressed-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity));background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:hover .mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-focus-state-layer-opacity, var(--mat-sys-focus-state-layer-opacity));background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox .mdc-checkbox__native-control:focus:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked+.mdc-checkbox__ripple{opacity:var(--mdc-checkbox-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox:active>.mdc-checkbox__native-control:checked~.mat-mdc-checkbox-ripple .mat-ripple-element{background-color:var(--mdc-checkbox-selected-pressed-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control~.mat-mdc-checkbox-ripple .mat-ripple-element,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control+.mdc-checkbox__ripple{background-color:var(--mdc-checkbox-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-checkbox .mdc-checkbox__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;width:var(--mdc-checkbox-state-layer-size, 40px);height:var(--mdc-checkbox-state-layer-size, 40px);top:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);right:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - var(--mdc-checkbox-state-layer-size, 40px))/2)}.mdc-checkbox--disabled{cursor:default;pointer-events:none}@media(forced-colors: active){.mdc-checkbox--disabled{opacity:.5}}.mdc-checkbox__background{display:inline-flex;position:absolute;align-items:center;justify-content:center;box-sizing:border-box;width:18px;height:18px;border:2px solid currentColor;border-radius:2px;background-color:rgba(0,0,0,0);pointer-events:none;will-change:background-color,border-color;transition:background-color 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-print-color-adjust:exact;color-adjust:exact;border-color:var(--mdc-checkbox-unselected-icon-color, var(--mat-sys-on-surface-variant));top:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2);left:calc((var(--mdc-checkbox-state-layer-size, 40px) - 18px)/2)}.mdc-checkbox__native-control:enabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:enabled:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox__native-control:disabled:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:disabled:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:checked)~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-hover-icon-color, var(--mat-sys-on-surface));background-color:rgba(0,0,0,0)}.mdc-checkbox:hover>.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox:hover>.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-hover-icon-color, var(--mat-sys-primary))}.mdc-checkbox__native-control:focus:focus:not(:checked)~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:not(:indeterminate)~.mdc-checkbox__background{border-color:var(--mdc-checkbox-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mdc-checkbox__native-control:focus:focus:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:focus:focus:indeterminate~.mdc-checkbox__background{border-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary));background-color:var(--mdc-checkbox-selected-focus-icon-color, var(--mat-sys-primary))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox:hover>.mdc-checkbox__native-control~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox .mdc-checkbox__native-control:focus~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__background{border-color:var(--mdc-checkbox-disabled-unselected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{background-color:var(--mdc-checkbox-disabled-selected-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent));border-color:rgba(0,0,0,0)}.mdc-checkbox__checkmark{position:absolute;top:0;right:0;bottom:0;left:0;width:100%;opacity:0;transition:opacity 180ms cubic-bezier(0.4, 0, 0.6, 1);color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}@media(forced-colors: active){.mdc-checkbox--disabled .mdc-checkbox__checkmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__checkmark{color:CanvasText}}.mdc-checkbox__checkmark-path{transition:stroke-dashoffset 180ms cubic-bezier(0.4, 0, 0.6, 1);stroke:currentColor;stroke-width:3.12px;stroke-dashoffset:29.7833385;stroke-dasharray:29.7833385}.mdc-checkbox__mixedmark{width:100%;height:0;transform:scaleX(0) rotate(0deg);border-width:1px;border-style:solid;opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);border-color:var(--mdc-checkbox-selected-checkmark-color, var(--mat-sys-on-primary))}@media(forced-colors: active){.mdc-checkbox__mixedmark{margin:0 1px}}.mdc-checkbox--disabled .mdc-checkbox__mixedmark,.mdc-checkbox--disabled.mat-mdc-checkbox-disabled-interactive .mdc-checkbox__mixedmark{border-color:var(--mdc-checkbox-disabled-selected-checkmark-color, var(--mat-sys-surface))}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__background,.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__background,.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__background,.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__background{animation-duration:180ms;animation-timing-function:linear}.mdc-checkbox--anim-unchecked-checked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-unchecked-checked-checkmark-path 180ms linear;transition:none}.mdc-checkbox--anim-unchecked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-unchecked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-unchecked .mdc-checkbox__checkmark-path{animation:mdc-checkbox-checked-unchecked-checkmark-path 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__checkmark{animation:mdc-checkbox-checked-indeterminate-checkmark 90ms linear;transition:none}.mdc-checkbox--anim-checked-indeterminate .mdc-checkbox__mixedmark{animation:mdc-checkbox-checked-indeterminate-mixedmark 90ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__checkmark{animation:mdc-checkbox-indeterminate-checked-checkmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-checked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-checked-mixedmark 500ms linear;transition:none}.mdc-checkbox--anim-indeterminate-unchecked .mdc-checkbox__mixedmark{animation:mdc-checkbox-indeterminate-unchecked-mixedmark 300ms linear;transition:none}.mdc-checkbox__native-control:checked~.mdc-checkbox__background,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1),background-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path{stroke-dashoffset:0}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__checkmark{transition:opacity 180ms cubic-bezier(0, 0, 0.2, 1),transform 180ms cubic-bezier(0, 0, 0.2, 1);opacity:1}.mdc-checkbox__native-control:checked~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(-45deg)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__checkmark{transform:rotate(45deg);opacity:0;transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-checkbox__native-control:indeterminate~.mdc-checkbox__background>.mdc-checkbox__mixedmark{transform:scaleX(1) rotate(0deg);opacity:1}@keyframes mdc-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:29.7833385}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 1)}100%{stroke-dashoffset:0}}@keyframes mdc-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mdc-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);opacity:1;stroke-dashoffset:0}to{opacity:0;stroke-dashoffset:-29.7833385}}@keyframes mdc-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(45deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(45deg);opacity:0}to{transform:rotate(360deg);opacity:1}}@keyframes mdc-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 1);transform:rotate(-45deg);opacity:0}to{transform:rotate(0deg);opacity:1}}@keyframes mdc-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);transform:rotate(0deg);opacity:1}to{transform:rotate(315deg);opacity:0}}@keyframes mdc-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;transform:scaleX(1);opacity:1}32.8%,100%{transform:scaleX(0);opacity:0}}.mat-mdc-checkbox{display:inline-block;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-touch-target,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__native-control,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__ripple,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mat-mdc-checkbox-ripple::before,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__checkmark>.mdc-checkbox__checkmark-path,.mat-mdc-checkbox._mat-animation-noopable>.mat-internal-form-field>.mdc-checkbox>.mdc-checkbox__background>.mdc-checkbox__mixedmark{transition:none !important;animation:none !important}.mat-mdc-checkbox label{cursor:pointer}.mat-mdc-checkbox .mat-internal-form-field{color:var(--mat-checkbox-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-checkbox-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-checkbox-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-checkbox-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-checkbox-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-checkbox-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive{pointer-events:auto}.mat-mdc-checkbox.mat-mdc-checkbox-disabled.mat-mdc-checkbox-disabled-interactive input{cursor:default}.mat-mdc-checkbox.mat-mdc-checkbox-disabled label{cursor:default;color:var(--mat-checkbox-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-checkbox label:empty{display:none}.mat-mdc-checkbox .mdc-checkbox__ripple{opacity:0}.mat-mdc-checkbox .mat-mdc-checkbox-ripple,.mdc-checkbox__ripple{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-checkbox .mat-mdc-checkbox-ripple:not(:empty),.mdc-checkbox__ripple:not(:empty){transform:translateZ(0)}.mat-mdc-checkbox-ripple .mat-ripple-element{opacity:.1}.mat-mdc-checkbox-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-checkbox-touch-target-display, block)}.mat-mdc-checkbox .mat-mdc-checkbox-ripple::before{border-radius:50%}.mdc-checkbox__native-control:focus~.mat-focus-indicator::before{content:""}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var zG = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [VG, Yt, Yt] });
    }
    return i59;
  })();
  var GD = class {
    _box;
    _destroyed = new we();
    _resizeSubject = new we();
    _resizeObserver;
    _elementObservables = /* @__PURE__ */ new Map();
    constructor(t) {
      this._box = t, typeof ResizeObserver < "u" && (this._resizeObserver = new ResizeObserver((e) => this._resizeSubject.next(e)));
    }
    observe(t) {
      return this._elementObservables.has(t) || this._elementObservables.set(t, new Et((e) => {
        let n = this._resizeSubject.subscribe(e);
        return this._resizeObserver?.observe(t, { box: this._box }), () => {
          this._resizeObserver?.unobserve(t), n.unsubscribe(), this._elementObservables.delete(t);
        };
      }).pipe(En((e) => e.some((n) => n.target === t)), L_({ bufferSize: 1, refCount: true }), Je(this._destroyed))), this._elementObservables.get(t);
    }
    destroy() {
      this._destroyed.next(), this._destroyed.complete(), this._resizeSubject.complete(), this._elementObservables.clear();
    }
  };
  var UG = (() => {
    class i59 {
      _cleanupErrorListener;
      _observers = /* @__PURE__ */ new Map();
      _ngZone = M(We);
      constructor() {
        typeof ResizeObserver < "u";
      }
      ngOnDestroy() {
        for (let [, e] of this._observers) e.destroy();
        this._observers.clear(), this._cleanupErrorListener?.();
      }
      observe(e, n) {
        let r = n?.box || "content-box";
        return this._observers.has(r) || this._observers.set(r, new GD(r)), this._observers.get(r).observe(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Rce = ["notch"];
  var Oce = ["matFormFieldNotchedOutline", ""];
  var Ace = ["*"];
  var Nce = ["textField"];
  var kce = ["iconPrefixContainer"];
  var Lce = ["textPrefixContainer"];
  var Fce = ["iconSuffixContainer"];
  var Bce = ["textSuffixContainer"];
  var Vce = ["*", [["mat-label"]], [["", "matPrefix", ""], ["", "matIconPrefix", ""]], [["", "matTextPrefix", ""]], [["", "matTextSuffix", ""]], [["", "matSuffix", ""], ["", "matIconSuffix", ""]], [["mat-error"], ["", "matError", ""]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]];
  var zce = ["*", "mat-label", "[matPrefix], [matIconPrefix]", "[matTextPrefix]", "[matTextSuffix]", "[matSuffix], [matIconSuffix]", "mat-error, [matError]", "mat-hint:not([align='end'])", "mat-hint[align='end']"];
  function Uce(i59, t) {
    i59 & 1 && ae(0, "span", 21);
  }
  function Gce(i59, t) {
    if (i59 & 1 && (b(0, "label", 20), zt(1, 1), X(2, Uce, 1, 0, "span", 21), x()), i59 & 2) {
      let e = T(2);
      U("floating", e._shouldLabelFloat())("monitorResize", e._hasOutline())("id", e._labelId), Ke("for", e._control.disableAutomaticLabeling ? null : e._control.id), C(2), he(!e.hideRequiredMarker && e._control.required ? 2 : -1);
    }
  }
  function Hce(i59, t) {
    if (i59 & 1 && X(0, Gce, 3, 5, "label", 20), i59 & 2) {
      let e = T();
      he(e._hasFloatingLabel() ? 0 : -1);
    }
  }
  function jce(i59, t) {
    i59 & 1 && ae(0, "div", 7);
  }
  function Wce(i59, t) {
  }
  function $ce(i59, t) {
    if (i59 & 1 && X(0, Wce, 0, 0, "ng-template", 13), i59 & 2) {
      T(2);
      let e = Ce(1);
      U("ngTemplateOutlet", e);
    }
  }
  function qce(i59, t) {
    if (i59 & 1 && (b(0, "div", 9), X(1, $ce, 1, 1, null, 13), x()), i59 & 2) {
      let e = T();
      U("matFormFieldNotchedOutlineOpen", e._shouldLabelFloat()), C(), he(e._forceDisplayInfixLabel() ? -1 : 1);
    }
  }
  function Yce(i59, t) {
    i59 & 1 && (b(0, "div", 10, 2), zt(2, 2), x());
  }
  function Xce(i59, t) {
    i59 & 1 && (b(0, "div", 11, 3), zt(2, 3), x());
  }
  function Zce(i59, t) {
  }
  function Qce(i59, t) {
    if (i59 & 1 && X(0, Zce, 0, 0, "ng-template", 13), i59 & 2) {
      T();
      let e = Ce(1);
      U("ngTemplateOutlet", e);
    }
  }
  function Kce(i59, t) {
    i59 & 1 && (b(0, "div", 14, 4), zt(2, 4), x());
  }
  function Jce(i59, t) {
    i59 & 1 && (b(0, "div", 15, 5), zt(2, 5), x());
  }
  function ede(i59, t) {
    i59 & 1 && ae(0, "div", 16);
  }
  function tde(i59, t) {
    if (i59 & 1 && (b(0, "div", 18), zt(1, 6), x()), i59 & 2) {
      let e = T();
      U("@transitionMessages", e._subscriptAnimationState);
    }
  }
  function nde(i59, t) {
    if (i59 & 1 && (b(0, "mat-hint", 22), D(1), x()), i59 & 2) {
      let e = T(2);
      U("id", e._hintLabelId), C(), Qe(e.hintLabel);
    }
  }
  function ide(i59, t) {
    if (i59 & 1 && (b(0, "div", 19), X(1, nde, 2, 2, "mat-hint", 22), zt(2, 7), ae(3, "div", 23), zt(4, 8), x()), i59 & 2) {
      let e = T();
      U("@transitionMessages", e._subscriptAnimationState), C(), he(e.hintLabel ? 1 : -1);
    }
  }
  var Ew = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["mat-label"]] });
    }
    return i59;
  })();
  var rde = new Ee("MatError");
  var GG = (() => {
    class i59 {
      align = "start";
      id = M(kn).getId("mat-mdc-hint-");
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["mat-hint"]], hostAttrs: [1, "mat-mdc-form-field-hint", "mat-mdc-form-field-bottom-align"], hostVars: 4, hostBindings: function(n, r) {
        n & 2 && (gr("id", r.id), Ke("align", null), ye("mat-mdc-form-field-hint-end", r.align === "end"));
      }, inputs: { align: "align", id: "id" } });
    }
    return i59;
  })();
  var ode = new Ee("MatPrefix");
  var sde = new Ee("MatSuffix");
  var XG = new Ee("FloatingLabelParent");
  var HG = (() => {
    class i59 {
      _elementRef = M(He);
      get floating() {
        return this._floating;
      }
      set floating(e) {
        this._floating = e, this.monitorResize && this._handleResize();
      }
      _floating = false;
      get monitorResize() {
        return this._monitorResize;
      }
      set monitorResize(e) {
        this._monitorResize = e, this._monitorResize ? this._subscribeToResize() : this._resizeSubscription.unsubscribe();
      }
      _monitorResize = false;
      _resizeObserver = M(UG);
      _ngZone = M(We);
      _parent = M(XG);
      _resizeSubscription = new Rt();
      constructor() {
      }
      ngOnDestroy() {
        this._resizeSubscription.unsubscribe();
      }
      getWidth() {
        return ade(this._elementRef.nativeElement);
      }
      get element() {
        return this._elementRef.nativeElement;
      }
      _handleResize() {
        setTimeout(() => this._parent._handleLabelResized());
      }
      _subscribeToResize() {
        this._resizeSubscription.unsubscribe(), this._ngZone.runOutsideAngular(() => {
          this._resizeSubscription = this._resizeObserver.observe(this._elementRef.nativeElement, { box: "border-box" }).subscribe(() => this._handleResize());
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["label", "matFormFieldFloatingLabel", ""]], hostAttrs: [1, "mdc-floating-label", "mat-mdc-floating-label"], hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("mdc-floating-label--float-above", r.floating);
      }, inputs: { floating: "floating", monitorResize: "monitorResize" } });
    }
    return i59;
  })();
  function ade(i59) {
    let t = i59;
    if (t.offsetParent !== null) return t.scrollWidth;
    let e = t.cloneNode(true);
    e.style.setProperty("position", "absolute"), e.style.setProperty("transform", "translate(-9999px, -9999px)"), document.documentElement.appendChild(e);
    let n = e.scrollWidth;
    return e.remove(), n;
  }
  var jG = "mdc-line-ripple--active";
  var Mw = "mdc-line-ripple--deactivating";
  var WG = (() => {
    class i59 {
      _elementRef = M(He);
      _cleanupTransitionEnd;
      constructor() {
        let e = M(We), n = M(Pr);
        e.runOutsideAngular(() => {
          this._cleanupTransitionEnd = n.listen(this._elementRef.nativeElement, "transitionend", this._handleTransitionEnd);
        });
      }
      activate() {
        let e = this._elementRef.nativeElement.classList;
        e.remove(Mw), e.add(jG);
      }
      deactivate() {
        this._elementRef.nativeElement.classList.add(Mw);
      }
      _handleTransitionEnd = (e) => {
        let n = this._elementRef.nativeElement.classList, r = n.contains(Mw);
        e.propertyName === "opacity" && r && n.remove(jG, Mw);
      };
      ngOnDestroy() {
        this._cleanupTransitionEnd();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["div", "matFormFieldLineRipple", ""]], hostAttrs: [1, "mdc-line-ripple"] });
    }
    return i59;
  })();
  var $G = (() => {
    class i59 {
      _elementRef = M(He);
      _ngZone = M(We);
      open = false;
      _notch;
      constructor() {
      }
      ngAfterViewInit() {
        let e = this._elementRef.nativeElement.querySelector(".mdc-floating-label");
        e ? (this._elementRef.nativeElement.classList.add("mdc-notched-outline--upgraded"), typeof requestAnimationFrame == "function" && (e.style.transitionDuration = "0s", this._ngZone.runOutsideAngular(() => {
          requestAnimationFrame(() => e.style.transitionDuration = "");
        }))) : this._elementRef.nativeElement.classList.add("mdc-notched-outline--no-label");
      }
      _setNotchWidth(e) {
        !this.open || !e ? this._notch.nativeElement.style.width = "" : this._notch.nativeElement.style.width = `calc(${e}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)`;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["div", "matFormFieldNotchedOutline", ""]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Rce, 5), n & 2) {
          let o;
          Ie(o = De()) && (r._notch = o.first);
        }
      }, hostAttrs: [1, "mdc-notched-outline"], hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("mdc-notched-outline--notched", r.open);
      }, inputs: { open: [0, "matFormFieldNotchedOutlineOpen", "open"] }, attrs: Oce, ngContentSelectors: Ace, decls: 5, vars: 0, consts: [["notch", ""], [1, "mat-mdc-notch-piece", "mdc-notched-outline__leading"], [1, "mat-mdc-notch-piece", "mdc-notched-outline__notch"], [1, "mat-mdc-notch-piece", "mdc-notched-outline__trailing"]], template: function(n, r) {
        n & 1 && (Tn(), ae(0, "div", 1), b(1, "div", 2, 0), zt(3), x(), ae(4, "div", 3));
      }, encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var lde = { transitionMessages: ki("transitionMessages", [Zi("enter", _n({ opacity: 1, transform: "translateY(0%)" })), Yn("void => enter", [_n({ opacity: 0, transform: "translateY(-5px)" }), oi("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) };
  var HD = (() => {
    class i59 {
      value;
      stateChanges;
      id;
      placeholder;
      ngControl;
      focused;
      empty;
      shouldLabelFloat;
      required;
      disabled;
      errorState;
      controlType;
      autofilled;
      userAriaDescribedBy;
      disableAutomaticLabeling;
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59 });
    }
    return i59;
  })();
  var jD = new Ee("MatFormField");
  var cde = new Ee("MAT_FORM_FIELD_DEFAULT_OPTIONS");
  var qG = "fill";
  var dde = "auto";
  var YG = "fixed";
  var ude = "translateY(-50%)";
  var ZG = (() => {
    class i59 {
      _elementRef = M(He);
      _changeDetectorRef = M(Ge);
      _dir = M(_i);
      _platform = M(Nn);
      _idGenerator = M(kn);
      _defaults = M(cde, { optional: true });
      _animationMode = M(An, { optional: true });
      _textField;
      _iconPrefixContainer;
      _textPrefixContainer;
      _iconSuffixContainer;
      _textSuffixContainer;
      _floatingLabel;
      _notchedOutline;
      _lineRipple;
      _formFieldControl;
      _prefixChildren;
      _suffixChildren;
      _errorChildren;
      _hintChildren;
      _labelChild = vN(Ew);
      get hideRequiredMarker() {
        return this._hideRequiredMarker;
      }
      set hideRequiredMarker(e) {
        this._hideRequiredMarker = zf(e);
      }
      _hideRequiredMarker = false;
      color = "primary";
      get floatLabel() {
        return this._floatLabel || this._defaults?.floatLabel || dde;
      }
      set floatLabel(e) {
        e !== this._floatLabel && (this._floatLabel = e, this._changeDetectorRef.markForCheck());
      }
      _floatLabel;
      get appearance() {
        return this._appearance;
      }
      set appearance(e) {
        let n = this._appearance, r = e || this._defaults?.appearance || qG;
        this._appearance = r, this._appearance === "outline" && this._appearance !== n && (this._needsOutlineLabelOffsetUpdate = true);
      }
      _appearance = qG;
      get subscriptSizing() {
        return this._subscriptSizing || this._defaults?.subscriptSizing || YG;
      }
      set subscriptSizing(e) {
        this._subscriptSizing = e || this._defaults?.subscriptSizing || YG;
      }
      _subscriptSizing = null;
      get hintLabel() {
        return this._hintLabel;
      }
      set hintLabel(e) {
        this._hintLabel = e, this._processHints();
      }
      _hintLabel = "";
      _hasIconPrefix = false;
      _hasTextPrefix = false;
      _hasIconSuffix = false;
      _hasTextSuffix = false;
      _labelId = this._idGenerator.getId("mat-mdc-form-field-label-");
      _hintLabelId = this._idGenerator.getId("mat-mdc-hint-");
      _subscriptAnimationState = "";
      get _control() {
        return this._explicitFormFieldControl || this._formFieldControl;
      }
      set _control(e) {
        this._explicitFormFieldControl = e;
      }
      _destroyed = new we();
      _isFocused = null;
      _explicitFormFieldControl;
      _needsOutlineLabelOffsetUpdate = false;
      _previousControl = null;
      _stateChanges;
      _valueChanges;
      _describedByChanges;
      _injector = M(mt);
      constructor() {
        let e = this._defaults;
        e && (e.appearance && (this.appearance = e.appearance), this._hideRequiredMarker = !!e?.hideRequiredMarker, e.color && (this.color = e.color));
      }
      ngAfterViewInit() {
        this._updateFocusState(), this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges();
      }
      ngAfterContentInit() {
        this._assertFormFieldControl(), this._initializeSubscript(), this._initializePrefixAndSuffix(), this._initializeOutlineLabelOffsetSubscriptions();
      }
      ngAfterContentChecked() {
        this._assertFormFieldControl(), this._control !== this._previousControl && (this._initializeControl(this._previousControl), this._previousControl = this._control);
      }
      ngOnDestroy() {
        this._stateChanges?.unsubscribe(), this._valueChanges?.unsubscribe(), this._describedByChanges?.unsubscribe(), this._destroyed.next(), this._destroyed.complete();
      }
      getLabelId = It(() => this._hasFloatingLabel() ? this._labelId : null);
      getConnectedOverlayOrigin() {
        return this._textField || this._elementRef;
      }
      _animateAndLockLabel() {
        this._hasFloatingLabel() && (this.floatLabel = "always");
      }
      _initializeControl(e) {
        let n = this._control, r = "mat-mdc-form-field-type-";
        e && this._elementRef.nativeElement.classList.remove(r + e.controlType), n.controlType && this._elementRef.nativeElement.classList.add(r + n.controlType), this._stateChanges?.unsubscribe(), this._stateChanges = n.stateChanges.subscribe(() => {
          this._updateFocusState(), this._changeDetectorRef.markForCheck();
        }), this._describedByChanges?.unsubscribe(), this._describedByChanges = n.stateChanges.pipe(ei([void 0, void 0]), kt(() => [n.errorState, n.userAriaDescribedBy]), k_(), En(([[o, s], [a, l]]) => o !== a || s !== l)).subscribe(() => this._syncDescribedByIds()), this._valueChanges?.unsubscribe(), n.ngControl && n.ngControl.valueChanges && (this._valueChanges = n.ngControl.valueChanges.pipe(Je(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()));
      }
      _checkPrefixAndSuffixTypes() {
        this._hasIconPrefix = !!this._prefixChildren.find((e) => !e._isText), this._hasTextPrefix = !!this._prefixChildren.find((e) => e._isText), this._hasIconSuffix = !!this._suffixChildren.find((e) => !e._isText), this._hasTextSuffix = !!this._suffixChildren.find((e) => e._isText);
      }
      _initializePrefixAndSuffix() {
        this._checkPrefixAndSuffixTypes(), Jn(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {
          this._checkPrefixAndSuffixTypes(), this._changeDetectorRef.markForCheck();
        });
      }
      _initializeSubscript() {
        this._hintChildren.changes.subscribe(() => {
          this._processHints(), this._changeDetectorRef.markForCheck();
        }), this._errorChildren.changes.subscribe(() => {
          this._syncDescribedByIds(), this._changeDetectorRef.markForCheck();
        }), this._validateHints(), this._syncDescribedByIds();
      }
      _assertFormFieldControl() {
        this._control;
      }
      _updateFocusState() {
        this._control.focused && !this._isFocused ? (this._isFocused = true, this._lineRipple?.activate()) : !this._control.focused && (this._isFocused || this._isFocused === null) && (this._isFocused = false, this._lineRipple?.deactivate()), this._textField?.nativeElement.classList.toggle("mdc-text-field--focused", this._control.focused);
      }
      _initializeOutlineLabelOffsetSubscriptions() {
        this._prefixChildren.changes.subscribe(() => this._needsOutlineLabelOffsetUpdate = true), tf(() => {
          this._needsOutlineLabelOffsetUpdate && (this._needsOutlineLabelOffsetUpdate = false, this._updateOutlineLabelOffset());
        }, { injector: this._injector }), this._dir.change.pipe(Je(this._destroyed)).subscribe(() => this._needsOutlineLabelOffsetUpdate = true);
      }
      _shouldAlwaysFloat() {
        return this.floatLabel === "always";
      }
      _hasOutline() {
        return this.appearance === "outline";
      }
      _forceDisplayInfixLabel() {
        return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat();
      }
      _hasFloatingLabel = It(() => !!this._labelChild());
      _shouldLabelFloat() {
        return this._hasFloatingLabel() ? this._control.shouldLabelFloat || this._shouldAlwaysFloat() : false;
      }
      _shouldForward(e) {
        let n = this._control ? this._control.ngControl : null;
        return n && n[e];
      }
      _getDisplayedMessages() {
        return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint";
      }
      _handleLabelResized() {
        this._refreshOutlineNotchWidth();
      }
      _refreshOutlineNotchWidth() {
        !this._hasOutline() || !this._floatingLabel || !this._shouldLabelFloat() ? this._notchedOutline?._setNotchWidth(0) : this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth());
      }
      _processHints() {
        this._validateHints(), this._syncDescribedByIds();
      }
      _validateHints() {
        this._hintChildren;
      }
      _syncDescribedByIds() {
        if (this._control) {
          let e = [];
          if (this._control.userAriaDescribedBy && typeof this._control.userAriaDescribedBy == "string" && e.push(...this._control.userAriaDescribedBy.split(" ")), this._getDisplayedMessages() === "hint") {
            let n = this._hintChildren ? this._hintChildren.find((o) => o.align === "start") : null, r = this._hintChildren ? this._hintChildren.find((o) => o.align === "end") : null;
            n ? e.push(n.id) : this._hintLabel && e.push(this._hintLabelId), r && e.push(r.id);
          } else this._errorChildren && e.push(...this._errorChildren.map((n) => n.id));
          this._control.setDescribedByIds(e);
        }
      }
      _updateOutlineLabelOffset() {
        if (!this._hasOutline() || !this._floatingLabel) return;
        let e = this._floatingLabel.element;
        if (!(this._iconPrefixContainer || this._textPrefixContainer)) {
          e.style.transform = "";
          return;
        }
        if (!this._isAttachedToDom()) {
          this._needsOutlineLabelOffsetUpdate = true;
          return;
        }
        let n = this._iconPrefixContainer?.nativeElement, r = this._textPrefixContainer?.nativeElement, o = this._iconSuffixContainer?.nativeElement, s = this._textSuffixContainer?.nativeElement, a = n?.getBoundingClientRect().width ?? 0, l = r?.getBoundingClientRect().width ?? 0, c = o?.getBoundingClientRect().width ?? 0, d = s?.getBoundingClientRect().width ?? 0, u = this._dir.value === "rtl" ? "-1" : "1", h = `${a + l}px`, f = `calc(${u} * (${h} + var(--mat-mdc-form-field-label-offset-x, 0px)))`;
        e.style.transform = `var(
        --mat-mdc-form-field-label-transform,
        ${ude} translateX(${f})
    )`;
        let m = a + l + c + d;
        this._elementRef.nativeElement.style.setProperty("--mat-form-field-notch-max-width", `calc(100% - ${m}px)`);
      }
      _isAttachedToDom() {
        let e = this._elementRef.nativeElement;
        if (e.getRootNode) {
          let n = e.getRootNode();
          return n && n !== e;
        }
        return document.documentElement.contains(e);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-form-field"]], contentQueries: function(n, r, o) {
        if (n & 1 && (UN(o, r._labelChild, Ew, 5), Xi(o, HD, 5), Xi(o, ode, 5), Xi(o, sde, 5), Xi(o, rde, 5), Xi(o, GG, 5)), n & 2) {
          wu();
          let s;
          Ie(s = De()) && (r._formFieldControl = s.first), Ie(s = De()) && (r._prefixChildren = s), Ie(s = De()) && (r._suffixChildren = s), Ie(s = De()) && (r._errorChildren = s), Ie(s = De()) && (r._hintChildren = s);
        }
      }, viewQuery: function(n, r) {
        if (n & 1 && (Fe(Nce, 5), Fe(kce, 5), Fe(Lce, 5), Fe(Fce, 5), Fe(Bce, 5), Fe(HG, 5), Fe($G, 5), Fe(WG, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r._textField = o.first), Ie(o = De()) && (r._iconPrefixContainer = o.first), Ie(o = De()) && (r._textPrefixContainer = o.first), Ie(o = De()) && (r._iconSuffixContainer = o.first), Ie(o = De()) && (r._textSuffixContainer = o.first), Ie(o = De()) && (r._floatingLabel = o.first), Ie(o = De()) && (r._notchedOutline = o.first), Ie(o = De()) && (r._lineRipple = o.first);
        }
      }, hostAttrs: [1, "mat-mdc-form-field"], hostVars: 42, hostBindings: function(n, r) {
        n & 2 && ye("mat-mdc-form-field-label-always-float", r._shouldAlwaysFloat())("mat-mdc-form-field-has-icon-prefix", r._hasIconPrefix)("mat-mdc-form-field-has-icon-suffix", r._hasIconSuffix)("mat-form-field-invalid", r._control.errorState)("mat-form-field-disabled", r._control.disabled)("mat-form-field-autofilled", r._control.autofilled)("mat-form-field-no-animations", r._animationMode === "NoopAnimations")("mat-form-field-appearance-fill", r.appearance == "fill")("mat-form-field-appearance-outline", r.appearance == "outline")("mat-form-field-hide-placeholder", r._hasFloatingLabel() && !r._shouldLabelFloat())("mat-focused", r._control.focused)("mat-primary", r.color !== "accent" && r.color !== "warn")("mat-accent", r.color === "accent")("mat-warn", r.color === "warn")("ng-untouched", r._shouldForward("untouched"))("ng-touched", r._shouldForward("touched"))("ng-pristine", r._shouldForward("pristine"))("ng-dirty", r._shouldForward("dirty"))("ng-valid", r._shouldForward("valid"))("ng-invalid", r._shouldForward("invalid"))("ng-pending", r._shouldForward("pending"));
      }, inputs: { hideRequiredMarker: "hideRequiredMarker", color: "color", floatLabel: "floatLabel", appearance: "appearance", subscriptSizing: "subscriptSizing", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [Bt([{ provide: jD, useExisting: i59 }, { provide: XG, useExisting: i59 }])], ngContentSelectors: zce, decls: 18, vars: 21, consts: [["labelTemplate", ""], ["textField", ""], ["iconPrefixContainer", ""], ["textPrefixContainer", ""], ["textSuffixContainer", ""], ["iconSuffixContainer", ""], [1, "mat-mdc-text-field-wrapper", "mdc-text-field", 3, "click"], [1, "mat-mdc-form-field-focus-overlay"], [1, "mat-mdc-form-field-flex"], ["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen"], [1, "mat-mdc-form-field-icon-prefix"], [1, "mat-mdc-form-field-text-prefix"], [1, "mat-mdc-form-field-infix"], [3, "ngTemplateOutlet"], [1, "mat-mdc-form-field-text-suffix"], [1, "mat-mdc-form-field-icon-suffix"], ["matFormFieldLineRipple", ""], [1, "mat-mdc-form-field-subscript-wrapper", "mat-mdc-form-field-bottom-align"], [1, "mat-mdc-form-field-error-wrapper"], [1, "mat-mdc-form-field-hint-wrapper"], ["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id"], ["aria-hidden", "true", 1, "mat-mdc-form-field-required-marker", "mdc-floating-label--required"], [3, "id"], [1, "mat-mdc-form-field-hint-spacer"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          Tn(Vce), X(0, Hce, 1, 1, "ng-template", null, 0, Tt), b(2, "div", 6, 1), Z("click", function(a) {
            return q(o), Y(r._control.onContainerClick(a));
          }), X(4, jce, 1, 0, "div", 7), b(5, "div", 8), X(6, qce, 2, 2, "div", 9)(7, Yce, 3, 0, "div", 10)(8, Xce, 3, 0, "div", 11), b(9, "div", 12), X(10, Qce, 1, 1, null, 13), zt(11), x(), X(12, Kce, 3, 0, "div", 14)(13, Jce, 3, 0, "div", 15), x(), X(14, ede, 1, 0, "div", 16), x(), b(15, "div", 17), X(16, tde, 2, 1, "div", 18)(17, ide, 5, 2, "div", 19), x();
        }
        if (n & 2) {
          let o;
          C(2), ye("mdc-text-field--filled", !r._hasOutline())("mdc-text-field--outlined", r._hasOutline())("mdc-text-field--no-label", !r._hasFloatingLabel())("mdc-text-field--disabled", r._control.disabled)("mdc-text-field--invalid", r._control.errorState), C(2), he(!r._hasOutline() && !r._control.disabled ? 4 : -1), C(2), he(r._hasOutline() ? 6 : -1), C(), he(r._hasIconPrefix ? 7 : -1), C(), he(r._hasTextPrefix ? 8 : -1), C(2), he(!r._hasOutline() || r._forceDisplayInfixLabel() ? 10 : -1), C(2), he(r._hasTextSuffix ? 12 : -1), C(), he(r._hasIconSuffix ? 13 : -1), C(), he(r._hasOutline() ? -1 : 14), C(), ye("mat-mdc-form-field-subscript-dynamic-size", r.subscriptSizing === "dynamic"), C(), he((o = r._getDisplayedMessages()) === "error" ? 16 : o === "hint" ? 17 : -1);
        }
      }, dependencies: [HG, $G, Ss, WG, GG], styles: ['.mdc-text-field{display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.mdc-text-field__input{width:100%;min-width:0;border:none;border-radius:0;background:none;padding:0;-moz-appearance:none;-webkit-appearance:none;height:28px}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}.mdc-text-field__input::placeholder{opacity:0}.mdc-text-field__input::-moz-placeholder{opacity:0}.mdc-text-field__input::-webkit-input-placeholder{opacity:0}.mdc-text-field__input:-ms-input-placeholder{opacity:0}.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input::-moz-placeholder,.mdc-text-field--focused .mdc-text-field__input::-moz-placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input::-webkit-input-placeholder,.mdc-text-field--focused .mdc-text-field__input::-webkit-input-placeholder{opacity:1}.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::-moz-placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive::-webkit-input-placeholder{opacity:0}.mdc-text-field--disabled:not(.mdc-text-field--no-label) .mdc-text-field__input.mat-mdc-input-disabled-interactive:-ms-input-placeholder{opacity:0}.mdc-text-field--outlined .mdc-text-field__input,.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-filled-text-field-input-text-color, var(--mat-sys-on-surface));caret-color:var(--mdc-filled-text-field-caret-color, var(--mat-sys-primary))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::-moz-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input::-webkit-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-filled-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-filled-text-field-error-caret-color)}.mdc-text-field--filled.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-filled-text-field-disabled-input-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input{color:var(--mdc-outlined-text-field-input-text-color, var(--mat-sys-on-surface));caret-color:var(--mdc-outlined-text-field-caret-color, var(--mat-sys-primary))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::-moz-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input::-webkit-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-text-field__input:-ms-input-placeholder{color:var(--mdc-outlined-text-field-input-text-placeholder-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-text-field__input{caret-color:var(--mdc-outlined-text-field-error-caret-color)}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-text-field__input{color:var(--mdc-outlined-text-field-disabled-input-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}@media(forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}}.mdc-text-field--filled{height:56px;border-bottom-right-radius:0;border-bottom-left-radius:0;border-top-left-radius:var(--mdc-filled-text-field-container-shape, var(--mat-sys-corner-extra-small));border-top-right-radius:var(--mdc-filled-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-text-field--filled:not(.mdc-text-field--disabled){background-color:var(--mdc-filled-text-field-container-color, var(--mat-sys-surface-variant))}.mdc-text-field--filled.mdc-text-field--disabled{background-color:var(--mdc-filled-text-field-disabled-container-color, color-mix(in srgb, var(--mat-sys-on-surface) 4%, transparent))}.mdc-text-field--outlined{height:56px;overflow:visible;padding-right:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)));padding-left:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)) + 4px)}[dir=rtl] .mdc-text-field--outlined{padding-right:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)) + 4px);padding-left:max(16px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))}.mdc-floating-label{position:absolute;left:0;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label{right:0;left:auto;transform-origin:right top;text-align:right}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:auto}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label{left:auto;right:4px}.mdc-text-field--filled .mdc-floating-label{left:16px;right:auto}[dir=rtl] .mdc-text-field--filled .mdc-floating-label{left:auto;right:16px}.mdc-text-field--disabled .mdc-floating-label{cursor:default}@media(forced-colors: active){.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-floating-label{color:var(--mdc-filled-text-field-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label{color:var(--mdc-filled-text-field-focus-label-text-color, var(--mat-sys-primary))}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-floating-label{color:var(--mdc-filled-text-field-hover-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled.mdc-text-field--disabled .mdc-floating-label{color:var(--mdc-filled-text-field-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-floating-label{color:var(--mdc-filled-text-field-error-label-text-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mdc-floating-label{color:var(--mdc-filled-text-field-error-focus-label-text-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-floating-label{color:var(--mdc-filled-text-field-error-hover-label-text-color, var(--mat-sys-on-error-container))}.mdc-text-field--filled .mdc-floating-label{font-family:var(--mdc-filled-text-field-label-text-font, var(--mat-sys-body-large-font));font-size:var(--mdc-filled-text-field-label-text-size, var(--mat-sys-body-large-size));font-weight:var(--mdc-filled-text-field-label-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mdc-filled-text-field-label-text-tracking, var(--mat-sys-body-large-tracking))}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mdc-floating-label{color:var(--mdc-outlined-text-field-label-text-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-floating-label{color:var(--mdc-outlined-text-field-focus-label-text-color, var(--mat-sys-primary))}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-floating-label{color:var(--mdc-outlined-text-field-hover-label-text-color, var(--mat-sys-on-surface))}.mdc-text-field--outlined.mdc-text-field--disabled .mdc-floating-label{color:var(--mdc-outlined-text-field-disabled-label-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-floating-label{color:var(--mdc-outlined-text-field-error-label-text-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mdc-floating-label{color:var(--mdc-outlined-text-field-error-focus-label-text-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--disabled):hover .mdc-floating-label{color:var(--mdc-outlined-text-field-error-hover-label-text-color, var(--mat-sys-on-error-container))}.mdc-text-field--outlined .mdc-floating-label{font-family:var(--mdc-outlined-text-field-label-text-font, var(--mat-sys-body-large-font));font-size:var(--mdc-outlined-text-field-label-text-size, var(--mat-sys-body-large-size));font-weight:var(--mdc-outlined-text-field-label-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mdc-outlined-text-field-label-text-tracking, var(--mat-sys-body-large-tracking))}.mdc-floating-label--float-above{cursor:auto;transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1);font-size:.75rem}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:0;margin-right:1px}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline{text-align:right}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mat-mdc-notch-piece{box-sizing:border-box;height:100%;pointer-events:none;border-top:1px solid;border-bottom:1px solid}.mdc-text-field--focused .mat-mdc-notch-piece{border-width:2px}.mdc-text-field--outlined:not(.mdc-text-field--disabled) .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-outline-color, var(--mat-sys-outline));border-width:var(--mdc-outlined-text-field-outline-width, 1px)}.mdc-text-field--outlined:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-hover-outline-color, var(--mat-sys-on-surface))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-focus-outline-color, var(--mat-sys-primary))}.mdc-text-field--outlined.mdc-text-field--disabled .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-disabled-outline-color, color-mix(in srgb, var(--mat-sys-on-surface) 12%, transparent))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-outline-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--focused):hover .mdc-notched-outline .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-hover-outline-color, var(--mat-sys-on-error-container))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--invalid.mdc-text-field--focused .mat-mdc-notch-piece{border-color:var(--mdc-outlined-text-field-error-focus-outline-color, var(--mat-sys-error))}.mdc-text-field--outlined:not(.mdc-text-field--disabled).mdc-text-field--focused .mdc-notched-outline .mat-mdc-notch-piece{border-width:var(--mdc-outlined-text-field-focus-outline-width, 2px)}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;border-top-right-radius:0;border-bottom-right-radius:0;border-top-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))}[dir=rtl] .mdc-notched-outline__leading{border-left:none;border-right:1px solid;border-bottom-left-radius:0;border-top-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-notched-outline__trailing{flex-grow:1;border-left:none;border-right:1px solid;border-top-left-radius:0;border-bottom-left-radius:0;border-top-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-right-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}[dir=rtl] .mdc-notched-outline__trailing{border-left:1px solid;border-right:none;border-top-right-radius:0;border-bottom-right-radius:0;border-top-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small));border-bottom-left-radius:var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small))}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:min(var(--mat-form-field-notch-max-width, 100%),100% - max(12px,var(--mdc-outlined-text-field-container-shape, var(--mat-sys-corner-extra-small)))*2)}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none;--mat-form-field-notch-max-width: 100%}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1;border-bottom-width:var(--mdc-filled-text-field-active-indicator-height, 1px)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-active-indicator-color, var(--mat-sys-on-surface-variant))}.mdc-text-field--filled:not(.mdc-text-field--disabled):not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-hover-active-indicator-color, var(--mat-sys-on-surface))}.mdc-text-field--filled.mdc-text-field--disabled .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-disabled-active-indicator-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-active-indicator-color, var(--mat-sys-error))}.mdc-text-field--filled:not(.mdc-text-field--disabled).mdc-text-field--invalid:not(.mdc-text-field--focused):hover .mdc-line-ripple::before{border-bottom-color:var(--mdc-filled-text-field-error-hover-active-indicator-color, var(--mat-sys-on-error-container))}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-text-field--filled .mdc-line-ripple::after{border-bottom-width:var(--mdc-filled-text-field-focus-active-indicator-height, 2px)}.mdc-text-field--filled:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-focus-active-indicator-color, var(--mat-sys-primary))}.mdc-text-field--filled.mdc-text-field--invalid:not(.mdc-text-field--disabled) .mdc-line-ripple::after{border-bottom-color:var(--mdc-filled-text-field-error-focus-active-indicator-color, var(--mat-sys-error))}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-text-field--disabled{pointer-events:none}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;line-height:normal;pointer-events:all;will-change:auto}.mat-mdc-form-field:not(.mat-form-field-disabled) .mat-mdc-floating-label.mdc-floating-label{cursor:inherit}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto;will-change:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-form-field-disabled .mdc-text-field__input::placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input::-moz-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input::-webkit-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-disabled .mdc-text-field__input:-ms-input-placeholder{color:var(--mat-form-field-disabled-input-text-placeholder-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field .mdc-notched-outline__notch{border-left:1px solid rgba(0,0,0,0)}[dir=rtl] .mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field.mat-mdc-form-field .mdc-notched-outline__notch{border-left:none;border-right:1px solid rgba(0,0,0,0)}.mat-mdc-form-field-infix{min-height:var(--mat-form-field-container-height, 56px);padding-top:var(--mat-form-field-filled-with-label-container-padding-top, 24px);padding-bottom:var(--mat-form-field-filled-with-label-container-padding-bottom, 8px)}.mdc-text-field--outlined .mat-mdc-form-field-infix,.mdc-text-field--no-label .mat-mdc-form-field-infix{padding-top:var(--mat-form-field-container-vertical-padding, 16px);padding-bottom:var(--mat-form-field-container-vertical-padding, 16px)}.mat-mdc-text-field-wrapper .mat-mdc-form-field-flex .mat-mdc-floating-label{top:calc(var(--mat-form-field-container-height, 56px)/2)}.mdc-text-field--filled .mat-mdc-floating-label{display:var(--mat-form-field-filled-label-display, block)}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{--mat-mdc-form-field-label-transform: translateY(calc(calc(6.75px + var(--mat-form-field-container-height, 56px) / 2) * -1)) scale(var(--mat-mdc-form-field-floating-label-scale, 0.75));transform:var(--mat-mdc-form-field-label-transform)}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block;color:var(--mat-form-field-error-text-color, var(--mat-sys-error))}.mat-mdc-form-field-subscript-wrapper,.mat-mdc-form-field-bottom-align::before{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-subscript-text-font, var(--mat-sys-body-small-font));line-height:var(--mat-form-field-subscript-text-line-height, var(--mat-sys-body-small-line-height));font-size:var(--mat-form-field-subscript-text-size, var(--mat-sys-body-small-size));letter-spacing:var(--mat-form-field-subscript-text-tracking, var(--mat-sys-body-small-tracking));font-weight:var(--mat-form-field-subscript-text-weight, var(--mat-sys-body-small-weight))}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none;background-color:var(--mat-form-field-state-layer-color, var(--mat-sys-on-surface))}.mat-mdc-text-field-wrapper:hover .mat-mdc-form-field-focus-overlay{opacity:var(--mat-form-field-hover-state-layer-opacity, var(--mat-sys-hover-state-layer-opacity))}.mat-mdc-form-field.mat-focused .mat-mdc-form-field-focus-overlay{opacity:var(--mat-form-field-focus-state-layer-opacity, 0)}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}select.mat-mdc-form-field-input-control:not(.mat-mdc-native-select-inline) option{color:var(--mat-form-field-select-option-text-color, var(--mat-sys-neutral10))}select.mat-mdc-form-field-input-control:not(.mat-mdc-native-select-inline) option:disabled{color:var(--mat-form-field-select-disabled-option-text-color, color-mix(in srgb, var(--mat-sys-neutral10) 38%, transparent))}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none;color:var(--mat-form-field-enabled-select-arrow-color, var(--mat-sys-on-surface-variant))}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select.mat-focused .mat-mdc-form-field-infix::after{color:var(--mat-form-field-focus-select-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field-type-mat-native-select.mat-form-field-disabled .mat-mdc-form-field-infix::after{color:var(--mat-form-field-disabled-select-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}@media(forced-colors: active){.mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}}@media(forced-colors: active){.mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}}@media(forced-colors: active){.mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}}@media(forced-colors: active){.mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-form-field-container-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-form-field-container-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-form-field-container-text-size, var(--mat-sys-body-large-size));letter-spacing:var(--mat-form-field-container-text-tracking, var(--mat-sys-body-large-tracking));font-weight:var(--mat-form-field-container-text-weight, var(--mat-sys-body-large-weight))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-floating-label--float-above{font-size:calc(var(--mat-form-field-outlined-label-text-populated-size)*var(--mat-mdc-form-field-floating-label-scale))}.mat-mdc-form-field .mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:var(--mat-form-field-outlined-label-text-populated-size)}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%;z-index:0}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:0 12px;box-sizing:content-box}.mat-mdc-form-field-icon-prefix{color:var(--mat-form-field-leading-icon-color, var(--mat-sys-on-surface-variant))}.mat-form-field-disabled .mat-mdc-form-field-icon-prefix{color:var(--mat-form-field-disabled-leading-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-trailing-icon-color, var(--mat-sys-on-surface-variant))}.mat-form-field-disabled .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-disabled-trailing-icon-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-form-field-invalid .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-trailing-icon-color, var(--mat-sys-error))}.mat-form-field-invalid:not(.mat-focused):not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper:hover .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-hover-trailing-icon-color, var(--mat-sys-on-error-container))}.mat-form-field-invalid.mat-focused .mat-mdc-text-field-wrapper .mat-mdc-form-field-icon-suffix{color:var(--mat-form-field-error-focus-trailing-icon-color, var(--mat-sys-error))}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field-infix:has(textarea[cols]){width:auto}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::-moz-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::-webkit-input-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::-moz-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::-moz-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input::-webkit-input-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input::-webkit-input-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mat-mdc-form-field:not(.mat-form-field-no-animations).mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'], encapsulation: 2, data: { animation: [lde.transitionMessages] }, changeDetection: 0 });
    }
    return i59;
  })();
  var mp = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt, Ky, Yt] });
    }
    return i59;
  })();
  var pde = ["trigger"];
  var fde = ["panel"];
  var mde = [[["mat-select-trigger"]], "*"];
  var gde = ["mat-select-trigger", "*"];
  function _de(i59, t) {
    if (i59 & 1 && (b(0, "span", 4), D(1), x()), i59 & 2) {
      let e = T();
      C(), Qe(e.placeholder);
    }
  }
  function vde(i59, t) {
    i59 & 1 && zt(0);
  }
  function yde(i59, t) {
    if (i59 & 1 && (b(0, "span", 11), D(1), x()), i59 & 2) {
      let e = T(2);
      C(), Qe(e.triggerValue);
    }
  }
  function bde(i59, t) {
    if (i59 & 1 && (b(0, "span", 5), X(1, vde, 1, 0)(2, yde, 2, 1, "span", 11), x()), i59 & 2) {
      let e = T();
      C(), he(e.customTrigger ? 1 : 2);
    }
  }
  function xde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 12, 1), Z("@transformPanel.done", function(r) {
        q(e);
        let o = T();
        return Y(o._panelDoneAnimatingStream.next(r.toState));
      })("keydown", function(r) {
        q(e);
        let o = T();
        return Y(o._handleKeydown(r));
      }), zt(2, 1), x();
    }
    if (i59 & 2) {
      let e = T();
      VN("mat-mdc-select-panel mdc-menu-surface mdc-menu-surface--open ", e._getPanelTheme(), ""), U("ngClass", e.panelClass)("@transformPanel", "showing"), Ke("id", e.id + "-panel")("aria-multiselectable", e.multiple)("aria-label", e.ariaLabel || null)("aria-labelledby", e._getPanelAriaLabelledby());
    }
  }
  var wde = { transformPanelWrap: ki("transformPanelWrap", [Yn("* => void", Uk("@transformPanel", [zk()], { optional: true }))]), transformPanel: ki("transformPanel", [Zi("void", _n({ opacity: 0, transform: "scale(1, 0.8)" })), Yn("void => showing", oi("120ms cubic-bezier(0, 0, 0.2, 1)", _n({ opacity: 1, transform: "scale(1, 1)" }))), Yn("* => void", oi("100ms linear", _n({ opacity: 0 })))]) };
  var QG = new Ee("mat-select-scroll-strategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.reposition();
  } });
  function Cde(i59) {
    return () => i59.scrollStrategies.reposition();
  }
  var Sde = new Ee("MAT_SELECT_CONFIG");
  var Mde = { provide: QG, deps: [fn], useFactory: Cde };
  var Ede = new Ee("MatSelectTrigger");
  var WD = class {
    source;
    value;
    constructor(t, e) {
      this.source = t, this.value = e;
    }
  };
  var Tw = (() => {
    class i59 {
      _viewportRuler = M(Bl);
      _changeDetectorRef = M(Ge);
      _elementRef = M(He);
      _dir = M(_i, { optional: true });
      _idGenerator = M(kn);
      _parentFormField = M(jD, { optional: true });
      ngControl = M(Nc, { self: true, optional: true });
      _liveAnnouncer = M(ub);
      _defaultOptions = M(Sde, { optional: true });
      _initialized = new we();
      options;
      optionGroups;
      customTrigger;
      _positions = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom", panelClass: "mat-mdc-select-panel-above" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom", panelClass: "mat-mdc-select-panel-above" }];
      _scrollOptionIntoView(e) {
        let n = this.options.toArray()[e];
        if (n) {
          let r = this.panel.nativeElement, o = xL(e, this.options, this.optionGroups), s = n._getHostElement();
          e === 0 && o === 1 ? r.scrollTop = 0 : r.scrollTop = wL(s.offsetTop, s.offsetHeight, r.scrollTop, r.offsetHeight);
        }
      }
      _positioningSettled() {
        this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);
      }
      _getChangeEvent(e) {
        return new WD(this, e);
      }
      _scrollStrategyFactory = M(QG);
      _panelOpen = false;
      _compareWith = (e, n) => e === n;
      _uid = this._idGenerator.getId("mat-select-");
      _triggerAriaLabelledBy = null;
      _previousControl;
      _destroy = new we();
      _errorStateTracker;
      stateChanges = new we();
      disableAutomaticLabeling = true;
      userAriaDescribedBy;
      _selectionModel;
      _keyManager;
      _preferredOverlayOrigin;
      _overlayWidth;
      _onChange = () => {
      };
      _onTouched = () => {
      };
      _valueId = this._idGenerator.getId("mat-select-value-");
      _panelDoneAnimatingStream = new we();
      _scrollStrategy;
      _overlayPanelClass = this._defaultOptions?.overlayPanelClass || "";
      get focused() {
        return this._focused || this._panelOpen;
      }
      _focused = false;
      controlType = "mat-select";
      trigger;
      panel;
      _overlayDir;
      panelClass;
      disabled = false;
      disableRipple = false;
      tabIndex = 0;
      get hideSingleSelectionIndicator() {
        return this._hideSingleSelectionIndicator;
      }
      set hideSingleSelectionIndicator(e) {
        this._hideSingleSelectionIndicator = e, this._syncParentProperties();
      }
      _hideSingleSelectionIndicator = this._defaultOptions?.hideSingleSelectionIndicator ?? false;
      get placeholder() {
        return this._placeholder;
      }
      set placeholder(e) {
        this._placeholder = e, this.stateChanges.next();
      }
      _placeholder;
      get required() {
        return this._required ?? this.ngControl?.control?.hasValidator(Fy.required) ?? false;
      }
      set required(e) {
        this._required = e, this.stateChanges.next();
      }
      _required;
      get multiple() {
        return this._multiple;
      }
      set multiple(e) {
        this._selectionModel, this._multiple = e;
      }
      _multiple = false;
      disableOptionCentering = this._defaultOptions?.disableOptionCentering ?? false;
      get compareWith() {
        return this._compareWith;
      }
      set compareWith(e) {
        this._compareWith = e, this._selectionModel && this._initializeSelection();
      }
      get value() {
        return this._value;
      }
      set value(e) {
        this._assignValue(e) && this._onChange(e);
      }
      _value;
      ariaLabel = "";
      ariaLabelledby;
      get errorStateMatcher() {
        return this._errorStateTracker.matcher;
      }
      set errorStateMatcher(e) {
        this._errorStateTracker.matcher = e;
      }
      typeaheadDebounceInterval;
      sortComparator;
      get id() {
        return this._id;
      }
      set id(e) {
        this._id = e || this._uid, this.stateChanges.next();
      }
      _id;
      get errorState() {
        return this._errorStateTracker.errorState;
      }
      set errorState(e) {
        this._errorStateTracker.errorState = e;
      }
      panelWidth = this._defaultOptions && typeof this._defaultOptions.panelWidth < "u" ? this._defaultOptions.panelWidth : "auto";
      canSelectNullableOptions = this._defaultOptions?.canSelectNullableOptions ?? false;
      optionSelectionChanges = nc(() => {
        let e = this.options;
        return e ? e.changes.pipe(ei(e), Ai(() => Jn(...e.map((n) => n.onSelectionChange)))) : this._initialized.pipe(Ai(() => this.optionSelectionChanges));
      });
      openedChange = new Ue();
      _openedStream = this.openedChange.pipe(En((e) => e), kt(() => {
      }));
      _closedStream = this.openedChange.pipe(En((e) => !e), kt(() => {
      }));
      selectionChange = new Ue();
      valueChange = new Ue();
      constructor() {
        let e = M(vL), n = M(dT, { optional: true }), r = M(uT, { optional: true }), o = M(new Tr("tabindex"), { optional: true });
        this.ngControl && (this.ngControl.valueAccessor = this), this._defaultOptions?.typeaheadDebounceInterval != null && (this.typeaheadDebounceInterval = this._defaultOptions.typeaheadDebounceInterval), this._errorStateTracker = new fb(e, this.ngControl, r, n, this.stateChanges), this._scrollStrategy = this._scrollStrategyFactory(), this.tabIndex = o == null ? 0 : parseInt(o) || 0, this.id = this.id;
      }
      ngOnInit() {
        this._selectionModel = new zd(this.multiple), this.stateChanges.next(), this._panelDoneAnimatingStream.pipe(qa(), Je(this._destroy)).subscribe(() => this._panelDoneAnimating(this.panelOpen)), this._viewportRuler.change().pipe(Je(this._destroy)).subscribe(() => {
          this.panelOpen && (this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin), this._changeDetectorRef.detectChanges());
        });
      }
      ngAfterContentInit() {
        this._initialized.next(), this._initialized.complete(), this._initKeyManager(), this._selectionModel.changed.pipe(Je(this._destroy)).subscribe((e) => {
          e.added.forEach((n) => n.select()), e.removed.forEach((n) => n.deselect());
        }), this.options.changes.pipe(ei(null), Je(this._destroy)).subscribe(() => {
          this._resetOptions(), this._initializeSelection();
        });
      }
      ngDoCheck() {
        let e = this._getTriggerAriaLabelledby(), n = this.ngControl;
        if (e !== this._triggerAriaLabelledBy) {
          let r = this._elementRef.nativeElement;
          this._triggerAriaLabelledBy = e, e ? r.setAttribute("aria-labelledby", e) : r.removeAttribute("aria-labelledby");
        }
        n && (this._previousControl !== n.control && (this._previousControl !== void 0 && n.disabled !== null && n.disabled !== this.disabled && (this.disabled = n.disabled), this._previousControl = n.control), this.updateErrorState());
      }
      ngOnChanges(e) {
        (e.disabled || e.userAriaDescribedBy) && this.stateChanges.next(), e.typeaheadDebounceInterval && this._keyManager && this._keyManager.withTypeAhead(this.typeaheadDebounceInterval);
      }
      ngOnDestroy() {
        this._keyManager?.destroy(), this._destroy.next(), this._destroy.complete(), this.stateChanges.complete(), this._clearFromModal();
      }
      toggle() {
        this.panelOpen ? this.close() : this.open();
      }
      open() {
        this._canOpen() && (this._parentFormField && (this._preferredOverlayOrigin = this._parentFormField.getConnectedOverlayOrigin()), this._overlayWidth = this._getOverlayWidth(this._preferredOverlayOrigin), this._applyModalPanelOwnership(), this._panelOpen = true, this._keyManager.withHorizontalOrientation(null), this._highlightCorrectOption(), this._changeDetectorRef.markForCheck(), this.stateChanges.next());
      }
      _trackedModal = null;
      _applyModalPanelOwnership() {
        let e = this._elementRef.nativeElement.closest('body > .cdk-overlay-container [aria-modal="true"]');
        if (!e) return;
        let n = `${this.id}-panel`;
        this._trackedModal && cb(this._trackedModal, "aria-owns", n), CT(e, "aria-owns", n), this._trackedModal = e;
      }
      _clearFromModal() {
        if (!this._trackedModal) return;
        let e = `${this.id}-panel`;
        cb(this._trackedModal, "aria-owns", e), this._trackedModal = null;
      }
      close() {
        this._panelOpen && (this._panelOpen = false, this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"), this._changeDetectorRef.markForCheck(), this._onTouched(), this.stateChanges.next());
      }
      writeValue(e) {
        this._assignValue(e);
      }
      registerOnChange(e) {
        this._onChange = e;
      }
      registerOnTouched(e) {
        this._onTouched = e;
      }
      setDisabledState(e) {
        this.disabled = e, this._changeDetectorRef.markForCheck(), this.stateChanges.next();
      }
      get panelOpen() {
        return this._panelOpen;
      }
      get selected() {
        return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];
      }
      get triggerValue() {
        if (this.empty) return "";
        if (this._multiple) {
          let e = this._selectionModel.selected.map((n) => n.viewValue);
          return this._isRtl() && e.reverse(), e.join(", ");
        }
        return this._selectionModel.selected[0].viewValue;
      }
      updateErrorState() {
        this._errorStateTracker.updateErrorState();
      }
      _isRtl() {
        return this._dir ? this._dir.value === "rtl" : false;
      }
      _handleKeydown(e) {
        this.disabled || (this.panelOpen ? this._handleOpenKeydown(e) : this._handleClosedKeydown(e));
      }
      _handleClosedKeydown(e) {
        let n = e.keyCode, r = n === 40 || n === 38 || n === 37 || n === 39, o = n === 13 || n === 32, s = this._keyManager;
        if (!s.isTyping() && o && !Ki(e) || (this.multiple || e.altKey) && r) e.preventDefault(), this.open();
        else if (!this.multiple) {
          let a = this.selected;
          s.onKeydown(e);
          let l = this.selected;
          l && a !== l && this._liveAnnouncer.announce(l.viewValue, 1e4);
        }
      }
      _handleOpenKeydown(e) {
        let n = this._keyManager, r = e.keyCode, o = r === 40 || r === 38, s = n.isTyping();
        if (o && e.altKey) e.preventDefault(), this.close();
        else if (!s && (r === 13 || r === 32) && n.activeItem && !Ki(e)) e.preventDefault(), n.activeItem._selectViaInteraction();
        else if (!s && this._multiple && r === 65 && e.ctrlKey) {
          e.preventDefault();
          let a = this.options.some((l) => !l.disabled && !l.selected);
          this.options.forEach((l) => {
            l.disabled || (a ? l.select() : l.deselect());
          });
        } else {
          let a = n.activeItemIndex;
          n.onKeydown(e), this._multiple && o && e.shiftKey && n.activeItem && n.activeItemIndex !== a && n.activeItem._selectViaInteraction();
        }
      }
      _onFocus() {
        this.disabled || (this._focused = true, this.stateChanges.next());
      }
      _onBlur() {
        this._focused = false, this._keyManager?.cancelTypeahead(), !this.disabled && !this.panelOpen && (this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next());
      }
      _onAttached() {
        this._overlayDir.positionChange.pipe(On(1)).subscribe(() => {
          this._changeDetectorRef.detectChanges(), this._positioningSettled();
        });
      }
      _getPanelTheme() {
        return this._parentFormField ? `mat-${this._parentFormField.color}` : "";
      }
      get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
      }
      _initializeSelection() {
        Promise.resolve().then(() => {
          this.ngControl && (this._value = this.ngControl.value), this._setSelectionByValue(this._value), this.stateChanges.next();
        });
      }
      _setSelectionByValue(e) {
        if (this.options.forEach((n) => n.setInactiveStyles()), this._selectionModel.clear(), this.multiple && e) Array.isArray(e), e.forEach((n) => this._selectOptionByValue(n)), this._sortValues();
        else {
          let n = this._selectOptionByValue(e);
          n ? this._keyManager.updateActiveItem(n) : this.panelOpen || this._keyManager.updateActiveItem(-1);
        }
        this._changeDetectorRef.markForCheck();
      }
      _selectOptionByValue(e) {
        let n = this.options.find((r) => {
          if (this._selectionModel.isSelected(r)) return false;
          try {
            return (r.value != null || this.canSelectNullableOptions) && this._compareWith(r.value, e);
          } catch {
            return false;
          }
        });
        return n && this._selectionModel.select(n), n;
      }
      _assignValue(e) {
        return e !== this._value || this._multiple && Array.isArray(e) ? (this.options && this._setSelectionByValue(e), this._value = e, true) : false;
      }
      _skipPredicate = (e) => this.panelOpen ? false : e.disabled;
      _getOverlayWidth(e) {
        return this.panelWidth === "auto" ? (e instanceof Vg ? e.elementRef : e || this._elementRef).nativeElement.getBoundingClientRect().width : this.panelWidth === null ? "" : this.panelWidth;
      }
      _syncParentProperties() {
        if (this.options) for (let e of this.options) e._changeDetectorRef.markForCheck();
      }
      _initKeyManager() {
        this._keyManager = new sb(this.options).withTypeAhead(this.typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withHomeAndEnd().withPageUpDown().withAllowedModifierKeys(["shiftKey"]).skipPredicate(this._skipPredicate), this._keyManager.tabOut.subscribe(() => {
          this.panelOpen && (!this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction(), this.focus(), this.close());
        }), this._keyManager.change.subscribe(() => {
          this._panelOpen && this.panel ? this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0) : !this._panelOpen && !this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction();
        });
      }
      _resetOptions() {
        let e = Jn(this.options.changes, this._destroy);
        this.optionSelectionChanges.pipe(Je(e)).subscribe((n) => {
          this._onSelect(n.source, n.isUserInput), n.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus());
        }), Jn(...this.options.map((n) => n._stateChanges)).pipe(Je(e)).subscribe(() => {
          this._changeDetectorRef.detectChanges(), this.stateChanges.next();
        });
      }
      _onSelect(e, n) {
        let r = this._selectionModel.isSelected(e);
        !this.canSelectNullableOptions && e.value == null && !this._multiple ? (e.deselect(), this._selectionModel.clear(), this.value != null && this._propagateChanges(e.value)) : (r !== e.selected && (e.selected ? this._selectionModel.select(e) : this._selectionModel.deselect(e)), n && this._keyManager.setActiveItem(e), this.multiple && (this._sortValues(), n && this.focus())), r !== this._selectionModel.isSelected(e) && this._propagateChanges(), this.stateChanges.next();
      }
      _sortValues() {
        if (this.multiple) {
          let e = this.options.toArray();
          this._selectionModel.sort((n, r) => this.sortComparator ? this.sortComparator(n, r, e) : e.indexOf(n) - e.indexOf(r)), this.stateChanges.next();
        }
      }
      _propagateChanges(e) {
        let n;
        this.multiple ? n = this.selected.map((r) => r.value) : n = this.selected ? this.selected.value : e, this._value = n, this.valueChange.emit(n), this._onChange(n), this.selectionChange.emit(this._getChangeEvent(n)), this._changeDetectorRef.markForCheck();
      }
      _highlightCorrectOption() {
        if (this._keyManager) if (this.empty) {
          let e = -1;
          for (let n = 0; n < this.options.length; n++) if (!this.options.get(n).disabled) {
            e = n;
            break;
          }
          this._keyManager.setActiveItem(e);
        } else this._keyManager.setActiveItem(this._selectionModel.selected[0]);
      }
      _canOpen() {
        return !this._panelOpen && !this.disabled && this.options?.length > 0;
      }
      focus(e) {
        this._elementRef.nativeElement.focus(e);
      }
      _getPanelAriaLabelledby() {
        if (this.ariaLabel) return null;
        let e = this._parentFormField?.getLabelId() || null, n = e ? e + " " : "";
        return this.ariaLabelledby ? n + this.ariaLabelledby : e;
      }
      _getAriaActiveDescendant() {
        return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null;
      }
      _getTriggerAriaLabelledby() {
        if (this.ariaLabel) return null;
        let e = this._parentFormField?.getLabelId(), n = (e ? e + " " : "") + this._valueId;
        return this.ariaLabelledby && (n += " " + this.ariaLabelledby), n;
      }
      _panelDoneAnimating(e) {
        this.openedChange.emit(e);
      }
      setDescribedByIds(e) {
        e.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", e.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby");
      }
      onContainerClick() {
        this.focus(), this.open();
      }
      get shouldLabelFloat() {
        return this.panelOpen || !this.empty || this.focused && !!this.placeholder;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-select"]], contentQueries: function(n, r, o) {
        if (n & 1 && (Xi(o, Ede, 5), Xi(o, yb, 5), Xi(o, vb, 5)), n & 2) {
          let s;
          Ie(s = De()) && (r.customTrigger = s.first), Ie(s = De()) && (r.options = s), Ie(s = De()) && (r.optionGroups = s);
        }
      }, viewQuery: function(n, r) {
        if (n & 1 && (Fe(pde, 5), Fe(fde, 5), Fe(SD, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.trigger = o.first), Ie(o = De()) && (r.panel = o.first), Ie(o = De()) && (r._overlayDir = o.first);
        }
      }, hostAttrs: ["role", "combobox", "aria-haspopup", "listbox", 1, "mat-mdc-select"], hostVars: 19, hostBindings: function(n, r) {
        n & 1 && Z("keydown", function(s) {
          return r._handleKeydown(s);
        })("focus", function() {
          return r._onFocus();
        })("blur", function() {
          return r._onBlur();
        }), n & 2 && (Ke("id", r.id)("tabindex", r.disabled ? -1 : r.tabIndex)("aria-controls", r.panelOpen ? r.id + "-panel" : null)("aria-expanded", r.panelOpen)("aria-label", r.ariaLabel || null)("aria-required", r.required.toString())("aria-disabled", r.disabled.toString())("aria-invalid", r.errorState)("aria-activedescendant", r._getAriaActiveDescendant()), ye("mat-mdc-select-disabled", r.disabled)("mat-mdc-select-invalid", r.errorState)("mat-mdc-select-required", r.required)("mat-mdc-select-empty", r.empty)("mat-mdc-select-multiple", r.multiple));
      }, inputs: { userAriaDescribedBy: [0, "aria-describedby", "userAriaDescribedBy"], panelClass: "panelClass", disabled: [2, "disabled", "disabled", tt], disableRipple: [2, "disableRipple", "disableRipple", tt], tabIndex: [2, "tabIndex", "tabIndex", (e) => e == null ? 0 : Gn(e)], hideSingleSelectionIndicator: [2, "hideSingleSelectionIndicator", "hideSingleSelectionIndicator", tt], placeholder: "placeholder", required: [2, "required", "required", tt], multiple: [2, "multiple", "multiple", tt], disableOptionCentering: [2, "disableOptionCentering", "disableOptionCentering", tt], compareWith: "compareWith", value: "value", ariaLabel: [0, "aria-label", "ariaLabel"], ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"], errorStateMatcher: "errorStateMatcher", typeaheadDebounceInterval: [2, "typeaheadDebounceInterval", "typeaheadDebounceInterval", Gn], sortComparator: "sortComparator", id: "id", panelWidth: "panelWidth", canSelectNullableOptions: [2, "canSelectNullableOptions", "canSelectNullableOptions", tt] }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, exportAs: ["matSelect"], features: [Bt([{ provide: HD, useExisting: i59 }, { provide: _b, useExisting: i59 }]), on, yn], ngContentSelectors: gde, decls: 11, vars: 8, consts: [["fallbackOverlayOrigin", "cdkOverlayOrigin", "trigger", ""], ["panel", ""], ["cdk-overlay-origin", "", 1, "mat-mdc-select-trigger", 3, "click"], [1, "mat-mdc-select-value"], [1, "mat-mdc-select-placeholder", "mat-mdc-select-min-line"], [1, "mat-mdc-select-value-text"], [1, "mat-mdc-select-arrow-wrapper"], [1, "mat-mdc-select-arrow"], ["viewBox", "0 0 24 24", "width", "24px", "height", "24px", "focusable", "false", "aria-hidden", "true"], ["d", "M7 10l5 5 5-5z"], ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "backdropClick", "attach", "detach", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayWidth"], [1, "mat-mdc-select-min-line"], ["role", "listbox", "tabindex", "-1", 3, "keydown", "ngClass"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          Tn(mde), b(0, "div", 2, 0), Z("click", function() {
            return q(o), Y(r.open());
          }), b(3, "div", 3), X(4, _de, 2, 1, "span", 4)(5, bde, 3, 1, "span", 5), x(), b(6, "div", 6)(7, "div", 7), to(), b(8, "svg", 8), ae(9, "path", 9), x()()()(), X(10, xde, 3, 9, "ng-template", 10), Z("backdropClick", function() {
            return q(o), Y(r.close());
          })("attach", function() {
            return q(o), Y(r._onAttached());
          })("detach", function() {
            return q(o), Y(r.close());
          });
        }
        if (n & 2) {
          let o = Ce(1);
          C(3), Ke("id", r._valueId), C(), he(r.empty ? 4 : 5), C(6), U("cdkConnectedOverlayPanelClass", r._overlayPanelClass)("cdkConnectedOverlayScrollStrategy", r._scrollStrategy)("cdkConnectedOverlayOrigin", r._preferredOverlayOrigin || o)("cdkConnectedOverlayOpen", r.panelOpen)("cdkConnectedOverlayPositions", r._positions)("cdkConnectedOverlayWidth", r._overlayWidth);
        }
      }, dependencies: [Vg, SD, Xv], styles: ['.mat-mdc-select{display:inline-block;width:100%;outline:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;color:var(--mat-select-enabled-trigger-text-color, var(--mat-sys-on-surface));font-family:var(--mat-select-trigger-text-font, var(--mat-sys-body-large-font));line-height:var(--mat-select-trigger-text-line-height, var(--mat-sys-body-large-line-height));font-size:var(--mat-select-trigger-text-size, var(--mat-sys-body-large-size));font-weight:var(--mat-select-trigger-text-weight, var(--mat-sys-body-large-weight));letter-spacing:var(--mat-select-trigger-text-tracking, var(--mat-sys-body-large-tracking))}div.mat-mdc-select-panel{box-shadow:var(--mat-select-container-elevation-shadow, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-select-disabled{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-disabled .mat-mdc-select-placeholder{color:var(--mat-select-disabled-trigger-text-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-trigger{display:inline-flex;align-items:center;cursor:pointer;position:relative;box-sizing:border-box;width:100%}.mat-mdc-select-disabled .mat-mdc-select-trigger{-webkit-user-select:none;user-select:none;cursor:default}.mat-mdc-select-value{width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-mdc-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-mdc-select-arrow-wrapper{height:24px;flex-shrink:0;display:inline-flex;align-items:center}.mat-form-field-appearance-fill .mdc-text-field--no-label .mat-mdc-select-arrow-wrapper{transform:none}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-invalid .mat-mdc-select-arrow,.mat-form-field-invalid:not(.mat-form-field-disabled) .mat-mdc-form-field-infix::after{color:var(--mat-select-invalid-arrow-color, var(--mat-sys-error))}.mat-mdc-select-arrow{width:10px;height:5px;position:relative;color:var(--mat-select-enabled-arrow-color, var(--mat-sys-on-surface-variant))}.mat-mdc-form-field.mat-focused .mat-mdc-select-arrow{color:var(--mat-select-focused-arrow-color, var(--mat-sys-primary))}.mat-mdc-form-field .mat-mdc-select.mat-mdc-select-disabled .mat-mdc-select-arrow{color:var(--mat-select-disabled-arrow-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-select-arrow svg{fill:currentColor;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%)}@media(forced-colors: active){.mat-mdc-select-arrow svg{fill:CanvasText}.mat-mdc-select-disabled .mat-mdc-select-arrow svg{fill:GrayText}}div.mat-mdc-select-panel{width:100%;max-height:275px;outline:0;overflow:auto;padding:8px 0;border-radius:4px;box-sizing:border-box;position:static;background-color:var(--mat-select-panel-background-color, var(--mat-sys-surface-container))}@media(forced-colors: active){div.mat-mdc-select-panel{outline:solid 1px}}.cdk-overlay-pane:not(.mat-mdc-select-panel-above) div.mat-mdc-select-panel{border-top-left-radius:0;border-top-right-radius:0;transform-origin:top center}.mat-mdc-select-panel-above div.mat-mdc-select-panel{border-bottom-left-radius:0;border-bottom-right-radius:0;transform-origin:bottom center}div.mat-mdc-select-panel .mat-mdc-option{--mdc-list-list-item-container-color: var(--mat-select-panel-background-color)}.mat-mdc-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1);color:var(--mat-select-placeholder-text-color, var(--mat-sys-on-surface-variant))}.mat-form-field-no-animations .mat-mdc-select-placeholder,._mat-animation-noopable .mat-mdc-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-mdc-select-placeholder{color:rgba(0,0,0,0);-webkit-text-fill-color:rgba(0,0,0,0);transition:none;display:block}.mat-mdc-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-mdc-text-field-wrapper{cursor:pointer}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mat-mdc-floating-label{max-width:calc(100% - 18px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-fill .mdc-floating-label--float-above{max-width:calc(100%/0.75 - 24px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mat-mdc-form-field-type-mat-select.mat-form-field-appearance-outline .mdc-text-field--label-floating .mdc-notched-outline__notch{max-width:calc(100% - 24px)}.mat-mdc-select-min-line:empty::before{content:" ";white-space:pre;width:1px;display:inline-block;visibility:hidden}.mat-form-field-appearance-fill .mat-mdc-select-arrow-wrapper{transform:var(--mat-select-arrow-transform, translateY(-8px))}'], encapsulation: 2, data: { animation: [wde.transformPanel] }, changeDetection: 0 });
    }
    return i59;
  })();
  var gp = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [Mde], imports: [ps, OT, Yt, Hs, mp, OT, Yt] });
    }
    return i59;
  })();
  var _p = (() => {
    class i59 {
      changeDetectorRef;
      pageSize;
      itemsCount;
      change = new Ue();
      curPageIndex = 0;
      constructor(e) {
        this.changeDetectorRef = e;
      }
      reset() {
        this.curPageIndex = 0, this.changeDetectorRef.markForCheck();
      }
      handleClickGoToPrevPage() {
        this.curPageIndex--, this.curPageIndex = Math.max(0, this.curPageIndex), this.change.emit(this.curPageIndex);
      }
      handleClickGoToNextPage() {
        this.curPageIndex++, this.curPageIndex = Math.min(Math.ceil(this.itemsCount / this.pageSize) - 1, this.curPageIndex), this.change.emit(this.curPageIndex);
      }
      get disablePrevButton() {
        return this.curPageIndex === 0;
      }
      get disableNextButton() {
        return this.curPageIndex === Math.ceil(this.itemsCount / this.pageSize) - 1;
      }
      get curRangeText() {
        let e = Math.min(this.itemsCount, this.curPageIndex * this.pageSize + 1), n = Math.min((this.curPageIndex + 1) * this.pageSize, this.itemsCount);
        return e === n ? `${e}` : `${e} - ${n}`;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["paginator"]], inputs: { pageSize: "pageSize", itemsCount: "itemsCount" }, outputs: { change: "change" }, decls: 9, vars: 5, consts: [[1, "container"], [1, "icon-container", "prev-page", 3, "click"], [1, "range-text"], [1, "icon-container", "next-page", 3, "click"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0)(1, "div", 1), Z("click", function() {
          return r.handleClickGoToPrevPage();
        }), b(2, "mat-icon"), D(3, "chevron_left"), x()(), b(4, "div", 2), D(5), x(), b(6, "div", 3), Z("click", function() {
          return r.handleClickGoToNextPage();
        }), b(7, "mat-icon"), D(8, "chevron_right"), x()()()), n & 2 && (C(), ye("disabled", r.disablePrevButton), C(4), Oe(" ", r.curRangeText, " "), C(), ye("disabled", r.disableNextButton));
      }, dependencies: [et, vt, St], styles: [`.container[_ngcontent-%COMP%]{display:flex;align-items:center;-webkit-user-select:none;user-select:none}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;width:24px;height:24px;border-radius:99px;cursor:pointer}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{background-color:#ddd}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover   mat-icon[_ngcontent-%COMP%]{opacity:1}.container[_ngcontent-%COMP%]   .icon-container.disabled[_ngcontent-%COMP%]{pointer-events:none;opacity:.3}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{opacity:.7;color:#333;font-size:20px;width:20px;height:20px}.container[_ngcontent-%COMP%]   .range-text[_ngcontent-%COMP%]{color:#333;font-size:12px;display:flex;align-items:center;justify-content:center}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Ide = ["searchInput"];
  var Dde = ["content"];
  function Pde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 11), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickClearSearchText());
      }), b(1, "mat-icon", 12), D(2, "close"), x()();
    }
  }
  function Rde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 25), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handlePaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.pageSize)("itemsCount", e.resultsCount);
    }
  }
  function Ode(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 26), Z("click", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.updateSelectedResultTypes(r));
      }), b(1, "div", 27)(2, "mat-icon"), D(3), x()(), b(4, "div", 28), D(5), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      ye("selected", e.selected), C(3), Qe(e.matchType), C(2), Oe(" ", e.label, " ");
    }
  }
  function Ade(i59, t) {
    if (i59 & 1 && ae(0, "io-tree", 22), i59 & 2) {
      let e = T(2);
      U("data", e.curSearchResultsData)("rendererId", e.rendererId)("tooltipPosition", "right")("showLocator", false);
    }
  }
  function Nde(i59, t) {
    i59 & 1 && (b(0, "div", 23), D(1, " No matching results "), x());
  }
  function kde(i59, t) {
    if (i59 & 1 && (b(0, "div", 13)(1, "div", 14)(2, "div", 15)(3, "div", 16), D(4), x(), X(5, Rde, 1, 2, "paginator", 17), x(), b(6, "div", 18)(7, "div", 19), Qt(8, Ode, 6, 4, "div", 20, mr), x()()(), b(10, "div", 21, 2), X(12, Ade, 1, 4, "io-tree", 22)(13, Nde, 2, 0, "div", 23), x(), b(14, "div", 24)(15, "mat-icon"), D(16, "tips_and_updates"), x(), D(17, " Click to locate node. Alt+Click to locate and select node. "), x()()), i59 & 2) {
      let e = T();
      sn("max-height", e.searchResultsContainerMaxHeight, "px"), C(4), Oe(" ", e.searchResultsTitle, " "), C(), he(e.showPaginator ? 5 : -1), C(3), Kt(e.searchResultTypes), C(4), he(e.resultsCount > 0 ? 12 : 13);
    }
  }
  function Lde(i59, t) {
    i59 & 1 && (b(0, "div", 29), D(1, " No matching results "), x());
  }
  function Fde(i59, t) {
    i59 & 1 && (b(0, "div", 30), D(1, " Use regex(es) to match nodes by label, attributes, input/output node label, and input/output metadata. Regexes separated by spaces are combined using the logical AND. "), ae(2, "br")(3, "br"), D(4, " For attributes and I/O metadata, regex will try to match "), b(5, "span", 31), D(6), x(), D(7, " or "), b(8, "span", 31), D(9), x(), D(10, ". "), ae(11, "br")(12, "br"), D(13, " Examples:"), ae(14, "br"), b(15, "ul")(16, "li")(17, "span", 32), D(18, "axis:"), x(), D(19, " will match attributes whose key is "), b(20, "span", 31), D(21, "axis"), x(), D(22, ". "), x(), b(23, "li")(24, "span", 32), D(25, "padding=[SAME|VALID]"), x(), D(26, " will match attributes whose key is "), b(27, "span", 31), D(28, "padding"), x(), D(29, " and value is either "), b(30, "span", 31), D(31, "SAME"), x(), D(32, " or "), b(33, "span", 31), D(34, "VALID"), x(), D(35, ". "), x()()()), i59 & 2 && (C(6), wc("", "{", "key", "}", ":", "{", "value", "}", ""), C(3), wc("", "{", "key", "}", "=", "{", "value", "}", ""));
  }
  var KG = "___ESCAPED_SPACE___";
  var JG = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      destroyRef;
      curModelGraph;
      rendererId;
      searchInput;
      content;
      curSearchText = new qr("");
      searchResultTypes = [{ matchType: _t.NODE_LABEL, label: "Label", selected: true }, { matchType: _t.ATTRIBUTE, label: "Attrs", selected: true }, { matchType: _t.INPUT_METADATA, label: "Inputs", selected: true }, { matchType: _t.OUTPUT_METADATA, label: "Outputs", selected: true }];
      searchResultTypeSelectorOverlaySize = { minWidth: 0, minHeight: 0 };
      searchResultTypeSelectorOverlayPositions = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }];
      pageSize;
      curSearchMatchedNodes = [];
      curSearchMatchData = [];
      curSearchResultsData;
      searching = false;
      curPageIndex = 0;
      constructor(e, n, r) {
        this.appService = e, this.changeDetectorRef = n, this.destroyRef = r, this.pageSize = this.appService.testMode ? 12 : 50, this.curSearchText.valueChanges.pipe(Wi(() => {
          this.searching = true, this.changeDetectorRef.markForCheck();
        }), vo(300), wi(this.destroyRef)).subscribe((o) => {
          this.handleSearch((o?.toLowerCase() || "").trim());
        }), this.appService.searchKeyClicked.pipe(wi(this.destroyRef)).subscribe(() => {
          this.rendererId === this.appService.curSelectedRenderer()?.id && this.searchInput.nativeElement.focus();
        });
      }
      handleClickClearSearchText() {
        this.curSearchText.setValue(""), this.handleSearch("");
      }
      updateSelectedResultTypes(e) {
        e.selected = !e.selected, this.changeDetectorRef.markForCheck(), this.handleSearch(this.curSearchText.value || ""), setTimeout(() => {
          this.content.nativeElement.scrollTop = 0;
        });
      }
      handlePaginatorChanged(e) {
        this.curPageIndex = e, this.updatePagedResults();
      }
      getDisableSearchResultTypeOption(e) {
        return this.searchResultTypes.filter((n) => n.selected).length === 1 && e.selected;
      }
      get searchResultsTitle() {
        let e = this.curSearchMatchedNodes?.length || 0;
        return `${e} result${e === 1 ? "" : "s"}`;
      }
      get showClearButton() {
        return (this.curSearchText.value || "").trim() !== "";
      }
      get showResultsPanel() {
        return !this.searching && (this.curSearchText.value || "").trim() !== "" && !this.showNoMatches;
      }
      get showNoMatches() {
        return !this.searching && (this.curSearchText.value || "").trim() !== "" && this.curSearchMatchedNodes.length === 0 && this.searchResultTypes.every((e) => e.selected);
      }
      get resultsCount() {
        return this.curSearchMatchedNodes.length;
      }
      get searchResultsContainerMaxHeight() {
        return document.body.offsetHeight - 300;
      }
      get showPaginator() {
        return this.resultsCount > this.pageSize;
      }
      handleSearch(e) {
        if (!e) {
          this.curPageIndex = 0, this.curSearchResultsData = void 0, this.curSearchMatchedNodes = [], this.changeDetectorRef.markForCheck(), this.searching = false, this.appService.clearSearchResults(this.rendererId);
          return;
        }
        let n = [], r = [], o = { results: {} }, s = new Set(this.searchResultTypes.filter((a) => a.selected).map((a) => a.matchType));
        try {
          let l = e.replaceAll("\\ ", KG).split(" ").filter((c) => c.trim() !== "").map((c) => c.replaceAll(KG, "\\ ")).map((c) => new RegExp(c, "i"));
          for (let c of this.curModelGraph.nodes) {
            if (dt(c) && c.hideInLayout) continue;
            let d = true, u = [], h = /* @__PURE__ */ new Set();
            for (let p of l) {
              let { matches: f, matchTypes: m } = ZE(s, p, c, this.curModelGraph, this.appService.config());
              if (f.length === 0) {
                d = false;
                break;
              } else {
                u.push(...f);
                for (let v of m) h.add(v);
              }
            }
            d && u.length > 0 && (n.push(c), r.push({ matches: u, matchTypes: h }), o.results[c.id] = u);
          }
          this.appService.setSearchResults(this.rendererId, o);
        } catch (a) {
          console.warn("Failed to search", a);
        }
        this.curPageIndex = 0, this.curSearchMatchedNodes = [...n], this.curSearchMatchData = r, this.updatePagedResults(), this.searching = false, this.changeDetectorRef.markForCheck();
      }
      updatePagedResults() {
        this.curSearchResultsData = Ha(this.curSearchMatchedNodes.slice(this.curPageIndex * this.pageSize, (this.curPageIndex + 1) * this.pageSize), [], "incoming", void 0, this.curSearchMatchData.slice(this.curPageIndex * this.pageSize, (this.curPageIndex + 1) * this.pageSize));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(pi));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["search-bar"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Ide, 5), Fe(Dde, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.searchInput = o.first), Ie(o = De()) && (r.content = o.first);
        }
      }, inputs: { curModelGraph: "curModelGraph", rendererId: "rendererId" }, decls: 14, vars: 6, consts: [["searchInput", ""], ["helpPopup", ""], ["content", ""], [1, "container"], [1, "input-container"], [1, "search"], ["placeholder", "Search nodes/layers by regex", 3, "formControl"], ["class", "btn-clear-container", 3, "click", 4, "ngIf"], [1, "icon-container", 3, "bubble", "hoverDelayMs"], ["class", "search-results-container", 3, "max-height", 4, "ngIf"], ["class", "no-matches", 4, "ngIf"], [1, "btn-clear-container", 3, "click"], [1, "clear"], [1, "search-results-container"], [1, "title-container"], [1, "title"], [1, "title-label"], [3, "pageSize", "itemsCount"], [1, "search-result-type-selector-container"], [1, "options-container"], [1, "option-container", 3, "selected"], [1, "content"], [3, "data", "rendererId", "tooltipPosition", "showLocator"], [1, "empty-results"], [1, "footer"], [3, "change", "pageSize", "itemsCount"], [1, "option-container", 3, "click"], [1, "icon-container"], [1, "option-label"], [1, "no-matches"], [1, "model-explorer-search-help-popup"], [1, "code"], [1, "code", "regex"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 3)(1, "div", 4)(2, "mat-icon", 5), D(3, "search"), x(), ae(4, "input", 6, 0), X(6, Pde, 3, 0, "div", 7), b(7, "div", 8)(8, "mat-icon"), D(9, "help_outline"), x()()(), X(10, kde, 18, 5, "div", 9)(11, Lde, 2, 0, "div", 10), x(), X(12, Fde, 36, 8, "ng-template", null, 1, Tt)), n & 2) {
          let o = Ce(13);
          C(4), U("formControl", r.curSearchText), C(2), U("ngIf", r.showClearButton), C(), U("bubble", o)("hoverDelayMs", 100), C(3), U("ngIf", r.showResultsPanel), C(), U("ngIf", r.showNoMatches);
        }
      }, dependencies: [Bn, et, In, Ul, zG, vt, St, gp, _p, Do, ul, Ps, Jo], styles: [`.container[_ngcontent-%COMP%]{position:relative;overflow:visible;background-color:#fff;border-radius:99px;height:30px;display:flex;align-items:center;padding:0 8px}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]{display:flex;align-items:center;width:250px}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   mat-icon.search[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   mat-icon.clear[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px;flex-shrink:0}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   mat-icon.clear[_ngcontent-%COMP%]{opacity:.6;cursor:pointer}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   mat-icon.clear[_ngcontent-%COMP%]:hover{opacity:.9}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{height:24px;border:none;outline:none;box-sizing:border-box;padding:0 4px;font-size:12px;flex-grow:1;min-width:0}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   .btn-clear-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;cursor:pointer;color:#999;opacity:.8}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px}.container[_ngcontent-%COMP%]   .input-container[_ngcontent-%COMP%]:has(input:focus)   mat-icon.search[_ngcontent-%COMP%]{color:#1a73e8}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]{overflow:hidden;position:absolute;top:calc(100% + 12px);left:-4px;border:1px solid #ccc;border-radius:4px;width:380px;display:flex;flex-direction:column;background-color:#fff;box-shadow:0 4px 6px -1px #0000001a,0 2px 4px -2px #0000001a}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .title-container[_ngcontent-%COMP%]{background-color:#f6f6f6;border-bottom:1px solid #ddd;box-sizing:border-box;padding:0 10px 10px}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{height:28px;min-height:28px;font-size:12px;display:flex;align-items:center;justify-content:space-between}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .title-label[_ngcontent-%COMP%]{white-space:nowrap}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{flex-grow:1;min-height:0;overflow-y:auto;padding-bottom:6px}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .empty-results[_ngcontent-%COMP%]{padding:12px 8px 6px;display:flex;align-items:center;font-size:12px;color:#ccc}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]{display:flex;align-items:center;font-size:12px;margin-top:2px}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .options-container[_ngcontent-%COMP%]{display:flex;align-items:center;gap:6px}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;cursor:pointer;-webkit-user-select:none;user-select:none;border:1px solid #ccc;padding:4px 14px;border-radius:6px;background-color:#fff;color:#474747}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container.selected[_ngcontent-%COMP%]{border-color:#a3c9ff;background-color:#a3c9ff;color:#001d35}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container.selected[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#001d35}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{width:18px;height:18px;display:flex;align-items:center;justify-content:center;box-sizing:border-box;margin-right:4px}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px;color:#474747}.container[_ngcontent-%COMP%]   .search-results-container[_ngcontent-%COMP%]   .search-result-type-selector-container[_ngcontent-%COMP%]   .option-container[_ngcontent-%COMP%]   .option-label[_ngcontent-%COMP%]{font-size:12px;font-family:Google Sans Text,Arial,Helvetica,sans-serif;letter-spacing:normal}.container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]{height:32px;min-height:32px;background-color:#f6f6f6;border-top:1px solid #ddd;box-sizing:border-box;padding:0 10px;font-size:12px;display:flex;align-items:center;color:#777}.container[_ngcontent-%COMP%]   .footer[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;height:16px;width:16px;color:#777;margin-right:4px}.container[_ngcontent-%COMP%]   .no-matches[_ngcontent-%COMP%]{position:absolute;top:calc(100% + 12px);left:-4px;color:#999;padding:8px;border:1px solid #ccc;border-radius:4px;background-color:#fff;font-size:12px;box-shadow:0 4px 6px -1px #0000001a,0 2px 4px -2px #0000001a}  .model-explorer-search-help-popup{padding:12px;font-size:12px;background-color:#fff}  .model-explorer-search-help-popup ul{margin-block-end:0}  .model-explorer-search-help-popup .code{display:inline-block;background-color:#fffdd0;font-family:monospace}  .model-explorer-search-help-popup .code.regex{background-color:#e6d0ff}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Bde = ["dialog"];
  var Vde = ["trigger"];
  function zde(i59, t) {
    i59 & 1 && D(0, " Maximum state count reached ");
  }
  function Ude(i59, t) {
    i59 & 1 && D(0, " Save the current graph state ");
  }
  function Gde(i59, t) {
    if (i59 & 1 && (b(0, "div", 7), X(1, zde, 1, 0)(2, Ude, 1, 0), b(3, "div", 8), D(4, " The saved state can be restored by clicking the corresponding state number. You can save up to 9 states. "), x()()), i59 & 2) {
      let e = T();
      C(), he(e.disableAddSnapshotButton ? 1 : 2);
    }
  }
  function Hde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 12)(1, "div", 13)(2, "div"), D(3), x(), b(4, "div", 14), Z("click", function() {
        q(e);
        let r = T().index, o = T(2);
        return Y(o.handleClickDeleteSnapshot(r));
      }), b(5, "mat-icon"), D(6, "delete"), x(), D(7, " Delete "), x()(), ae(8, "canvas"), x();
    }
    if (i59 & 2) {
      let e = T(), n = e.$implicit, r = e.index, o = T(2);
      C(3), Oe("Shortcut key: ", r + 1, ""), C(5), sn("width", o.getSnapshotCanvasWidth(n, true), "px")("height", o.getSnapshotCanvasHeight(n, true), "px");
    }
  }
  function jde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 11, 1), Z("opened", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.handleSnapshotPopupOpened(r));
      })("click", function() {
        let r = q(e).index, o = T(2);
        return Y(o.handleClickSnapshot(r));
      }), D(3), X(4, Hde, 9, 5, "ng-template", null, 2, Tt), x();
    }
    if (i59 & 2) {
      let e = t.index, n = Ce(5), r = T(2);
      U("bubble", n)("overlaySize", r.snapshotPopupSize)("overlayPositions", r.snapshotPopupPosition)("hoverDelayMs", 150), C(3), Oe(" ", e + 1, " ");
    }
  }
  function Wde(i59, t) {
    if (i59 & 1 && (b(0, "div", 9), X(1, jde, 6, 5, "div", 10), x()), i59 & 2) {
      let e = T();
      C(), U("ngForOf", e.curSnapshots)("ngForTrackBy", e.trackBySnapshotId);
    }
  }
  var $de = /* @__PURE__ */ new Set(["1", "2", "3", "4", "5", "6", "7", "8", "9"]);
  var eH = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      paneId;
      rendererId;
      snapshotPopups = new Ni();
      snapshotTriggers = new Ni();
      helpPopupSize = { minWidth: 0, minHeight: 0, maxWidth: 340 };
      snapshotPopupSize = { maxWidth: 1e3, maxHeight: 1e3 };
      snapshotPopupPosition = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top", offsetY: 12 }];
      curSnapshots = [];
      curModelGraph;
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n, ht(() => {
          let r = this.appService.getPaneById(this.paneId);
          this.curModelGraph = r?.modelGraph, r?.modelGraph != null && (this.curSnapshots = (r?.snapshots || {})[r.modelGraph.id] || [], this.changeDetectorRef.markForCheck());
        });
      }
      handleKeyboardEvent(e) {
        if ($de.has(e.key) && this.appService.curSelectedRenderer()?.id === this.rendererId && !Oy()) {
          let n = Number(e.key) - 1;
          if (n <= this.curSnapshots.length - 1) {
            this.handleClickSnapshot(n);
            let r = this.snapshotTriggers.get(n)?.nativeElement;
            r && (r.classList.add("clicked"), setTimeout(() => {
              r.classList.remove("clicked");
            }, 50));
          }
        }
      }
      handleClickAddSnapshot() {
        this.disableAddSnapshotButton || this.appService.addSnapshotClicked.next({ rendererId: this.rendererId });
      }
      handleClickSnapshot(e) {
        let n = this.curSnapshots[e];
        this.snapshotPopups.get(e)?.closeDialog(), this.appService.curSnapshotToRestore.next({ snapshot: n, rendererId: this.rendererId });
      }
      handleClickDeleteSnapshot(e) {
        this.curModelGraph && this.appService.deleteSnapshot(e, this.curModelGraph.id, this.paneId);
      }
      handleSnapshotPopupOpened(e) {
        let n = document.querySelector(".model-explorer-snapshot-popup canvas"), r = this.getSnapshotCanvasWidth(e), o = this.getSnapshotCanvasHeight(e);
        n.width = r, n.height = o;
        let s = n.getContext("2d");
        s.imageSmoothingQuality = "high", s.drawImage(e.imageBitmap, 0, 0, r, o), n.classList.add("show");
      }
      getSnapshotCanvasWidth(e, n = false) {
        return e.imageBitmap.width / (n ? window.devicePixelRatio : 1);
      }
      getSnapshotCanvasHeight(e, n = false) {
        return e.imageBitmap.height / (n ? window.devicePixelRatio : 1);
      }
      trackBySnapshotId(e, n) {
        return n.id;
      }
      get addSnapshotTooltip() {
        return this.disableAddSnapshotButton ? "Maximum bookmark count reached" : "Bookmark the current graph states to restore later";
      }
      get disableAddSnapshotButton() {
        return this.curSnapshots.length >= 9;
      }
      get hasSnapshots() {
        return this.curSnapshots.length > 0;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["snapshot-manager"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Bde, 5), Fe(Vde, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.snapshotPopups = o), Ie(o = De()) && (r.snapshotTriggers = o);
        }
      }, hostBindings: function(n, r) {
        n & 1 && Z("keypress", function(s) {
          return r.handleKeyboardEvent(s);
        }, false, Bv);
      }, inputs: { paneId: "paneId", rendererId: "rendererId" }, decls: 7, vars: 6, consts: [["help", ""], ["dialog", "bubble", "trigger", ""], ["snapshotPopup", ""], [1, "container"], [1, "mat-icon-container", "take-snapshot", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon"], ["class", "snapshots-container", 4, "ngIf"], [1, "model-explorer-help-popup"], [1, "description"], [1, "snapshots-container"], ["class", "snapshot", 3, "bubble", "overlaySize", "overlayPositions", "hoverDelayMs", "opened", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "snapshot", 3, "opened", "click", "bubble", "overlaySize", "overlayPositions", "hoverDelayMs"], [1, "model-explorer-snapshot-popup"], [1, "info-row"], [1, "icon-container", "delete", 3, "click"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 3)(1, "div", 4), Z("click", function() {
            return q(o), Y(r.handleClickAddSnapshot());
          }), b(2, "mat-icon", 5), D(3, "bookmark_add"), x()(), X(4, Gde, 5, 1, "ng-template", null, 0, Tt)(6, Wde, 2, 2, "div", 6), x();
        }
        if (n & 2) {
          let o = Ce(5);
          C(), ye("disabled", r.disableAddSnapshotButton), U("bubble", o)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(5), U("ngIf", r.hasSnapshots);
        }
      }, dependencies: [Bn, et, Wr, In, vt, St, tn], styles: [`.container[_ngcontent-%COMP%]{display:flex;align-items:center;margin-right:3px}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{width:24px;height:24px;display:flex;align-items:center;justify-content:center;cursor:pointer}.container[_ngcontent-%COMP%]   .mat-icon-container.disabled[_ngcontent-%COMP%]{cursor:default;opacity:.5}.container[_ngcontent-%COMP%]   .mat-icon-container.disabled[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]:hover{opacity:.6}.container[_ngcontent-%COMP%]   mat-icon.toolbar-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px;opacity:.6}.container[_ngcontent-%COMP%]   mat-icon.toolbar-icon[_ngcontent-%COMP%]:hover{opacity:.9}.container[_ngcontent-%COMP%]   .snapshots-container[_ngcontent-%COMP%]{display:flex;align-items:center;font-size:11px;margin-left:6px;margin-right:6px;gap:2px}.container[_ngcontent-%COMP%]   .snapshots-container[_ngcontent-%COMP%]   .snapshot[_ngcontent-%COMP%]{width:16px;height:16px;border-radius:8px;background-color:#7cacf8;color:#fff;box-sizing:border-box;display:flex;align-items:center;justify-content:center;font-weight:500;cursor:pointer}.container[_ngcontent-%COMP%]   .snapshots-container[_ngcontent-%COMP%]   .snapshot[_ngcontent-%COMP%]:hover, .container[_ngcontent-%COMP%]   .snapshots-container[_ngcontent-%COMP%]   .snapshot.clicked[_ngcontent-%COMP%]{background-color:#0b57d0;color:#fff}  .model-explorer-snapshot-popup{font-size:11px;line-height:12px;background-color:#fff}  .model-explorer-snapshot-popup .info-row{color:#333;display:flex;align-items:center;justify-content:space-between;background-color:#f6f6f6;padding:4px 8px;border-bottom:1px solid #ddd}  .model-explorer-snapshot-popup .info-row .icon-container{display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:.8}  .model-explorer-snapshot-popup .info-row .icon-container:hover{opacity:1}  .model-explorer-snapshot-popup .info-row .icon-container mat-icon{font-size:18px;width:18px;height:19px}  .model-explorer-snapshot-popup canvas{opacity:0;transition:opacity .2s ease-out}  .model-explorer-snapshot-popup canvas.show{opacity:1}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function qde(i59, t) {
    i59 & 1 && (b(0, "mat-icon", 2), D(1, "chevron_right"), x());
  }
  function Yde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 1), Z("click", function() {
        let r = q(e).$index, o = T();
        return Y(o.handleClickItem(r));
      }), D(1), x(), X(2, qde, 2, 0, "mat-icon", 2);
    }
    if (i59 & 2) {
      let e = t.$implicit, n = t.$index, r = T();
      ye("current", n === r.curSubgraphBreadcrumbs.length - 1), C(), Oe(" ", e.graphId, " "), C(), he(n !== r.curSubgraphBreadcrumbs.length - 1 ? 2 : -1);
    }
  }
  var tH = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      paneId;
      curSubgraphBreadcrumbs = [];
      savedSubgraphBreadcrumbs;
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n, ht(() => {
          let o = this.appService.getPaneById(this.paneId)?.subgraphBreadcrumbs;
          o !== this.savedSubgraphBreadcrumbs && (this.savedSubgraphBreadcrumbs = o, this.curSubgraphBreadcrumbs = o || [], this.changeDetectorRef.markForCheck());
        });
      }
      handleClickItem(e) {
        if (e === this.curSubgraphBreadcrumbs.length - 1) return;
        this.appService.setCurrentSubgraphBreadcrumb(this.paneId, e);
        let n = this.curSubgraphBreadcrumbs[e], r = n.snapshot;
        if (r) if (n.graphId === this.appService.getPaneById(this.paneId)?.modelGraph?.id) this.appService.curSnapshotToRestore.next({ rendererId: this.paneId, snapshot: r });
        else {
          let o = this.appService.getGraphById(n.graphId);
          o && this.appService.selectGraphInCurrentPane(o, r.flattenLayers, r);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["subgraph-breadcrumbs"]], inputs: { paneId: "paneId" }, decls: 3, vars: 0, consts: [[1, "container"], [1, "item", 3, "click"], [1, "separator"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0), Qt(1, Yde, 3, 4, null, null, mr), x()), n & 2 && (C(), Kt(r.curSubgraphBreadcrumbs));
      }, dependencies: [et, vt, St, tn], styles: [`.container[_ngcontent-%COMP%]{border:1px solid #3876c7;background-color:#d5e7ff;border-radius:4px;box-sizing:border-box;padding:4px 8px;display:flex;align-items:center;font-size:13px}.container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]{display:flex;align-items:center;color:#777}.container[_ngcontent-%COMP%]   .item[_ngcontent-%COMP%]:hover:not(.current){cursor:pointer;text-decoration:underline}.container[_ngcontent-%COMP%]   .item.current[_ngcontent-%COMP%]{color:#000}.container[_ngcontent-%COMP%]   .separator[_ngcontent-%COMP%]{color:#999;font-size:16px;width:16px;height:16px;margin:0 3px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var nH = (i59, t) => t.type;
  function Xde(i59, t) {
    i59 & 1 && (b(0, "div", 7), D(1, " Select data to view on nodes / edges "), x());
  }
  function Zde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 13)(1, "input", 14, 3), Z("keydown.enter", function() {
        q(e);
        let r = Ce(2);
        return Y(r.blur());
      })("input", function() {
        q(e);
        let r = Ce(2), o = T().$implicit, s = T(2);
        return Y(s.setAttrsFilterText(o, r.value));
      })("change", function() {
        q(e);
        let r = T().$implicit, o = T(2);
        return Y(o.handleAttrsFilterChanged(r));
      }), x(), b(3, "div", 15)(4, "mat-icon"), D(5, "help_outline"), x()(), b(6, "div", 16), Z("click", function() {
        q(e);
        let r = Ce(2);
        return Y(r.blur());
      }), b(7, "mat-icon"), D(8, "done"), x()()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T(2), r = Ce(9);
      C(), U("disabled", !e.selected)("value", n.getAttrsFilterText(e)), C(2), U("bubble", r)("hoverDelayMs", 100);
    }
  }
  function Qde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 11), Z("click", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.handleToggleShowOnNode(r));
      }), ae(1, "input", 12), D(2), x(), X(3, Zde, 9, 4, "div", 13);
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(2);
      C(), U("checked", e.selected), C(), Oe(" ", n.getShowOnNodeItemLabel(e), " "), C(), he(n.getIsAttrs(e) ? 3 : -1);
    }
  }
  function Kde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 19)(1, "input", 20, 3), Z("keydown.enter", function() {
        q(e);
        let r = Ce(2);
        return Y(r.blur());
      })("input", function() {
        q(e);
        let r = Ce(2), o = T().$implicit, s = T(3);
        return Y(s.setEdgeItemMetadataKeyText(o, r.value));
      })("change", function() {
        q(e);
        let r = T().$implicit, o = T(3);
        return Y(o.handleEdgeItemFilterChanged(r));
      }), x(), b(3, "div", 16), Z("click", function() {
        q(e);
        let r = Ce(2);
        return Y(r.blur());
      }), b(4, "mat-icon"), D(5, "done"), x()()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T(3);
      C(), U("placeholder", n.getEdgeItemPlaceholder(e))("disabled", !e.selected)("value", n.getEdgeItemMetadataKeyText(e));
    }
  }
  function Jde(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "label", 17)(1, "input", 18, 3), Z("change", function() {
        let r = q(e).$implicit, o = Ce(2), s = T(3);
        return Y(s.handleSetShowOnEdge(o.checked, r));
      }), x(), D(3), x(), X(4, Kde, 6, 3, "div", 19);
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(3);
      C(), U("checked", e.selected), C(2), Oe(" ", e.type, " "), C(), he(n.getEdgeItemHaveFilter(e) ? 4 : -1);
    }
  }
  function eue(i59, t) {
    if (i59 & 1 && (b(0, "div", 9)(1, "div"), D(2, "View on edges"), x()(), Qt(3, Jde, 5, 3, null, null, nH)), i59 & 2) {
      let e = T(2);
      C(3), Kt(e.showOnEdgeItems);
    }
  }
  function tue(i59, t) {
    if (i59 & 1 && (b(0, "div", 8)(1, "div", 9)(2, "div"), D(3, "View on nodes"), x(), b(4, "div", 10)(5, "mat-icon"), D(6, "close"), x()()(), Qt(7, Qde, 4, 3, null, null, nH), X(9, eue, 5, 0), x()), i59 & 2) {
      let e = T();
      C(7), Kt(e.showOnNodeItems), C(2), he(e.showOnEdgeItems.length > 0 ? 9 : -1);
    }
  }
  function nue(i59, t) {
    i59 & 1 && (b(0, "div", 21), D(1, " Use regex to match "), b(2, "span", 22), D(3), x(), D(4, " or "), b(5, "span", 22), D(6), x(), D(7, ". "), ae(8, "br")(9, "br"), D(10, " Examples:"), ae(11, "br"), b(12, "ul")(13, "li")(14, "span", 23), D(15, "axis:"), x(), D(16, " will match attributes whose key is "), b(17, "span", 22), D(18, "axis"), x(), D(19, ". "), x(), b(20, "li")(21, "span", 23), D(22, "padding=[SAME|VALID]"), x(), D(23, " will match attributes whose key is "), b(24, "span", 22), D(25, "padding"), x(), D(26, " and value is either "), b(27, "span", 22), D(28, "SAME"), x(), D(29, " or "), b(30, "span", 22), D(31, "VALID"), x(), D(32, ". "), x()()()), i59 & 2 && (C(3), wc("", "{", "key", "}", ":", "{", "value", "}", ""), C(3), wc("", "{", "key", "}", "=", "{", "value", "}", ""));
  }
  var iue = [Wt.OP_NODE_ID, Wt.OP_ATTRS, Wt.OP_INPUTS, Wt.OP_OUTPUTS, Wt.LAYER_NODE_CHILDREN_COUNT, Wt.LAYER_NODE_DESCENDANTS_COUNT, Wt.LAYER_NODE_ATTRS];
  var rue = [hn.OFF, hn.TENSOR_SHAPE, hn.SOURCE_NODE_ATTR, hn.TARGET_NODE_ATTR, hn.OUTPUT_METADATA, hn.INPUT_METADATA];
  var iH = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      localStorageService;
      nodeDataProviderExtensionService;
      rendererId;
      paneId;
      inPopup = false;
      popup;
      savedShowOnNodeItemTypes;
      nodeDataProviderRunNames = It(() => {
        let e = this.appService.getModelGraphFromPane(this.paneId);
        return (e ? Object.values(this.nodeDataProviderExtensionService.getRunsForModelGraph(e)) : []).map((r) => va(r, e));
      });
      savedNodeDataProviderRunNames = [];
      savedShowOnEdgeItems;
      helpPopupSize = { minWidth: 0, minHeight: 0 };
      viewPopupSize = { minWidth: 280, minHeight: 0, maxHeight: 800 };
      showOnNodeItems = [];
      showOnEdgeItems = [];
      curOpAttrsFilterText = "";
      curGroupAttrsFilterText = "";
      curSourceNodeAttrKeyText = "";
      curTargetNodeAttrKeyText = "";
      curOutputMetadataKeyText = "";
      curInputMetadataKeyText = "";
      opened = false;
      constructor(e, n, r, o) {
        this.appService = e, this.changeDetectorRef = n, this.localStorageService = r, this.nodeDataProviderExtensionService = o, ht(() => {
          let a = this.appService.getPaneById(this.paneId)?.showOnNodeItemTypes || {}, l = this.nodeDataProviderRunNames();
          if (a === this.savedShowOnNodeItemTypes && JSON.stringify(l) === JSON.stringify(this.savedNodeDataProviderRunNames)) return;
          this.savedNodeDataProviderRunNames = l, this.savedShowOnNodeItemTypes = a;
          let c = this.appService.config(), d = [];
          for (let u of iue) {
            if (c?.viewOnNodeConfig?.hideOpNodeId && u === Wt.OP_NODE_ID || c?.viewOnNodeConfig?.hideOpNodeAttributes && u === Wt.OP_ATTRS || c?.viewOnNodeConfig?.hideOpNodeInputs && u === Wt.OP_INPUTS || c?.viewOnNodeConfig?.hideOpNodeOutputs && u === Wt.OP_OUTPUTS || c?.viewOnNodeConfig?.hideLayerNodeChildrenCount && u === Wt.LAYER_NODE_CHILDREN_COUNT || c?.viewOnNodeConfig?.hideLayerNodeDescendantsCount && u === Wt.LAYER_NODE_DESCENDANTS_COUNT || c?.viewOnNodeConfig?.hideLayerNodeAttributes && u === Wt.LAYER_NODE_ATTRS) continue;
            let h = { type: u, selected: (a[this.rendererId] || {})[u]?.selected };
            d.push(h), u === Wt.OP_ATTRS ? (h.filterRegex = (a[this.rendererId] || {})[u]?.filterRegex || "", this.curOpAttrsFilterText = h.filterRegex) : u === Wt.LAYER_NODE_ATTRS && (h.filterRegex = (a[this.rendererId] || {})[u]?.filterRegex || "", this.curGroupAttrsFilterText = h.filterRegex);
          }
          for (let u of this.savedNodeDataProviderRunNames) {
            let h = `${ga}${u}`;
            d.push({ type: h, selected: (a[this.rendererId] || {})[h]?.selected });
          }
          this.showOnNodeItems = d, this.changeDetectorRef.markForCheck();
        }), ht(() => {
          let a = this.appService.getPaneById(this.paneId)?.showOnEdgeItems || {};
          if (a === this.savedShowOnEdgeItems) return;
          this.savedShowOnEdgeItems = a;
          let l = a[this.rendererId];
          this.curInputMetadataKeyText = l?.inputMetadataKey ?? "", this.curOutputMetadataKeyText = l?.outputMetadataKey ?? "", this.curSourceNodeAttrKeyText = l?.sourceNodeAttrKey ?? "", this.curTargetNodeAttrKeyText = l?.targetNodeAttrKey ?? "";
          let c = [];
          if (!this.appService.config()?.viewOnNodeConfig?.hideViewOnEdgesSection) for (let d of rue) {
            let u = { type: d, selected: d === a[this.rendererId]?.type };
            d === hn.OFF && a[this.rendererId] == null && (u.selected = true), c.push(u);
          }
          this.showOnEdgeItems = c, this.changeDetectorRef.markForCheck();
        });
      }
      handleClickOnViewOnNode(e) {
        this.opened && this.popup.closeDialog();
      }
      handleToggleShowOnNode(e) {
        this.appService.toggleShowOnNode(this.paneId, this.rendererId, e.type), this.saveShowOnNodeItemsToLocalStorage();
      }
      handleSetShowOnEdge(e, n) {
        this.appService.setShowOnEdge(this.paneId, this.rendererId, n.type, this.getEdgeItemMetadataKeyText(n), this.curOutputMetadataKeyText, this.curInputMetadataKeyText, this.curSourceNodeAttrKeyText, this.curTargetNodeAttrKeyText), this.saveShowOnEdgeItemsToLocalStorage();
      }
      handleAttrsFilterChanged(e) {
        this.appService.setShowOnNodeFilter(this.paneId, this.rendererId, e.type, this.getAttrsFilterText(e)), this.saveShowOnNodeItemsToLocalStorage();
      }
      handleEdgeItemFilterChanged(e) {
        this.appService.setShowOnEdge(this.paneId, this.rendererId, e.type, this.getEdgeItemMetadataKeyText(e), this.curOutputMetadataKeyText, this.curInputMetadataKeyText, this.curSourceNodeAttrKeyText, this.curTargetNodeAttrKeyText), this.saveShowOnEdgeItemsToLocalStorage();
      }
      getShowOnNodeItemLabel(e) {
        switch (e.type) {
          case Wt.OP_NODE_ID:
            return this.appService.config()?.viewOnNodeConfig?.renameOpNodeIdTo ?? e.type;
          case Wt.OP_ATTRS:
            return this.appService.config()?.viewOnNodeConfig?.renameOpNodeAttributesTo ?? e.type;
          case Wt.OP_INPUTS:
            return this.appService.config()?.viewOnNodeConfig?.renameOpNodeInputsTo ?? e.type;
          case Wt.OP_OUTPUTS:
            return this.appService.config()?.viewOnNodeConfig?.renameOpNodeOutputsTo ?? e.type;
          default:
            return e.type;
        }
      }
      getAttrsFilterText(e) {
        switch (e.type) {
          case Wt.OP_ATTRS:
            return this.curOpAttrsFilterText;
          case Wt.LAYER_NODE_ATTRS:
            return this.curGroupAttrsFilterText;
          default:
            return "";
        }
      }
      setAttrsFilterText(e, n) {
        switch (e.type) {
          case Wt.OP_ATTRS:
            this.curOpAttrsFilterText = n;
            break;
          case Wt.LAYER_NODE_ATTRS:
            this.curGroupAttrsFilterText = n;
            break;
          default:
            break;
        }
      }
      getEdgeItemMetadataKeyText(e) {
        switch (e.type) {
          case hn.OUTPUT_METADATA:
            return this.curOutputMetadataKeyText;
          case hn.INPUT_METADATA:
            return this.curInputMetadataKeyText;
          case hn.SOURCE_NODE_ATTR:
            return this.curSourceNodeAttrKeyText;
          case hn.TARGET_NODE_ATTR:
            return this.curTargetNodeAttrKeyText;
          default:
            return "";
        }
      }
      setEdgeItemMetadataKeyText(e, n) {
        switch (e.type) {
          case hn.OUTPUT_METADATA:
            this.curOutputMetadataKeyText = n;
            break;
          case hn.INPUT_METADATA:
            this.curInputMetadataKeyText = n;
            break;
          case hn.SOURCE_NODE_ATTR:
            this.curSourceNodeAttrKeyText = n;
            break;
          case hn.TARGET_NODE_ATTR:
            this.curTargetNodeAttrKeyText = n;
            break;
          default:
            break;
        }
      }
      getIsAttrs(e) {
        return e.type === Wt.OP_ATTRS || e.type === Wt.LAYER_NODE_ATTRS;
      }
      getEdgeItemHaveFilter(e) {
        return e.type === hn.OUTPUT_METADATA || e.type === hn.INPUT_METADATA || e.type === hn.SOURCE_NODE_ATTR || e.type === hn.TARGET_NODE_ATTR;
      }
      getEdgeItemPlaceholder(e) {
        switch (e.type) {
          case hn.OUTPUT_METADATA:
          case hn.INPUT_METADATA:
            return "Metadata key";
          case hn.SOURCE_NODE_ATTR:
          case hn.TARGET_NODE_ATTR:
            return "Attribute key";
          default:
            return "";
        }
      }
      saveShowOnNodeItemsToLocalStorage() {
        if (!this.inPopup && !this.appService.testMode) {
          let e = this.appService.getShowOnNodeItemTypes(this.paneId, this.rendererId), n = Object.keys(e).filter((r) => r.startsWith(ga));
          for (let r of n) delete e[r];
          this.localStorageService.setItem(Ty, JSON.stringify(e));
        }
      }
      saveShowOnEdgeItemsToLocalStorage() {
        if (!this.inPopup && !this.appService.testMode) {
          let e = this.appService.getShowOnEdgeItem(this.paneId, this.rendererId);
          this.localStorageService.setItem(Iy, JSON.stringify(e));
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(Io), K(Cr));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["view-on-node"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Xr, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.popup = o.first);
        }
      }, inputs: { rendererId: "rendererId", paneId: "paneId", inPopup: "inPopup" }, decls: 10, vars: 5, consts: [["help", ""], ["viewPopup", ""], ["helpPopup", ""], ["input", ""], [1, "container", 3, "bubble", "overlaySize", "hoverDelayMs"], [1, "mat-icon-container", "view", 3, "opened", "closed", "click", "bubbleClick", "overlaySize"], [1, "toolbar-icon"], [1, "model-explorer-help-popup"], [1, "model-explorer-view-popup"], [1, "label"], ["bubbleClose", "", 1, "icon-container", "close"], [1, "show-on-node-item", 3, "click"], ["type", "checkbox", 3, "checked"], [1, "show-on-node-filter"], ["placeholder", "Filter by regex", 1, "input-attrs-filter", 3, "keydown.enter", "input", "change", "disabled", "value"], [1, "icon-container", 3, "bubble", "hoverDelayMs"], [1, "icon-container", "ok", 3, "click"], [1, "show-on-node-item"], ["type", "radio", "name", "show-on-edge", 3, "change", "checked"], [1, "show-on-node-filter", "on-edge"], [1, "input-attrs-filter", 3, "keydown.enter", "input", "change", "placeholder", "disabled", "value"], [1, "model-explorer-view-on-node-help-popup"], [1, "code"], [1, "code", "regex"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 4)(1, "div", 5), Z("opened", function() {
            return q(o), Y(r.opened = true);
          })("closed", function() {
            return q(o), Y(r.opened = false);
          })("click", function(a) {
            return q(o), Y(r.handleClickOnViewOnNode(a));
          }), b(2, "mat-icon", 6), D(3, "visibility"), x()()(), X(4, Xde, 2, 0, "ng-template", null, 0, Tt)(6, tue, 10, 1, "ng-template", null, 1, Tt)(8, nue, 33, 8, "ng-template", null, 2, Tt);
        }
        if (n & 2) {
          let o = Ce(5), s = Ce(7);
          U("bubble", o)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(), U("bubbleClick", s)("overlaySize", r.viewPopupSize);
        }
      }, dependencies: [Bn, Xr, et, vt, St, tn], styles: [`.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{width:20px;height:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;opacity:.6}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]:hover{opacity:.9}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px}  .model-explorer-view-popup{padding:10px 12px 12px;font-size:12px;background-color:#fff;display:flex;flex-direction:column}  .model-explorer-view-popup .label{font-weight:500;font-size:11px;text-transform:uppercase;margin-bottom:6px;display:flex;align-items:center;justify-content:space-between}  .model-explorer-view-popup .label:not(:first-child){margin-top:12px}  .model-explorer-view-popup .label .icon-container{cursor:pointer;opacity:.7;display:flex;align-items:center;justify-content:center}  .model-explorer-view-popup .label .icon-container:hover{opacity:1}  .model-explorer-view-popup .label mat-icon{font-size:20px;width:20px;height:20px;color:#999}  .model-explorer-view-popup .show-on-node-item{display:flex;align-items:center;gap:4px;cursor:pointer;color:#555;-webkit-user-select:none;user-select:none}  .model-explorer-view-popup .show-on-node-item input[type=checkbox]{cursor:pointer}  .model-explorer-view-popup .show-on-node-item input[type=radio]{margin-bottom:4px;cursor:pointer}  .model-explorer-view-popup .show-on-node-filter{margin:1px 0 4px 25px;display:flex;align-items:center;position:relative}  .model-explorer-view-popup .show-on-node-filter:focus-within .icon-container.ok{visibility:visible}  .model-explorer-view-popup .show-on-node-filter.on-edge{margin-right:20px}  .model-explorer-view-popup .show-on-node-filter.on-edge .icon-container.ok{right:6px}  .model-explorer-view-popup .show-on-node-filter input{flex-grow:1;box-sizing:border-box;border:1px solid #aaa;border-radius:3px;padding:3px 26px 3px 4px;width:200px}  .model-explorer-view-popup .show-on-node-filter input::placeholder{color:#aaa}  .model-explorer-view-popup .show-on-node-filter .icon-container{display:flex;align-items:center;justify-content:center;opacity:.8;cursor:pointer;margin-left:4px}  .model-explorer-view-popup .show-on-node-filter .icon-container:hover{opacity:1}  .model-explorer-view-popup .show-on-node-filter .icon-container.ok{position:absolute;right:26px;visibility:hidden}  .model-explorer-view-popup .show-on-node-filter .icon-container mat-icon{font-size:16px;width:16px;height:16px;color:#999}  .model-explorer-view-on-node-help-popup{padding:12px;font-size:12px;background-color:#fff}  .model-explorer-view-on-node-help-popup ul{margin-block-end:0}  .model-explorer-view-on-node-help-popup .code{display:inline-block;background-color:#fffdd0;font-family:monospace}  .model-explorer-view-on-node-help-popup .code.regex{background-color:#e6d0ff}  .cdk-overlay-container:has(.model-explorer-view-popup) .cdk-overlay-backdrop{pointer-events:none}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var oue = ["webglRenderer"];
  function sue(i59, t) {
    if (i59 & 1 && (bc(0), ae(1, "search-bar", 21)(2, "div", 15), xc()), i59 & 2) {
      let e = T(2);
      C(), U("curModelGraph", e.modelGraph)("rendererId", e.rendererId);
    }
  }
  function aue(i59, t) {
    i59 & 1 && (b(0, "div", 22), D(1, " Zoom to fit "), b(2, "div", 23)(3, "mat-icon"), D(4, "keyboard"), x(), D(5, " Shortcut: SPACE "), x()());
  }
  function lue(i59, t) {
    i59 & 1 && (b(0, "div", 22), D(1, " Expand all layers in the graph "), x());
  }
  function cue(i59, t) {
    i59 & 1 && (b(0, "div", 22), D(1, " Collapse all layers in the graph "), x());
  }
  function due(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 24), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickExpandAllLayers());
      }), b(1, "mat-icon", 25), D(2, "unfold_more_double"), x()(), X(3, lue, 2, 0, "ng-template", null, 3, Tt), b(5, "div", 26), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickCollapseAllLayers());
      }), b(6, "mat-icon", 27), D(7, "unfold_less_double"), x()(), X(8, cue, 2, 0, "ng-template", null, 4, Tt), ae(10, "div", 15);
    }
    if (i59 & 2) {
      let e = Ce(4), n = Ce(9), r = T(2);
      ye("disable", r.disableExpandCollapseAllButton), U("bubble", e)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(5), ye("disable", r.disableExpandCollapseAllButton), U("bubble", n)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10);
    }
  }
  function uue(i59, t) {
    i59 & 1 && (b(0, "div", 22), D(1, " Flatten all layers in the graph "), b(2, "div", 30), D(3, " Nodes will be laid out without any layers data "), x()());
  }
  function hue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 28), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickFlattenAllLayers());
      }), b(1, "mat-icon", 29), D(2, "layers_clear"), x()(), ae(3, "div", 15), X(4, uue, 4, 0, "ng-template", null, 5, Tt);
    }
    if (i59 & 2) {
      let e = Ce(5), n = T(2);
      ye("enabled", n.flattenAllLayers()), U("bubble", e)("overlaySize", n.helpPopupSize)("hoverDelayMs", 10);
    }
  }
  function pue(i59, t) {
    i59 & 1 && (b(0, "span"), D(1, "Disable inputs/outputs tracing"), x());
  }
  function fue(i59, t) {
    i59 & 1 && (b(0, "span"), D(1, "Enable inputs/outputs tracing"), x());
  }
  function mue(i59, t) {
    if (i59 & 1 && (b(0, "div", 22), X(1, pue, 2, 0, "span")(2, fue, 2, 0, "span"), b(3, "div", 30), D(4, " Highlight selected op node's ancestors and descendants and dim the rest "), x()()), i59 & 2) {
      let e = T(2);
      C(), he(e.tracing ? 1 : 2);
    }
  }
  function gue(i59, t) {
    if (i59 & 1 && ae(0, "edge-overlays-dropdown", 20), i59 & 2) {
      let e = T(2);
      U("rendererId", e.rendererId)("paneId", e.paneId);
    }
  }
  function _ue(i59, t) {
    i59 & 1 && (b(0, "div", 22), D(1, " Download graph as PNG "), b(2, "div", 30), D(3, " The maximum PNG size is limited to 5000 x 5000 "), x()());
  }
  function vue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      ae(0, "div", 15), b(1, "div", 31), Z("menuOpened", function() {
        q(e);
        let r = T(2);
        return Y(r.disableDownloadPngHelpPopup = true);
      })("menuClosed", function() {
        q(e);
        let r = T(2);
        return Y(r.disableDownloadPngHelpPopup = false);
      }), b(2, "mat-icon", 32), D(3, " image "), x()(), X(4, _ue, 4, 0, "ng-template", null, 6, Tt), b(6, "mat-menu", 33, 7)(8, "div", 34), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickDownloadAsPng(false));
      }), D(9, " Graph in current viewport "), x(), b(10, "div", 34), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickDownloadAsPng(true));
      }), D(11, " Full graph "), x(), b(12, "div", 35), Z("click", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleClickToggleTransparentPngBackground(r));
      }), ae(13, "input", 36), D(14, " Transparent background "), x()();
    }
    if (i59 & 2) {
      let e = Ce(5), n = Ce(7), r = T(2);
      C(), U("bubble", e)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10)("bubbleDisabled", r.disableDownloadPngHelpPopup)("matMenuTriggerFor", n), C(12), U("formControl", r.transparentPngBackground);
    }
  }
  function yue(i59, t) {
    if (i59 & 1 && (bc(0), ae(1, "div", 15)(2, "snapshot-manager", 20), xc()), i59 & 2) {
      let e = T(2);
      C(2), U("rendererId", e.rendererId)("paneId", e.paneId);
    }
  }
  function bue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 12), X(1, sue, 3, 2, "ng-container", 13), ae(2, "view-on-node", 14)(3, "div", 15), b(4, "div", 16), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickZoomFitIcon());
      }), b(5, "mat-icon", 17), D(6, "fit_screen"), x()(), ae(7, "div", 15), X(8, aue, 6, 0, "ng-template", null, 1, Tt)(10, due, 11, 10)(11, hue, 6, 5), b(12, "div", 18), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickTrace());
      }), b(13, "mat-icon", 19), D(14, " multiple_stop "), x()(), X(15, mue, 5, 1, "ng-template", null, 2, Tt)(17, gue, 1, 2, "edge-overlays-dropdown", 20)(18, vue, 15, 6)(19, yue, 3, 2, "ng-container", 13), x();
    }
    if (i59 & 2) {
      let e = Ce(9), n = Ce(16), r = T();
      ye("in-popup", r.inPopup)("pushed-down", r.showSubgraphBreadcrumbs), C(), U("ngIf", r.showSearchBar), C(), U("rendererId", r.rendererId)("paneId", r.paneId)("inPopup", r.inPopup), C(2), U("bubble", e)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(6), he(r.showExpandCollapseAllLayers ? 10 : -1), C(), he(r.showFlattenLayers ? 11 : -1), C(), ye("enabled", r.tracing), U("bubble", n)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(5), he(r.showEdgeOverlaysDropdown ? 17 : -1), C(), he(r.showDownloadPng ? 18 : -1), C(), U("ngIf", r.showSnapshotManager);
    }
  }
  function xue(i59, t) {
    if (i59 & 1 && ae(0, "subgraph-breadcrumbs", 37), i59 & 2) {
      let e = T();
      U("paneId", e.paneId);
    }
  }
  var Iw = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      modelGraph;
      rendererId;
      paneId;
      rootNodeId;
      inPopup = false;
      openInPopupClicked = new Ue();
      webglRenderer;
      helpPopupSize = { minWidth: 0, minHeight: 0, maxWidth: 340 };
      flattenAllLayers = It(() => this.appService.getFlattenLayers(this.paneId));
      disableDownloadPngHelpPopup = false;
      transparentPngBackground = new qr(false);
      curSubgraphBreadcrumbs = [];
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n, ht(() => {
          let r = this.appService.getPaneById(this.paneId);
          this.curSubgraphBreadcrumbs = r?.subgraphBreadcrumbs || [], this.changeDetectorRef.markForCheck();
        });
      }
      handleOpenOnPopupClicked(e) {
        this.openInPopupClicked.emit(e);
      }
      handleClickZoomFitIcon() {
        this.appService.spaceKeyToZoomFitClicked.next({});
      }
      handleClickExpandAllLayers() {
        this.appService.expandOrCollapseAllGraphLayersClicked.next({ expandOrCollapse: true, rendererId: this.rendererId });
      }
      handleClickCollapseAllLayers() {
        this.appService.expandOrCollapseAllGraphLayersClicked.next({ expandOrCollapse: false, rendererId: this.rendererId });
      }
      handleClickFlattenAllLayers() {
        let e = this.appService.getPaneById(this.paneId)?.selectedNodeInfo?.nodeId;
        e != null && ct(this.modelGraph.nodesById[e]) && this.appService.selectNode(this.paneId, void 0), this.appService.toggleFlattenLayers(this.paneId), this.appService.processGraph(this.paneId, this.appService.getFlattenLayers(this.paneId)), this.appService.curInitialUiState.set(void 0);
      }
      handleClickDownloadAsPng(e) {
        this.appService.downloadAsPngClicked.next({ rendererId: this.rendererId, fullGraph: e, transparentBackground: this.transparentPngBackground.value === true });
      }
      handleClickTrace() {
        this.webglRenderer?.toggleIoTrace();
      }
      handleClickToggleTransparentPngBackground(e) {
        e.stopPropagation(), this.transparentPngBackground.setValue(!this.transparentPngBackground.value);
      }
      getActiveSelectedNodeInfo() {
        return this.webglRenderer?.getActiveSelectedNodeInfo();
      }
      get showSearchBar() {
        return !this.inPopup;
      }
      get showExpandCollapseAllLayers() {
        return !this.inPopup && this.appService.config()?.toolbarConfig?.hideExpandCollapseAllLayers !== true;
      }
      get showFlattenLayers() {
        return !this.inPopup && this.appService.config()?.toolbarConfig?.hideFlattenAllLayers !== true;
      }
      get showDownloadPng() {
        return !this.inPopup;
      }
      get showSnapshotManager() {
        return !this.inPopup;
      }
      get showSubgraphBreadcrumbs() {
        return !this.inPopup && this.curSubgraphBreadcrumbs.length > 1;
      }
      get showEdgeOverlaysDropdown() {
        return !this.inPopup && this.appService.config()?.toolbarConfig?.hideCustomEdgeOverlays !== true;
      }
      get disableExpandCollapseAllButton() {
        return this.appService.getFlattenLayers(this.paneId);
      }
      get tracing() {
        return this.webglRenderer?.tracing === true;
      }
      get showToolBar() {
        return !this.appService.config()?.hideToolBar;
      }
      get isTestMode() {
        return this.appService.testMode;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["renderer-wrapper"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(oue, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.webglRenderer = o.first);
        }
      }, inputs: { modelGraph: "modelGraph", rendererId: "rendererId", paneId: "paneId", rootNodeId: "rootNodeId", inPopup: "inPopup" }, outputs: { openInPopupClicked: "openInPopupClicked" }, decls: 5, vars: 7, consts: [["webglRenderer", ""], ["helpZoomToFit", ""], ["helpTraceIO", ""], ["helpExpandAll", ""], ["helpCollapseAll", ""], ["helpFlattenLayers", ""], ["helpDownloadPng", ""], ["menu", "matMenu"], [1, "container"], [3, "openInPopupClicked", "modelGraph", "rendererId", "paneId", "rootNodeId", "inPopup"], [1, "toolbar", 3, "in-popup", "pushed-down"], [3, "paneId", 4, "ngIf"], [1, "toolbar"], [4, "ngIf"], [3, "rendererId", "paneId", "inPopup"], [1, "vertical-divider"], [1, "mat-icon-container", "zoom-fit", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon"], [1, "mat-icon-container", "trace-io", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon", "trace"], [3, "rendererId", "paneId"], [3, "curModelGraph", "rendererId"], [1, "model-explorer-help-popup"], [1, "shortcut"], [1, "mat-icon-container", "expand-all", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon", "expand-all"], [1, "mat-icon-container", "collapse-all", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon", "collapse-all"], [1, "mat-icon-container", "flatten-layers", 3, "click", "bubble", "overlaySize", "hoverDelayMs"], [1, "toolbar-icon", "flatten-layers"], [1, "description"], [1, "mat-icon-container", "download-png", 3, "menuOpened", "menuClosed", "bubble", "overlaySize", "hoverDelayMs", "bubbleDisabled", "matMenuTriggerFor"], [1, "toolbar-icon", "download-png"], [1, "model-explorer-download-png-menu"], [1, "menu-item", 3, "click"], [1, "transparent-background-toggle", 3, "click"], ["type", "checkbox", 3, "formControl"], [3, "paneId"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 8)(1, "webgl-renderer", 9, 0), Z("openInPopupClicked", function(a) {
            return q(o), Y(r.handleOpenOnPopupClicked(a));
          }), x(), X(3, bue, 20, 21, "div", 10)(4, xue, 1, 1, "subgraph-breadcrumbs", 11), x();
        }
        n & 2 && (C(), U("modelGraph", r.modelGraph)("rendererId", r.rendererId)("paneId", r.paneId)("rootNodeId", r.rootNodeId)("inPopup", r.inPopup), C(2), he(r.showToolBar ? 3 : -1), C(), U("ngIf", r.showSubgraphBreadcrumbs));
      }, dependencies: [Bn, et, In, LG, Hn, vt, St, Vl, $s, cp, tn, Do, kf, Ps, Jo, JG, eH, tH, iH, Cw], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;overflow:hidden;position:relative}.container[_ngcontent-%COMP%]   svg-rednerer[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   webgl-rednerer[_ngcontent-%COMP%]{width:100%;height:100%}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]{position:absolute;top:8px;left:12px;padding:0 8px 0 6px;box-sizing:border-box;height:40px;display:flex;background-color:#edf2fa;border-radius:99px;align-items:center;outline:2px solid white}.container[_ngcontent-%COMP%]   .toolbar.in-popup[_ngcontent-%COMP%]{padding-left:10px}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]:has(search-bar  input:focus){border-color:#1a73e8}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   search-bar[_ngcontent-%COMP%]{margin-right:4px}.container[_ngcontent-%COMP%]   .toolbar.pushed-down[_ngcontent-%COMP%]{top:44px}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{width:24px;height:24px;display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   .mat-icon-container.enabled[_ngcontent-%COMP%]{background-color:#ffdeb1;outline:1px solid #ea8600;border-radius:4px}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   .mat-icon-container.disable[_ngcontent-%COMP%]{opacity:.2;pointer-events:none}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px;cursor:pointer;opacity:.6}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon[_ngcontent-%COMP%]:hover{opacity:.9}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon.expand-all[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon.collapse-all[_ngcontent-%COMP%]{font-size:18px;width:18px;height:18px}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon.flatten-layers[_ngcontent-%COMP%]{font-size:20px;width:20px;height:20px;border:1px solid transparent}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   mat-icon.toolbar-icon.trace[_ngcontent-%COMP%]{transform:rotate(90deg);border:1px solid transparent}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   .vertical-divider[_ngcontent-%COMP%]{width:1px;border-left:1px solid #d0d0d0;margin:2px 5px;height:20px}.container[_ngcontent-%COMP%]   .toolbar[_ngcontent-%COMP%]   edge-overlays-dropdown[_ngcontent-%COMP%]{margin-left:4px}.container[_ngcontent-%COMP%]   subgraph-breadcrumbs[_ngcontent-%COMP%]{position:absolute;top:8px;left:12px}  bubble-container:has(.model-explorer-view-popup){border-top-left-radius:0;border-top-right-radius:0}  .model-explorer-download-png-menu .menu-item{letter-spacing:normal!important;font-family:Google Sans Text,Arial,Helvetica,sans-serif!important;font-size:12px;padding:0 8px;cursor:pointer;display:flex;align-items:center}  .model-explorer-download-png-menu .menu-item:hover{background-color:#eee}  .model-explorer-download-png-menu .transparent-background-toggle{display:flex;align-items:center;font-size:12px;letter-spacing:normal;padding:6px 8px 0 4px;border-top:1px solid #ddd;margin-top:8px;cursor:pointer}  .model-explorer-download-png-menu .transparent-background-toggle input{cursor:inherit}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var wue = ["rendererWrapper"];
  var Cue = 400;
  var Sue = 400;
  var Mue = 26;
  var rH = (() => {
    class i59 {
      appService;
      root;
      id;
      paneId;
      groupNode;
      initialPosition;
      curModelGraph;
      closeClicked = new Ue();
      rendererWrapper;
      selected = It(() => this.appService.curSelectedRenderer()?.id === this.rendererWrapper?.rendererId && this.appService.selectedPaneId() === this.paneId);
      minimized = false;
      savedHeight = "";
      mouseDownListener = (e) => {
        this.rendererWrapper && (this.appService.curSelectedRenderer.set({ id: this.rendererWrapper.rendererId, ownerType: ol.POPUP }), this.appService.selectNode(this.paneId, this.rendererWrapper.getActiveSelectedNodeInfo()), this.appService.selectPane(this.paneId));
      };
      constructor(e, n) {
        this.appService = e, this.root = n;
      }
      ngOnInit() {
        this.root.nativeElement.addEventListener("mousedown", this.mouseDownListener, true);
        let e = this.root.nativeElement;
        e.style.left = `${this.initialPosition.x}px`, e.style.top = `${this.initialPosition.y}px`, e.style.width = `${Cue}px`, e.style.height = `${Sue}px`;
      }
      ngOnDestroy() {
        this.root.nativeElement.removeEventListener("mousedown", this.mouseDownListener, true);
      }
      toggleMinimize() {
        this.minimized = !this.minimized, this.minimized ? (this.savedHeight = this.root.nativeElement.style.height, this.root.nativeElement.style.height = `${Mue}px`) : this.root.nativeElement.style.height = this.savedHeight;
      }
      handleMouseDown(e) {
        e.stopPropagation(), e.button !== 2 && new Sw(this.root.nativeElement).drag(e);
      }
      handleMouseUp(e) {
      }
      get title() {
        return this.groupNode.label;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(He));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["popup-panel"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(wue, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.rendererWrapper = o.first);
        }
      }, inputs: { id: "id", paneId: "paneId", groupNode: "groupNode", initialPosition: "initialPosition", curModelGraph: "curModelGraph" }, outputs: { closeClicked: "closeClicked" }, decls: 22, vars: 13, consts: [["rendererWrapper", ""], [1, "container", 3, "mousedown", "mouseup"], [1, "title", 3, "dblclick"], [1, "label"], [1, "icons-container"], [1, "mat-icon-container", "minimize", 3, "click"], [1, "mat-icon-container", "close", 3, "click"], [3, "modelGraph", "rendererId", "paneId", "rootNodeId", "inPopup"], [1, "resize-box", 3, "mousedown", "mouseup"], ["data-position", "top"], ["data-position", "bottom"], ["data-position", "left"], ["data-position", "right"], ["data-position", "top-right"], ["data-position", "top-left"], ["data-position", "bottom-right"], ["data-position", "bottom-left"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 1), Z("mousedown", function(a) {
            return q(o), Y(r.handleMouseDown(a));
          })("mouseup", function(a) {
            return q(o), Y(r.handleMouseUp(a));
          }), b(1, "div", 2), Z("dblclick", function() {
            return q(o), Y(r.toggleMinimize());
          }), b(2, "div", 3), D(3), x(), b(4, "div", 4)(5, "div", 5), Z("click", function() {
            return q(o), Y(r.toggleMinimize());
          }), b(6, "mat-icon"), D(7), x()(), b(8, "div", 6), Z("click", function() {
            return q(o), Y(r.closeClicked.emit(r.id));
          }), b(9, "mat-icon"), D(10, "close"), x()()()(), ae(11, "renderer-wrapper", 7, 0), x(), b(13, "div", 8), Z("mousedown", function(a) {
            return q(o), Y(r.handleMouseDown(a));
          })("mouseup", function(a) {
            return q(o), Y(r.handleMouseUp(a));
          }), ae(14, "div", 9)(15, "div", 10)(16, "div", 11)(17, "div", 12)(18, "div", 13)(19, "div", 14)(20, "div", 15)(21, "div", 16), x();
        }
        n & 2 && (ye("selected", r.selected())("minimized", r.minimized), C(3), Qe(r.title), C(4), Qe(r.minimized ? "unfold_more" : "unfold_less"), C(4), U("modelGraph", r.curModelGraph)("rendererId", r.id)("paneId", r.paneId)("rootNodeId", r.groupNode.id)("inPopup", true), C(2), ye("disabled", r.minimized));
      }, dependencies: [vt, St, Iw], styles: [`[_nghost-%COMP%]{position:absolute;-webkit-user-select:none;user-select:none}.container[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;flex-direction:column;font-size:13px;outline:2px solid transparent;position:relative;background-color:#fff;border-radius:4px;overflow:hidden;border:2px solid #aaa;cursor:pointer}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{height:27px;border-bottom:1px solid #ccc;box-sizing:border-box;background-color:#e7f3ff;display:flex;align-items:center;justify-content:space-between;flex-shrink:0;overflow:hidden;border-top-left-radius:2px;border-top-right-radius:2px;white-space:nowrap}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{flex-grow:1;overflow:hidden;text-overflow:ellipsis;box-sizing:border-box;padding-left:8px;padding-right:4px}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .icons-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{width:24px;display:flex;align-items:center;justify-content:center;opacity:.6;cursor:pointer}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;font-weight:700;width:16px;height:16px}.container[_ngcontent-%COMP%]   renderer-wrapper[_ngcontent-%COMP%]{flex-grow:1;min-height:0}.container.selected[_ngcontent-%COMP%]{box-shadow:0 4px 6px -1px #0000001a,0 2px 4px -2px #0000001a}.container.selected[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{background-color:#ea8600;color:#fff}.container.minimized[_ngcontent-%COMP%]   svg-renderer[_ngcontent-%COMP%]{display:none}.resize-box[_ngcontent-%COMP%]{position:absolute;inset:-4px;pointer-events:none;z-index:100}.resize-box.disabled[_ngcontent-%COMP%]   [data-position][_ngcontent-%COMP%]{pointer-events:none}.resize-box[_ngcontent-%COMP%]   div[_ngcontent-%COMP%]{position:absolute;pointer-events:all;background-color:transparent}.resize-box[_ngcontent-%COMP%]   [data-position=top][_ngcontent-%COMP%]{top:0;width:100%;height:8px;cursor:ns-resize}.resize-box[_ngcontent-%COMP%]   [data-position=bottom][_ngcontent-%COMP%]{bottom:0;width:100%;height:8px;cursor:ns-resize}.resize-box[_ngcontent-%COMP%]   [data-position=left][_ngcontent-%COMP%]{left:0;height:100%;width:8px;cursor:ew-resize}.resize-box[_ngcontent-%COMP%]   [data-position=right][_ngcontent-%COMP%]{right:0;height:100%;width:8px;cursor:ew-resize}.resize-box[_ngcontent-%COMP%]   [data-position=top-right][_ngcontent-%COMP%]{top:0;right:0;height:8px;width:8px;cursor:nesw-resize}.resize-box[_ngcontent-%COMP%]   [data-position=top-left][_ngcontent-%COMP%]{top:0;left:0;height:8px;width:8px;cursor:nwse-resize}.resize-box[_ngcontent-%COMP%]   [data-position=bottom-left][_ngcontent-%COMP%]{bottom:0;left:0;height:8px;width:8px;cursor:nesw-resize}.resize-box[_ngcontent-%COMP%]   [data-position=bottom-right][_ngcontent-%COMP%]{bottom:0;right:0;height:8px;width:8px;cursor:nwse-resize}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function Eue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "button", 5), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickExportToResource());
      }), b(1, "mat-icon"), D(2, "drive_folder_upload"), x(), D(3, " Export to resource "), x();
    }
  }
  function Tue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "button", 5), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickExportSelectedNodes());
      }), b(1, "mat-icon"), D(2), x(), D(3), x();
    }
    if (i59 & 2) {
      let e = T(2);
      C(2), Qe(e.exportSelectedNodesButtonIcon), C(), Oe(" ", e.exportSelectedNodesButtonLabel, " ");
    }
  }
  function Iue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 0)(1, "div", 1), D(2, " Selection "), x(), b(3, "div", 2), D(4), b(5, "div", 3), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickClear());
      }), D(6, " Clear "), x()(), b(7, "div", 4)(8, "button", 5), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickDownloadSubgraph());
      }), D(9, " Download subgraph "), x(), X(10, Eue, 4, 0, "button", 6)(11, Tue, 4, 2, "button", 6), x()();
    }
    if (i59 & 2) {
      let e = T();
      C(4), Oe(" ", e.selectedNodeCountLabel(), " "), C(6), he(e.enableExportToResource ? 10 : -1), C(), he(e.enableExportSelectedNodes ? 11 : -1);
    }
  }
  var oH = (() => {
    class i59 {
      appService;
      subgraphSelectionService;
      paneId;
      hasSelectedNodes;
      selectedNodeCountLabel = It(() => {
        let e = this.subgraphSelectionService.selectedNodeCount();
        return `${e} node${e === 1 ? "" : "s"}`;
      });
      constructor(e, n) {
        this.appService = e, this.subgraphSelectionService = n, this.hasSelectedNodes = this.subgraphSelectionService.hasSelectedNodes;
      }
      handleClickClear() {
        this.subgraphSelectionService.clearSelection();
      }
      handleClickDownloadSubgraph() {
        let e = this.subgraphSelectionService.getSelectedSubgraph();
        if (!e) return;
        let n = document.createElement("a");
        n.download = `${e.collectionLabel}_subgraph.json`;
        let r = `data:text/json;charset=utf-8, ${encodeURIComponent(JSON.stringify([e], null, 2))}`;
        qs(n, r), n.click();
      }
      handleClickExportToResource() {
        let e = this.subgraphSelectionService.getSelectedSubgraph();
        e && Ny(`${e.collectionLabel ?? ""}_subgraph.json`, [e]);
      }
      handleClickExportSelectedNodes() {
        let e = this.subgraphSelectionService.selectedNodes(), n = this.appService.getModelGraphFromPane(this.paneId);
        window.parent.postMessage({ cmd: x2, nodes: e, graph_collection_label: n?.collectionLabel ?? "", graph_id: n?.id ?? "" }, "*");
      }
      get enableExportToResource() {
        return this.appService.config()?.enableExportToResource === true;
      }
      get enableExportSelectedNodes() {
        return this.appService.config()?.enableExportSelectedNodes === true;
      }
      get exportSelectedNodesButtonLabel() {
        return this.appService.config()?.exportSelectedNodesButtonLabel ?? "Export selected nodes";
      }
      get exportSelectedNodesButtonIcon() {
        return this.appService.config()?.exportSelectedNodesButtonIcon ?? "file_upload";
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Fo));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["selection-panel"]], inputs: { paneId: "paneId" }, decls: 1, vars: 1, consts: [[1, "container"], [1, "title"], [1, "content"], [1, "link-clear", 3, "click"], [1, "btns-container"], ["mat-flat-button", "", "color", "primary", 3, "click"], ["mat-flat-button", "", "color", "primary"]], template: function(n, r) {
        n & 1 && X(0, Iue, 12, 3, "div", 0), n & 2 && he(r.hasSelectedNodes() ? 0 : -1);
      }, dependencies: [et, Hn, vr, vt, St], styles: [`.container[_ngcontent-%COMP%]{font-size:12px;border:2px solid #09b83e;overflow:hidden;border-radius:6px;background-color:#fff}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{padding:6px 8px;background-color:#09b83e;color:#fff;font-weight:500}.container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{padding:16px 8px 12px;display:flex;align-items:center;justify-content:space-between}.container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .link-clear[_ngcontent-%COMP%]{text-decoration:underline;color:#00639b;cursor:pointer;opacity:.8;-webkit-user-select:none;user-select:none}.container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .link-clear[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .btns-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;padding:8px;gap:8px}.container[_ngcontent-%COMP%]   .btns-container[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{letter-spacing:normal;width:100%}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Due = ["popupPanel"];
  function Pue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "renderer-wrapper", 5), Z("openInPopupClicked", function(r) {
        q(e);
        let o = T();
        return Y(o.handleOpenOnPopupClicked(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T();
      U("modelGraph", e.modelGraph)("rendererId", e.rendererId)("paneId", e.paneId);
    }
  }
  function Rue(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "popup-panel", 6, 0), Z("closeClicked", function(r) {
        q(e);
        let o = T();
        return Y(o.handleClickClosePanel(r));
      }), x();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T();
      U("id", e.id)("paneId", n.paneId)("groupNode", e.groupNode)("initialPosition", e.initialPosition)("curModelGraph", e.curModelGraph);
    }
  }
  function Oue(i59, t) {
    if (i59 & 1 && ae(0, "legends-panel", 4), i59 & 2) {
      let e = T();
      U("paneId", e.paneId);
    }
  }
  var sH = (() => {
    class i59 {
      root;
      appService;
      changeDetectorRef;
      subgraphSelectionService;
      modelGraph;
      rendererId;
      paneId;
      popupPanelComponents = new Ni();
      popupPanels = [];
      showRenderer = true;
      mouseDownListener = (e) => {
        e.target.closest("popup-panel") == null && this.appService.curSelectedRenderer.set({ id: this.rendererId, ownerType: ol.GRAPH_PANEL });
      };
      resizeObserver;
      constructor(e, n, r, o) {
        this.root = e, this.appService = n, this.changeDetectorRef = r, this.subgraphSelectionService = o, ht(() => {
          let s = this.appService.curSelectedRenderer(), a = this.root.nativeElement.querySelector("popup-panel.top");
          a && a.classList.remove("top");
          let l = this.popupPanelComponents.find((c) => c.rendererWrapper?.rendererId === s?.id);
          l && l.root.nativeElement.classList.add("top");
        });
      }
      ngOnInit() {
        this.root.nativeElement.addEventListener("mousedown", this.mouseDownListener, true), this.subgraphSelectionService.paneId = this.paneId;
      }
      ngOnChanges(e) {
        e.modelGraph && this.modelGraph && (this.subgraphSelectionService.clearSelection(), this.showRenderer = false, this.changeDetectorRef.detectChanges(), this.showRenderer = true, this.changeDetectorRef.detectChanges());
      }
      ngAfterViewInit() {
        let e = this.root.nativeElement;
        this.resizeObserver = new ResizeObserver((n) => {
          this.handleResize();
        }), this.resizeObserver.observe(e);
      }
      ngOnDestroy() {
        this.root.nativeElement.removeEventListener("mousedown", this.mouseDownListener, true), this.resizeObserver && this.resizeObserver.unobserve(this.root.nativeElement);
      }
      trackByPopupPanelId(e, n) {
        return n.id;
      }
      handleOpenOnPopupClicked(e) {
        this.popupPanels.push(e);
      }
      handleClickClosePanel(e) {
        let n = this.popupPanels.findIndex((r) => r.id === e);
        n >= 0 && this.popupPanels.splice(n, 1);
      }
      get showLegends() {
        return !this.appService.config()?.hideLegends;
      }
      handleResize() {
        let e = this.root.nativeElement;
        for (let n of this.popupPanelComponents) {
          let r = n.root.nativeElement;
          if (!r) continue;
          let o = Number(r.style.width.replace("px", "")), s = Number(r.style.height.replace("px", "")), a = Number(r.style.left.replace("px", "")) + o, l = Number(r.style.top.replace("px", "")) + s;
          a > e.offsetWidth && (r.style.left = `${e.offsetWidth - o}px`), l > e.offsetHeight && (r.style.top = `${e.offsetHeight - s}px`);
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(He), K(nt), K(Ge), K(Fo));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["graph-panel"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Due, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.popupPanelComponents = o);
        }
      }, inputs: { modelGraph: "modelGraph", rendererId: "rendererId", paneId: "paneId" }, features: [yn], decls: 5, vars: 5, consts: [["popupPanel", ""], [1, "container"], [3, "modelGraph", "rendererId", "paneId", "openInPopupClicked", 4, "ngIf"], [3, "id", "paneId", "groupNode", "initialPosition", "curModelGraph", "closeClicked", 4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "paneId"], [3, "openInPopupClicked", "modelGraph", "rendererId", "paneId"], [3, "closeClicked", "id", "paneId", "groupNode", "initialPosition", "curModelGraph"]], template: function(n, r) {
        n & 1 && (b(0, "div", 1), X(1, Pue, 1, 3, "renderer-wrapper", 2)(2, Rue, 2, 5, "popup-panel", 3)(3, Oue, 1, 1, "legends-panel", 4), ae(4, "selection-panel", 4), x()), n & 2 && (C(), U("ngIf", r.showRenderer), C(), U("ngForOf", r.popupPanels)("ngForTrackBy", r.trackByPopupPanelId), C(), he(r.showLegends ? 3 : -1), C(), U("paneId", r.paneId));
      }, dependencies: [et, Wr, In, OG, rH, Iw, oH], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;position:relative;overflow:hidden}.container[_ngcontent-%COMP%]   renderer-wrapper[_ngcontent-%COMP%]{width:100%;height:100%}.container[_ngcontent-%COMP%]   popup-panel.top[_ngcontent-%COMP%]{z-index:100}.container[_ngcontent-%COMP%]   legends-panel[_ngcontent-%COMP%]{position:absolute;left:8px;bottom:8px;border-radius:6px;border:1px solid #ddd;overflow:hidden}.container[_ngcontent-%COMP%]   selection-panel[_ngcontent-%COMP%]{position:absolute;right:8px;top:8px;overflow:hidden}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Aue = ["switch"];
  var Nue = ["*"];
  function kue(i59, t) {
    i59 & 1 && (b(0, "span", 10), to(), b(1, "svg", 12), ae(2, "path", 13), x(), b(3, "svg", 14), ae(4, "path", 15), x()());
  }
  var Lue = new Ee("mat-slide-toggle-default-options", { providedIn: "root", factory: () => ({ disableToggleValue: false, hideIcon: false, disabledInteractive: false }) });
  var Fue = { provide: kc, useExisting: Gr(() => aH), multi: true };
  var Dw = class {
    source;
    checked;
    constructor(t, e) {
      this.source = t, this.checked = e;
    }
  };
  var aH = (() => {
    class i59 {
      _elementRef = M(He);
      _focusMonitor = M(so);
      _changeDetectorRef = M(Ge);
      defaults = M(Lue);
      _onChange = (e) => {
      };
      _onTouched = () => {
      };
      _validatorOnChange = () => {
      };
      _uniqueId;
      _checked = false;
      _createChangeEvent(e) {
        return new Dw(this, e);
      }
      _labelId;
      get buttonId() {
        return `${this.id || this._uniqueId}-button`;
      }
      _switchElement;
      focus() {
        this._switchElement.nativeElement.focus();
      }
      _noopAnimations;
      _focused;
      name = null;
      id;
      labelPosition = "after";
      ariaLabel = null;
      ariaLabelledby = null;
      ariaDescribedby;
      required;
      color;
      disabled = false;
      disableRipple = false;
      tabIndex = 0;
      get checked() {
        return this._checked;
      }
      set checked(e) {
        this._checked = e, this._changeDetectorRef.markForCheck();
      }
      hideIcon;
      disabledInteractive;
      change = new Ue();
      toggleChange = new Ue();
      get inputId() {
        return `${this.id || this._uniqueId}-input`;
      }
      constructor() {
        M(mi).load(ts);
        let e = M(new Tr("tabindex"), { optional: true }), n = this.defaults, r = M(An, { optional: true });
        this.tabIndex = e == null ? 0 : parseInt(e) || 0, this.color = n.color || "accent", this._noopAnimations = r === "NoopAnimations", this.id = this._uniqueId = M(kn).getId("mat-mdc-slide-toggle-"), this.hideIcon = n.hideIcon ?? false, this.disabledInteractive = n.disabledInteractive ?? false, this._labelId = this._uniqueId + "-label";
      }
      ngAfterContentInit() {
        this._focusMonitor.monitor(this._elementRef, true).subscribe((e) => {
          e === "keyboard" || e === "program" ? (this._focused = true, this._changeDetectorRef.markForCheck()) : e || Promise.resolve().then(() => {
            this._focused = false, this._onTouched(), this._changeDetectorRef.markForCheck();
          });
        });
      }
      ngOnChanges(e) {
        e.required && this._validatorOnChange();
      }
      ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
      }
      writeValue(e) {
        this.checked = !!e;
      }
      registerOnChange(e) {
        this._onChange = e;
      }
      registerOnTouched(e) {
        this._onTouched = e;
      }
      validate(e) {
        return this.required && e.value !== true ? { required: true } : null;
      }
      registerOnValidatorChange(e) {
        this._validatorOnChange = e;
      }
      setDisabledState(e) {
        this.disabled = e, this._changeDetectorRef.markForCheck();
      }
      toggle() {
        this.checked = !this.checked, this._onChange(this.checked);
      }
      _emitChangeEvent() {
        this._onChange(this.checked), this.change.emit(this._createChangeEvent(this.checked));
      }
      _handleClick() {
        this.disabled || (this.toggleChange.emit(), this.defaults.disableToggleValue || (this.checked = !this.checked, this._onChange(this.checked), this.change.emit(new Dw(this, this.checked))));
      }
      _getAriaLabelledBy() {
        return this.ariaLabelledby ? this.ariaLabelledby : this.ariaLabel ? null : this._labelId;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-slide-toggle"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Aue, 5), n & 2) {
          let o;
          Ie(o = De()) && (r._switchElement = o.first);
        }
      }, hostAttrs: [1, "mat-mdc-slide-toggle"], hostVars: 13, hostBindings: function(n, r) {
        n & 2 && (gr("id", r.id), Ke("tabindex", null)("aria-label", null)("name", null)("aria-labelledby", null), io(r.color ? "mat-" + r.color : ""), ye("mat-mdc-slide-toggle-focused", r._focused)("mat-mdc-slide-toggle-checked", r.checked)("_mat-animation-noopable", r._noopAnimations));
      }, inputs: { name: "name", id: "id", labelPosition: "labelPosition", ariaLabel: [0, "aria-label", "ariaLabel"], ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"], ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"], required: [2, "required", "required", tt], color: "color", disabled: [2, "disabled", "disabled", tt], disableRipple: [2, "disableRipple", "disableRipple", tt], tabIndex: [2, "tabIndex", "tabIndex", (e) => e == null ? 0 : Gn(e)], checked: [2, "checked", "checked", tt], hideIcon: [2, "hideIcon", "hideIcon", tt], disabledInteractive: [2, "disabledInteractive", "disabledInteractive", tt] }, outputs: { change: "change", toggleChange: "toggleChange" }, exportAs: ["matSlideToggle"], features: [Bt([Fue, { provide: Lc, useExisting: i59, multi: true }]), on, yn], ngContentSelectors: Nue, decls: 13, vars: 27, consts: [["switch", ""], ["mat-internal-form-field", "", 3, "labelPosition"], ["role", "switch", "type", "button", 1, "mdc-switch", 3, "click", "tabIndex", "disabled"], [1, "mdc-switch__track"], [1, "mdc-switch__handle-track"], [1, "mdc-switch__handle"], [1, "mdc-switch__shadow"], [1, "mdc-elevation-overlay"], [1, "mdc-switch__ripple"], ["mat-ripple", "", 1, "mat-mdc-slide-toggle-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mdc-switch__icons"], [1, "mdc-label", 3, "click", "for"], ["viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-switch__icon", "mdc-switch__icon--on"], ["d", "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z"], ["viewBox", "0 0 24 24", "aria-hidden", "true", 1, "mdc-switch__icon", "mdc-switch__icon--off"], ["d", "M20 13H4v-2h16v2z"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          Tn(), b(0, "div", 1)(1, "button", 2, 0), Z("click", function() {
            return q(o), Y(r._handleClick());
          }), ae(3, "span", 3), b(4, "span", 4)(5, "span", 5)(6, "span", 6), ae(7, "span", 7), x(), b(8, "span", 8), ae(9, "span", 9), x(), X(10, kue, 5, 0, "span", 10), x()()(), b(11, "label", 11), Z("click", function(a) {
            return q(o), Y(a.stopPropagation());
          }), zt(12), x()();
        }
        if (n & 2) {
          let o = Ce(2);
          U("labelPosition", r.labelPosition), C(), ye("mdc-switch--selected", r.checked)("mdc-switch--unselected", !r.checked)("mdc-switch--checked", r.checked)("mdc-switch--disabled", r.disabled)("mat-mdc-slide-toggle-disabled-interactive", r.disabledInteractive), U("tabIndex", r.disabled && !r.disabledInteractive ? -1 : r.tabIndex)("disabled", r.disabled && !r.disabledInteractive), Ke("id", r.buttonId)("name", r.name)("aria-label", r.ariaLabel)("aria-labelledby", r._getAriaLabelledBy())("aria-describedby", r.ariaDescribedby)("aria-required", r.required || null)("aria-checked", r.checked)("aria-disabled", r.disabled && r.disabledInteractive ? "true" : null), C(8), U("matRippleTrigger", o)("matRippleDisabled", r.disableRipple || r.disabled)("matRippleCentered", true), C(), he(r.hideIcon ? -1 : 10), C(), U("for", r.buttonId), Ke("id", r._labelId);
        }
      }, dependencies: [ba, qu], styles: ['.mdc-switch{align-items:center;background:none;border:none;cursor:pointer;display:inline-flex;flex-shrink:0;margin:0;outline:none;overflow:visible;padding:0;position:relative;width:var(--mdc-switch-track-width, 52px)}.mdc-switch.mdc-switch--disabled{cursor:default;pointer-events:none}.mdc-switch.mat-mdc-slide-toggle-disabled-interactive{pointer-events:auto}.mdc-switch__track{overflow:hidden;position:relative;width:100%;height:var(--mdc-switch-track-height, 32px);border-radius:var(--mdc-switch-track-shape, var(--mat-sys-corner-full))}.mdc-switch--disabled.mdc-switch .mdc-switch__track{opacity:var(--mdc-switch-disabled-track-opacity, 0.12)}.mdc-switch__track::before,.mdc-switch__track::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";height:100%;left:0;position:absolute;width:100%;border-width:var(--mat-switch-track-outline-width, 2px);border-color:var(--mat-switch-track-outline-color, var(--mat-sys-outline))}.mdc-switch--selected .mdc-switch__track::before,.mdc-switch--selected .mdc-switch__track::after{border-width:var(--mat-switch-selected-track-outline-width, 2px);border-color:var(--mat-switch-selected-track-outline-color, transparent)}.mdc-switch--disabled .mdc-switch__track::before,.mdc-switch--disabled .mdc-switch__track::after{border-width:var(--mat-switch-disabled-unselected-track-outline-width, 2px);border-color:var(--mat-switch-disabled-unselected-track-outline-color, var(--mat-sys-on-surface))}@media(forced-colors: active){.mdc-switch__track{border-color:currentColor}}.mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0, 0, 0.2, 1);transform:translateX(0);background:var(--mdc-switch-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__track::before{transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.6, 1);transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch--selected .mdc-switch__track::before{transform:translateX(-100%)}.mdc-switch--selected .mdc-switch__track::before{opacity:var(--mat-switch-hidden-track-opacity, 0);transition:var(--mat-switch-hidden-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::before{opacity:var(--mat-switch-visible-track-opacity, 1);transition:var(--mat-switch-visible-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-hover-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::before{background:var(--mdc-switch-unselected-focus-track-color, var(--mat-sys-surface-variant))}.mdc-switch:enabled:active .mdc-switch__track::before{background:var(--mdc-switch-unselected-pressed-track-color, var(--mat-sys-surface-variant))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::before,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::before,.mdc-switch.mdc-switch--disabled .mdc-switch__track::before{background:var(--mdc-switch-disabled-unselected-track-color, var(--mat-sys-surface-variant))}.mdc-switch__track::after{transform:translateX(-100%);background:var(--mdc-switch-selected-track-color, var(--mat-sys-primary))}[dir=rtl] .mdc-switch__track::after{transform:translateX(100%)}.mdc-switch--selected .mdc-switch__track::after{transform:translateX(0)}.mdc-switch--selected .mdc-switch__track::after{opacity:var(--mat-switch-visible-track-opacity, 1);transition:var(--mat-switch-visible-track-transition, opacity 75ms)}.mdc-switch--unselected .mdc-switch__track::after{opacity:var(--mat-switch-hidden-track-opacity, 0);transition:var(--mat-switch-hidden-track-transition, opacity 75ms)}.mdc-switch:enabled:hover:not(:focus):not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-hover-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:focus:not(:active) .mdc-switch__track::after{background:var(--mdc-switch-selected-focus-track-color, var(--mat-sys-primary))}.mdc-switch:enabled:active .mdc-switch__track::after{background:var(--mdc-switch-selected-pressed-track-color, var(--mat-sys-primary))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__track::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__track::after,.mdc-switch.mdc-switch--disabled .mdc-switch__track::after{background:var(--mdc-switch-disabled-selected-track-color, var(--mat-sys-on-surface))}.mdc-switch__handle-track{height:100%;pointer-events:none;position:absolute;top:0;transition:transform 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);left:0;right:auto;transform:translateX(0);width:calc(100% - var(--mdc-switch-handle-width))}[dir=rtl] .mdc-switch__handle-track{left:auto;right:0}.mdc-switch--selected .mdc-switch__handle-track{transform:translateX(100%)}[dir=rtl] .mdc-switch--selected .mdc-switch__handle-track{transform:translateX(-100%)}.mdc-switch__handle{display:flex;pointer-events:auto;position:absolute;top:50%;transform:translateY(-50%);left:0;right:auto;transition:width 75ms cubic-bezier(0.4, 0, 0.2, 1),height 75ms cubic-bezier(0.4, 0, 0.2, 1),margin 75ms cubic-bezier(0.4, 0, 0.2, 1);width:var(--mdc-switch-handle-width);height:var(--mdc-switch-handle-height);border-radius:var(--mdc-switch-handle-shape, var(--mat-sys-corner-full))}[dir=rtl] .mdc-switch__handle{left:auto;right:0}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle{width:var(--mat-switch-unselected-handle-size, 16px);height:var(--mat-switch-unselected-handle-size, 16px);margin:var(--mat-switch-unselected-handle-horizontal-margin, 0 8px)}.mat-mdc-slide-toggle .mdc-switch--unselected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-switch-unselected-with-icon-handle-horizontal-margin, 0 4px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle{width:var(--mat-switch-selected-handle-size, 24px);height:var(--mat-switch-selected-handle-size, 24px);margin:var(--mat-switch-selected-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch--selected .mdc-switch__handle:has(.mdc-switch__icons){margin:var(--mat-switch-selected-with-icon-handle-horizontal-margin, 0 24px)}.mat-mdc-slide-toggle .mdc-switch__handle:has(.mdc-switch__icons){width:var(--mat-switch-with-icon-handle-size, 24px);height:var(--mat-switch-with-icon-handle-size, 24px)}.mat-mdc-slide-toggle .mdc-switch:active:not(.mdc-switch--disabled) .mdc-switch__handle{width:var(--mat-switch-pressed-handle-size, 28px);height:var(--mat-switch-pressed-handle-size, 28px)}.mat-mdc-slide-toggle .mdc-switch--selected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-switch-selected-pressed-handle-horizontal-margin, 0 22px)}.mat-mdc-slide-toggle .mdc-switch--unselected:active:not(.mdc-switch--disabled) .mdc-switch__handle{margin:var(--mat-switch-unselected-pressed-handle-horizontal-margin, 0 2px)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__handle::after{opacity:var(--mat-switch-disabled-selected-handle-opacity, 1)}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__handle::after{opacity:var(--mat-switch-disabled-unselected-handle-opacity, 0.38)}.mdc-switch__handle::before,.mdc-switch__handle::after{border:1px solid rgba(0,0,0,0);border-radius:inherit;box-sizing:border-box;content:"";width:100%;height:100%;left:0;position:absolute;top:0;transition:background-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1),border-color 75ms 0ms cubic-bezier(0.4, 0, 0.2, 1);z-index:-1}@media(forced-colors: active){.mdc-switch__handle::before,.mdc-switch__handle::after{border-color:currentColor}}.mdc-switch--selected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-selected-handle-color, var(--mat-sys-on-primary))}.mdc-switch--selected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-hover-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-selected-focus-handle-color, var(--mat-sys-primary-container))}.mdc-switch--selected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-selected-pressed-handle-color, var(--mat-sys-primary-container))}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:hover:not(:focus):not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:focus:not(:active) .mdc-switch__handle::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled.mdc-switch--selected:active .mdc-switch__handle::after,.mdc-switch--selected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-selected-handle-color, var(--mat-sys-surface))}.mdc-switch--unselected:enabled .mdc-switch__handle::after{background:var(--mdc-switch-unselected-handle-color, var(--mat-sys-outline))}.mdc-switch--unselected:enabled:hover:not(:focus):not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-hover-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:focus:not(:active) .mdc-switch__handle::after{background:var(--mdc-switch-unselected-focus-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected:enabled:active .mdc-switch__handle::after{background:var(--mdc-switch-unselected-pressed-handle-color, var(--mat-sys-on-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__handle::after{background:var(--mdc-switch-disabled-unselected-handle-color, var(--mat-sys-on-surface))}.mdc-switch__handle::before{background:var(--mdc-switch-handle-surface-color)}.mdc-switch__shadow{border-radius:inherit;bottom:0;left:0;position:absolute;right:0;top:0}.mdc-switch:enabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-handle-elevation-shadow)}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:hover:not(:focus):not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:focus:not(:active) .mdc-switch__shadow,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:active .mdc-switch__shadow,.mdc-switch.mdc-switch--disabled .mdc-switch__shadow{box-shadow:var(--mdc-switch-disabled-handle-elevation-shadow)}.mdc-switch__ripple{left:50%;position:absolute;top:50%;transform:translate(-50%, -50%);z-index:-1;width:var(--mdc-switch-state-layer-size, 40px);height:var(--mdc-switch-state-layer-size, 40px)}.mdc-switch__ripple::after{content:"";opacity:0}.mdc-switch--disabled .mdc-switch__ripple::after{display:none}.mat-mdc-slide-toggle-disabled-interactive .mdc-switch__ripple::after{display:block}.mdc-switch:hover .mdc-switch__ripple::after{opacity:.04;transition:75ms opacity cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mdc-switch .mdc-switch__ripple::after{opacity:.12}.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:focus .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:active .mdc-switch__ripple::after,.mat-mdc-slide-toggle-disabled-interactive.mdc-switch--disabled:enabled:hover:not(:focus) .mdc-switch__ripple::after,.mdc-switch--unselected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-hover-state-layer-color, var(--mat-sys-on-surface))}.mdc-switch--unselected:enabled:focus .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-focus-state-layer-color, var(--mat-sys-on-surface))}.mdc-switch--unselected:enabled:active .mdc-switch__ripple::after{background:var(--mdc-switch-unselected-pressed-state-layer-color, var(--mat-sys-on-surface));opacity:var(--mdc-switch-unselected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch--selected:enabled:hover:not(:focus) .mdc-switch__ripple::after{background:var(--mdc-switch-selected-hover-state-layer-color, var(--mat-sys-primary))}.mdc-switch--selected:enabled:focus .mdc-switch__ripple::after{background:var(--mdc-switch-selected-focus-state-layer-color, var(--mat-sys-primary))}.mdc-switch--selected:enabled:active .mdc-switch__ripple::after{background:var(--mdc-switch-selected-pressed-state-layer-color, var(--mat-sys-primary));opacity:var(--mdc-switch-selected-pressed-state-layer-opacity, var(--mat-sys-pressed-state-layer-opacity));transition:opacity 75ms linear}.mdc-switch__icons{position:relative;height:100%;width:100%;z-index:1}.mdc-switch--disabled.mdc-switch--unselected .mdc-switch__icons{opacity:var(--mdc-switch-disabled-unselected-icon-opacity, 0.38)}.mdc-switch--disabled.mdc-switch--selected .mdc-switch__icons{opacity:var(--mdc-switch-disabled-selected-icon-opacity, 0.38)}.mdc-switch__icon{bottom:0;left:0;margin:auto;position:absolute;right:0;top:0;opacity:0;transition:opacity 30ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-switch--unselected .mdc-switch__icon{width:var(--mdc-switch-unselected-icon-size, 16px);height:var(--mdc-switch-unselected-icon-size, 16px);fill:var(--mdc-switch-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--unselected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-unselected-icon-color, var(--mat-sys-surface-variant))}.mdc-switch--selected .mdc-switch__icon{width:var(--mdc-switch-selected-icon-size, 16px);height:var(--mdc-switch-selected-icon-size, 16px);fill:var(--mdc-switch-selected-icon-color, var(--mat-sys-on-primary-container))}.mdc-switch--selected.mdc-switch--disabled .mdc-switch__icon{fill:var(--mdc-switch-disabled-selected-icon-color, var(--mat-sys-on-surface))}.mdc-switch--selected .mdc-switch__icon--on,.mdc-switch--unselected .mdc-switch__icon--off{opacity:1;transition:opacity 45ms 30ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-slide-toggle{-webkit-user-select:none;user-select:none;display:inline-block;-webkit-tap-highlight-color:rgba(0,0,0,0);outline:0}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple,.mat-mdc-slide-toggle .mdc-switch__ripple::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:50%;pointer-events:none}.mat-mdc-slide-toggle .mat-mdc-slide-toggle-ripple:not(:empty),.mat-mdc-slide-toggle .mdc-switch__ripple::after:not(:empty){transform:translateZ(0)}.mat-mdc-slide-toggle.mat-mdc-slide-toggle-focused .mat-focus-indicator::before{content:""}.mat-mdc-slide-toggle .mat-internal-form-field{color:var(--mat-switch-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-switch-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-switch-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-switch-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-switch-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-switch-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-slide-toggle .mat-ripple-element{opacity:.12}.mat-mdc-slide-toggle .mat-focus-indicator::before{border-radius:50%}.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle-track,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__icon,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__handle::after,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::before,.mat-mdc-slide-toggle._mat-animation-noopable .mdc-switch__track::after{transition:none}.mat-mdc-slide-toggle .mdc-switch:enabled+.mdc-label{cursor:pointer}.mat-mdc-slide-toggle .mdc-switch--disabled+label{color:var(--mdc-switch-disabled-label-text-color)}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var lH = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [aH, Yt, Yt] });
    }
    return i59;
  })();
  var Bue = ["container"];
  var Vue = ["oneLineText"];
  function zue(i59, t) {
    if (i59 & 1 && (b(0, "div", 8), D(1, " Showing at most "), b(2, "span", 9), D(3), x()()), i59 & 2) {
      let e = T(2);
      C(2), U("matTooltipShowDelay", 300), C(), Oe(" ", e.getMaxConstValueCount(), " elements ");
    }
  }
  function Uue(i59, t) {
    i59 & 1 && (b(0, "div", 8), D(1, " Showing "), b(2, "span", 9), D(3, " all elements "), x()()), i59 & 2 && (C(2), U("matTooltipShowDelay", 300));
  }
  function Gue(i59, t) {
    if (i59 & 1 && (X(0, zue, 4, 2, "div", 8)(1, Uue, 4, 1, "div", 8), b(2, "div", 4), D(3), x()), i59 & 2) {
      let e = T();
      he(e.getMaxConstValueCount() > 0 ? 0 : e.getMaxConstValueCount() < 0 ? 1 : -1), C(3), Qe(e.text);
    }
  }
  function Hue(i59, t) {
    if (i59 & 1 && (b(0, "div", 11)(1, "div", 12), D(2), x(), b(3, "div", 13), D(4), x()()), i59 & 2) {
      let e = t.$implicit, n = t.$index;
      C(2), Qe(n), C(2), Qe(e);
    }
  }
  function jue(i59, t) {
    if (i59 & 1 && (b(0, "div", 8), D(1, " Namespace hierarchy "), x(), b(2, "div", 10), Qt(3, Hue, 5, 2, "div", 11, lf), x()), i59 & 2) {
      let e = T();
      C(3), Kt(e.namespaceComponents);
    }
  }
  function Wue(i59, t) {
    if (i59 & 1 && (b(0, "div", 4), D(1), x()), i59 & 2) {
      let e = T();
      C(), Qe(e.formatQuantization);
    }
  }
  function $ue(i59, t) {
    if (i59 & 1 && (b(0, "div", 5), D(1), x()), i59 & 2) {
      let e = T();
      C(), Qe(e.text);
    }
  }
  var cH = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      text = "";
      type = "";
      bgColor = "transparent";
      textColor = "inherit";
      container;
      oneLineText;
      expanded = false;
      hasOverflowInternal = false;
      resizeObserver;
      constructor(e, n) {
        this.appService = e, this.changeDetectorRef = n;
      }
      get hostExpanded() {
        return this.expanded;
      }
      ngAfterViewInit() {
        setTimeout(() => {
          this.updateHasOverflow(), this.changeDetectorRef.markForCheck();
        }), this.container && (this.resizeObserver = new ResizeObserver(() => {
          this.updateHasOverflow(), this.changeDetectorRef.markForCheck();
        }), this.resizeObserver.observe(this.container.nativeElement));
      }
      ngOnChanges() {
        setTimeout(() => {
          this.updateHasOverflow(), this.changeDetectorRef.markForCheck();
        });
      }
      ngOnDestroy() {
        this.resizeObserver && this.resizeObserver.disconnect();
      }
      handleToggleExpand(e, n = false) {
        !this.hasOverflow && !this.hasMultipleLines || (e.stopPropagation(), !(n && this.expanded) && (this.expanded = !this.expanded));
      }
      getMaxConstValueCount() {
        return this.appService.config()?.maxConstValueCount ?? 0;
      }
      get hasOverflow() {
        return this.updateHasOverflow(), this.hasOverflowInternal;
      }
      get hasMultipleLines() {
        return this.type !== "namespace" && this.text.includes(`
`);
      }
      get iconName() {
        return this.expanded ? "unfold_less" : "unfold_more";
      }
      get hasBgColor() {
        return this.bgColor !== "transparent";
      }
      get namespaceComponents() {
        let e = this.text.split("/");
        return this.text !== "<root>" && e.unshift("<root>"), e;
      }
      get formatQuantization() {
        return this.text.replace("[", "").replace("]", "").split(",").map((n) => n.trim()).join(`
`);
      }
      updateHasOverflow() {
        if (!this.oneLineText) {
          this.hasOverflowInternal = false;
          return;
        }
        this.hasOverflowInternal = this.oneLineText.nativeElement.scrollWidth > this.oneLineText.nativeElement.offsetWidth, this.expanded && (this.type === "namespace" || this.type === "values") && (this.hasOverflowInternal = true);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["expandable-info-text"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Bue, 5), Fe(Vue, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.container = o.first), Ie(o = De()) && (r.oneLineText = o.first);
        }
      }, hostVars: 2, hostBindings: function(n, r) {
        n & 2 && ye("expanded", r.hostExpanded);
      }, inputs: { text: "text", type: "type", bgColor: "bgColor", textColor: "textColor" }, features: [yn], decls: 13, vars: 15, consts: [["container", ""], ["oneLineText", ""], [1, "container", 3, "click"], [1, "expanded-text"], [1, "monospace-content"], [1, "text-content"], [1, "one-line-text"], [1, "icon-container", "toggle", 3, "click"], [1, "info-msg"], ["matTooltip", "configurable in Settings in homepage", "matTooltipPosition", "above", 1, "underline", 3, "matTooltipShowDelay"], [1, "namespace-content"], [1, "namespace-row"], [1, "index"], [1, "namespace"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 2, 0), Z("click", function(a) {
            return q(o), Y(r.handleToggleExpand(a, true));
          }), b(2, "div", 3), X(3, Gue, 4, 2)(4, jue, 5, 0)(5, Wue, 2, 1, "div", 4)(6, $ue, 2, 1, "div", 5), x(), b(7, "div", 6, 1), D(9), x(), b(10, "div", 7), Z("click", function(a) {
            return q(o), Y(r.handleToggleExpand(a));
          }), b(11, "mat-icon"), D(12), x()()();
        }
        n & 2 && (sn("background-color", r.bgColor)("color", r.textColor), ye("has-bg-color", r.hasBgColor)("has-overflow", r.hasOverflow)("has-multiple-lines", r.hasMultipleLines)("expanded", r.expanded), C(3), he(r.type === "values" ? 3 : r.type === "namespace" ? 4 : r.type === "quantization" ? 5 : 6), C(6), Oe(" ", r.text, " "), C(3), Qe(r.iconName));
      }, dependencies: [et, vt, St, tn, $n], styles: [`[_nghost-%COMP%]{overflow:hidden}.container[_ngcontent-%COMP%]{overflow:hidden;display:flex;align-items:flex-start;position:relative}.container.has-overflow[_ngcontent-%COMP%], .container.has-multiple-lines[_ngcontent-%COMP%]{cursor:pointer}.container.has-overflow[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%], .container.has-multiple-lines[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex}.container.has-overflow[_ngcontent-%COMP%]:hover   .icon-container[_ngcontent-%COMP%], .container.has-multiple-lines[_ngcontent-%COMP%]:hover   .icon-container[_ngcontent-%COMP%]{opacity:1}.container.has-bg-color[_ngcontent-%COMP%]{border-radius:4px;padding-left:4px}.container.expanded[_ngcontent-%COMP%]   .one-line-text[_ngcontent-%COMP%]{position:absolute;inset:0;visibility:hidden}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]{display:block;flex-grow:1;cursor:text}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .info-msg[_ngcontent-%COMP%]{margin-bottom:2px;color:#999;font-size:12px}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .info-msg[_ngcontent-%COMP%]   .underline[_ngcontent-%COMP%]{text-decoration:underline dashed}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .monospace-content[_ngcontent-%COMP%]{font-size:11px;white-space:pre-wrap;font-family:monospace;max-height:500px;overflow:auto}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .text-content[_ngcontent-%COMP%]{white-space:pre-wrap;max-height:500px;overflow:auto}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .namespace-content[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:2px}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .namespace-row[_ngcontent-%COMP%]{font-size:12px;line-height:14px;display:flex;align-items:flex-start}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .namespace-row[_ngcontent-%COMP%]   .index[_ngcontent-%COMP%]{width:16px;color:#999;flex-shrink:0;line-height:14px}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .namespace-row[_ngcontent-%COMP%]   .namespace[_ngcontent-%COMP%]{line-height:14px}.container.expanded[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]   .namespace-row[_ngcontent-%COMP%]   .namespace.hidden[_ngcontent-%COMP%]{color:#999}.container.expanded[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{background-color:#eee;border:1px solid #999}.container.expanded[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#999}.container[_ngcontent-%COMP%]   .one-line-text[_ngcontent-%COMP%]{flex-grow:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.container[_ngcontent-%COMP%]   .expanded-text[_ngcontent-%COMP%]{display:none}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{width:12px;height:12px;flex-shrink:0;display:none;background-color:#d7f1ff;border-radius:2px;margin-left:2px;cursor:pointer;align-items:center;justify-content:center;border:1px solid #4e90b5;opacity:.75}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#00639b;font-size:11px;width:11px;height:11px;font-weight:700}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var que = ["container"];
  function Yue(i59, t) {
    if (i59 & 1 && (b(0, "div", 3), D(1), x()), i59 & 2) {
      let e = T();
      C(), Oe(" ", e.label, " ");
    }
  }
  var dH = (() => {
    class i59 {
      changeDetectorRef;
      label = "";
      container;
      showPopup = false;
      popupSize = { minWidth: 0, minHeight: 0 };
      popupPosition = [{ originX: "end", originY: "top", overlayX: "end", overlayY: "top", offsetY: -1 }];
      constructor(e) {
        this.changeDetectorRef = e;
      }
      ngAfterViewInit() {
        setTimeout(() => {
          let e = this.container.nativeElement;
          this.showPopup = e.scrollWidth > e.offsetWidth, this.changeDetectorRef.markForCheck();
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["hoverable-label"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(que, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.container = o.first);
        }
      }, inputs: { label: "label" }, decls: 5, vars: 6, consts: [["container", ""], ["popup", ""], [1, "container", 3, "bubble", "overlaySize", "overlayPositions", "hoverDelayMs", "bubbleDisabled"], [1, "model-explorer-hoverable-label-popup"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 2, 0), D(2), x(), X(3, Yue, 2, 1, "ng-template", null, 1, Tt)), n & 2) {
          let o = Ce(4);
          U("bubble", o)("overlaySize", r.popupSize)("overlayPositions", r.popupPosition)("hoverDelayMs", 10)("bubbleDisabled", !r.showPopup), C(2), Oe(" ", r.label, `
`);
        }
      }, dependencies: [Bn], styles: ["[_nghost-%COMP%]{overflow:hidden}.container[_ngcontent-%COMP%]{overflow:hidden;text-overflow:ellipsis}  bubble-container:has(.model-explorer-hoverable-label-popup){width:100%;box-shadow:none;border:1px solid #ccc;border-radius:4px}  .model-explorer-hoverable-label-popup{padding:2px;font-size:12px;line-height:12px;background-color:#fff;color:#999;font-family:Google Sans Text,Arial,Helvetica,sans-serif}"], changeDetection: 0 });
    }
    return i59;
  })();
  var vp = (() => {
    class i59 {
      curSortingRunIndex = -2;
      curSortingDirection = "asc";
      curChildrenStatSortingColIndex = -2;
      curChildrenStatSortingDirection = "asc";
      statsTableCollapsed = false;
      childrenStatsTableCollapsed = false;
      nodeDataTableCollapsed = false;
      collapsedSectionNames = /* @__PURE__ */ new Set();
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac });
    }
    return i59;
  })();
  var Xue = ["paginator"];
  var Zue = ["childrenStatsPaginator"];
  var hH = (i59) => ({ $implicit: i59 });
  function Que(i59, t) {
    if (i59 & 1 && (b(0, "div", 26), D(1), x()), i59 & 2) {
      let e = T().index;
      C(), Qe(e + 1);
    }
  }
  function Kue(i59, t) {
    i59 & 1 && ae(0, "mat-spinner", 27);
  }
  function Jue(i59, t) {
    if (i59 & 1 && (b(0, "div", 28)(1, "mat-icon"), D(2, "error"), x()()), i59 & 2) {
      let e = T().$implicit;
      U("matTooltip", e.error)("matTooltipDisabled", !e.error);
    }
  }
  function ehe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 29), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T();
        return Y(s.handleClickToggleVisibility(o, r));
      }), b(1, "mat-icon"), D(2), x()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T();
      ye("selected", n.isRunItemSelected(e))("hide", !e.done), U("matTooltip", n.getVisibleToggleTooltip(e)), C(2), Qe(n.getIconName(e));
    }
  }
  function the(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 30), Z("click", function() {
        q(e);
        let r = T().$implicit, o = T();
        return Y(o.handleClickDelete(r));
      }), b(1, "mat-icon"), D(2, "delete"), x()();
    }
    i59 & 2 && U("matTooltip", "Delete");
  }
  function nhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 17), Z("click", function(r) {
        let o = q(e).$implicit, s = T();
        return Y(s.handleClickToggleVisibility(o, r));
      }), b(1, "div", 18), X(2, Que, 2, 1, "div", 19)(3, Kue, 1, 0, "mat-spinner", 20), x(), b(4, "div", 21), D(5), x(), b(6, "div", 22), X(7, Jue, 3, 2, "div", 23)(8, ehe, 3, 6, "div", 24)(9, the, 3, 1, "div", 25), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T();
      ye("selected", n.isRunItemSelected(e)), C(2), U("ngIf", e.done), C(), U("ngIf", !e.done), C(2), Qe(e.runName), C(2), U("ngIf", e.error), C(), U("ngIf", !e.error), C(), U("ngIf", e.done);
    }
  }
  function ihe(i59, t) {
    if (i59 & 1 && (b(0, "th", 37)(1, "div", 38)(2, "div", 26), D(3), x(), b(4, "div", 39), D(5), x()()()), i59 & 2) {
      let e = t.$implicit, n = t.index;
      ye("hidden", e.hideInAggregatedStatsTable), C(3), Qe(n + 1), C(2), Qe(e.runName);
    }
  }
  function rhe(i59, t) {
    if (i59 & 1 && (b(0, "td", 37), D(1), x()), i59 & 2) {
      let e = t.$implicit, n = t.index, r = T(4);
      ye("hidden", r.getHideStatsTableCol(n)), C(), Oe(" ", r.getStatValue(e), " ");
    }
  }
  function ohe(i59, t) {
    if (i59 & 1 && (b(0, "tr")(1, "td"), D(2), x(), X(3, rhe, 2, 3, "td", 35), x()), i59 & 2) {
      let e = t.$implicit;
      C(2), Qe(e.stat), C(), U("ngForOf", e.values);
    }
  }
  function she(i59, t) {
    if (i59 & 1 && (b(0, "table", 33)(1, "thead")(2, "tr")(3, "th", 34), D(4, " Stat "), x(), X(5, ihe, 6, 4, "th", 35), x()(), b(6, "tbody"), X(7, ohe, 4, 2, "tr", 36), x()()), i59 & 2) {
      let e = T(2);
      C(5), U("ngForOf", e.runItems), C(2), U("ngForOf", e.curStatRows)("ngForTrackBy", e.trackByStat);
    }
  }
  function ahe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 31, 2)(2, "div", 12)(3, "div", 13), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleExpandCollapseStatsTable(r));
      }), b(4, "mat-icon"), D(5), x(), D(6), x()(), X(7, she, 8, 3, "table", 32), x();
    }
    if (i59 & 2) {
      let e = T();
      ye("collapsed", e.statsTableCollapsed), C(5), Qe(e.statsTableTitleIcon), C(), Oe(" ", e.statsTableTitle, " "), C(), U("ngIf", e.showResults);
    }
  }
  function lhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 42, 4), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleChildrenStatsTablePaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.tablePageSize)("itemsCount", e.childrenStatRowsCount);
    }
  }
  function che(i59, t) {
    i59 & 1 && fi(0);
  }
  function dhe(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(3);
      C(), Oe(" ", e.curChildrenStatSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function uhe(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(3);
      C(), Oe(" ", e.curChildrenStatSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function hhe(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(4);
      C(), Oe(" ", e.curChildrenStatSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function phe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "th", 49), Z("click", function() {
        let r = q(e).$implicit, o = T(3);
        return Y(o.handleClickChildrenStatsHeader(r.colIndex));
      }), b(1, "div", 38)(2, "div", 26), D(3), x(), b(4, "div", 39), D(5), x(), X(6, hhe, 2, 1, "mat-icon", 45), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(3);
      ye("hidden", e.hideInChildrenStatsTable), C(3), Qe(e.runIndex + 1), C(), ye("multi-line", e.multiLineHeader), C(), Qe(e.label), C(), U("ngIf", e.colIndex === n.curChildrenStatSortingColIndex);
    }
  }
  function fhe(i59, t) {
    if (i59 & 1 && (b(0, "td", 37), D(1), x()), i59 & 2) {
      let e = t.$implicit, n = t.index, r = T().$implicit;
      ye("hidden", r.colHidden[n]), C(), Oe(" ", e, " ");
    }
  }
  function mhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "tr")(1, "td"), D(2), x(), b(3, "td", 50), Z("click", function() {
        let r = q(e).$implicit, o = T(3);
        return Y(o.handleClickNodeLabel(r.id));
      }), D(4), x(), X(5, fhe, 2, 3, "td", 35), x();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      C(2), Qe(e.index), C(2), Oe(" ", e.label, " "), C(), U("ngForOf", e.colStrs);
    }
  }
  function ghe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "table", 43)(1, "thead")(2, "tr")(3, "th", 44), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickChildrenStatsHeader(-2));
      }), b(4, "div", 38), D(5, " # "), X(6, dhe, 2, 1, "mat-icon", 45), x()(), b(7, "th", 46), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickChildrenStatsHeader(-1));
      }), b(8, "div", 38), D(9, " Node "), X(10, uhe, 2, 1, "mat-icon", 45), x()(), X(11, phe, 7, 7, "th", 47), x()(), b(12, "tbody"), X(13, mhe, 6, 3, "tr", 36), x()();
    }
    if (i59 & 2) {
      let e = T(2);
      C(6), U("ngIf", e.curChildrenStatSortingColIndex === -2), C(4), U("ngIf", e.curChildrenStatSortingColIndex === -1), C(), U("ngForOf", e.childrenStatsCols), C(2), U("ngForOf", e.curPageChildrenStatRows)("ngForTrackBy", e.trackByNodeId);
    }
  }
  function _he(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 40, 3)(2, "div", 12)(3, "div", 13), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleExpandCollapseChildrenStatsTable(r));
      }), b(4, "mat-icon"), D(5), x(), D(6), x(), X(7, lhe, 2, 2, "paginator", 14), x(), X(8, che, 1, 0, "ng-container", 15)(9, ghe, 14, 5, "table", 41), x();
    }
    if (i59 & 2) {
      let e = T(), n = Ce(16);
      ye("collapsed", e.childrenStatsTableCollapsed), C(5), Qe(e.childrenStatsTableTitleIcon), C(), Oe(" ", e.childrenStatsTableTitle, " "), C(), he(e.childrenStatRowsCount > e.tablePageSize && !e.childrenStatsTableCollapsed ? 7 : -1), C(), U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(8, hH, e.childrenStatsTableNodeFilter)), C(), U("ngIf", e.showResults);
    }
  }
  function vhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 42, 5), Z("change", function(r) {
        q(e);
        let o = T();
        return Y(o.handleTablePaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T();
      U("pageSize", e.tablePageSize)("itemsCount", e.rowsCount);
    }
  }
  function yhe(i59, t) {
    i59 & 1 && fi(0);
  }
  function bhe(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(2);
      C(), Oe(" ", e.curSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function xhe(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(2);
      C(), Oe(" ", e.curSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function whe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 54), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T(2);
        return Y(s.handleClickToggleVisibility(o, r));
      }), b(1, "mat-icon"), D(2), x()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T(2);
      ye("selected", n.isRunItemSelected(e))("hide", !e.done), U("matTooltip", n.getVisibleToggleTooltip(e)), C(2), Qe(n.getIconName(e));
    }
  }
  function Che(i59, t) {
    if (i59 & 1 && (b(0, "mat-icon", 48), D(1), x()), i59 & 2) {
      let e = T(3);
      C(), Oe(" ", e.curSortingDirection === "asc" ? "arrow_upward" : "arrow_downward", " ");
    }
  }
  function She(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "th", 49), Z("click", function() {
        let r = q(e).index, o = T(2);
        return Y(o.handleClickHeader(r));
      }), b(1, "div", 38)(2, "div", 26), D(3), x(), b(4, "div", 39), D(5), x(), X(6, whe, 3, 6, "div", 53)(7, Che, 2, 1, "mat-icon", 45), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = t.index, r = T(2);
      C(3), Qe(n + 1), C(2), Qe(e.runName), C(), U("ngIf", !e.error), C(), U("ngIf", n === r.curSortingRunIndex);
    }
  }
  function Mhe(i59, t) {
    if (i59 & 1 && (b(0, "td", 37), D(1), x()), i59 & 2) {
      let e = t.$implicit;
      sn("background-color", e.bgColor)("color", e.textColor), C(), Oe(" ", e.strValue, " ");
    }
  }
  function Ehe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "tr")(1, "td"), D(2), x(), b(3, "td", 50), Z("click", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.handleClickNodeLabel(r.id));
      }), D(4), x(), X(5, Mhe, 2, 5, "td", 55), x();
    }
    if (i59 & 2) {
      let e = t.$implicit;
      C(2), Qe(e.index), C(), ye("input", e.isInput)("output", e.isOutput), C(), Oe(" ", e.label, " "), C(), U("ngForOf", e.cols);
    }
  }
  function The(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "table", 51)(1, "thead")(2, "tr")(3, "th", 44), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickHeader(-2));
      }), b(4, "div", 38), D(5, " # "), X(6, bhe, 2, 1, "mat-icon", 45), x()(), b(7, "th", 46), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickHeader(-1));
      }), b(8, "div", 38), D(9, " Node "), X(10, xhe, 2, 1, "mat-icon", 45), x()(), X(11, She, 8, 4, "th", 52), x()(), b(12, "tbody"), X(13, Ehe, 6, 7, "tr", 36), x()();
    }
    if (i59 & 2) {
      let e = T();
      C(6), U("ngIf", e.curSortingRunIndex === -2), C(4), U("ngIf", e.curSortingRunIndex === -1), C(), U("ngForOf", e.runItems), C(2), U("ngForOf", e.curPageRows)("ngForTrackBy", e.trackByNodeId);
    }
  }
  function Ihe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 60), Z("click", function() {
        q(e);
        let r = T().$implicit, o = T();
        return Y(o.handleClearStatsTableFilter(r));
      }), b(1, "mat-icon", 61), D(2, "close"), x()();
    }
  }
  function Dhe(i59, t) {
    if (i59 & 1 && (b(0, "div", 56), ae(1, "input", 57), b(2, "mat-icon", 58), D(3, "filter_alt"), x(), X(4, Ihe, 3, 0, "div", 59), x()), i59 & 2) {
      let e = t.$implicit;
      C(), U("formControl", e), C(3), he(e.value ? 4 : -1);
    }
  }
  var Phe = ["Sum %"];
  var pH = (() => {
    class i59 {
      appService;
      destroyRef;
      infoPanelService;
      nodeDataProviderExtensionService;
      changeDetectorRef;
      paneId;
      rootGroupNodeId;
      paginator;
      childrenStatsPaginator;
      childrenStatsTableNodeFilter = new qr("");
      resultsTableNodeFilter = new qr("");
      curRows;
      curPageRows = [];
      savedCurRows;
      curStatRows = [];
      curChildrenStatRows = [];
      curPageChildrenStatRows = [];
      savedChildrenStatRows = [];
      runItems = [];
      curSelectedRunId = "";
      orderedNodes = [];
      childrenStatsCols = [];
      tablePageSize = 50;
      curModelGraph;
      prevModelGraph;
      prevRunsKey = "";
      orderedNodesCache = {};
      constructor(e, n, r, o, s) {
        this.appService = e, this.destroyRef = n, this.infoPanelService = r, this.nodeDataProviderExtensionService = o, this.changeDetectorRef = s;
        let a = new URLSearchParams(document.location.search);
        a.has("nodeDataProviderDataSummaryTablePageSize") && (this.tablePageSize = Number(a.get("nodeDataProviderDataSummaryTablePageSize"))), ht(() => {
          let l = this.appService.getPaneById(this.paneId)?.modelGraph;
          if (!l) return;
          let c = this.nodeDataProviderExtensionService.getSelectedRunForModelGraph(this.paneId, l);
          this.curSelectedRunId = c?.runId || "", this.changeDetectorRef.markForCheck();
        }), ht(() => {
          this.curModelGraph = this.appService.getPaneById(this.paneId)?.modelGraph;
          let l = this.curModelGraph ? this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph) : [], c = false, d = false;
          this.prevModelGraph !== this.curModelGraph && (this.prevModelGraph = this.curModelGraph, c = true);
          let u = this.getRunsKey(l);
          if (this.prevRunsKey !== u && (this.prevRunsKey = u, d = true), this.curModelGraph && (c || d)) {
            this.runItems = [];
            let h = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph);
            for (let p of h) this.runItems.push({ runId: p.runId, runName: this.getRunName(p), done: p.done, error: p.error, hideInAggregatedStatsTable: (p.nodeDataProviderData ?? {})[this.curModelGraph.id]?.hideInAggregatedStatsTable });
            this.changeDetectorRef.markForCheck(), this.infoPanelService.curSortingRunIndex = Math.min(this.infoPanelService.curSortingRunIndex, h.length - 1), this.paginator?.reset(), this.genOrderedNodes(), this.populateResultsTable(), this.infoPanelService.curChildrenStatSortingColIndex = Math.min(this.infoPanelService.curChildrenStatSortingColIndex, this.childrenStatsCols.length - 1), this.childrenStatsPaginator?.reset();
          }
        }), this.childrenStatsTableNodeFilter.valueChanges.pipe(vo(150), wi(this.destroyRef)).subscribe((l) => {
          this.handleChildrenStatsTableFilterChanged();
        }), this.resultsTableNodeFilter.valueChanges.pipe(vo(150), wi(this.destroyRef)).subscribe((l) => {
          this.handleResultsTableFilterChanged();
        });
      }
      ngOnChanges(e) {
        e.rootGroupNodeId && (this.paginator?.reset(), this.childrenStatsPaginator?.reset(), this.genOrderedNodes(), this.populateResultsTable());
      }
      getIconName(e) {
        return this.isRunItemSelected(e) ? "visibility" : "visibility_off";
      }
      getVisibleToggleTooltip(e) {
        return this.isRunItemSelected(e) ? "Visualizing in graph" : "Click to visualize in graph";
      }
      isRunItemSelected(e) {
        return e.runId === this.curSelectedRunId;
      }
      handleChildrenStatsTablePaginatorChanged(e) {
        this.curPageChildrenStatRows = this.curChildrenStatRows.slice(e * this.tablePageSize, (e + 1) * this.tablePageSize), this.changeDetectorRef.markForCheck();
      }
      handleTablePaginatorChanged(e) {
        this.curRows == null ? this.curPageRows = [] : this.curPageRows = this.curRows.slice(e * this.tablePageSize, (e + 1) * this.tablePageSize), this.changeDetectorRef.markForCheck();
      }
      handleClickHeader(e) {
        this.infoPanelService.curSortingRunIndex === e ? this.infoPanelService.curSortingDirection = this.nextSortingDirection(this.curSortingDirection) : this.infoPanelService.curSortingDirection = e < 0 ? "asc" : "desc", this.infoPanelService.curSortingRunIndex = e, this.sortAndFiltertRows(), this.paginator?.reset(), this.handleTablePaginatorChanged(0);
      }
      handleClickChildrenStatsHeader(e) {
        this.infoPanelService.curChildrenStatSortingColIndex === e ? this.infoPanelService.curChildrenStatSortingDirection = this.nextSortingDirection(this.infoPanelService.curChildrenStatSortingDirection) : this.infoPanelService.curChildrenStatSortingDirection = e < 0 ? "asc" : "desc", this.infoPanelService.curChildrenStatSortingColIndex = e, this.sortAndFilterChildrenStatsRows(), this.childrenStatsPaginator?.reset(), this.handleChildrenStatsTablePaginatorChanged(0);
      }
      handleClickToggleVisibility(e, n) {
        n.stopPropagation(), !this.isRunItemSelected(e) && this.appService.setSelectedNodeDataProviderRunId(this.paneId, e.runId);
      }
      handleClickDelete(e) {
        this.curModelGraph && (this.nodeDataProviderExtensionService.deleteRun(e.runId), this.appService.deleteShowOnNodeItemType([`${ga}${e.runName}`]));
      }
      handleClickNodeLabel(e) {
        this.appService.curToLocateNodeInfo.set({ nodeId: e, rendererId: this.paneId, isGroupNode: false });
      }
      handleToggleExpandCollapseStatsTable(e) {
        this.infoPanelService.statsTableCollapsed ? e.style.maxHeight = `${e.scrollHeight}px` : e.style.maxHeight = `${e.offsetHeight}px`, this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.infoPanelService.statsTableCollapsed = !this.infoPanelService.statsTableCollapsed, this.changeDetectorRef.markForCheck(), this.infoPanelService.statsTableCollapsed || setTimeout(() => {
            e.style.maxHeight = "fit-content";
          }, 150);
        });
      }
      handleToggleExpandCollapseChildrenStatsTable(e) {
        this.infoPanelService.childrenStatsTableCollapsed ? e.style.maxHeight = `${e.scrollHeight}px` : e.style.maxHeight = `${e.offsetHeight}px`, this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.infoPanelService.childrenStatsTableCollapsed = !this.infoPanelService.childrenStatsTableCollapsed, this.changeDetectorRef.markForCheck(), this.infoPanelService.childrenStatsTableCollapsed || setTimeout(() => {
            e.style.maxHeight = "fit-content";
          }, 150);
        });
      }
      handleToggleExpandCollapseNodeDataTable(e) {
        this.infoPanelService.nodeDataTableCollapsed ? e.style.maxHeight = `${e.scrollHeight}px` : e.style.maxHeight = `${e.offsetHeight}px`, this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.infoPanelService.nodeDataTableCollapsed = !this.infoPanelService.nodeDataTableCollapsed, this.changeDetectorRef.markForCheck(), this.infoPanelService.nodeDataTableCollapsed || setTimeout(() => {
            e.style.maxHeight = "fit-content";
          }, 150);
        });
      }
      handleChildrenStatsTableFilterChanged() {
        this.childrenStatsPaginator?.reset(), this.sortAndFilterChildrenStatsRows(), this.handleChildrenStatsTablePaginatorChanged(0);
      }
      handleResultsTableFilterChanged() {
        this.paginator?.reset(), this.sortAndFiltertRows(), this.handleTablePaginatorChanged(0);
      }
      handleClearStatsTableFilter(e) {
        e === this.childrenStatsTableNodeFilter ? this.childrenStatsPaginator?.reset() : e === this.resultsTableNodeFilter && this.paginator?.reset(), e.reset();
      }
      getStatValue(e) {
        return e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY || isNaN(e) ? "-" : `${e}`;
      }
      getHideStatsTableCol(e) {
        return this.runItems[e]?.hideInAggregatedStatsTable === true;
      }
      trackByRunId(e, n) {
        return n.runId;
      }
      trackByNodeId(e, n) {
        return n.id;
      }
      trackByStat(e, n) {
        return n.stat;
      }
      get showResults() {
        return this.runItems.some((e) => e.done);
      }
      get rowsCount() {
        return this.curRows == null ? 0 : this.curRows.length;
      }
      get childrenStatRowsCount() {
        return this.curChildrenStatRows.length;
      }
      get statsTableTitleIcon() {
        return this.statsTableCollapsed ? "arrow_right" : "arrow_drop_down";
      }
      get statsTableTitle() {
        return this.rootGroupNodeId == null ? "Aggregated stats" : "Aggregated stats in selected layer";
      }
      get statsTableCollapsed() {
        return this.infoPanelService.statsTableCollapsed;
      }
      get childrenStatsTableTitleIcon() {
        return this.childrenStatsTableCollapsed ? "arrow_right" : "arrow_drop_down";
      }
      get childrenStatsTableTitle() {
        return this.rootGroupNodeId == null ? "Root-level nodes stats" : "Child nodes stats in selected layer";
      }
      get childrenStatsTableCollapsed() {
        return this.infoPanelService.childrenStatsTableCollapsed;
      }
      get nodeDataTableTitleIcon() {
        return this.nodeDataTableCollapsed ? "arrow_right" : "arrow_drop_down";
      }
      get nodeDataTableTitle() {
        return this.rootGroupNodeId == null ? "Node data" : "Node data in selected layer";
      }
      get nodeDataTableCollapsed() {
        return this.infoPanelService.nodeDataTableCollapsed;
      }
      get curSortingDirection() {
        return this.infoPanelService.curSortingDirection;
      }
      get curSortingRunIndex() {
        return this.infoPanelService.curSortingRunIndex;
      }
      get curChildrenStatSortingDirection() {
        return this.infoPanelService.curChildrenStatSortingDirection;
      }
      get curChildrenStatSortingColIndex() {
        return this.infoPanelService.curChildrenStatSortingColIndex;
      }
      get showStatsTable() {
        if (!this.curModelGraph) return false;
        let e = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph), n = true;
        for (let r of e) {
          if (!r.nodeDataProviderData) continue;
          if (!r.nodeDataProviderData[this.curModelGraph.id].hideInAggregatedStatsTable) {
            n = false;
            break;
          }
        }
        return !n;
      }
      get showChildrenStatsTable() {
        if (!this.curModelGraph) return false;
        let e = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph), n = true;
        for (let r of e) {
          if (!r.nodeDataProviderData) continue;
          if (!r.nodeDataProviderData[this.curModelGraph.id].hideInChildrenStatsTable) {
            n = false;
            break;
          }
        }
        return !n;
      }
      genOrderedNodes() {
        if (!this.curModelGraph) return;
        let e = this.getOrderedNodesCacheKey(), n = this.orderedNodesCache[e];
        if (n != null) this.orderedNodes = n;
        else {
          let r = this.rootGroupNodeId == null ? void 0 : this.curModelGraph.nodesById[this.rootGroupNodeId], o = /* @__PURE__ */ new Set();
          r != null && (o = new Set(r.descendantsOpNodeIds || [])), this.orderedNodes = this.curModelGraph.nodes.filter((s) => dt(s) && !s.hideInLayout && s.id !== "GraphInputs" && s.id !== "GraphOutputs" && (r == null || o.has(s.id))), this.orderedNodesCache[e] = this.orderedNodes;
        }
      }
      populateResultsTable() {
        if (!this.curModelGraph || this.orderedNodes.length === 0) return;
        let e = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph);
        this.curStatRows = [{ stat: "Min", values: [] }, { stat: "Max", values: [] }, { stat: "Sum", values: [] }, { stat: "Avg", values: [] }];
        let n = [];
        for (let c = 0; c < e.length; c++) n.push({ min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY, sum: 0, count: 0 });
        this.curRows = [];
        for (let c = 0; c < this.orderedNodes.length; c++) {
          let d = this.orderedNodes[c], u = d.id, h = [];
          for (let _ = 0; _ < e.length; _++) {
            let w = ((e[_].results || {})[this.curModelGraph.id] || {})[u], E = w?.value, P = w?.strValue || "-", S = w?.bgColor || "", A = w?.textColor || "black";
            if (h.push({ value: E, strValue: P, bgColor: S, textColor: A }), E != null && typeof E == "number") {
              let W = n[_];
              W.min = Math.min(E, W.min), W.max = Math.max(E, W.max), W.count++, W.sum += E;
            }
          }
          let p = d.incomingEdges || [], f = p.length === 0 || p.some((_) => _.sourceNodeId === "GraphInputs"), m = d.outgoingEdges || [], v = m.length === 0 || m.some((_) => _.targetNodeId === "GraphOutputs");
          this.curRows.push({ id: u, index: c, isInput: f, isOutput: v, label: this.curModelGraph.nodesById[u].label || "?", cols: h });
        }
        this.savedCurRows = [...this.curRows], this.sortAndFiltertRows(), this.handleTablePaginatorChanged(0), this.curStatRows[0].values = n.map((c) => c.min), this.curStatRows[1].values = n.map((c) => c.max), this.curStatRows[2].values = n.map((c) => c.sum), this.curStatRows[3].values = n.map((c) => c.sum / c.count);
        let r = ["min", "max", "sum", "avg"];
        for (let c = 0; c < e.length; c++) {
          let u = e[c].nodeDataProviderData?.[this.curModelGraph.id]?.hideAggregatedStats ?? [];
          for (let h = 0; h < r.length; h++) {
            let p = r[h];
            u.includes(p) && (this.curStatRows[h].values[c] = Number.POSITIVE_INFINITY);
          }
        }
        this.childrenStatsCols = [];
        let o = 0, s = this.curModelGraph.nodesById[this.rootGroupNodeId ?? ""], a = {};
        for (let c = 0; c < e.length; c++) {
          let d = e[c], u = Phe, h = [], p = false;
          (d.nodeDataProviderData ?? {})[this.curModelGraph.id]?.showLabelCountColumnsInChildrenStatsTable && (h = If(s, this.curModelGraph, (d.results ?? {})[this.curModelGraph.id]).sort((f, m) => f.label.localeCompare(m.label)), a[d.runId] = h, u = h.map((f) => `#${f.label}`), p = true);
          for (let f of u) {
            let m = f;
            e.length > 1 && (p ? m = `${this.getRunName(e[c])}
${f}` : m = `${this.getRunName(e[c])} \u2022 ${f}`), this.childrenStatsCols.push({ colIndex: o, runIndex: c, label: m, hideInChildrenStatsTable: e[c].nodeDataProviderData?.[this.curModelGraph.id]?.hideInChildrenStatsTable, multiLineHeader: p }), o++;
          }
        }
        this.curChildrenStatRows = [];
        let l = this.rootGroupNodeId ? this.curModelGraph.nodesById[this.rootGroupNodeId].nsChildrenIds || [] : this.curModelGraph.rootNodes.map((c) => c.id);
        for (let c = 0; c < l.length; c++) {
          let d = l[c], u = this.curModelGraph.nodesById[d], h = [], p = [], f = [];
          for (let m = 0; m < e.length; m++) {
            let v = e[m], _ = v.results || {};
            if (a[v.runId]) {
              let g = a[v.runId], y = v.results || {}, E = (y[this.curModelGraph.id] || {})[d]?.value || "";
              for (let P of g) {
                let S = 0;
                if (dt(u)) P.label === E && (S = 1);
                else if (ct(u)) {
                  let A = u.descendantsOpNodeIds || [];
                  for (let W of A) ((y[this.curModelGraph.id] || {})[W]?.value || "") === P.label && S++;
                }
                h.push(S), p.push(`${S}`), f.push(v.nodeDataProviderData?.[this.curModelGraph.id]?.hideInChildrenStatsTable === true);
              }
            } else {
              let g = 0, y = false;
              if (dt(u)) {
                let E = (_[this.curModelGraph.id] || {})[d]?.value;
                E != null && typeof E == "number" && (g = E / n[m].sum * 100, y = true);
              } else if (ct(u)) {
                let w = 0, E = u.descendantsOpNodeIds || [];
                for (let P of E) {
                  let A = (_[this.curModelGraph.id] || {})[P]?.value;
                  A != null && typeof A == "number" && (w += A, y = true);
                }
                g = w / n[m].sum * 100;
              }
              h.push(g), p.push(y ? g.toFixed(1) : "-"), f.push(v.nodeDataProviderData?.[this.curModelGraph.id]?.hideInChildrenStatsTable === true);
            }
          }
          this.curChildrenStatRows.push({ id: d, label: u.label, index: c, colValues: h, colStrs: p, colHidden: f });
        }
        this.savedChildrenStatRows = [...this.curChildrenStatRows], this.sortAndFilterChildrenStatsRows(), this.handleChildrenStatsTablePaginatorChanged(0), this.changeDetectorRef.markForCheck();
      }
      nextSortingDirection(e) {
        switch (e) {
          case "desc":
            return "asc";
          case "asc":
            return "desc";
          default:
            return e;
        }
      }
      sortAndFiltertRows() {
        this.curRows = [...this.savedCurRows || []];
        let e = (this.resultsTableNodeFilter.value || "").trim();
        if (e !== "") try {
          let n = new RegExp(e, "i");
          this.curRows = this.curRows.filter((r) => n.test(r.label));
        } catch {
          return;
        }
        this.curRows.sort((n, r) => {
          let o = this.getCellValue(n, this.infoPanelService.curSortingRunIndex), s = this.getCellValue(r, this.infoPanelService.curSortingRunIndex);
          return this.compareValue(o, s, this.infoPanelService.curSortingDirection);
        });
      }
      sortAndFilterChildrenStatsRows() {
        this.curChildrenStatRows = [...this.savedChildrenStatRows || []];
        let e = (this.childrenStatsTableNodeFilter.value || "").trim();
        if (e !== "") try {
          let n = new RegExp(e, "i");
          this.curChildrenStatRows = this.curChildrenStatRows.filter((r) => n.test(r.label));
        } catch {
          return;
        }
        this.curChildrenStatRows.sort((n, r) => {
          let o = this.getChildrenStatsColValue(n, this.infoPanelService.curChildrenStatSortingColIndex), s = this.getChildrenStatsColValue(r, this.infoPanelService.curChildrenStatSortingColIndex);
          return this.compareValue(o, s, this.infoPanelService.curChildrenStatSortingDirection);
        });
      }
      compareValue(e, n, r) {
        if (e == null && n == null) return 0;
        if (e == null && n != null) return r === "asc" ? -1 : 1;
        if (e != null && n == null) return r === "asc" ? 1 : -1;
        if (typeof e == "number" && typeof n == "number") return r === "asc" ? e - n : n - e;
        {
          let o = JSON.stringify(e), s = JSON.stringify(n);
          return r === "asc" ? o.localeCompare(s) : s.localeCompare(o);
        }
      }
      getCellValue(e, n) {
        switch (n) {
          case -2:
            return e.index;
          case -1:
            return e.label;
          default:
            return e.cols[n].value;
        }
      }
      getChildrenStatsColValue(e, n) {
        switch (n) {
          case -2:
            return e.index;
          case -1:
            return e.label;
          default:
            return e.colValues[n];
        }
      }
      getOrderedNodesCacheKey() {
        return `${this.curModelGraph?.collectionLabel}___${this.curModelGraph?.id}___${this.rootGroupNodeId}`;
      }
      getRunsKey(e) {
        return e.map((n) => {
          let r = [];
          r.push(n.runId), r.push(String(n.done));
          let o = n.results || {};
          return r.push(String(Object.keys(o).length)), r.join("__");
        }).join(",");
      }
      getRunName(e) {
        return va(e, this.curModelGraph);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(pi), K(vp), K(Cr), K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["node-data-provider-summary-panel"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Xue, 5), Fe(Zue, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.paginator = o.first), Ie(o = De()) && (r.childrenStatsPaginator = o.first);
        }
      }, inputs: { paneId: "paneId", rootGroupNodeId: "rootGroupNodeId" }, features: [yn], decls: 17, vars: 14, consts: [["nodeDataTableContainer", ""], ["nodeFilter", ""], ["statsTableContainer", ""], ["childrenStatsTableContainer", ""], ["childrenStatsPaginator", ""], ["paginator", ""], [1, "container"], [1, "index-container"], ["class", "index-row", 3, "selected", "click", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "table-container", 3, "collapsed"], [1, "table-container", "children-stats", 3, "collapsed"], [1, "table-container", "results"], [1, "table-title-container"], [1, "title-label-container", 3, "click"], [3, "pageSize", "itemsCount"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "results", "border", "0", "cellspacing", "0", "cellpadding", "0", 4, "ngIf"], [1, "index-row", 3, "click"], [1, "index-number-container"], ["class", "index-number", 4, "ngIf"], ["color", "primary", "diameter", "16", 4, "ngIf"], [1, "run-name"], [1, "action-icons-container"], ["class", "error", 3, "matTooltip", "matTooltipDisabled", 4, "ngIf"], ["class", "icon-container visibility", 3, "selected", "hide", "matTooltip", "click", 4, "ngIf"], ["class", "icon-container action", 3, "matTooltip", "click", 4, "ngIf"], [1, "index-number"], ["color", "primary", "diameter", "16"], [1, "error", 3, "matTooltip", "matTooltipDisabled"], [1, "icon-container", "visibility", 3, "click", "matTooltip"], [1, "icon-container", "action", 3, "click", "matTooltip"], [1, "table-container"], ["border", "0", "cellspacing", "0", "cellpadding", "0", 4, "ngIf"], ["border", "0", "cellspacing", "0", "cellpadding", "0"], [1, "stats"], ["class", "value-col", 3, "hidden", 4, "ngFor", "ngForOf"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "value-col"], [1, "header-content"], [1, "stat-label"], [1, "table-container", "children-stats"], ["class", "children-stats-results", "border", "0", "cellspacing", "0", "cellpadding", "0", 4, "ngIf"], [3, "change", "pageSize", "itemsCount"], ["border", "0", "cellspacing", "0", "cellpadding", "0", 1, "children-stats-results"], [1, "index", 3, "click"], ["class", "sort", 4, "ngIf"], [1, "header", "node-label", 3, "click"], ["class", "value-col", 3, "hidden", "click", 4, "ngFor", "ngForOf"], [1, "sort"], [1, "value-col", 3, "click"], [1, "node-label", 3, "click"], ["border", "0", "cellspacing", "0", "cellpadding", "0", 1, "results"], ["class", "value-col", 3, "click", 4, "ngFor", "ngForOf"], ["class", "icon-container visibility", "matTooltipPosition", "above", 3, "selected", "hide", "matTooltip", "click", 4, "ngIf"], ["matTooltipPosition", "above", 1, "icon-container", "visibility", 3, "click", "matTooltip"], ["class", "value-col", 3, "background-color", "color", 4, "ngFor", "ngForOf"], [1, "node-filter"], ["placeholder", "regex to filter nodes", 3, "formControl"], [1, "filter"], [1, "clear-container"], [1, "clear-container", 3, "click"], [1, "clear"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 6)(1, "div", 7), X(2, nhe, 10, 8, "div", 8), x(), X(3, ahe, 8, 5, "div", 9)(4, _he, 10, 10, "div", 10), b(5, "div", 11, 0)(7, "div", 12)(8, "div", 13), Z("click", function() {
            q(o);
            let a = Ce(6);
            return Y(r.handleToggleExpandCollapseNodeDataTable(a));
          }), b(9, "mat-icon"), D(10), x(), D(11), x(), X(12, vhe, 2, 2, "paginator", 14), x(), X(13, yhe, 1, 0, "ng-container", 15)(14, The, 14, 5, "table", 16), x()(), X(15, Dhe, 5, 2, "ng-template", null, 1, Tt);
        }
        if (n & 2) {
          let o = Ce(16);
          C(2), U("ngForOf", r.runItems)("ngForTrackBy", r.trackByRunId), C(), he(r.showStatsTable ? 3 : -1), C(), he(r.showChildrenStatsTable ? 4 : -1), C(), ye("collapsed", r.nodeDataTableCollapsed), C(5), Qe(r.nodeDataTableTitleIcon), C(), Oe(" ", r.nodeDataTableTitle, " "), C(), he(r.rowsCount > r.tablePageSize && !r.nodeDataTableCollapsed ? 12 : -1), C(), U("ngTemplateOutlet", o)("ngTemplateOutletContext", wo(12, hH, r.resultsTableNodeFilter)), C(), U("ngIf", r.showResults);
        }
      }, dependencies: [et, Wr, In, Ss, vt, St, Zs, fp, tn, $n, _p, Do, ul, Ps, Jo], styles: [`.container[_ngcontent-%COMP%]{padding-top:12px;box-sizing:border-box;display:flex;flex-direction:column;height:100%}.container[_ngcontent-%COMP%]   .index-number[_ngcontent-%COMP%]{font-size:10px;width:16px;height:16px;border-radius:8px;box-sizing:border-box;border:1px solid #999;background-color:#eee;display:flex;align-items:center;justify-content:center;flex-shrink:0}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]{margin-bottom:4px;position:relative}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;border:1px solid #ccc;padding:3px 4px 3px 19px;border-radius:4px;box-sizing:border-box}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:12px;width:12px;height:12px;color:#999}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]   mat-icon.filter[_ngcontent-%COMP%]{position:absolute;top:6px;left:3px}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]   .clear-container[_ngcontent-%COMP%]{position:absolute;top:6px;right:3px;cursor:pointer;display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .node-filter[_ngcontent-%COMP%]   .clear-container[_ngcontent-%COMP%]:hover   mat-icon[_ngcontent-%COMP%]{color:#555}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;width:16px;height:16px;opacity:.3;cursor:pointer}.container[_ngcontent-%COMP%]   .icon-container.selected[_ngcontent-%COMP%]{opacity:1;cursor:default}.container[_ngcontent-%COMP%]   .icon-container.selected[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#e1a011}.container[_ngcontent-%COMP%]   .icon-container.hide[_ngcontent-%COMP%]{visibility:hidden}.container[_ngcontent-%COMP%]   .icon-container.action[_ngcontent-%COMP%]{opacity:.7;margin-left:4px}.container[_ngcontent-%COMP%]   .icon-container.action[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .icon-container.visibility[_ngcontent-%COMP%]{margin-left:4px}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px;line-height:16px;color:#000}.container[_ngcontent-%COMP%]   .index-container[_ngcontent-%COMP%]   .index-row[_ngcontent-%COMP%]{display:flex;align-items:center;overflow:hidden;padding:2px 8px;cursor:pointer}.container[_ngcontent-%COMP%]   .index-container[_ngcontent-%COMP%]   .index-row.selected[_ngcontent-%COMP%]{background-color:#fff2d5}.container[_ngcontent-%COMP%]   .index-container[_ngcontent-%COMP%]   .index-row[_ngcontent-%COMP%]   .index-number-container[_ngcontent-%COMP%]{width:16px;height:16px;flex-shrink:0;display:flex;align-items:center;justify-content:center;margin-right:6px}.container[_ngcontent-%COMP%]   .index-container[_ngcontent-%COMP%]   .index-row[_ngcontent-%COMP%]   .run-name[_ngcontent-%COMP%]{flex-grow:1;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.container[_ngcontent-%COMP%]   .index-container[_ngcontent-%COMP%]   .index-row[_ngcontent-%COMP%]   .action-icons-container[_ngcontent-%COMP%]{display:flex;align-items:center;flex-shrink:0}.container[_ngcontent-%COMP%]   select[_ngcontent-%COMP%]{width:100%}.container[_ngcontent-%COMP%]   .running[_ngcontent-%COMP%]{display:flex;align-items:center;margin-top:16px}.container[_ngcontent-%COMP%]   .running[_ngcontent-%COMP%]   mat-spinner[_ngcontent-%COMP%]{margin-right:4px}.container[_ngcontent-%COMP%]   .running[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{color:#777}.container[_ngcontent-%COMP%]   .error[_ngcontent-%COMP%]{width:16px;height:16px}.container[_ngcontent-%COMP%]   .error[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;height:16px;width:16px;color:#a00}.container[_ngcontent-%COMP%]   .table-container[_ngcontent-%COMP%]{width:100%;box-sizing:border-box;padding:8px;margin-top:2px;display:flex;flex-direction:column;transition:max-height .15s ease-out;overflow-y:clip}.container[_ngcontent-%COMP%]   .table-container.collapsed[_ngcontent-%COMP%]{max-height:30px!important}.container[_ngcontent-%COMP%]   .table-container[_ngcontent-%COMP%]   .table-title-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;line-height:22px}.container[_ngcontent-%COMP%]   .table-container[_ngcontent-%COMP%]   .table-title-container[_ngcontent-%COMP%]   .title-label-container[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer;-webkit-user-select:none;user-select:none;line-height:15px}.container[_ngcontent-%COMP%]   .table-container[_ngcontent-%COMP%]   .table-title-container[_ngcontent-%COMP%]   .title-label-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin-left:-4px}.container[_ngcontent-%COMP%]   .table-container[_ngcontent-%COMP%]   paginator[_ngcontent-%COMP%]{align-self:flex-end}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]{border:1px solid #ccc;border-radius:4px;width:100%;box-sizing:border-box;-webkit-user-select:none;user-select:none;background-color:#fdfdfd;overflow:hidden}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]{height:24px;background-color:#f2f2f2;font-size:11px}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]{font-size:11px;font-family:Arial,Helvetica,sans-serif}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover{outline:1px solid #999}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{padding:1px 4px;text-align:left}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.node-label[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   th.node-label[_ngcontent-%COMP%]{border-left:1px solid #ddd}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.value-col[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   th.value-col[_ngcontent-%COMP%]{border-left:1px solid #ddd;max-width:80px;text-overflow:ellipsis;overflow:hidden}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]{height:100%;display:flex;align-items:center;font-size:11px}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   mat-icon.sort[_ngcontent-%COMP%]{font-size:12px;width:12px;height:12px;color:#999;margin-left:4px;flex-shrink:0}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .stat-label[_ngcontent-%COMP%]{margin-left:4px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   .header-content[_ngcontent-%COMP%]   .stat-label.multi-line[_ngcontent-%COMP%]{white-space:pre}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.node-label[_ngcontent-%COMP%]{cursor:pointer}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.node-label[_ngcontent-%COMP%]:hover{text-decoration:underline dotted #0085f2}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.input[_ngcontent-%COMP%]{color:#009e73;font-weight:500}.container[_ngcontent-%COMP%]   table[_ngcontent-%COMP%]   td.output[_ngcontent-%COMP%]{color:#d55e00;font-weight:500}.container[_ngcontent-%COMP%]   .hidden[_ngcontent-%COMP%]{display:none}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Rhe = ["inputValueContent"];
  var Pw = (i59) => ({ items: i59 });
  var Ohe = (i59) => ({ value: i59 });
  var Ahe = (i59, t) => t.label;
  var Nhe = (i59, t) => t.id || t.label;
  var khe = (i59, t) => t.opNode.id;
  var mH = (i59, t) => t.key;
  var Lhe = (i59, t) => t.id;
  function Fhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 30), Z("click", function(r) {
        let o = q(e).$implicit, s = T(6);
        return Y(s.handleLocateNode(o, r));
      }), D(1), b(2, "div", 31)(3, "mat-icon", 32), D(4, "my_location"), x()()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(6);
      C(), Oe(" ", e, " "), C(), U("matTooltip", n.locatorTooltip);
    }
  }
  function Bhe(i59, t) {
    if (i59 & 1 && Qt(0, Fhe, 5, 2, "div", 29, mr), i59 & 2) {
      let e = T(2).$implicit;
      Kt(e.specialValue.nodeIds);
    }
  }
  function Vhe(i59, t) {
    if (i59 & 1 && X(0, Bhe, 2, 0), i59 & 2) {
      let e, n = T().$implicit, r = T(3);
      he((e = n.specialValue.type) === r.NodeAttributeValueType.NODE_IDS ? 0 : -1);
    }
  }
  function zhe(i59, t) {
    if (i59 & 1 && ae(0, "expandable-info-text", 28), i59 & 2) {
      let e = T().$implicit;
      U("text", e.value)("type", e.label)("bgColor", e.bgColor || "transparent")("textColor", e.textColor || "black");
    }
  }
  function Uhe(i59, t) {
    if (i59 & 1 && (b(0, "tr")(1, "td", 25), ae(2, "hoverable-label", 26), x(), b(3, "td", 27), X(4, Vhe, 1, 1)(5, zhe, 1, 4, "expandable-info-text", 28), x()()), i59 & 2) {
      let e = t.$implicit, n = T(3);
      ye("search-match", n.isSearchMatchedAttrId(e.label)), C(2), U("label", e.label), C(2), he(e.specialValue ? 4 : 5);
    }
  }
  function Ghe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 19, 3)(2, "div", 20)(3, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T().$implicit, s = T();
        return Y(s.handleToggleSection(o.label, r));
      }), b(4, "mat-icon"), D(5), x()(), D(6), x(), b(7, "div", 22)(8, "table", 23), Qt(9, Uhe, 6, 4, "tr", 24, Nhe), x()()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T();
      ye("collapsed", n.isSectionCollapsed(e.label)), C(5), Qe(n.getSectionToggleIcon(e.label)), C(), Oe(" ", e.label, " "), C(3), Kt(e.items);
    }
  }
  function Hhe(i59, t) {
    if (i59 & 1 && X(0, Ghe, 11, 4, "div", 18), i59 & 2) {
      let e = t.$implicit;
      he(e.items.length > 0 ? 0 : -1);
    }
  }
  function jhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 19, 4)(2, "div", 20)(3, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.NODE_DATA_PROVIDERS, r));
      }), b(4, "mat-icon"), D(5), x()(), D(6, " Node data providers "), x(), ae(7, "node-data-provider-summary-panel", 33), x();
    }
    if (i59 & 2) {
      let e = T();
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.NODE_DATA_PROVIDERS)), C(5), Qe(e.getSectionToggleIcon(e.SectionLabel.NODE_DATA_PROVIDERS)), C(2), U("paneId", e.paneId)("rootGroupNodeId", e.curSelectedNodeId);
    }
  }
  function Whe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 39), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleInputPaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.ioPageSize)("itemsCount", e.curInputsCount);
    }
  }
  function $he(i59, t) {
    i59 & 1 && fi(0);
  }
  function qhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 34, 5)(2, "div", 35)(3, "div", 36)(4, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.INPUTS, r));
      }), b(5, "mat-icon"), D(6), x()(), D(7), x(), X(8, Whe, 1, 2, "paginator", 37), x(), X(9, $he, 1, 0, "ng-container", 38), x();
    }
    if (i59 & 2) {
      let e = T(), n = Ce(16);
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.INPUTS)), C(6), Qe(e.getSectionToggleIcon(e.SectionLabel.INPUTS)), C(), Oe(" inputs (", e.curInputsCount, ") "), C(), he(e.showInputPaginator ? 8 : -1), C(), U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(7, Pw, e.inputItemsForCurPage));
    }
  }
  function Yhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 39), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleOutputPaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.ioPageSize)("itemsCount", e.outputItems.length);
    }
  }
  function Xhe(i59, t) {
    i59 & 1 && fi(0);
  }
  function Zhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 40, 6)(2, "div", 41)(3, "div", 36)(4, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.OUTPUTS, r));
      }), b(5, "mat-icon"), D(6), x()(), D(7), x(), X(8, Yhe, 1, 2, "paginator", 37), x(), X(9, Xhe, 1, 0, "ng-container", 38), x();
    }
    if (i59 & 2) {
      let e = T(), n = Ce(18);
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.OUTPUTS)), C(6), Qe(e.getSectionToggleIcon(e.SectionLabel.OUTPUTS)), C(), Oe(" outputs (", e.curOutputsCount, ") "), C(), he(e.showOutputPaginator ? 8 : -1), C(), U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(7, Pw, e.outputItemsForCurPage));
    }
  }
  function Qhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 39), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleIdenticalGroupsPaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.ioPageSize)("itemsCount", e.identicalGroupNodes.length);
    }
  }
  function Khe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 19, 7)(2, "div", 42)(3, "div", 36)(4, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.IDENTICAL_GROUPS, r));
      }), b(5, "mat-icon"), D(6), x()(), D(7), x(), X(8, Qhe, 1, 2, "paginator", 37), x(), ae(9, "io-tree", 43), x();
    }
    if (i59 & 2) {
      let e = T();
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.IDENTICAL_GROUPS)), C(6), Qe(e.getSectionToggleIcon(e.SectionLabel.IDENTICAL_GROUPS)), C(), Oe(" Identical layers (", e.identicalGroupNodes.length, ") "), C(), he(e.showIdenticalGroupsPaginator ? 8 : -1), C(), U("data", e.identicalGroupsData)("rendererId", e.curRendererId);
    }
  }
  function Jhe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 39), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleGroupInputPaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.ioPageSize)("itemsCount", e.curGroupInputsCount);
    }
  }
  function epe(i59, t) {
    i59 & 1 && fi(0);
  }
  function tpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 34, 8)(2, "div", 35)(3, "div", 36)(4, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.GROUP_INPUTS, r));
      }), b(5, "mat-icon"), D(6), x()(), D(7), x(), X(8, Jhe, 1, 2, "paginator", 37), x(), X(9, epe, 1, 0, "ng-container", 38), x();
    }
    if (i59 & 2) {
      let e = T(), n = Ce(16);
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.GROUP_INPUTS)), C(6), Qe(e.getSectionToggleIcon(e.SectionLabel.GROUP_INPUTS)), C(), Oe(" layer inputs (", e.curGroupInputsCount, ") "), C(), he(e.showGroupInputPaginator ? 8 : -1), C(), U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(7, Pw, e.groupInputItemsForCurPage));
    }
  }
  function npe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "paginator", 39), Z("change", function(r) {
        q(e);
        let o = T(2);
        return Y(o.handleGroupOutputPaginatorChanged(r));
      }), x();
    }
    if (i59 & 2) {
      let e = T(2);
      U("pageSize", e.ioPageSize)("itemsCount", e.curGroupOutputsCount);
    }
  }
  function ipe(i59, t) {
    i59 & 1 && fi(0);
  }
  function rpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 40, 9)(2, "div", 41)(3, "div", 36)(4, "button", 21), Z("click", function() {
        q(e);
        let r = Ce(1), o = T();
        return Y(o.handleToggleSection(o.SectionLabel.GROUP_OUTPUTS, r));
      }), b(5, "mat-icon"), D(6), x()(), D(7), x(), X(8, npe, 1, 2, "paginator", 37), x(), X(9, ipe, 1, 0, "ng-container", 38), x();
    }
    if (i59 & 2) {
      let e = T(), n = Ce(18);
      ye("collapsed", e.isSectionCollapsed(e.SectionLabel.GROUP_OUTPUTS)), C(6), Qe(e.getSectionToggleIcon(e.SectionLabel.GROUP_OUTPUTS)), C(), Oe(" layer outputs (", e.curGroupOutputsCount, ") "), C(), he(e.showGroupOutputPaginator ? 8 : -1), C(), U("ngTemplateOutlet", n)("ngTemplateOutletContext", wo(7, Pw, e.groupOutputItemsForCurPage));
    }
  }
  function ope(i59, t) {
    if (i59 & 1 && (b(0, "div", 46), D(1), x()), i59 & 2) {
      let e = t.$implicit;
      C(), Oe(" ", e, " ");
    }
  }
  function spe(i59, t) {
    if (i59 & 1 && (b(0, "div", 44), D(1, " Namespace hierarchy "), x(), b(2, "div", 45), Qt(3, ope, 2, 1, "div", 46, lf), x()), i59 & 2) {
      let e = t.value;
      C(3), Kt(e.split("/"));
    }
  }
  function ape(i59, t) {
    if (i59 & 1 && (b(0, "div", 54)(1, "mat-icon", 55), D(2, "arrow_forward"), x(), b(3, "div", 56), D(4), x()()), i59 & 2) {
      let e = T(2).$implicit;
      C(4), Qe(e.targetOpNode.label);
    }
  }
  function lpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 53), D(1), x(), X(2, ape, 5, 1, "div", 54)), i59 & 2) {
      let e = T().$implicit, n = T(2);
      C(), Qe(n.getInputName(e)), C(), he(e.targetOpNode ? 2 : -1);
    }
  }
  function cpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 54)(1, "mat-icon", 55), D(2, "arrow_forward"), x(), b(3, "div", 56), D(4), x()()), i59 & 2) {
      let e = T(2).$implicit;
      C(4), Qe(e.targetOpNode.label);
    }
  }
  function dpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 60), Z("click", function(r) {
        q(e);
        let o = T(2).$implicit, s = T().items, a = T();
        return Y(a.handleToggleInputOpNodeVisibility(o.opNode.id, s, r));
      }), b(1, "mat-icon"), D(2), x()();
    }
    if (i59 & 2) {
      let e = T(2).$implicit, n = T(2);
      ye("visible", n.getInputOpNodeToggleVisible(e.opNode.id)), U("matTooltip", n.getInputOpNodeToggleVisibilityTooltip(e.opNode.id)), C(2), Oe(" ", n.getInputOpNodeToggleVisibilityIcon(e.opNode.id), " ");
    }
  }
  function upe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 57), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T(2);
        return Y(s.handleLocateNode(o.opNode.id, r));
      }), D(1), b(2, "div", 31)(3, "mat-icon", 32), D(4, "my_location"), x()(), X(5, cpe, 5, 1, "div", 54), ae(6, "div", 58), X(7, dpe, 3, 4, "div", 59), x();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T(2);
      Ke("data-id", e.opNode.id), C(), Oe(" ", n.getInputName(e), " "), C(), U("matTooltip", n.locatorTooltip), C(3), he(e.targetOpNode ? 5 : -1), C(2), he(e.opNode.hideInLayout ? -1 : 7);
    }
  }
  function hpe(i59, t) {
    if (i59 & 1 && (b(0, "tr", null, 10)(2, "td", 25)(3, "div", 61)(4, "mat-icon", 62), D(5, "circle"), x(), ae(6, "hoverable-label", 26), x()(), b(7, "td", 27), ae(8, "expandable-info-text", 63), x()()), i59 & 2) {
      let e = T().$implicit, n = T(3);
      ye("search-match", n.isSearchMatchedInputValue(e.value)), C(6), U("label", e.key), C(2), U("text", e.value)("type", e.key);
    }
  }
  function ppe(i59, t) {
    if (i59 & 1 && X(0, hpe, 9, 5, "tr", 24), i59 & 2) {
      let e = t.$implicit, n = T(3);
      he(n.getShowMetadata(e) ? 0 : -1);
    }
  }
  function fpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 48)(1, "div", 49)(2, "div", 50), D(3), x(), X(4, lpe, 3, 2)(5, upe, 8, 5, "div", 51), x(), b(6, "table", 52), Qt(7, ppe, 1, 1, null, null, mH), x()()), i59 & 2) {
      let e = t.$implicit, n = T(2);
      C(), ye("search-match", n.isSearchMatchedInputValue(n.getInputTensorTag(e)) || n.isSearchMatchedInputValue(e.opNode.label)), C(2), Qe(e.index), C(), he(e.opNode.hideInLayout ? 4 : 5), C(3), Kt(e.metadataList);
    }
  }
  function mpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 47), Qt(1, fpe, 9, 4, "div", 48, khe), x()), i59 & 2) {
      let e = t.items;
      C(), Kt(e);
    }
  }
  function gpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 64), D(1), x()), i59 & 2) {
      let e = T().$implicit;
      C(), Oe(" (", e.sourceOpNode.label, ") ");
    }
  }
  function _pe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 66), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T().items, a = T();
        return Y(a.handleToggleOutputVisibility(o, s, r));
      }), b(1, "mat-icon"), D(2), x()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T(2);
      ye("visible", n.getOutputToggleVisible(e)), U("matTooltip", n.getOutputToggleVisibilityTooltip(e)), C(2), Oe(" ", n.getOutputToggleVisibilityIcon(e), " ");
    }
  }
  function vpe(i59, t) {
    i59 & 1 && fi(0);
  }
  function ype(i59, t) {
    if (i59 & 1 && (b(0, "div", 69), X(1, vpe, 1, 0, "ng-container", 38), x()), i59 & 2) {
      let e = T().$implicit, n = T(6), r = Ce(14);
      C(), U("ngTemplateOutlet", r)("ngTemplateOutletContext", wo(2, Ohe, n.getNamespaceLabel(e)));
    }
  }
  function bpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 68), Z("click", function(r) {
        let o = q(e).$implicit, s = T(6);
        return Y(s.handleLocateNode(o.id, r));
      }), D(1), b(2, "div", 31)(3, "mat-icon", 32), D(4, "my_location"), x()()(), X(5, ype, 2, 4, "ng-template", null, 11, Tt);
    }
    if (i59 & 2) {
      let e = t.$implicit, n = Ce(6), r = T(6);
      ye("search-match", r.isSearchMatchedOutputValue(e.label)), U("bubble", n)("overlaySize", r.constValuesPopupSize)("overlayPositions", r.outputConnectsToNamespacePopupPosition)("hoverDelayMs", 50), Ke("data-id", e.id), C(), Oe(" ", e.label, " "), C(), U("matTooltip", r.locatorTooltip);
    }
  }
  function xpe(i59, t) {
    if (i59 & 1 && Qt(0, bpe, 7, 9, null, null, Lhe), i59 & 2) {
      let e = T().$implicit;
      Kt(e.connectedNodes);
    }
  }
  function wpe(i59, t) {
    if (i59 & 1 && ae(0, "expandable-info-text", 67), i59 & 2) {
      let e = T().$implicit;
      U("text", e.value);
    }
  }
  function Cpe(i59, t) {
    if (i59 & 1 && (b(0, "tr")(1, "td", 25)(2, "div", 61)(3, "mat-icon", 62), D(4, "circle"), x(), ae(5, "hoverable-label", 26), x()(), b(6, "td", 27), X(7, xpe, 2, 0)(8, wpe, 1, 1, "expandable-info-text", 67), x()()), i59 & 2) {
      let e = t.$implicit, n = T(4);
      ye("search-match", n.isSearchMatchedOutputValue(e.value)), C(5), U("label", e.key), C(2), he(e.key === n.outputMetadataConnectedTo ? 7 : 8);
    }
  }
  function Spe(i59, t) {
    if (i59 & 1 && (b(0, "table", 52), Qt(1, Cpe, 9, 4, "tr", 24, mH), x()), i59 & 2) {
      let e = T().$implicit;
      C(), Kt(e.metadataList);
    }
  }
  function Mpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 48)(1, "div", 49)(2, "div", 50), D(3), x(), b(4, "div", 53), D(5), x(), X(6, gpe, 2, 1, "div", 64), ae(7, "div", 58), X(8, _pe, 3, 4, "div", 65), x(), X(9, Spe, 3, 0, "table", 52), x()), i59 & 2) {
      let e = t.$implicit, n = T(2);
      C(), ye("search-match", n.isSearchMatchedOutputValue(e.tensorTag)), C(2), Qe(e.index), C(2), Qe(n.getOutputName(e)), C(), he(e.showSourceOpNode ? 6 : -1), C(2), he(n.getHasConnectedToNodes(e) ? 8 : -1), C(), he(e.metadataList.length > 0 ? 9 : -1);
    }
  }
  function Epe(i59, t) {
    if (i59 & 1 && (b(0, "div", 47), Qt(1, Mpe, 10, 7, "div", 48, lf), x()), i59 & 2) {
      let e = t.items;
      C(), Kt(e);
    }
  }
  var _o = function(i59) {
    return i59.GRAPH_INFO = "Graph info", i59.NODE_INFO = "Node info", i59.LAYER_INFO = "Layer info", i59.LAYER_ATTRS = "Layer attributes", i59.ATTRIBUTES = "Attributes", i59.NODE_DATA_PROVIDERS = "Node data providers", i59.IDENTICAL_GROUPS = "Identical groups", i59.INPUTS = "inputs", i59.OUTPUTS = "outputs", i59.GROUP_INPUTS = "layer inputs", i59.GROUP_OUTPUTS = "layer outputs", i59;
  }(_o || {});
  var Tpe = 64;
  var Ipe = 150;
  var fH = 370;
  var gH = (() => {
    class i59 {
      appService;
      nodeDataProviderExtensionService;
      changeDetectorRef;
      infoPanelService;
      splitPaneService;
      paneId;
      inputValueContents = new Ni();
      NodeAttributeValueType = Au;
      curModelGraph;
      curSelectedNode;
      curShowOnOpNodeInfoIds = /* @__PURE__ */ new Set();
      curShowOnOpNodeAttrIds = /* @__PURE__ */ new Set();
      curShowOnGroupNodeInfoIds = /* @__PURE__ */ new Set();
      curShowOnNodeDataProviderRuns = {};
      curSearchResults = void 0;
      width = fH;
      minWidth = fH;
      sections = [];
      inputItems = [];
      inputItemsForCurPage = [];
      outputItems = [];
      outputItemsForCurPage = [];
      groupInputItems = [];
      groupInputItemsForCurPage = [];
      groupOutputItems = [];
      groupOutputItemsForCurPage = [];
      identicalGroupNodes = [];
      identicalGroupsData;
      curRendererId = "";
      curInputsCount = 0;
      curOutputsCount = 0;
      curGroupInputsCount = 0;
      curGroupOutputsCount = 0;
      resizing = false;
      hide = false;
      ioPageSize;
      SectionLabel = _o;
      outputMetadataConnectedTo = "connects to";
      inputMetadataValuesKey = "values";
      inputMetadataNamespaceKey = "namespace";
      locatorTooltip = `Click: locate
Alt+click: select`;
      getNamespaceLabel = Dc;
      constValuesPopupSize = { minWidth: 100, minHeight: 0, maxWidth: 600 };
      constValuesPopupPosition = [{ originX: "start", originY: "top", overlayX: "end", overlayY: "top", offsetX: -32 }];
      outputConnectsToNamespacePopupPosition = [{ originX: "start", originY: "top", overlayX: "end", overlayY: "top", offsetX: -4 }];
      curSearchAttrMatches = [];
      curSearchInputMatches = [];
      curSearchOutputMatches = [];
      savedWidth = 0;
      constructor(e, n, r, o, s) {
        this.appService = e, this.nodeDataProviderExtensionService = n, this.changeDetectorRef = r, this.infoPanelService = o, this.splitPaneService = s, this.ioPageSize = this.appService.testMode ? 5 : 25, ht(() => {
          let a = this.appService.getPaneById(this.paneId);
          if (!a || !a.modelGraph) return;
          this.curModelGraph = a.modelGraph, this.curRendererId = a.selectedNodeInfo?.rendererId || "";
          let l = a.selectedNodeInfo?.nodeId || "";
          this.curSelectedNodeId !== l && (this.handleNodeSelected(l), setTimeout(() => {
            this.splitPaneService.resetInputOutputHiddenIds(), this.handleSearchResultsChanged();
          }));
        }), ht(() => {
          let a = this.appService.getPaneById(this.paneId);
          !a || !a.modelGraph || this.curSearchResults !== a.searchResults && (this.curSearchResults = a.searchResults, this.handleSearchResultsChanged());
        }), ht(() => {
          this.nodeDataProviderExtensionService.runs(), this.genInfoData(), this.changeDetectorRef.markForCheck(), setTimeout(() => {
            this.updateInputValueContentsExpandable();
          });
        });
      }
      isSearchMatchedAttrId(e) {
        return this.curSearchAttrMatches.find((n) => n.matchedAttrId === e) != null;
      }
      isSearchMatchedInputValue(e) {
        return this.curSearchInputMatches ? this.curSearchInputMatches.find((n) => n.matchedText === e) != null : false;
      }
      isSearchMatchedOutputValue(e) {
        return this.curSearchOutputMatches ? this.curSearchOutputMatches.find((n) => n.matchedText === e) != null : false;
      }
      handleMouseDownResizer(e) {
        e.preventDefault(), document.body.style.cursor = "ew-resize";
        let n = zn(document, "mousemove"), r = zn(window, "mouseup"), o = this.width, s = e.clientX;
        this.resizing = true, this.changeDetectorRef.markForCheck(), cr([n]).pipe(Je(r)).subscribe({ next: ([a]) => {
          let l = a.clientX - s;
          this.width = Math.max(Tpe, o - l), this.minWidth = this.width, this.changeDetectorRef.markForCheck();
        }, complete: () => {
          document.body.style.cursor = "default", this.resizing = false, this.changeDetectorRef.markForCheck();
        } });
      }
      handleInputPaginatorChanged(e) {
        this.inputItemsForCurPage = this.inputItems.slice(e * this.ioPageSize, (e + 1) * this.ioPageSize), this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.updateInputValueContentsExpandable();
        });
      }
      handleOutputPaginatorChanged(e) {
        this.outputItemsForCurPage = this.outputItems.slice(e * this.ioPageSize, (e + 1) * this.ioPageSize), this.changeDetectorRef.markForCheck();
      }
      handleGroupInputPaginatorChanged(e) {
        this.groupInputItemsForCurPage = this.groupInputItems.slice(e * this.ioPageSize, (e + 1) * this.ioPageSize), this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.updateInputValueContentsExpandable();
        });
      }
      handleGroupOutputPaginatorChanged(e) {
        this.groupOutputItemsForCurPage = this.groupOutputItems.slice(e * this.ioPageSize, (e + 1) * this.ioPageSize), this.changeDetectorRef.markForCheck();
      }
      handleIdenticalGroupsPaginatorChanged(e) {
        this.identicalGroupsData = Ha(this.identicalGroupNodes.slice(e * this.ioPageSize, (e + 1) * this.ioPageSize), [], "incoming", this.curSelectedNode?.id || "");
      }
      toggleHideInfoPanel() {
        this.hide = !this.hide;
        let e = 0;
        this.hide ? this.savedWidth = this.width : e = this.savedWidth, this.animateSidePanelWidth(e);
      }
      handleToggleSection(e, n) {
        if (!n) return;
        this.isSectionCollapsed(e) ? n.style.maxHeight = `${n.scrollHeight}px` : (n.style.maxHeight = `${n.offsetHeight}px`, n.style.overflow = "hidden"), this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.infoPanelService.collapsedSectionNames.has(e) ? this.infoPanelService.collapsedSectionNames.delete(e) : this.infoPanelService.collapsedSectionNames.add(e), this.changeDetectorRef.markForCheck(), setTimeout(() => {
            this.isSectionCollapsed(e) ? n.style.overflow = "hidden" : (n.style.overflow = "visible", n.style.maxHeight = "fit-content");
          }, 150);
        });
      }
      isSectionCollapsed(e) {
        return this.infoPanelService.collapsedSectionNames.has(e);
      }
      getSectionToggleIcon(e) {
        return this.isSectionCollapsed(e) ? "chevron_right" : "expand_more";
      }
      handleLocateNode(e, n) {
        this.appService.curToLocateNodeInfo.set({ nodeId: e, rendererId: this.curRendererId, isGroupNode: false, select: n.altKey });
      }
      handleToggleInputOpNodeVisibility(e, n, r) {
        r.stopPropagation(), r.altKey ? this.splitPaneService.setInputOpNodeVisible(e, n.map((o) => o.opNode.id)) : this.splitPaneService.toggleInputOpNodeVisibility(e);
      }
      getInputOpNodeToggleVisible(e) {
        return this.splitPaneService.getInputOpNodeVisible(e);
      }
      getInputOpNodeToggleVisibilityIcon(e) {
        return this.getInputOpNodeToggleVisible(e) ? "visibility" : "visibility_off";
      }
      getInputOpNodeToggleVisibilityTooltip(e) {
        return this.getInputOpNodeToggleVisible(e) ? "Click to hide highlight" : "Click to show highlight";
      }
      handleToggleOutputVisibility(e, n, r) {
        r.stopPropagation(), r.altKey ? this.splitPaneService.setOutputVisible(e.sourceOpNode.id, e.outputId, n.map((o) => ({ nodeId: o.sourceOpNode.id, outputId: o.outputId }))) : this.splitPaneService.toggleOutputVisibility(e.sourceOpNode.id, e.outputId);
      }
      getOutputToggleVisible(e) {
        return this.splitPaneService.getOutputVisible(e.sourceOpNode.id, e.outputId);
      }
      getOutputToggleVisibilityIcon(e) {
        return this.getOutputToggleVisible(e) ? "visibility" : "visibility_off";
      }
      getOutputToggleVisibilityTooltip(e) {
        return this.getOutputToggleVisible(e) ? "Click to hide highlight" : "Click to show highlight";
      }
      getInputName(e) {
        let n = e.metadataList.find((r) => r.key === To);
        return n ? `${n.value} (${e.opNode.label})` : e.opNode.label;
      }
      getInputTensorTag(e) {
        return e.metadataList.find((r) => r.key === To)?.value ?? "";
      }
      getOutputName(e) {
        return e.tensorTag === "" ? "output" : e.tensorTag;
      }
      getShowMetadata(e) {
        return !e.key.startsWith("__");
      }
      getHasConnectedToNodes(e) {
        return (e.metadataList.find((r) => r.key === this.outputMetadataConnectedTo)?.connectedNodes || []).length > 0;
      }
      trackByItemIdOrLabel(e, n) {
        return n.id || n.label;
      }
      get canShowGraphInfo() {
        return this.curModelGraph != null && this.curSelectedNode == null;
      }
      get showNodeDataProviderSummary() {
        return !this.curModelGraph || this.appService.config()?.hideNodeDataInInfoPanel ? false : (this.curSelectedNode == null || ct(this.curSelectedNode)) && this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph).length > 0;
      }
      get curSelectedNodeId() {
        return this.curSelectedNode ? this.curSelectedNode.id : void 0;
      }
      get showInputPaginator() {
        return this.inputItems.length > this.ioPageSize && !this.isSectionCollapsed(_o.INPUTS);
      }
      get showOutputPaginator() {
        return this.outputItems.length > this.ioPageSize && !this.isSectionCollapsed(_o.OUTPUTS);
      }
      get showGroupInputPaginator() {
        return this.groupInputItems.length > this.ioPageSize && !this.isSectionCollapsed(_o.GROUP_INPUTS);
      }
      get showGroupOutputPaginator() {
        return this.groupOutputItems.length > this.ioPageSize && !this.isSectionCollapsed(_o.GROUP_OUTPUTS);
      }
      get showIdenticalGroupsPaginator() {
        return this.identicalGroupNodes.length > this.ioPageSize && !this.isSectionCollapsed(_o.IDENTICAL_GROUPS);
      }
      get hideToggleTooltip() {
        return this.hide ? "Show info panel" : "Hide info panel";
      }
      get hideToggleIconName() {
        return this.hide ? "chevron_left" : "chevron_right";
      }
      handleNodeSelected(e) {
        !this.curModelGraph || !e ? this.curSelectedNode = void 0 : this.curSelectedNode = this.curModelGraph.nodesById[e], this.genInfoData(), this.changeDetectorRef.markForCheck(), setTimeout(() => {
          this.updateInputValueContentsExpandable();
        });
      }
      genInfoData() {
        this.sections = [], this.inputItems = [], this.outputItems = [], this.groupInputItems = [], this.groupOutputItems = [], this.identicalGroupNodes = [], this.identicalGroupsData = void 0, this.canShowGraphInfo ? this.genInfoDataForGraph() : this.curSelectedNode && (dt(this.curSelectedNode) ? (this.genInfoDataForSelectedOpNode(), this.genInputsOutputsData()) : ct(this.curSelectedNode) && (this.genInfoDataForSelectedGroupNode(), this.appService.config()?.highlightLayerNodeInputsOutputs && this.genGroupInputsOutputsData()));
      }
      genInfoDataForGraph() {
        if (!this.curModelGraph) return;
        let e = { label: _o.GRAPH_INFO, sectionType: "graph", items: [] };
        this.sections.push(e);
        let n = this.curModelGraph.groupNodeAttributes?.[""];
        if (n) for (let s of Object.keys(n)) e.items.push({ section: e, label: s, value: n[s] });
        let r = 0, o = 0;
        for (let s of this.curModelGraph.nodes) dt(s) && !s.hideInLayout ? r++ : ct(s) && o++;
        e.items.push({ section: e, label: "op node count", value: String(r) }, { section: e, label: "layer count", value: String(o) });
      }
      genInfoDataForSelectedOpNode() {
        if (!this.curModelGraph || !this.curSelectedNode) return;
        let e = this.curSelectedNode, n = this.appService.config(), r = { label: _o.NODE_INFO, sectionType: "op", items: [] };
        this.sections.push(r);
        let o = n?.renameNodeInfoOpNameTo ?? "op name";
        r.items.push({ section: r, label: o, value: `${e.label}` }), o = "id", r.items.push({ section: r, label: o, value: e.id, canShowOnNode: true, showOnNode: this.curShowOnOpNodeInfoIds.has(o) }), o = "namespace", r.items.push({ section: r, label: o, value: Dc(e), canShowOnNode: true, showOnNode: this.curShowOnOpNodeInfoIds.has(o) });
        let s = n?.nodeInfoKeysToHide ?? [];
        if (r.items = r.items.filter((l) => !(n && s.some((c) => l.label.match(c)))), Object.keys(e.attrs || {}).length > 0) {
          let l = { label: _o.ATTRIBUTES, sectionType: "op", items: [] }, c = e.attrs || {};
          for (let d of Object.keys(c)) {
            if (d.startsWith("__")) continue;
            let u = c[d], h = typeof u == "string" ? u : "", p = typeof u == "string" ? void 0 : u;
            l.items.push({ section: l, label: d, value: h, canShowOnNode: true, showOnNode: this.curShowOnOpNodeAttrIds.has(d), specialValue: p });
          }
          l.items.length > 0 && this.sections.push(l);
        }
        let a = this.nodeDataProviderExtensionService.getRunsForModelGraph(this.curModelGraph);
        if (a.length > 0) {
          let l = { label: _o.NODE_DATA_PROVIDERS, sectionType: "op", items: [] };
          this.sections.push(l);
          for (let c of a) {
            let d = ((c.results || {})[this.curModelGraph.id] || {})[e.id];
            if (this.appService.config()?.hideEmptyNodeDataEntries && !d) continue;
            let u = d?.strValue || "-", h = d?.bgColor || "transparent", p = d?.textColor || "black";
            l.items.push({ id: c.runId, section: l, label: va(c, this.curModelGraph), value: u, canShowOnNode: c.done, showOnNode: this.curShowOnNodeDataProviderRuns[c.runId] != null, bgColor: h, textColor: p, loading: !c.done });
          }
        }
      }
      genInputsOutputsData() {
        if (!this.curModelGraph || !this.curSelectedNode) return;
        let e = this.curSelectedNode, n = e.incomingEdges || [];
        this.inputItems = [];
        for (let a = 0; a < n.length; a++) {
          let l = n[a], c = this.genInputMetadataList(e, l), d = this.curModelGraph?.nodesById[l.sourceNodeId];
          this.inputItems.push({ index: a, opNode: d, metadataList: c });
        }
        this.curInputsCount = this.inputItems.length, this.inputItemsForCurPage = this.inputItems.slice(0, this.ioPageSize), this.outputItems = [];
        let r = e.outputsMetadata || {}, o = e.outgoingEdges || [], s = 0;
        for (let a of Object.keys(r)) {
          let l = o.filter((u) => u.sourceNodeOutputId === a).map((u) => this.curModelGraph.nodesById[u.targetNodeId]), { metadataList: c, tensorTag: d } = this.genOutputMetadataList(o, r[a], l);
          this.outputItems.push({ index: s, tensorTag: d, outputId: a, sourceOpNode: e, metadataList: c }), s++;
        }
        this.curOutputsCount = this.outputItems.length, this.outputItemsForCurPage = this.outputItems.slice(0, this.ioPageSize);
      }
      genGroupInputsOutputsData() {
        if (!this.curModelGraph || !this.curSelectedNode) return;
        let e = this.curSelectedNode, n = /* @__PURE__ */ new Set();
        this.groupInputItems = [];
        let r = 0;
        for (let o of e.descendantsOpNodeIds || []) {
          let s = new Set(e.descendantsOpNodeIds || []), a = this.curModelGraph?.nodesById[o], l = a.incomingEdges || [];
          for (let c of l) {
            let d = this.curModelGraph?.nodesById[c.sourceNodeId];
            if (s.has(d.id) || n.has(d.id)) continue;
            n.add(d.id);
            let u = this.genInputMetadataList(a, c);
            this.groupInputItems.push({ index: r++, opNode: d, metadataList: u, targetOpNode: a });
          }
        }
        this.curGroupInputsCount = this.groupInputItems.length, this.groupInputItemsForCurPage = this.groupInputItems.slice(0, this.ioPageSize), this.groupOutputItems = [], r = 0;
        for (let o of e.descendantsOpNodeIds || []) {
          let s = new Set(e.descendantsOpNodeIds || []), a = this.curModelGraph?.nodesById[o], l = a.outputsMetadata || {}, c = a.outgoingEdges || [];
          for (let d of Object.keys(l)) {
            let u = c.filter((f) => !s.has(f.targetNodeId)).filter((f) => f.sourceNodeOutputId === d).map((f) => this.curModelGraph.nodesById[f.targetNodeId]);
            if (u.length === 0) continue;
            let { metadataList: h, tensorTag: p } = this.genOutputMetadataList(c, l[d], u);
            this.groupOutputItems.push({ index: r, tensorTag: p, outputId: d, sourceOpNode: a, metadataList: h, showSourceOpNode: true }), r++;
          }
        }
        this.curGroupOutputsCount = this.groupOutputItems.length, this.groupOutputItemsForCurPage = this.groupOutputItems.slice(0, this.ioPageSize);
      }
      genInputMetadataList(e, n) {
        let r = this.curModelGraph?.nodesById[n.sourceNodeId], o = (e.inputsMetadata || {})[n.targetNodeInputId] || {}, s = le({}, (r.outputsMetadata || {})[n.sourceNodeOutputId] || {});
        for (let u of Object.keys(s)) o[u] == null && u !== To && (o[u] = s[u]);
        let a = [];
        Object.entries(o).forEach(([u, h]) => {
          a.push({ key: u, value: h });
        }), a.sort((u, h) => u.key.localeCompare(h.key)), a.push({ key: this.inputMetadataNamespaceKey, value: Dc(r) });
        let l = r.attrs || {};
        if (l[_a]) {
          let u = l[_a];
          typeof u == "string" && a.push({ key: this.inputMetadataValuesKey, value: u });
        }
        let c = this.appService.config(), d = c?.inputMetadataKeysToHide ?? [];
        return a.filter((u) => !(c && d.some((h) => u.key.match(h))));
      }
      genOutputMetadataList(e, n, r) {
        let o = [], s = "";
        for (let c of Object.keys(n)) {
          let d = n[c];
          c === To && (s = d), !c.startsWith("__") && o.push({ key: c, value: d });
        }
        o.sort((c, d) => c.key.localeCompare(d.key)), o.push({ key: this.outputMetadataConnectedTo, value: "", connectedNodes: r });
        let a = this.appService.config(), l = a?.outputMetadataKeysToHide ?? [];
        return o = o.filter((c) => !(a && l.some((d) => c.key.match(d)))), { metadataList: o, tensorTag: s };
      }
      genInfoDataForSelectedGroupNode() {
        if (!this.curModelGraph || !this.curSelectedNode) return;
        let e = this.curSelectedNode, n = { label: _o.LAYER_INFO, sectionType: "group", items: [] };
        this.sections.push(n);
        let r = "name";
        n.items.push({ section: n, label: "name", value: e.label }), r = "namespace", n.items.push({ section: n, label: r, value: Dc(e), canShowOnNode: true, showOnNode: this.curShowOnGroupNodeInfoIds.has(r) }), r = "#children", n.items.push({ section: n, label: r, value: String((e.nsChildrenIds || []).length), canShowOnNode: true, showOnNode: this.curShowOnGroupNodeInfoIds.has(r) }), r = "#descendants", n.items.push({ section: n, label: r, value: String((e.descendantsNodeIds || []).length), canShowOnNode: true, showOnNode: this.curShowOnGroupNodeInfoIds.has(r) });
        let o = this.appService.config(), s = o?.nodeInfoKeysToHide ?? [];
        n.items = n.items.filter((l) => !(o && s.some((c) => l.label.match(c))));
        let a = this.curModelGraph.groupNodeAttributes?.[e.id.replace("___group___", "")];
        if (a) {
          let l = { label: _o.LAYER_ATTRS, sectionType: "group", items: [] };
          this.sections.push(l);
          for (let c of Object.keys(a)) l.items.push({ section: n, label: c, value: a[c] });
        }
        e.identicalGroupIndex != null && (this.identicalGroupNodes = this.curModelGraph.nodes.filter((l) => ct(l) && l.identicalGroupIndex === e.identicalGroupIndex), this.identicalGroupsData = Ha(this.identicalGroupNodes.slice(0, this.ioPageSize), [], "incoming", e.id));
      }
      handleSearchResultsChanged() {
        if (!this.curSelectedNode || !this.curSearchResults) return;
        let e = this.curSelectedNode.id, n = this.curSearchResults.results[e] || [], r = [], o = [], s = [];
        for (let a of n) switch (a.type) {
          case _t.INPUT_METADATA:
            r.push(a);
            break;
          case _t.OUTPUT_METADATA:
            o.push(a);
            break;
          case _t.ATTRIBUTE:
            s.push(a);
            break;
          default:
            break;
        }
        this.curSearchAttrMatches = s, this.curSearchOutputMatches = o, this.curSearchInputMatches = r, this.changeDetectorRef.markForCheck();
      }
      animateSidePanelWidth(e) {
        let n = Date.now(), r = this.width, o = () => {
          let s = Date.now() - n, a = this.appService.testMode ? 1 : Math.min(1, s / Ipe);
          a = Math.sin(a * Math.PI / 2);
          let l = r + (e - r) * a;
          if (this.width = l, this.minWidth = l, this.changeDetectorRef.markForCheck(), a >= 1) {
            this.width = e, this.minWidth = e, this.changeDetectorRef.markForCheck();
            return;
          }
          requestAnimationFrame(o);
        };
        o();
      }
      updateInputValueContentsExpandable() {
        for (let e = 0; e < this.inputValueContents.length; e++) {
          let n = this.inputValueContents.get(e)?.nativeElement;
          n && n.scrollHeight > n.offsetHeight && n.classList.add("expandable");
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Cr), K(Ge), K(vp), K(Fl));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["info-panel"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Rhe, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.inputValueContents = o);
        }
      }, hostVars: 4, hostBindings: function(n, r) {
        n & 2 && sn("width", r.width, "px")("min-width", r.minWidth, "px");
      }, inputs: { paneId: "paneId" }, features: [Bt([vp])], decls: 19, vars: 12, consts: [["namespaceHierarchy", ""], ["inputItemsTmpl", ""], ["outputItemsTmpl", ""], ["sectionEle", ""], ["ndpSectionEle", ""], ["inputsSectionEle", ""], ["outputsSectionEle", ""], ["identicalGroupsSectionEle", ""], ["groupInputsSectionEle", ""], ["groupOutputsSectionEle", ""], ["rowEle", ""], ["namespacePopup", ""], [1, "container"], ["class", "section", 3, "collapsed", 4, "ngIf"], ["class", "section inputs", 3, "collapsed", 4, "ngIf"], ["class", "section outputs", 3, "collapsed", 4, "ngIf"], [1, "resizer", 3, "mousedown"], [1, "hide-toggle", 3, "click", "matTooltip"], [1, "section", 3, "collapsed"], [1, "section"], [1, "header"], ["mat-icon-button", "", 1, "toggle", 3, "click"], [1, "items-container"], [1, "metadata-table", "info-attrs"], [3, "search-match"], [1, "key"], [3, "label"], [1, "value"], [3, "text", "type", "bgColor", "textColor"], [1, "node-id-attribute"], [1, "node-id-attribute", 3, "click"], ["matTooltipClass", "multiline-tooltip-left", "matTooltipPosition", "right", 1, "locator-icon-container", 3, "matTooltip"], [1, "locator-icon"], [3, "paneId", "rootGroupNodeId"], [1, "section", "inputs"], [1, "header", "input"], [1, "header-label-container"], [3, "pageSize", "itemsCount"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "change", "pageSize", "itemsCount"], [1, "section", "outputs"], [1, "header", "output"], [1, "header", "identical-groups"], [3, "data", "rendererId"], [1, "values-count-msg"], [1, "namespace-content"], [1, "namespace-row"], [1, "flat-items-container"], [1, "flat-item"], [1, "name-row"], [1, "index"], [1, "name", "locator"], [1, "metadata-table"], [1, "name"], [1, "target-op-container"], [1, "arrow"], [1, "target-op-node-label"], [1, "name", "locator", 3, "click"], [1, "filler"], ["matTooltipPosition", "left", 1, "visibility-icon-container", "input", 3, "matTooltip", "visible"], ["matTooltipPosition", "left", 1, "visibility-icon-container", "input", 3, "click", "matTooltip"], [1, "key-container"], [1, "bullet"], [3, "text", "type"], [1, "source-op-node-label"], ["matTooltipPosition", "left", 1, "visibility-icon-container", "output", 3, "visible", "matTooltip"], ["matTooltipPosition", "left", 1, "visibility-icon-container", "output", 3, "click", "matTooltip"], [3, "text"], [1, "target-node-container", 3, "click", "bubble", "overlaySize", "overlayPositions", "hoverDelayMs"], [1, "model-explorer-const-values-popup"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 12), Qt(1, Hhe, 1, 1, null, null, Ahe), X(3, jhe, 8, 5, "div", 13)(4, qhe, 10, 9, "div", 14)(5, Zhe, 10, 9, "div", 15)(6, Khe, 10, 7, "div", 13)(7, tpe, 10, 9, "div", 14)(8, rpe, 10, 9, "div", 15), x(), b(9, "div", 16), Z("mousedown", function(a) {
            return q(o), Y(r.handleMouseDownResizer(a));
          }), x(), b(10, "div", 17), Z("click", function() {
            return q(o), Y(r.toggleHideInfoPanel());
          }), b(11, "mat-icon"), D(12), x()(), X(13, spe, 5, 0, "ng-template", null, 0, Tt)(15, mpe, 3, 0, "ng-template", null, 1, Tt)(17, Epe, 3, 0, "ng-template", null, 2, Tt);
        }
        n & 2 && (ye("graph-info", r.showNodeDataProviderSummary), C(), Kt(r.sections), C(2), U("ngIf", r.showNodeDataProviderSummary), C(), U("ngIf", r.inputItems.length > 0), C(), U("ngIf", r.outputItems.length > 0), C(), U("ngIf", r.identicalGroupsData), C(), U("ngIf", r.groupInputItems.length > 0), C(), U("ngIf", r.groupOutputItems.length > 0), C(), ye("resizing", r.resizing), C(), U("matTooltip", r.hideToggleTooltip), C(2), Qe(r.hideToggleIconName));
      }, dependencies: [Bn, et, In, Ss, cH, dH, Hn, pl, vt, St, Zs, lH, tn, $n, _p, Ul, pH], styles: [`[_nghost-%COMP%]{position:relative;width:370px;min-width:370px}.container[_ngcontent-%COMP%]{width:100%;height:100%;box-sizing:border-box;border-left:1px solid #e1e3e1;background-color:#fff;font-size:12px;overflow-y:auto;position:relative}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]{transition:max-height .15s ease-out;padding-bottom:8px;box-sizing:border-box}.container[_ngcontent-%COMP%]   .section.collapsed[_ngcontent-%COMP%]{max-height:32px!important;overflow:hidden}.container[_ngcontent-%COMP%]   .section.inputs[_ngcontent-%COMP%]{padding-bottom:16px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-items-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;margin-top:10px;gap:8px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]{display:flex;flex-direction:column;padding:0 2px 0 12px;font-size:12px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]   .index[_ngcontent-%COMP%]{color:#999;min-width:14px;margin-right:2px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]   .name[_ngcontent-%COMP%]{color:#00639b;font-weight:500;display:flex;align-items:center}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]   .name.locator[_ngcontent-%COMP%]{flex-grow:1;display:flex;align-items:center;cursor:pointer}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]   .name.locator[_ngcontent-%COMP%]:hover{background-color:#f6f6f6}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .name-row[_ngcontent-%COMP%]   .name.locator[_ngcontent-%COMP%]:hover   .locator-icon-container[_ngcontent-%COMP%]{opacity:.8}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .target-op-container[_ngcontent-%COMP%]{display:flex;align-items:center;color:#999;font-weight:400}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .target-op-container[_ngcontent-%COMP%]   mat-icon.arrow[_ngcontent-%COMP%]{font-size:12px;height:12px;width:12px;margin:0 4px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .source-op-node-label[_ngcontent-%COMP%]{color:#999;font-weight:400;margin-left:6px}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .flat-item[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]{margin-top:3px;margin-left:18px;margin-right:0}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]   .node-id-attribute[_ngcontent-%COMP%]{display:flex;cursor:pointer}.container[_ngcontent-%COMP%]   .section[_ngcontent-%COMP%]:not(:first-child){border-top:1px solid #dadce0}.container[_ngcontent-%COMP%]   .filler[_ngcontent-%COMP%]{flex-grow:1}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]{display:flex;align-items:center;font-size:11px;font-weight:700;padding:4px 12px 0;text-transform:uppercase;position:sticky;top:0;z-index:100;flex-shrink:0;box-sizing:border-box;background-color:#fff;-webkit-user-select:none;user-select:none;color:#000000de}.container[_ngcontent-%COMP%]   .header.input[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .header.output[_ngcontent-%COMP%], .container[_ngcontent-%COMP%]   .header.identical-groups[_ngcontent-%COMP%]{justify-content:space-between}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   .header-label-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   button.toggle[_ngcontent-%COMP%]{padding:0;width:24px;height:24px;margin-left:-8px;margin-right:2px;display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   button.toggle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:inherit;font-size:20px;width:20px;height:20px}.container[_ngcontent-%COMP%]   .header[_ngcontent-%COMP%]   button.toggle[_ngcontent-%COMP%]     .mat-mdc-button-touch-target{display:none}.container[_ngcontent-%COMP%]   .output-item-container[_ngcontent-%COMP%]{font-family:Roboto,sans-serif}.container[_ngcontent-%COMP%]   .output-item-container[_ngcontent-%COMP%]:not(.last){margin-top:8px}.container[_ngcontent-%COMP%]   .output-item-label[_ngcontent-%COMP%]{font-size:13px;padding:4px 12px;color:#00639b;font-weight:500}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]{border-spacing:0;border-collapse:collapse;font-size:12px;margin:0 12px;word-break:break-all;max-width:calc(100% - 28px)}.container[_ngcontent-%COMP%]   .metadata-table.info-attrs[_ngcontent-%COMP%]{margin-left:30px}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]{vertical-align:text-top}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]:hover.has-hover-values{cursor:pointer;background-color:#f6f6f6}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   mat-icon.bullet[_ngcontent-%COMP%]{flex-shrink:0;font-size:4px;width:5px;height:5px;color:#bbb;margin-right:4px;margin-top:6px}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.key[_ngcontent-%COMP%]{color:#999;padding-right:6px;white-space:nowrap;min-width:100px;width:100px;max-width:100px;overflow:hidden;text-overflow:ellipsis;position:relative}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.key[_ngcontent-%COMP%]   .key-container[_ngcontent-%COMP%]{display:flex;align-items:flex-start;overflow:hidden;position:absolute;inset:0}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.value[_ngcontent-%COMP%]{max-width:10px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   td.value[_ngcontent-%COMP%]:has(expandable-info-text.expanded){white-space:normal;max-width:inherit}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   .target-node-container[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   .target-node-container[_ngcontent-%COMP%]:hover   .locator-icon-container[_ngcontent-%COMP%]{opacity:.8}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   .target-node-container.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.container[_ngcontent-%COMP%]   .metadata-table[_ngcontent-%COMP%]   .values-hover-trigger[_ngcontent-%COMP%]{box-sizing:border-box;border-radius:99px;display:flex;align-items:center;background-color:#d7f1ff;color:#00639b;width:fit-content;height:16px;padding:0 6px;font-size:10px}.container[_ngcontent-%COMP%]   .items-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:4px;margin-top:10px;margin-bottom:6px}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;padding:0 12px}.container[_ngcontent-%COMP%]   .item-container.search-match[_ngcontent-%COMP%]{background-color:#f5e25a}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .label-row[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{font-weight:500;color:#aaa;font-size:12px;margin-bottom:1px}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .show-on-node-toggle[_ngcontent-%COMP%]{height:16px;display:flex;font-size:11px;align-items:center;justify-content:center;box-sizing:border-box;cursor:pointer;-webkit-user-select:none;user-select:none;transform:scale(.7);margin-right:-6px;margin-top:-1px}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .value[_ngcontent-%COMP%]{font-size:13px;word-break:break-word}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .value.big-text[_ngcontent-%COMP%]{font-size:14px;font-weight:500}.container[_ngcontent-%COMP%]   .item-container[_ngcontent-%COMP%]   .value.has-bg-color[_ngcontent-%COMP%]{padding:2px 4px;border-radius:4px;margin-top:2px}.container[_ngcontent-%COMP%]   .locator-icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;opacity:.5;margin-left:4px}.container[_ngcontent-%COMP%]   .locator-icon-container.left[_ngcontent-%COMP%]{margin-right:4px;margin-left:0;display:inline-block}.container[_ngcontent-%COMP%]   .locator-icon-container.left[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin-bottom:-2px}.container[_ngcontent-%COMP%]   .locator-icon-container[_ngcontent-%COMP%]:hover{opacity:.8}.container[_ngcontent-%COMP%]   .locator-icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#333;font-size:12px;width:12px;height:12px}.container[_ngcontent-%COMP%]   .visibility-icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;opacity:.5;padding:0 11px 0 20px;cursor:pointer}.container[_ngcontent-%COMP%]   .visibility-icon-container[_ngcontent-%COMP%]:hover{opacity:.8}.container[_ngcontent-%COMP%]   .visibility-icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#333;font-size:14px;width:14px;height:14px}.container[_ngcontent-%COMP%]   .visibility-icon-container.input.visible[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#009e73}.container[_ngcontent-%COMP%]   .visibility-icon-container.output.visible[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#d55e00}.resizer[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;left:0;width:6px;cursor:ew-resize;background-color:transparent;z-index:200}.resizer[_ngcontent-%COMP%]:hover, .resizer.resizing[_ngcontent-%COMP%]{background-color:#0000000a}.hide-toggle[_ngcontent-%COMP%]{position:absolute;right:100%;bottom:2px;width:16px;height:20px;border:1px solid #ccc;border-right:none;box-sizing:border-box;border-radius:99px 0 0 99px;cursor:pointer;background-color:#fff}.hide-toggle[_ngcontent-%COMP%]:hover{background-color:#eee}.hide-toggle[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{width:18px;height:18px;font-size:18px;color:#999}  bubble-container:has(.model-explorer-const-values-popup){width:100%}  .model-explorer-const-values-popup{padding:8px;line-height:12px;background-color:#fff}  .model-explorer-const-values-popup .values-count-msg{margin-bottom:8px;color:#999;font-size:12px}  .model-explorer-const-values-popup .content{font-size:11px;white-space:pre-wrap;font-family:monospace}  .model-explorer-const-values-popup .namespace-row{font-size:12px;padding:3px 0}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function Dpe(i59, t) {
    if (i59 & 1 && ae(0, "graph-panel", 3), i59 & 2) {
      let e = T();
      U("@showModelGraph", void 0)("@.disabled", e.disableAnimation)("modelGraph", e.pane.modelGraph)("paneId", e.pane.id)("rendererId", e.pane.id);
    }
  }
  function Ppe(i59, t) {
    if (i59 & 1 && ae(0, "info-panel", 2), i59 & 2) {
      let e = T();
      U("paneId", e.pane.id);
    }
  }
  var _H = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      edgeOverlaysService;
      pane;
      constructor(e, n, r) {
        this.appService = e, this.changeDetectorRef = n, this.edgeOverlaysService = r;
      }
      ngOnInit() {
        let e = this.appService.config(), n = this.appService.panes();
        if (n.length > 0 && n[0].id === this.pane.id && e?.edgeOverlaysDataListLeftPane) for (let r of e.edgeOverlaysDataListLeftPane) this.edgeOverlaysService.addEdgeOverlayData(r);
        else if (n.length > 1 && n[1].id === this.pane.id && e?.edgeOverlaysDataListRightPane) for (let r of e.edgeOverlaysDataListRightPane) this.edgeOverlaysService.addEdgeOverlayData(r);
      }
      refresh() {
        this.changeDetectorRef.markForCheck();
      }
      get disableAnimation() {
        return this.appService.testMode;
      }
      get showInfoPanel() {
        return !this.appService.config()?.hideInfoPanel;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(Gs));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["split-pane"]], inputs: { pane: "pane" }, features: [Bt([Gs, Fo, Fl])], decls: 3, vars: 2, consts: [[1, "container"], [3, "modelGraph", "paneId", "rendererId", 4, "ngIf"], [3, "paneId"], [3, "modelGraph", "paneId", "rendererId"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0), X(1, Dpe, 1, 5, "graph-panel", 1)(2, Ppe, 1, 1, "info-panel", 2), x()), n & 2 && (C(), U("ngIf", r.pane.modelGraph), C(), he(r.showInfoPanel ? 2 : -1));
      }, dependencies: [et, In, sH, gH], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;overflow:hidden}.container[_ngcontent-%COMP%]   graph-panel[_ngcontent-%COMP%]{flex-grow:1}

















`], data: { animation: [ki("showModelGraph", [Zi("void", _n({ opacity: 0, transform: "scale(1.03, 1.03)" })), Yn("void => *", oi("150ms 100ms ease-out", _n({ opacity: 1, transform: "scale(1, 1)" })))])] }, changeDetection: 0 });
    }
    return i59;
  })();
  var Rpe = ["input"];
  var Ope = ["formField"];
  var Ape = ["*"];
  var $D = class {
    source;
    value;
    constructor(t, e) {
      this.source = t, this.value = e;
    }
  };
  var Npe = new Ee("MatRadioGroup");
  var kpe = new Ee("mat-radio-default-options", { providedIn: "root", factory: Lpe });
  function Lpe() {
    return { color: "accent", disabledInteractive: false };
  }
  var qD = (() => {
    class i59 {
      _elementRef = M(He);
      _changeDetector = M(Ge);
      _focusMonitor = M(so);
      _radioDispatcher = M(wU);
      _defaultOptions = M(kpe, { optional: true });
      _ngZone = M(We);
      _renderer = M(Pr);
      _uniqueId = M(kn).getId("mat-radio-");
      _cleanupClick;
      id = this._uniqueId;
      name;
      ariaLabel;
      ariaLabelledby;
      ariaDescribedby;
      disableRipple = false;
      tabIndex = 0;
      get checked() {
        return this._checked;
      }
      set checked(e) {
        this._checked !== e && (this._checked = e, e && this.radioGroup && this.radioGroup.value !== this.value ? this.radioGroup.selected = this : !e && this.radioGroup && this.radioGroup.value === this.value && (this.radioGroup.selected = null), e && this._radioDispatcher.notify(this.id, this.name), this._changeDetector.markForCheck());
      }
      get value() {
        return this._value;
      }
      set value(e) {
        this._value !== e && (this._value = e, this.radioGroup !== null && (this.checked || (this.checked = this.radioGroup.value === e), this.checked && (this.radioGroup.selected = this)));
      }
      get labelPosition() {
        return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || "after";
      }
      set labelPosition(e) {
        this._labelPosition = e;
      }
      _labelPosition;
      get disabled() {
        return this._disabled || this.radioGroup !== null && this.radioGroup.disabled;
      }
      set disabled(e) {
        this._setDisabled(e);
      }
      get required() {
        return this._required || this.radioGroup && this.radioGroup.required;
      }
      set required(e) {
        this._required = e;
      }
      get color() {
        return this._color || this.radioGroup && this.radioGroup.color || this._defaultOptions && this._defaultOptions.color || "accent";
      }
      set color(e) {
        this._color = e;
      }
      _color;
      get disabledInteractive() {
        return this._disabledInteractive || this.radioGroup !== null && this.radioGroup.disabledInteractive;
      }
      set disabledInteractive(e) {
        this._disabledInteractive = e;
      }
      _disabledInteractive;
      change = new Ue();
      radioGroup;
      get inputId() {
        return `${this.id || this._uniqueId}-input`;
      }
      _checked = false;
      _disabled;
      _required;
      _value = null;
      _removeUniqueSelectionListener = () => {
      };
      _previousTabIndex;
      _inputElement;
      _rippleTrigger;
      _noopAnimations;
      _injector = M(mt);
      constructor() {
        M(mi).load(ts);
        let e = M(Npe, { optional: true }), n = M(An, { optional: true }), r = M(new Tr("tabindex"), { optional: true });
        this.radioGroup = e, this._noopAnimations = n === "NoopAnimations", this._disabledInteractive = this._defaultOptions?.disabledInteractive ?? false, r && (this.tabIndex = Gn(r, 0));
      }
      focus(e, n) {
        n ? this._focusMonitor.focusVia(this._inputElement, n, e) : this._inputElement.nativeElement.focus(e);
      }
      _markForCheck() {
        this._changeDetector.markForCheck();
      }
      ngOnInit() {
        this.radioGroup && (this.checked = this.radioGroup.value === this._value, this.checked && (this.radioGroup.selected = this), this.name = this.radioGroup.name), this._removeUniqueSelectionListener = this._radioDispatcher.listen((e, n) => {
          e !== this.id && n === this.name && (this.checked = false);
        });
      }
      ngDoCheck() {
        this._updateTabIndex();
      }
      ngAfterViewInit() {
        this._updateTabIndex(), this._focusMonitor.monitor(this._elementRef, true).subscribe((e) => {
          !e && this.radioGroup && this.radioGroup._touch();
        }), this._ngZone.runOutsideAngular(() => {
          this._cleanupClick = this._renderer.listen(this._inputElement.nativeElement, "click", this._onInputClick);
        });
      }
      ngOnDestroy() {
        this._cleanupClick?.(), this._focusMonitor.stopMonitoring(this._elementRef), this._removeUniqueSelectionListener();
      }
      _emitChangeEvent() {
        this.change.emit(new $D(this, this._value));
      }
      _isRippleDisabled() {
        return this.disableRipple || this.disabled;
      }
      _onInputInteraction(e) {
        if (e.stopPropagation(), !this.checked && !this.disabled) {
          let n = this.radioGroup && this.value !== this.radioGroup.value;
          this.checked = true, this._emitChangeEvent(), this.radioGroup && (this.radioGroup._controlValueAccessorChangeFn(this.value), n && this.radioGroup._emitChangeEvent());
        }
      }
      _onTouchTargetClick(e) {
        this._onInputInteraction(e), (!this.disabled || this.disabledInteractive) && this._inputElement?.nativeElement.focus();
      }
      _setDisabled(e) {
        this._disabled !== e && (this._disabled = e, this._changeDetector.markForCheck());
      }
      _onInputClick = (e) => {
        this.disabled && this.disabledInteractive && e.preventDefault();
      };
      _updateTabIndex() {
        let e = this.radioGroup, n;
        if (!e || !e.selected || this.disabled ? n = this.tabIndex : n = e.selected === this ? this.tabIndex : -1, n !== this._previousTabIndex) {
          let r = this._inputElement?.nativeElement;
          r && (r.setAttribute("tabindex", n + ""), this._previousTabIndex = n, Yi(() => {
            queueMicrotask(() => {
              e && e.selected && e.selected !== this && document.activeElement === r && (e.selected?._inputElement.nativeElement.focus(), document.activeElement === r && this._inputElement.nativeElement.blur());
            });
          }, { injector: this._injector }));
        }
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["mat-radio-button"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Rpe, 5), Fe(Ope, 7, He)), n & 2) {
          let o;
          Ie(o = De()) && (r._inputElement = o.first), Ie(o = De()) && (r._rippleTrigger = o.first);
        }
      }, hostAttrs: [1, "mat-mdc-radio-button"], hostVars: 19, hostBindings: function(n, r) {
        n & 1 && Z("focus", function() {
          return r._inputElement.nativeElement.focus();
        }), n & 2 && (Ke("id", r.id)("tabindex", null)("aria-label", null)("aria-labelledby", null)("aria-describedby", null), ye("mat-primary", r.color === "primary")("mat-accent", r.color === "accent")("mat-warn", r.color === "warn")("mat-mdc-radio-checked", r.checked)("mat-mdc-radio-disabled", r.disabled)("mat-mdc-radio-disabled-interactive", r.disabledInteractive)("_mat-animation-noopable", r._noopAnimations));
      }, inputs: { id: "id", name: "name", ariaLabel: [0, "aria-label", "ariaLabel"], ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"], ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"], disableRipple: [2, "disableRipple", "disableRipple", tt], tabIndex: [2, "tabIndex", "tabIndex", (e) => e == null ? 0 : Gn(e)], checked: [2, "checked", "checked", tt], value: "value", labelPosition: "labelPosition", disabled: [2, "disabled", "disabled", tt], required: [2, "required", "required", tt], color: "color", disabledInteractive: [2, "disabledInteractive", "disabledInteractive", tt] }, outputs: { change: "change" }, exportAs: ["matRadioButton"], features: [on], ngContentSelectors: Ape, decls: 13, vars: 17, consts: [["formField", ""], ["input", ""], ["mat-internal-form-field", "", 3, "labelPosition"], [1, "mdc-radio"], [1, "mat-mdc-radio-touch-target", 3, "click"], ["type", "radio", 1, "mdc-radio__native-control", 3, "change", "id", "checked", "disabled", "required"], [1, "mdc-radio__background"], [1, "mdc-radio__outer-circle"], [1, "mdc-radio__inner-circle"], ["mat-ripple", "", 1, "mat-radio-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mat-ripple-element", "mat-radio-persistent-ripple"], [1, "mdc-label", 3, "for"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          Tn(), b(0, "div", 2, 0)(2, "div", 3)(3, "div", 4), Z("click", function(a) {
            return q(o), Y(r._onTouchTargetClick(a));
          }), x(), b(4, "input", 5, 1), Z("change", function(a) {
            return q(o), Y(r._onInputInteraction(a));
          }), x(), b(6, "div", 6), ae(7, "div", 7)(8, "div", 8), x(), b(9, "div", 9), ae(10, "div", 10), x()(), b(11, "label", 11), zt(12), x()();
        }
        n & 2 && (U("labelPosition", r.labelPosition), C(2), ye("mdc-radio--disabled", r.disabled), C(2), U("id", r.inputId)("checked", r.checked)("disabled", r.disabled && !r.disabledInteractive)("required", r.required), Ke("name", r.name)("value", r.value)("aria-label", r.ariaLabel)("aria-labelledby", r.ariaLabelledby)("aria-describedby", r.ariaDescribedby)("aria-disabled", r.disabled && r.disabledInteractive ? "true" : null), C(5), U("matRippleTrigger", r._rippleTrigger.nativeElement)("matRippleDisabled", r._isRippleDisabled())("matRippleCentered", true), C(2), U("for", r.inputId));
      }, dependencies: [ba, qu], styles: ['.mat-mdc-radio-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-radio-button .mdc-radio{display:inline-block;position:relative;flex:0 0 auto;box-sizing:content-box;width:20px;height:20px;cursor:pointer;will-change:opacity,transform,border-color,color;padding:calc((var(--mdc-radio-state-layer-size, 40px) - 20px)/2)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:not([disabled]):not(:focus)~.mdc-radio__background::before{opacity:.04;transform:scale(1)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:not([disabled])~.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-hover-icon-color, var(--mat-sys-on-surface))}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-hover-icon-color, var(--mat-sys-primary))}.mat-mdc-radio-button .mdc-radio:active .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-pressed-icon-color, var(--mat-sys-on-surface))}.mat-mdc-radio-button .mdc-radio:active .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio:active .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-pressed-icon-color, var(--mat-sys-primary))}.mat-mdc-radio-button .mdc-radio__background{display:inline-block;position:relative;box-sizing:border-box;width:20px;height:20px}.mat-mdc-radio-button .mdc-radio__background::before{position:absolute;transform:scale(0, 0);border-radius:50%;opacity:0;pointer-events:none;content:"";transition:opacity 90ms cubic-bezier(0.4, 0, 0.6, 1),transform 90ms cubic-bezier(0.4, 0, 0.6, 1);width:var(--mdc-radio-state-layer-size, 40px);height:var(--mdc-radio-state-layer-size, 40px);top:calc(-1*(var(--mdc-radio-state-layer-size, 40px) - 20px)/2);left:calc(-1*(var(--mdc-radio-state-layer-size, 40px) - 20px)/2)}.mat-mdc-radio-button .mdc-radio__outer-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;border-width:2px;border-style:solid;border-radius:50%;transition:border-color 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-radio-button .mdc-radio__inner-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;transform:scale(0, 0);border-width:10px;border-style:solid;border-radius:50%;transition:transform 90ms cubic-bezier(0.4, 0, 0.6, 1),border-color 90ms cubic-bezier(0.4, 0, 0.6, 1)}.mat-mdc-radio-button .mdc-radio__native-control{position:absolute;margin:0;padding:0;opacity:0;top:0;right:0;left:0;cursor:inherit;z-index:1;width:var(--mdc-radio-state-layer-size, 40px);height:var(--mdc-radio-state-layer-size, 40px)}.mat-mdc-radio-button .mdc-radio__native-control:checked+.mdc-radio__background,.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background{transition:opacity 90ms cubic-bezier(0, 0, 0.2, 1),transform 90ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-radio-button .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__outer-circle{transition:border-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-radio-button .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{transition:transform 90ms cubic-bezier(0, 0, 0.2, 1),border-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-radio-button .mdc-radio__native-control:focus+.mdc-radio__background::before{transform:scale(1);opacity:.12;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 1),transform 90ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-radio-button .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-unselected-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-radio-disabled-unselected-icon-opacity, 0.38)}.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background{cursor:default}.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-selected-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-radio-disabled-selected-icon-opacity, 0.38)}.mat-mdc-radio-button .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-icon-color, var(--mat-sys-on-surface-variant))}.mat-mdc-radio-button .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-icon-color, var(--mat-sys-primary))}.mat-mdc-radio-button .mdc-radio__native-control:enabled:focus:checked+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio__native-control:enabled:focus:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-focus-icon-color, var(--mat-sys-primary))}.mat-mdc-radio-button .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle{transform:scale(0.5);transition:transform 90ms cubic-bezier(0, 0, 0.2, 1),border-color 90ms cubic-bezier(0, 0, 0.2, 1)}.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled{pointer-events:auto}.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-unselected-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-radio-disabled-unselected-icon-opacity, 0.38)}.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled:hover .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled:hover .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__native-control:checked:focus+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__native-control:checked:focus+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__native-control+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-selected-icon-color, var(--mat-sys-on-surface));opacity:var(--mdc-radio-disabled-selected-icon-opacity, 0.38)}.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__background::before,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__outer-circle,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__inner-circle{transition:none !important}.mat-mdc-radio-button .mdc-radio__background::before{background-color:var(--mat-radio-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-radio-button.mat-mdc-radio-checked .mat-ripple-element,.mat-mdc-radio-button.mat-mdc-radio-checked .mdc-radio__background::before{background-color:var(--mat-radio-checked-ripple-color, var(--mat-sys-primary))}.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mat-ripple-element,.mat-mdc-radio-button.mat-mdc-radio-disabled-interactive .mdc-radio--disabled .mdc-radio__background::before{background-color:var(--mat-radio-ripple-color, var(--mat-sys-on-surface))}.mat-mdc-radio-button .mat-internal-form-field{color:var(--mat-radio-label-text-color, var(--mat-sys-on-surface));font-family:var(--mat-radio-label-text-font, var(--mat-sys-body-medium-font));line-height:var(--mat-radio-label-text-line-height, var(--mat-sys-body-medium-line-height));font-size:var(--mat-radio-label-text-size, var(--mat-sys-body-medium-size));letter-spacing:var(--mat-radio-label-text-tracking, var(--mat-sys-body-medium-tracking));font-weight:var(--mat-radio-label-text-weight, var(--mat-sys-body-medium-weight))}.mat-mdc-radio-button .mdc-radio--disabled+label{color:var(--mat-radio-disabled-label-color, color-mix(in srgb, var(--mat-sys-on-surface) 38%, transparent))}.mat-mdc-radio-button .mat-radio-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:50%}.mat-mdc-radio-button .mat-radio-ripple .mat-ripple-element{opacity:.14}.mat-mdc-radio-button .mat-radio-ripple::before{border-radius:50%}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:focus:enabled:not(:checked)~.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-focus-icon-color, var(--mat-sys-on-surface))}.mat-mdc-radio-button.cdk-focused .mat-focus-indicator::before{content:""}.mat-mdc-radio-disabled{cursor:default;pointer-events:none}.mat-mdc-radio-disabled.mat-mdc-radio-disabled-interactive{pointer-events:auto}.mat-mdc-radio-touch-target{position:absolute;top:50%;left:50%;height:48px;width:48px;transform:translate(-50%, -50%);display:var(--mat-radio-touch-target-display, block)}[dir=rtl] .mat-mdc-radio-touch-target{left:auto;right:50%;transform:translate(50%, -50%)}'], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var vH = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ imports: [Yt, $c, qD, Yt] });
    }
    return i59;
  })();
  function Bpe(i59, t) {
    i59 & 1 && (b(0, "div", 5), D(1, " Synchronize the node selection across two panes by the given node id mapping. "), x());
  }
  function Vpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "button", 15), Z("click", function() {
        q(e);
        let r = Ce(3), o = T(3);
        return Y(o.handleClickUpload(r));
      }), D(1, " Upload "), x(), b(2, "input", 16, 2), Z("change", function() {
        q(e);
        let r = Ce(3), o = T(3);
        return Y(o.handleUploadedFileChanged(r));
      }), x(), b(4, "div", 17), D(5), x();
    }
    if (i59 & 2) {
      let e = T(3);
      C(5), Oe(" ", e.uploadedFileName, " ");
    }
  }
  function zpe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 12)(1, "div", 13)(2, "mat-radio-button", 14), Z("change", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.setSyncMode(r));
      }), D(3), x(), X(4, Vpe, 6, 1), x()();
    }
    if (i59 & 2) {
      let e, n = t.$implicit, r = T(2);
      C(2), ye("cns", n === r.SyncNavigationMode.LOAD_MAPPING_FROM_CNS), U("disableRipple", true)("checked", r.syncMode() === n), C(), Oe(" ", r.getModeLabel(n), " "), C(), he((e = n) === r.SyncNavigationMode.UPLOAD_MAPPING_FROM_COMPUTER ? 4 : -1);
    }
  }
  function Upe(i59, t) {
    if (i59 & 1 && (b(0, "div", 6)(1, "div", 7)(2, "div"), D(3, "Select a sync mode"), x(), b(4, "div", 8)(5, "a", 9), D(6, " Guide "), x(), b(7, "div", 10)(8, "mat-icon", 11), D(9, "close"), x()()()(), Qt(10, zpe, 5, 6, "div", 12, mr), x()), i59 & 2) {
      let e = T();
      C(10), Kt(e.allSyncModes);
    }
  }
  var yH = (() => {
    class i59 {
      dropdown;
      appService = M(nt);
      changeDetectorRef = M(Ge);
      localStorageService = M(Io);
      syncNavigationService = M(Xs);
      snackBar = M(Gl);
      SyncNavigationMode = dn;
      allSyncModes;
      syncMode = this.syncNavigationService.mode;
      syncEnabled = It(() => this.syncMode() !== dn.DISABLED);
      syncIcon = It(() => this.syncMode() === dn.DISABLED && !this.syncNavigationService.loadingFromCns() ? "sync_disabled" : "sync");
      loadingFromCns = this.syncNavigationService.loadingFromCns;
      helpPopupSize = { minWidth: 0, minHeight: 0 };
      dropdownSize = { minWidth: 0, minHeight: 0, maxHeight: 500 };
      uploadedFileName = "";
      constructor() {
        let e = this.appService.config()?.syncNavigationData;
        this.allSyncModes = e ? [dn.DISABLED, dn.MATCH_NODE_ID, dn.VISUALIZER_CONFIG, dn.UPLOAD_MAPPING_FROM_COMPUTER] : [dn.DISABLED, dn.MATCH_NODE_ID, dn.UPLOAD_MAPPING_FROM_COMPUTER], e && (this.syncNavigationService.mode.set(dn.VISUALIZER_CONFIG), this.syncNavigationService.updateSyncNavigationData(dn.VISUALIZER_CONFIG, e));
      }
      setSyncMode(e) {
        switch (this.syncNavigationService.mode.set(e), e) {
          case dn.DISABLED:
          case dn.MATCH_NODE_ID:
            this.syncNavigationService.syncNavigationModeChanged$.next({ mode: e });
            break;
          default:
            break;
        }
      }
      getModeLabel(e) {
        return MG[e];
      }
      handleClickUpload(e) {
        this.syncNavigationService.mode.set(dn.UPLOAD_MAPPING_FROM_COMPUTER), e.click();
      }
      handleUploadedFileChanged(e) {
        let n = e.files;
        if (!n || n.length === 0) return;
        let r = n[0];
        this.uploadedFileName = "";
        let o = new FileReader();
        o.onload = (s) => {
          this.syncNavigationService.processJsonData(s.target?.result, dn.UPLOAD_MAPPING_FROM_COMPUTER) || (this.uploadedFileName = r.name, this.changeDetectorRef.markForCheck());
        }, o.readAsText(r);
      }
      showError(e) {
        console.error(e), this.snackBar.open(e, "Dismiss", { duration: 5e3 });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["sync-navigation-button"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Xr, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.dropdown = o.first);
        }
      }, decls: 10, vars: 10, consts: [["help", ""], ["dropdown", ""], ["input", ""], [1, "container", 3, "bubble", "overlaySize", "hoverDelayMs"], [1, "content", 3, "bubbleClick", "overlaySize"], [1, "model-explorer-help-popup"], [1, "model-explorer-sync-navigation-dropdown"], [1, "section-label"], [1, "right"], ["href", "https://github.com/google-ai-edge/model-explorer/wiki/2.-User-Guide#synchronize-navigation", "target", "_blank"], ["bubbleClose", "", 1, "icon-container"], [1, "close"], [1, "section"], [1, "select-container"], ["color", "primary", 3, "change", "disableRipple", "checked"], ["mat-flat-button", "", "color", "primary", 1, "upload-mapping-button", 3, "click"], ["type", "file", "accept", ".json", 1, "upload-mapping-input", 3, "change"], [1, "uploaded-file-name"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 3)(1, "div", 4)(2, "mat-icon"), D(3), x(), b(4, "div"), D(5, "Sync"), x()()(), X(6, Bpe, 2, 0, "ng-template", null, 0, Tt)(8, Upe, 12, 0, "ng-template", null, 1, Tt)), n & 2) {
          let o = Ce(7), s = Ce(9);
          ye("enabled", r.syncEnabled()), U("bubble", o)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(), U("bubbleClick", s)("overlaySize", r.dropdownSize), C(), ye("loading", r.loadingFromCns()), C(), Oe(" ", r.syncIcon(), " ");
        }
      }, dependencies: [Bn, Xr, et, Hn, vr, vt, St, Zs, vH, qD, tn], styles: [`@keyframes _ngcontent-%COMP%_rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.container[_ngcontent-%COMP%]{height:100%;display:flex;align-items:center;font-size:11px;cursor:pointer;color:#777;padding:0 5px;background-color:#fff;border-radius:99px;border:1px solid #ccc;box-sizing:border-box}.container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;opacity:.8}.container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]:hover{opacity:1}.container.enabled[_ngcontent-%COMP%]{background-color:#004fb8;color:#fff}.container.enabled[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#fff}.container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:18px;height:18px;width:18px}.container[_ngcontent-%COMP%]   mat-icon.loading[_ngcontent-%COMP%]{animation:_ngcontent-%COMP%_rotating 2s linear infinite}  .model-explorer-sync-navigation-dropdown{font-size:12px;background-color:#fff;display:flex;flex-direction:column;padding-bottom:12px}  .model-explorer-sync-navigation-dropdown .section-label{padding:8px 12px;margin-bottom:8px;font-size:11px;background:#f1f1f1;font-weight:500;text-transform:uppercase;display:flex;align-items:center;justify-content:space-between}  .model-explorer-sync-navigation-dropdown .section-label .right{display:flex;align-items:center;gap:4px}  .model-explorer-sync-navigation-dropdown .section-label .right .icon-container{display:flex;cursor:pointer;opacity:.8}  .model-explorer-sync-navigation-dropdown .section-label .right .icon-container:hover{opacity:1}  .model-explorer-sync-navigation-dropdown .section-label .right mat-icon{font-size:18px;height:18px;width:18px;color:#999}  .model-explorer-sync-navigation-dropdown .section{padding-right:16px}  .model-explorer-sync-navigation-dropdown mat-radio-button{cursor:pointer}  .model-explorer-sync-navigation-dropdown mat-radio-button.cns{margin-top:8px}  .model-explorer-sync-navigation-dropdown mat-radio-button>div[mat-internal-form-field]{height:24px}  .model-explorer-sync-navigation-dropdown mat-radio-button div:has(>input[type=radio]){transform:scale(.7);margin-right:-8px}  .model-explorer-sync-navigation-dropdown mat-radio-button label{letter-spacing:normal;cursor:pointer;font-size:12px;font-family:Google Sans Text,Google Sans,Arial,Helvetica,sans-serif}  .model-explorer-sync-navigation-dropdown .select-container{display:flex;flex-direction:column}  .model-explorer-sync-navigation-dropdown .upload-mapping-button{margin:2px 0 0 36px;width:90px;height:30px;font-size:12px!important;letter-spacing:normal!important}  .model-explorer-sync-navigation-dropdown .upload-mapping-button.cns{margin-top:4px}  .model-explorer-sync-navigation-dropdown .upload-mapping-button   .mat-mdc-button-touch-target{display:none}  .model-explorer-sync-navigation-dropdown .upload-mapping-input{display:none}  .model-explorer-sync-navigation-dropdown .uploaded-file-name{margin-left:36px;color:#999;line-break:anywhere;line-height:14px}  .model-explorer-sync-navigation-dropdown textarea{height:48px;box-sizing:border-box;margin:4px 0 0 36px;resize:none;border-radius:3px;font-family:sans-serif;font-size:11px;padding:2px;line-break:anywhere}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var Gpe = ["panesContainer"];
  var Hpe = ["noMappedNodeMessage"];
  var jpe = ["splitPane"];
  var Wpe = (i59, t) => t.label;
  function $pe(i59, t) {
    i59 & 1 && (b(0, "div", 12), D(1), x()), i59 & 2 && (C(), Oe(" ", t, " "));
  }
  function qpe(i59, t) {
    i59 & 1 && (b(0, "mat-icon"), D(1, "error"), x());
  }
  function Ype(i59, t) {
    i59 & 1 && ae(0, "mat-spinner", 14);
  }
  function Xpe(i59, t) {
    i59 & 1 && ae(0, "mat-spinner", 22);
  }
  function Zpe(i59, t) {
    i59 & 1 && (b(0, "mat-icon"), D(1, "check_circle"), x());
  }
  function Qpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 21), X(1, Xpe, 1, 0, "mat-spinner", 22)(2, Zpe, 2, 0, "mat-icon"), b(3, "div", 23), D(4), x()()), i59 & 2) {
      let e = t.$implicit;
      C(), he(e.processing ? 1 : 2), C(3), Oe(" ", e.label, " ");
    }
  }
  function Kpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 20), Qt(1, Qpe, 5, 2, "div", 21, Wpe), x()), i59 & 2) {
      let e = T(3).$implicit, n = T();
      C(), Kt(n.getProcessingTasksForPane(e.id));
    }
  }
  function Jpe(i59, t) {
    if (i59 & 1 && (b(0, "div", 13), X(1, qpe, 2, 0, "mat-icon")(2, Ype, 1, 0, "mat-spinner", 14), D(3, " Processing graph... "), x(), b(4, "div", 15), D(5, " Please remain on this page while the model is being processed "), x(), b(6, "div", 16)(7, "div", 17), ae(8, "div", 18), x(), b(9, "div", 19)(10, "mat-icon"), D(11, "info"), x()(), X(12, Kpe, 3, 0, "ng-template", null, 2, Tt), x()), i59 & 2) {
      let e = Ce(13), n = T(2).$implicit, r = T();
      C(), he(r.getProcessingError(n) ? 1 : 2), C(7), sn("width", r.getProgressPct(n.id), "%"), C(), U("bubble", e)("hoverDelayMs", 100);
    }
  }
  function efe(i59, t) {
    if (i59 & 1 && (b(0, "div", 9), X(1, $pe, 2, 1, "div", 12)(2, Jpe, 14, 5), x()), i59 & 2) {
      let e, n = T().$implicit, r = T();
      U("@hideProcessingPanel", void 0)("@.disabled", r.disableAnimation), C(), he((e = r.getProcessingError(n)) ? 1 : 2, e);
    }
  }
  function tfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 24)(1, "div", 25), D(2), x(), b(3, "div", 26)(4, "div", 27), Z("click", function() {
        q(e);
        let r = T(2);
        return Y(r.handleClickSwapPane());
      })("mousedown", function(r) {
        return q(e), Y(r.stopPropagation());
      }), b(5, "mat-icon"), D(6, "swap_horiz"), x()(), b(7, "div", 28), Z("click", function() {
        q(e);
        let r = T().$implicit, o = T();
        return Y(o.handleClickClosePane(r));
      })("mousedown", function(r) {
        return q(e), Y(r.stopPropagation());
      }), b(8, "mat-icon"), D(9, "close"), x()()()();
    }
    if (i59 & 2) {
      let e = T(), n = e.$implicit, r = e.index, o = T();
      ye("extra-left-padding", r === 1)("extra-right-padding", r === 0), C(2), Oe(" ", o.getPaneTitle(n), " ");
    }
  }
  function nfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 8), X(1, efe, 3, 3, "div", 9)(2, tfe, 10, 5, "div", 10), ae(3, "split-pane", 11, 1), x()), i59 & 2) {
      let e = t.$implicit, n = t.index, r = T();
      sn("width", r.getPaneWidthPct(n), "%"), ye("selected", r.isPaneSelected(e)), Ke("data-pane-id", e.id), C(), he(r.getShowLoading(e) ? 1 : -1), C(), U("ngIf", r.hasSplitPane), C(), U("pane", e);
    }
  }
  function ife(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 29), Z("mousedown", function(r) {
        q(e);
        let o = T(), s = Ce(1);
        return Y(o.handleMouseDownResizer(r, s));
      }), ae(1, "div", 30), x();
    }
    if (i59 & 2) {
      let e = T();
      sn("left", e.resizerLeft);
    }
  }
  function rfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 31), ae(1, "sync-navigation-button"), b(2, "div", 32, 3), D(4, " No mapped node found "), x()()), i59 & 2) {
      let e = T();
      sn("left", e.resizerLeft);
    }
  }
  var bH = (() => {
    class i59 {
      changeDetectorRef;
      appService;
      destroyRef;
      syncNavigationService;
      workerService;
      panesContainer;
      noMappedNodeMessage;
      splitPanes = new Ni();
      processingTasks = {};
      allPanesLoaded;
      resizingSplitPane = false;
      curLeftWidthFraction = 1;
      panes;
      curUpdateProcessingProgressReq;
      hideNoMappedNodeMessageTimeoutId = -1;
      constructor(e, n, r, o, s) {
        this.changeDetectorRef = e, this.appService = n, this.destroyRef = r, this.syncNavigationService = o, this.workerService = s, this.panes = this.appService.panes, this.allPanesLoaded = It(() => this.panes().every((a) => a.modelGraph != null)), ht(() => {
          let a = this.panes();
          a.length >= 1 && (this.curLeftWidthFraction = a[0].widthFraction);
          for (let l of a) l.modelGraph || (this.processingTasks[l.id] = E2.map((c) => ({ label: c, processing: true })));
          this.changeDetectorRef.detectChanges();
          for (let l = 0; l < this.splitPanes.length; l++) this.splitPanes.get(l)?.refresh();
        }), this.workerService.worker.addEventListener("message", (a) => {
          switch (a.data.eventType) {
            case Qi.UPDATE_PROCESSING_PROGRESS:
              this.handleUpdateProcessingProgressRequest(a.data);
              break;
            default:
              break;
          }
        }), this.syncNavigationService.showNoMappedNodeMessageTrigger$.pipe(wi(this.destroyRef)).subscribe((a) => {
          a === void 0 ? this.hideNoMappedNodeMessage() : this.showNoMappedNodeMessage();
        });
      }
      ngAfterViewInit() {
        this.panesContainer.nativeElement.addEventListener("mousedown", (e) => {
          let n = e.target.closest(".pane-container");
          if (!n) return;
          let r = n.dataset.paneId || "";
          this.appService.selectPane(r);
        }, true);
      }
      handleClickSwapPane() {
        this.appService.swapPane();
      }
      handleClickClosePane(e) {
        this.appService.closePane(e.id);
      }
      getPaneTitle(e) {
        let n = e.modelGraph;
        return n ? `${n.collectionLabel} | ${n.id}` : "-";
      }
      handleMouseDownResizer(e, n) {
        e.preventDefault(), document.body.style.cursor = "ew-resize";
        let r = zn(document, "mousemove"), o = zn(window, "mouseup"), a = this.appService.panes()[0].widthFraction, l = n.offsetWidth, c = l * a, d = e.clientX;
        this.resizingSplitPane = true, this.changeDetectorRef.markForCheck(), cr([r]).pipe(Je(o)).subscribe({ next: ([u]) => {
          let h = u.clientX - d, p = Math.min(l - 200, Math.max(200, c + h));
          this.curLeftWidthFraction = p / l, this.changeDetectorRef.markForCheck();
        }, complete: () => {
          document.body.style.cursor = "default", this.resizingSplitPane = false, this.appService.setPaneWidthFraction(this.curLeftWidthFraction), this.changeDetectorRef.markForCheck();
        } });
      }
      isPaneSelected(e) {
        return e.id === this.appService.selectedPaneId();
      }
      getPaneWidthPct(e) {
        return (e === 0 ? this.curLeftWidthFraction : 1 - this.curLeftWidthFraction) * 100;
      }
      trackByPaneId(e, n) {
        return n.id;
      }
      getProcessingTasksForPane(e) {
        return this.processingTasks[e] || [];
      }
      getProgressPct(e) {
        let n = this.processingTasks[e];
        return n ? n.filter((o) => !o.processing).length / n.length * 100 : 0;
      }
      getShowLoading(e) {
        return e.modelGraph == null || this.getProcessingTasksForPane(e.id).some((n) => n.error != null && n.error !== "");
      }
      getProcessingError(e) {
        return this.getProcessingTasksForPane(e.id).find((n) => n.error != null && n.error !== "")?.error ?? "";
      }
      get hasSplitPane() {
        return this.appService.panes().length > 1;
      }
      get resizerLeft() {
        return `calc(${this.curLeftWidthFraction * 100}% - 5px)`;
      }
      get disableAnimation() {
        return this.appService.testMode;
      }
      handleUpdateProcessingProgressRequest(e) {
        let n = e.paneId;
        if (!this.appService.getPaneById(n)) return;
        let s = this.processingTasks[n].find((a) => a.label === e.label);
        s != null && (s.processing = false, s.error = e.error, this.changeDetectorRef.detectChanges());
      }
      hideNoMappedNodeMessage() {
        let e = this.noMappedNodeMessage?.nativeElement;
        e && (this.hideNoMappedNodeMessageTimeoutId >= 0 && (clearTimeout(this.hideNoMappedNodeMessageTimeoutId), this.hideNoMappedNodeMessageTimeoutId = -1), e.classList.remove("show"));
      }
      showNoMappedNodeMessage() {
        let e = this.noMappedNodeMessage?.nativeElement;
        e && (this.hideNoMappedNodeMessageTimeoutId >= 0 && (clearTimeout(this.hideNoMappedNodeMessageTimeoutId), this.hideNoMappedNodeMessageTimeoutId = -1), e.classList.add("show"), this.hideNoMappedNodeMessageTimeoutId = setTimeout(() => {
          e.classList.remove("show");
        }, 3e3));
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge), K(nt), K(pi), K(Xs), K(ll));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["split-panes-container"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Gpe, 5), Fe(Hpe, 5), Fe(jpe, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.panesContainer = o.first), Ie(o = De()) && (r.noMappedNodeMessage = o.first), Ie(o = De()) && (r.splitPanes = o);
        }
      }, decls: 5, vars: 4, consts: [["panesContainer", ""], ["splitPane", ""], ["progressPopup", ""], ["noMappedNodeMessage", ""], [1, "container"], ["class", "pane-container", 3, "selected", "width", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "resizer split-pane", 3, "left", "mousedown", 4, "ngIf"], [1, "sync-navigation-container", 3, "left"], [1, "pane-container"], [1, "loading"], ["class", "pane-title-container", 3, "extra-left-padding", "extra-right-padding", 4, "ngIf"], [3, "pane"], [1, "error-msg"], [1, "processing-msg-container"], ["color", "primary", "diameter", "18"], [1, "stay-on-page-info"], [1, "progress-bar-wrapper"], [1, "progress-bar-container"], [1, "progress-bar-body"], [1, "icon-container", 3, "bubble", "hoverDelayMs"], [1, "model-explorer-processing-tasks-container"], [1, "processing-task-container"], ["color", "primary", "diameter", "16"], [1, "task-label"], [1, "pane-title-container"], [1, "pane-title"], [1, "buttons-container"], ["matTooltip", "Swap pane", 1, "icon-container", "swap", 3, "click", "mousedown"], ["matTooltip", "Close pane", 1, "icon-container", "close", 3, "click", "mousedown"], [1, "resizer", "split-pane", 3, "mousedown"], [1, "resizer-line"], [1, "sync-navigation-container"], [1, "no-mapped-node-message"]], template: function(n, r) {
        n & 1 && (b(0, "div", 4, 0), X(2, nfe, 5, 8, "div", 5)(3, ife, 2, 2, "div", 6)(4, rfe, 5, 2, "div", 7), x()), n & 2 && (C(2), U("ngForOf", r.panes())("ngForTrackBy", r.trackByPaneId), C(), U("ngIf", r.hasSplitPane), C(), he(r.hasSplitPane && r.allPanesLoaded() ? 4 : -1));
      }, dependencies: [Bn, et, Wr, In, vt, St, Zs, fp, tn, $n, _H, yH], styles: [`.container[_ngcontent-%COMP%]{flex-grow:1;display:flex;position:relative;width:100%;height:100%}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]{position:relative;display:flex;flex-direction:column}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]{height:24px;box-sizing:border-box;background-color:#eee;padding:0 12px;display:flex;align-items:center;justify-content:space-between;font-size:12px;color:#999;cursor:pointer;flex-shrink:0}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container.extra-left-padding[_ngcontent-%COMP%]{padding-left:36px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container.extra-right-padding[_ngcontent-%COMP%]{padding-right:36px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .buttons-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;cursor:pointer;color:#999;opacity:.8;margin-left:6px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:18px;height:18px;width:18px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{width:1px;height:12px;background-color:#999;margin:0 4px 0 12px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   split-pane[_ngcontent-%COMP%]{width:100%;flex-grow:1;display:flex;overflow:hidden}.container[_ngcontent-%COMP%]   .pane-container.selected[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#fff}.container[_ngcontent-%COMP%]   .pane-container.selected[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]{background-color:#ea8600;color:#fff}.container[_ngcontent-%COMP%]   .pane-container.selected[_ngcontent-%COMP%]   .pane-title-container[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{background-color:#fff}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;z-index:150;color:#999;background-color:#fff;display:flex;align-items:center;justify-content:center;flex-direction:column}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .processing-msg-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .processing-msg-container[_ngcontent-%COMP%]   mat-spinner[_ngcontent-%COMP%]{margin-right:8px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-wrapper[_ngcontent-%COMP%]{display:flex;align-items:center;margin-top:18px;margin-right:-30px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-wrapper[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{cursor:pointer;opacity:.8;display:flex;align-items:center;justify-content:center}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-wrapper[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-wrapper[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{color:#ccc;font-size:18px;width:18px;height:18px;margin-left:6px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]{height:7px;width:280px;border:1px solid #ccc;border-radius:99px;box-sizing:border-box;overflow:hidden}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .progress-bar-container[_ngcontent-%COMP%]   .progress-bar-body[_ngcontent-%COMP%]{height:100%;transition:width .1s;background-color:#ccc}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .stay-on-page-info[_ngcontent-%COMP%]{font-size:12px;width:100%;display:flex;justify-content:center;margin-top:4px}.container[_ngcontent-%COMP%]   .pane-container[_ngcontent-%COMP%]   .loading[_ngcontent-%COMP%]   .error-msg[_ngcontent-%COMP%]{font-size:13px;padding:16px;color:#a00}.container[_ngcontent-%COMP%]   .resizer[_ngcontent-%COMP%]{height:100%;width:10px;top:0;left:50%;display:flex;align-items:center;justify-content:center;position:absolute;padding-left:1px;cursor:ew-resize;z-index:200}.container[_ngcontent-%COMP%]   .resizer[_ngcontent-%COMP%]:hover{background-color:#0000000a}.container[_ngcontent-%COMP%]   .resizer[_ngcontent-%COMP%]:hover   .resizer-line[_ngcontent-%COMP%]{border-color:#fcc986}.container[_ngcontent-%COMP%]   .resizer[_ngcontent-%COMP%]   .resizer-line[_ngcontent-%COMP%]{height:100%;width:1px;border-left:1px solid #999}.container[_ngcontent-%COMP%]   .sync-navigation-container[_ngcontent-%COMP%]{position:absolute;transform:translate(-22px);top:0;height:24px;z-index:250}.container[_ngcontent-%COMP%]   .sync-navigation-container[_ngcontent-%COMP%]   .no-mapped-node-message[_ngcontent-%COMP%]{position:absolute;top:28px;width:140px;font-size:12px;left:-44px;background-color:#a00;color:#fff;padding:2px 4px;display:flex;align-items:center;justify-content:center;border-radius:99px;pointer-events:none;opacity:0;transition:opacity .1s}.container[_ngcontent-%COMP%]   .sync-navigation-container[_ngcontent-%COMP%]   .no-mapped-node-message.show[_ngcontent-%COMP%]{opacity:1}  .model-explorer-processing-tasks-container{display:flex;flex-direction:column;padding:12px}  .model-explorer-processing-tasks-container .processing-task-container{display:flex;align-items:center;font-size:13px;margin:2px 0}  .model-explorer-processing-tasks-container .processing-task-container mat-spinner{margin-right:8px;width:16px}  .model-explorer-processing-tasks-container .processing-task-container mat-icon{color:#0a0;font-size:16px;width:16px;height:16px;margin-right:8px}

















`], data: { animation: [ki("hideProcessingPanel", [Yn("* => void", oi("150ms 100ms ease-out", _n({ opacity: 0, transform: "scale(0.95, 0.95)" })))])] }, changeDetection: 0 });
    }
    return i59;
  })();
  function ofe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "button", 1), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickOpenInNewTab());
      }), b(1, "mat-icon"), D(2, "open_in_new"), x(), D(3, " Open in new tab "), x();
    }
  }
  var xH = (() => {
    class i59 {
      showOpenInNewTab;
      isChrome = /Chrome/.test(navigator.userAgent);
      constructor() {
        let e = new URLSearchParams(window.location.search);
        this.showOpenInNewTab = e.get("show_open_in_new_tab") === "1" && this.isChrome;
      }
      handleClickOpenInNewTab() {
        let e = new URL(window.location.href), n = new URLSearchParams(e.search);
        n.delete("show_open_in_new_tab"), e.search = n.toString(), window.open(e.toString(), "_blank");
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["open-in-new-tab-button"]], decls: 1, vars: 1, consts: [["mat-flat-button", "", "color", "primary", 1, "btn-open-in-tab"], ["mat-flat-button", "", "color", "primary", 1, "btn-open-in-tab", 3, "click"]], template: function(n, r) {
        n & 1 && X(0, ofe, 4, 0, "button", 0), n & 2 && he(r.showOpenInNewTab ? 0 : -1);
      }, dependencies: [et, Hn, vr, vt, St], encapsulation: 2 });
    }
    return i59;
  })();
  function sfe(i59, t) {
    i59 & 1 && (b(0, "mat-icon", 15), D(1, " turn_left "), x());
  }
  function afe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 16), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T(2);
        return Y(s.handleClickOpenInSplitPane(r, o));
      }), b(1, "div", 17), ae(2, "div", 18), x()();
    }
  }
  function lfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 7)(1, "div", 8)(2, "div", 9), Z("click", function() {
        let r = q(e).$implicit, o = T(2);
        return Y(o.handleSelectGraph(r));
      }), b(3, "div", 10), X(4, sfe, 2, 0, "mat-icon", 11), b(5, "div", 12), D(6), x()(), b(7, "div", 13), D(8), x()(), X(9, afe, 3, 0, "div", 14), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(2);
      Ke("data-id", e.id), C(), sn("padding-left", n.getGraphItemPaddingLeft(e), "px"), ye("selected", e.id === n.selectedGraphId()), C(3), U("ngIf", n.showIndentSymbol(e)), C(2), Oe(" ", e.id, " "), C(2), Oe(" ", n.getGraphNonHiddenNodeCountLabel(e.nonHiddenNodeCount), " "), C(), U("ngIf", n.showOpenInSplitPane);
    }
  }
  function cfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 4)(1, "div", 5), D(2), x(), X(3, lfe, 10, 9, "div", 6), x()), i59 & 2) {
      let e = t.$implicit, n = T();
      C(2), Oe(" ", e.label, " "), C(), U("ngForOf", e.graphs)("ngForTrackBy", n.trackByGraph);
    }
  }
  var wH = 24;
  var CH = (() => {
    class i59 {
      appService;
      graphCollectionItems = [];
      onClose = new Ue();
      hasFilteredOutGraphs = false;
      selectedGraphId = It(() => {
        let e = this.appService.getSelectedPane();
        return !e || !e.modelGraph ? "" : e.modelGraph.id;
      });
      curFilterText = "";
      constructor(e) {
        this.appService = e;
      }
      getGraphNonHiddenNodeCountLabel(e) {
        return `${e} node${e === 1 ? "" : "s"}`;
      }
      handleSelectGraph(e) {
        this.onClose.next({}), this.resetFilter(), this.appService.selectGraphInCurrentPane(e.graph), this.appService.curInitialUiState.set(void 0), this.appService.selectNode(this.appService.selectedPaneId(), void 0), this.appService.curToLocateNodeInfo.set(void 0), this.appService.setFlattenLayersInCurrentPane(false);
      }
      handleFilterTextChanged(e) {
        this.curFilterText = e.toLowerCase();
      }
      handleClickOpenInSplitPane(e, n) {
        e.stopPropagation(), this.onClose.next({}), this.resetFilter(), this.appService.openGraphInSplitPane(n.graph);
      }
      showIndentSymbol(e) {
        return !this.hasFilteredOutGraphs && (e.level ?? 0) > 0;
      }
      getGraphItemPaddingLeft(e) {
        return this.hasFilteredOutGraphs ? wH : wH + (e.level ?? 0) * 12;
      }
      trackByCollection(e, n) {
        return `${e}`;
      }
      trackByGraph(e, n) {
        return `${n.graph.collectionLabel}___${n.graph.id}`;
      }
      get curGraphCollectionItems() {
        let e = [];
        this.hasFilteredOutGraphs = false;
        for (let { label: n, collection: r, graphs: o } of this.graphCollectionItems) {
          let s = { label: n, collection: r, graphs: [] };
          for (let a of o) {
            if (this.curFilterText !== "" && !a.id.toLowerCase().includes(this.curFilterText)) {
              this.hasFilteredOutGraphs = true;
              continue;
            }
            s.graphs.push(a);
          }
          s.graphs.length > 0 && e.push(s);
        }
        return e;
      }
      get showOpenInSplitPane() {
        return this.appService.panes().length === 1;
      }
      resetFilter() {
        this.curFilterText = "", this.hasFilteredOutGraphs = false;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["graph-selector-panel"]], inputs: { graphCollectionItems: "graphCollectionItems" }, outputs: { onClose: "onClose" }, decls: 4, vars: 3, consts: [["input", ""], [1, "container"], ["placeholder", "Filter graphs", 3, "input"], ["class", "collection-container", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "collection-container"], [1, "collection-label"], ["class", "graph-item-container", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "graph-item-container"], [1, "graph-item"], [1, "graph-info-wrapper", 3, "click"], [1, "graph-label-wrapper"], ["class", "indent-symbol", 4, "ngIf"], [1, "graph-label"], [1, "node-count-label"], ["class", "action-button", "matTooltip", "Open in split pane", "matTooltipPosition", "right", 3, "click", 4, "ngIf"], [1, "indent-symbol"], ["matTooltip", "Open in split pane", "matTooltipPosition", "right", 1, "action-button", 3, "click"], [1, "block-container"], [1, "right-block"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 1)(1, "input", 2, 0), Z("input", function() {
            q(o);
            let a = Ce(2);
            return Y(r.handleFilterTextChanged(a.value));
          }), x(), X(3, cfe, 4, 3, "div", 3), x();
        }
        n & 2 && (U("@transformPanel", "showing"), C(3), U("ngForOf", r.curGraphCollectionItems)("ngForTrackBy", r.trackByCollection));
      }, dependencies: [et, Wr, In, mp, vt, St, gp, tn, $n, Do], styles: [`.container[_ngcontent-%COMP%]{box-shadow:0 3px 5px -1px #0003,0 6px 10px #00000024,0 1px 18px #0000001f;transform-origin:top center;font-size:12px;padding:8px 0;border-radius:0 0 4px 4px;max-height:100%;overflow-y:auto}.container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-family:sans-serif;font-size:12px;margin:4px 10px;width:calc(100% - 20px);box-sizing:border-box;pointer-events:all;border:1px solid #ccc;height:20px;border-radius:4px;padding:0 2px;min-width:184px}.container[_ngcontent-%COMP%]   .collection-container[_ngcontent-%COMP%]   .collection-label[_ngcontent-%COMP%]{font-weight:700;padding:4px 12px}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;padding:4px 12px 4px 24px;cursor:pointer}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]:hover{background-color:#0000000a}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item.selected[_ngcontent-%COMP%]{background-color:#c2e7ff}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .graph-info-wrapper[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;flex-grow:1}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .graph-label-wrapper[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .indent-symbol[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px;color:#999;margin-right:4px;transform:rotate(-180deg)}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .graph-label[_ngcontent-%COMP%]{overflow:hidden;white-space:nowrap;text-overflow:ellipsis}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .node-count-label[_ngcontent-%COMP%]{color:#999;margin-left:12px}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .action-button[_ngcontent-%COMP%]{flex-shrink:0;width:16px;height:16px;display:flex;align-items:center;margin-left:6px;opacity:.8;cursor:pointer}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .action-button[_ngcontent-%COMP%]:hover{opacity:1}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .action-button[_ngcontent-%COMP%]   .block-container[_ngcontent-%COMP%]{border-radius:3px;border:1px solid #999;height:100%;width:100%;box-sizing:border-box;display:flex;align-items:center;justify-content:flex-end;padding:1px}.container[_ngcontent-%COMP%]   .graph-item-container[_ngcontent-%COMP%]   .graph-item[_ngcontent-%COMP%]   .action-button[_ngcontent-%COMP%]   .block-container[_ngcontent-%COMP%]   .right-block[_ngcontent-%COMP%]{height:100%;width:50%;background-color:#999;border-top-right-radius:2px;border-bottom-right-radius:2px}

















`], data: { animation: ow }, changeDetection: 0 });
    }
    return i59;
  })();
  var dfe = ["input"];
  function ufe(i59, t) {
    if (i59 & 1 && (b(0, "div", 16), D(1), x()), i59 & 2) {
      let e = T();
      C(), Oe(" ", e.selectedGraphNodeCount, " nodes ");
    }
  }
  function hfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 17), Z("click", function() {
        q(e);
        let r = T();
        return Y(r.handleClickExportGraphJsonToResource());
      }), b(1, "mat-icon"), D(2, "drive_folder_upload"), x()();
    }
  }
  function pfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "mat-optgroup", 18)(1, "mat-option")(2, "input", 19, 1), Z("click", function(r) {
        return q(e), Y(r.stopPropagation());
      })("keydown.space", function(r) {
        return q(e), Y(r.stopPropagation());
      })("input", function() {
        q(e);
        let r = Ce(3), o = T();
        return Y(o.handleFilterTextChanged(r.value));
      }), x()()();
    }
  }
  function ffe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 26), Z("click", function(r) {
        q(e);
        let o = T().$implicit, s = T(2);
        return Y(s.handleClickOpenInSplitPane(r, o));
      }), b(1, "div", 27), ae(2, "div", 28), x()();
    }
  }
  function mfe(i59, t) {
    if (i59 & 1 && (b(0, "mat-option", 22)(1, "div", 23)(2, "div", 24)(3, "div", 7), D(4), x(), b(5, "div", 16), D(6), x()(), X(7, ffe, 3, 0, "div", 25), x()()), i59 & 2) {
      let e = t.$implicit, n = T(2);
      ye("selected", e.graph === n.selectedGraph.value), U("value", e.graph), Ke("data-id", e.id), C(4), Qe(e.id), C(2), Oe(" ", e.nonHiddenNodeCount, " nodes "), C(), U("ngIf", n.showOpenInSplitPane);
    }
  }
  function gfe(i59, t) {
    if (i59 & 1 && (b(0, "mat-optgroup", 20), X(1, mfe, 8, 7, "mat-option", 21), x()), i59 & 2) {
      let e = t.$implicit;
      U("label", e.label), C(), U("ngForOf", e.graphs);
    }
  }
  var _fe = new OffscreenCanvas(500, 300);
  var SH = {};
  var MH = (() => {
    class i59 {
      appService;
      overlay;
      viewContainerRef;
      mySelector;
      filterInput;
      selectedGraph = new qr(void 0);
      selectedGraphNodeCount = 0;
      selectedGraphCollectionLabel = "";
      selectedCollection;
      maxGraphItemIdWidth = 0;
      graphCollectionItems = It(() => {
        let e = this.appService.config();
        if (!e) return [];
        let n = this.appService.curGraphCollections();
        this.nodeLabelsToHide = new Set((e.nodeLabelsToHide || []).map((s) => s.toLowerCase()));
        let r = [], o = this.curFilterText().toLowerCase();
        for (let s of n) {
          let a = { label: s.label, collection: s, graphs: [] };
          for (let { graph: l, level: c } of s.graphsWithLevel ?? []) {
            if (o !== "" && !l.id.toLowerCase().includes(o)) continue;
            let d = l.nodes.filter((h) => !this.nodeLabelsToHide.has(h.label.toLowerCase())).length, u = this.getLabelWidth(` ${l.id}    ${d} nodes`) + 30;
            a.graphs.push({ id: l.id, graph: l, level: c, nonHiddenNodeCount: d, width: u }), this.maxGraphItemIdWidth = Math.max(u + 30, this.maxGraphItemIdWidth);
          }
          if (a.graphs.length > 0) {
            r.push(a);
            let l = this.getLabelWidth(s.label, 12, true) + 30;
            this.maxGraphItemIdWidth = Math.max(l, this.maxGraphItemIdWidth);
          }
        }
        return r;
      });
      graphsCount = It(() => {
        let e = 0, n = this.appService.curGraphCollections();
        for (let r of n) e += r.graphs.length;
        return e;
      });
      nodeLabelsToHide = /* @__PURE__ */ new Set();
      curFilterText = gt("");
      portal = null;
      selectedGraphId = It(() => {
        let e = this.appService.getSelectedPane();
        return !e || !e.modelGraph ? "" : e.modelGraph.id;
      });
      constructor(e, n, r) {
        this.appService = e, this.overlay = n, this.viewContainerRef = r, ht(() => {
          let o = this.selectedGraphId();
          o && this.updateSelectedGraphInfo(o);
        });
      }
      handleFilterTextChanged(e) {
        this.curFilterText.set(e);
      }
      handleClickOpenGraphDropdown(e) {
        let n = this.createOverlay(e), r = n.attach(this.portal);
        r.instance.graphCollectionItems = this.graphCollectionItems(), r.instance.onClose.subscribe(() => {
          n.dispose();
        });
      }
      handleGraphSelectorOpenedChanged(e) {
        e || (this.filterInput.nativeElement.value = "", this.curFilterText.set(""));
      }
      handleGraphSelected() {
        this.selectedGraph.value && (this.updateSelectedGraphInfo(this.selectedGraph.value.id), this.appService.selectGraphInCurrentPane(this.selectedGraph.value), this.appService.curInitialUiState.set(void 0), this.appService.selectNode(this.appService.selectedPaneId(), void 0), this.appService.curToLocateNodeInfo.set(void 0), this.appService.setFlattenLayersInCurrentPane(false));
      }
      handleClickOpenInSplitPane(e, n) {
        e.stopPropagation(), this.mySelector.close(), this.appService.openGraphInSplitPane(n.graph);
      }
      handleClickDownloadGraphJson() {
        if (this.selectedCollection == null) return;
        let e = document.createElement("a");
        e.download = `${this.selectedGraphCollectionLabel}.json`;
        let n = `data:text/json;charset=utf-8, ${encodeURIComponent(JSON.stringify(this.selectedCollection, null, 2))}`;
        qs(e, n), e.click();
      }
      handleClickExportGraphJsonToResource() {
        !this.selectedCollection != null && Ny(`${this.selectedGraphCollectionLabel}.json`, this.selectedCollection);
      }
      getGraphLabel(e) {
        return `${e.id} (${e.nodes.length} nodes)`;
      }
      get graphSelectorDropdownWidth() {
        return this.maxGraphItemIdWidth;
      }
      get showOpenInSplitPane() {
        return this.appService.panes().length === 1;
      }
      get enableExportToResource() {
        return this.appService.config()?.enableExportToResource === true;
      }
      getLabelWidth(e, n = 12, r = false) {
        let o = e, s = SH[o];
        if (s == null) {
          let a = _fe.getContext("2d");
          a.font = `${n}px "Google Sans Text", Arial, Helvetica, sans-serif`, r && (a.font = `bold ${a.font}`);
          let c = a.measureText(e).width;
          SH[o] = c, s = c;
        }
        return s;
      }
      updateSelectedGraphInfo(e) {
        let n = false;
        for (let r of this.graphCollectionItems()) {
          for (let o of r.graphs) if (o.graph.id === e) {
            this.selectedGraphNodeCount = o.nonHiddenNodeCount, this.selectedGraphCollectionLabel = r.label, this.selectedCollection = r.collection, this.selectedGraph.setValue(o.graph), n = true;
            break;
          }
          if (n) break;
        }
      }
      createOverlay(e) {
        let n = new Gi({ positionStrategy: this.overlay.position().flexibleConnectedTo(e).withPositions([{ originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }]), maxHeight: "calc(100% - 70px)", hasBackdrop: true, backdropClass: "cdk-overlay-transparent-backdrop", scrollStrategy: this.overlay.scrollStrategies.reposition(), panelClass: "graph-selector-panel" }), r = this.overlay.create(n);
        return this.portal = new Ui(CH, this.viewContainerRef), r.backdropClick().subscribe(() => {
          r.dispose();
        }), r;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(fn), K(un));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["graph-selector"]], viewQuery: function(n, r) {
        if (n & 1 && (Fe(Tw, 5), Fe(dfe, 5)), n & 2) {
          let o;
          Ie(o = De()) && (r.mySelector = o.first), Ie(o = De()) && (r.filterInput = o.first);
        }
      }, decls: 22, vars: 7, consts: [["selector", ""], ["input", ""], [1, "container"], [1, "collection-label"], [1, "graph-selector-label", 3, "click"], [1, "selector-label-container"], [1, "selector-label-content"], [1, "option-label"], ["class", "node-count-label", 4, "ngIf"], [1, "triangle"], ["matTooltip", "Download processed graphs json", 1, "mat-icon-container", 3, "click"], ["matTooltip", "Export to resource", 1, "mat-icon-container"], [1, "select-form"], ["color", "primary", "panelClass", "graph-selector-panel", 3, "selectionChange", "openedChange", "formControl"], ["class", "graph-search-optgroup", 4, "ngIf"], [3, "label", 4, "ngFor", "ngForOf"], [1, "node-count-label"], ["matTooltip", "Export to resource", 1, "mat-icon-container", 3, "click"], [1, "graph-search-optgroup"], ["placeholder", "Filter graphs", 3, "click", "keydown.space", "input"], [3, "label"], [3, "selected", "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "option-wrapper"], [1, "option-container"], ["class", "action-button", "matTooltip", "Open in split pane", "matTooltipPosition", "right", 3, "click", 4, "ngIf"], ["matTooltip", "Open in split pane", "matTooltipPosition", "right", 1, "action-button", 3, "click"], [1, "block-container"], [1, "right-block"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 2)(1, "div", 3), D(2), x(), b(3, "div", 4, 0), Z("click", function() {
            q(o);
            let a = Ce(4);
            return Y(r.handleClickOpenGraphDropdown(a));
          }), b(5, "div", 5)(6, "div", 6)(7, "div", 7), D(8), x(), X(9, ufe, 2, 1, "div", 8), x(), b(10, "div", 9), D(11, "\u25BC"), x()()(), b(12, "div", 10), Z("click", function() {
            return q(o), Y(r.handleClickDownloadGraphJson());
          }), b(13, "mat-icon"), D(14, "download"), x()(), X(15, hfe, 3, 0, "div", 11), b(16, "mat-form-field", 12)(17, "mat-label"), D(18, "Select an option"), x(), b(19, "mat-select", 13), Z("selectionChange", function() {
            return q(o), Y(r.handleGraphSelected());
          })("openedChange", function(a) {
            return q(o), Y(r.handleGraphSelectorOpenedChanged(a));
          }), X(20, pfe, 4, 0, "mat-optgroup", 14)(21, gfe, 2, 2, "mat-optgroup", 15), x()()();
        }
        n & 2 && (C(2), Oe(" ", r.selectedGraphCollectionLabel, " "), C(6), Qe((r.selectedGraph.value == null ? null : r.selectedGraph.value.id) || "-"), C(), U("ngIf", r.selectedGraph.value), C(6), he(r.enableExportToResource ? 15 : -1), C(4), U("formControl", r.selectedGraph), C(), U("ngIf", r.graphsCount() > 1), C(), U("ngForOf", r.graphCollectionItems()));
      }, dependencies: [et, Wr, In, mp, ZG, Ew, vt, St, gp, Tw, yb, bL, tn, $n, Do, Ps, Jo], styles: [`.container[_ngcontent-%COMP%]{font-size:12px;display:flex;align-items:center;line-height:14px;position:relative}.container[_ngcontent-%COMP%]   .collection-label[_ngcontent-%COMP%]{font-weight:700;margin-right:6px}.container[_ngcontent-%COMP%]   .select-form[_ngcontent-%COMP%]{height:0;max-height:0;position:absolute;top:26px;right:28px}.container[_ngcontent-%COMP%]   .select-form[_ngcontent-%COMP%]    >*{height:0}.container[_ngcontent-%COMP%]   .selector-label-content[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;flex-grow:1}.container[_ngcontent-%COMP%]   .option-label[_ngcontent-%COMP%]{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin-right:2px}.container[_ngcontent-%COMP%]   .node-count-label[_ngcontent-%COMP%]{color:#999;margin-left:12px}.container[_ngcontent-%COMP%]   .triangle[_ngcontent-%COMP%]{font-size:10px;margin-left:8px}.container[_ngcontent-%COMP%]   .graph-selector-label[_ngcontent-%COMP%]{font-size:12px;border:1px solid #aaa;border-radius:3px;padding:2px 4px;cursor:pointer;flex-grow:1;height:24px;display:flex;box-sizing:border-box}.container[_ngcontent-%COMP%]   .graph-selector-label[_ngcontent-%COMP%]   .selector-label-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between;flex-grow:1}.container[_ngcontent-%COMP%]   .graph-selector-label[_ngcontent-%COMP%]:hover{border-color:#ea8600}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;margin-left:4px;cursor:pointer;opacity:.6}.container[_ngcontent-%COMP%]   .mat-icon-container[_ngcontent-%COMP%]:hover{opacity:1}  .graph-selector-panel{background-color:#fff}  .graph-selector-panel mat-option{height:24px;font-size:12px;min-height:unset;padding:1px 0;padding-left:20px!important;background-color:none!important}  .graph-selector-panel mat-option .option-wrapper{display:flex;align-items:center}  .graph-selector-panel mat-option .option-container{display:flex;align-items:center;justify-content:space-between;letter-spacing:normal;font-family:Google Sans Text,Arial,Helvetica,sans-serif;flex-grow:1}  .graph-selector-panel mat-option .option-container .option-label{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;color:#000!important}  .graph-selector-panel mat-option .option-container .node-count-label{color:#999}  .graph-selector-panel mat-option .action-button{flex-shrink:0;width:16px;height:16px;display:flex;align-items:center;margin-left:4px;opacity:.8;cursor:pointer}  .graph-selector-panel mat-option .action-button:hover{opacity:1}  .graph-selector-panel mat-option .action-button .block-container{border-radius:3px;border:1px solid #999;height:100%;width:100%;box-sizing:border-box;display:flex;align-items:center;justify-content:flex-end;padding:1px}  .graph-selector-panel mat-option .action-button .block-container .right-block{height:100%;width:50%;background-color:#999;border-top-right-radius:2px;border-bottom-right-radius:2px}  .graph-selector-panel mat-option span{white-space:break-spaces!important;word-break:break-all;line-height:14px!important;width:100%;box-sizing:border-box;padding-right:10px}  .graph-selector-panel mat-option mat-pseudo-checkbox{display:none}  .graph-selector-panel mat-option.selected{background-color:#fff1de!important}  .graph-selector-panel mat-optgroup span{min-height:unset;font-size:12px;font-weight:700;padding-left:8px}  .graph-selector-panel mat-optgroup.graph-search-optgroup{pointer-events:none}  .graph-selector-panel mat-optgroup.graph-search-optgroup span{padding:0}  .graph-selector-panel mat-optgroup.graph-search-optgroup mat-option{padding-left:16px!important;padding-right:12px!important;height:28px}  .graph-selector-panel mat-optgroup.graph-search-optgroup input{font-size:12px;width:100%;box-sizing:border-box;pointer-events:all;border:1px solid #ccc;height:20px;border-radius:4px;padding:0 2px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var qn = function(i59) {
    return i59[i59.DT_INVALID = 0] = "DT_INVALID", i59[i59.DT_FLOAT = 1] = "DT_FLOAT", i59[i59.DT_DOUBLE = 2] = "DT_DOUBLE", i59[i59.DT_INT32 = 3] = "DT_INT32", i59[i59.DT_UINT8 = 4] = "DT_UINT8", i59[i59.DT_INT16 = 5] = "DT_INT16", i59[i59.DT_INT8 = 6] = "DT_INT8", i59[i59.DT_STRING = 7] = "DT_STRING", i59[i59.DT_COMPLEX64 = 8] = "DT_COMPLEX64", i59[i59.DT_INT64 = 9] = "DT_INT64", i59[i59.DT_BOOL = 10] = "DT_BOOL", i59[i59.DT_QINT8 = 11] = "DT_QINT8", i59[i59.DT_QUINT8 = 12] = "DT_QUINT8", i59[i59.DT_QINT32 = 13] = "DT_QINT32", i59[i59.DT_BFLOAT16 = 14] = "DT_BFLOAT16", i59[i59.DT_QINT16 = 15] = "DT_QINT16", i59[i59.DT_QUINT16 = 16] = "DT_QUINT16", i59[i59.DT_UINT16 = 17] = "DT_UINT16", i59[i59.DT_COMPLEX128 = 18] = "DT_COMPLEX128", i59[i59.DT_HALF = 19] = "DT_HALF", i59[i59.DT_RESOURCE = 20] = "DT_RESOURCE", i59[i59.DT_VARIANT = 21] = "DT_VARIANT", i59[i59.DT_UINT32 = 22] = "DT_UINT32", i59[i59.DT_UINT64 = 23] = "DT_UINT64", i59;
  }(qn || {});
  var tYe = /* @__PURE__ */ new Map([[qn.DT_FLOAT, "float"], [qn.DT_DOUBLE, "double"], [qn.DT_INT32, "int32"], [qn.DT_UINT8, "uint8"], [qn.DT_INT16, "int16"], [qn.DT_INT8, "int8"], [qn.DT_STRING, "string"], [qn.DT_COMPLEX64, "complex64"], [qn.DT_INT64, "int64"], [qn.DT_BOOL, "bool"], [qn.DT_QINT8, "qint8"], [qn.DT_QUINT8, "qint8"], [qn.DT_QINT32, "qint32"], [qn.DT_BFLOAT16, "bfloat16"], [qn.DT_QINT16, "qint16"], [qn.DT_QUINT16, "qint16"], [qn.DT_UINT16, "uint16"], [qn.DT_COMPLEX128, "complex128"], [qn.DT_HALF, "half"], [qn.DT_RESOURCE, "resource"], [qn.DT_VARIANT, "variant"], [qn.DT_UINT32, "uint32"], [qn.DT_UINT64, "uint64"]]);
  var oYe = new URLSearchParams(window.location.search).get("internal_colab") === "1";
  function EH() {
    return window.meElectronApi;
  }
  function vfe(i59, t) {
    i59 & 1 && (b(0, "div", 4), D(1, " Run the following command in your console to upgrade: "), b(2, "div", 10), D(3, " pip install -U ai-edge-model-explorer "), x()());
  }
  function yfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 9)(1, "mat-icon", 7), D(2, "get_app"), x(), b(3, "a", 8), D(4, " Download desktop app "), x()()), i59 & 2) {
      let e = T(3);
      C(3), U("href", e.info().desktopAppUrl, tM);
    }
  }
  function bfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 2), D(1, " Model Explorer "), b(2, "span", 3), D(3), x(), D(4, " is available. You are running "), b(5, "span", 3), D(6), x(), D(7, ". "), X(8, vfe, 4, 0, "div", 4), b(9, "div", 5)(10, "div", 6)(11, "mat-icon", 7), D(12, "description"), x(), b(13, "a", 8), D(14, " Release notes "), x()(), X(15, yfe, 5, 1, "div", 9), x()()), i59 & 2) {
      let e = T(2);
      C(3), Oe("v", e.info().version, ""), C(3), Oe("v", e.info().runningVersion, ""), C(2), he(e.isElectron ? -1 : 8), C(5), U("href", e.info().releaseUrl, tM), C(2), he(e.isElectron && e.info().desktopAppUrl ? 15 : -1);
    }
  }
  function xfe(i59, t) {
    if (i59 & 1 && (b(0, "div", 1)(1, "mat-icon"), D(2, "upgrade"), x(), D(3, " New version available "), x(), X(4, bfe, 16, 5, "ng-template", null, 0, Tt)), i59 & 2) {
      let e = Ce(5);
      U("bubble", e)("hoverDelayMs", 100);
    }
  }
  var wfe = "/api/v1/check_new_version";
  var Cfe = (() => {
    class i59 {
      info = gt({ version: "", runningVersion: "", releaseUrl: "", desktopAppUrl: "" });
      constructor() {
        let e = window.modelExplorer != null;
        !e && this.checkNewVersion();
      }
      checkNewVersion() {
        return $t(this, null, function* () {
          try {
            let e = yield fetch(wfe);
            if (e.ok) {
              let n = yield e.json();
              this.info.set(n);
            }
          } catch {
          }
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var TH = (() => {
    class i59 {
      newVersionService;
      info;
      isElectron = EH() != null;
      constructor(e) {
        this.newVersionService = e, this.info = this.newVersionService.info;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Cfe));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["new-version-chip"]], decls: 1, vars: 1, consts: [["upgrade", ""], [1, "container", 3, "bubble", "hoverDelayMs"], [1, "model-explorer-upgrade-popup"], [1, "bold"], [1, "upgrade-command"], [1, "items"], [1, "release-notes"], [1, "item-icon"], ["target", "_blank", 3, "href"], [1, "download-desktop-app"], [1, "code"]], template: function(n, r) {
        n & 1 && X(0, xfe, 6, 2), n & 2 && he(r.info().version !== "" ? 0 : -1);
      }, dependencies: [Bn, et, vt, St], styles: [".container[_ngcontent-%COMP%]{font-size:12px;display:flex;align-items:center;color:#ab6c17;background-color:#ffefd9;line-height:18px;border-radius:99px;font-weight:500;padding:2px 10px 2px 4px;cursor:pointer}.container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px}  .model-explorer-upgrade-popup{padding:8px;font-size:12px;background-color:#fff;line-height:normal}  .model-explorer-upgrade-popup .bold{font-weight:500}  .model-explorer-upgrade-popup .upgrade-command{margin-top:12px}  .model-explorer-upgrade-popup .code{background-color:#f1f1f1;font-family:monospace;margin-top:4px;padding:4px;font-size:11px}  .model-explorer-upgrade-popup .items{display:flex;flex-direction:column;gap:4px;margin-top:12px}  .model-explorer-upgrade-popup .release-notes,   .model-explorer-upgrade-popup .download-desktop-app{display:flex;align-items:center}  .model-explorer-upgrade-popup .item-icon{font-size:16px;width:16px;height:16px;margin-right:4px;color:#777}"] });
    }
    return i59;
  })();
  function Sfe(i59, t) {
    i59 & 1 && ae(0, "mat-spinner", 5);
  }
  function Mfe(i59, t) {
    i59 & 1 && (b(0, "mat-icon"), D(1, "add_circle_outline"), x());
  }
  function Efe(i59, t) {
    i59 & 1 && (b(0, "div", 7), D(1, " Add custom data and styles to the nodes in the current model "), x());
  }
  function Tfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 8)(1, "div", 9)(2, "div"), D(3, "Load json data file"), x(), b(4, "a", 10), D(5, " Guide "), x()(), b(6, "div", 11)(7, "div", 12), D(8, "From computer"), x(), b(9, "button", 13), Z("click", function() {
        q(e);
        let r = Ce(12);
        return Y(r.click());
      }), D(10, " Upload "), x()(), b(11, "input", 14, 2), Z("change", function() {
        q(e);
        let r = Ce(12), o = T();
        return Y(o.handleClickUpload(r));
      }), x()();
    }
  }
  var IH = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      localStorageService;
      nodeDataProviderExtensionService;
      dropdown;
      extensions = [];
      loadingExtensions = true;
      helpPopupSize = { minWidth: 0, minHeight: 0 };
      dropdownSize = { minWidth: 0, minHeight: 0, maxHeight: 500 };
      remoteSourceLoading;
      constructor(e, n, r, o) {
        this.appService = e, this.changeDetectorRef = n, this.localStorageService = r, this.nodeDataProviderExtensionService = o, this.remoteSourceLoading = this.nodeDataProviderExtensionService.remoteSourceLoading;
      }
      handleClickUpload(e) {
        let n = e.files;
        if (!n) return;
        let r = this.appService.getModelGraphFromSelectedPane();
        if (r) {
          for (let o of Array.from(n)) {
            let s = new FileReader();
            s.onload = (a) => {
              let l = Li();
              try {
                let c = this.getNodeDataProviderData(a.target?.result, r);
                this.nodeDataProviderExtensionService.addRun(l, o.name, "", r, c);
              } catch (c) {
                this.nodeDataProviderExtensionService.addRun(l, o.name, "", r), this.nodeDataProviderExtensionService.updateRunResults(l, { [r.id]: { results: {} } }, r, `Failed to process JSON file. ${c}`);
              } finally {
                this.dropdown?.closeDialog();
              }
            }, s.readAsText(o);
          }
          e.value = "";
        }
      }
      getNodeDataProviderData(e, n) {
        let r = JSON.parse(e), o = {};
        return r.results != null && r.results.results == null ? n && (o[n.id] = r) : o = r, o;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(Io), K(Cr));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["node-data-provider-dropdown"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Xr, 5), n & 2) {
          let o;
          Ie(o = De()) && (r.dropdown = o.first);
        }
      }, decls: 10, vars: 6, consts: [["help", ""], ["dropdown", ""], ["input", ""], [1, "container", 3, "bubble", "overlaySize", "hoverDelayMs"], [1, "icon-container", 3, "bubbleClick", "overlaySize"], ["color", "primary", "diameter", "18"], [1, "label"], [1, "model-explorer-help-popup"], [1, "model-explorer-node-data-provider-dropdown"], [1, "section-label", "upload"], ["href", "https://github.com/google-ai-edge/model-explorer/wiki/2.-User-Guide#custom-node-data", "target", "_blank"], [1, "upload-container"], [1, "description"], ["mat-flat-button", "", "color", "primary", 1, "upload-json-file-button", "upload", 3, "click"], ["type", "file", "multiple", "", "accept", ".json", 1, "upload-per-node-data-input", 3, "change"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 3)(1, "div", 4), X(2, Sfe, 1, 0, "mat-spinner", 5)(3, Mfe, 2, 0, "mat-icon"), b(4, "span", 6), D(5, "Add per-node data"), x()()(), X(6, Efe, 2, 0, "ng-template", null, 0, Tt)(8, Tfe, 13, 0, "ng-template", null, 1, Tt)), n & 2) {
          let o = Ce(7), s = Ce(9);
          U("bubble", o)("overlaySize", r.helpPopupSize)("hoverDelayMs", 10), C(), U("bubbleClick", s)("overlaySize", r.dropdownSize), C(), he(r.remoteSourceLoading() ? 2 : 3);
        }
      }, dependencies: [Bn, Xr, et, Hn, vr, vt, St, Zs, fp, tn], styles: [`.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;cursor:pointer;color:#666;padding-bottom:12px;margin-bottom:-12px}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin-right:4px}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-spinner[_ngcontent-%COMP%]{margin-right:6px}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{font-size:13px}.container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{color:#444}  .model-explorer-node-data-provider-dropdown{font-size:12px;background-color:#fff;display:flex;flex-direction:column;padding-bottom:8px}  .model-explorer-node-data-provider-dropdown .section-label{padding:8px 12px;font-size:11px;background:#f1f1f1;font-weight:500;text-transform:uppercase}  .model-explorer-node-data-provider-dropdown .section-label .address-container{text-transform:none;font-weight:400;letter-spacing:normal;color:#777;line-height:12px;padding-bottom:5px;display:flex;align-items:flex-start;margin-top:-4px;margin-left:-2px}  .model-explorer-node-data-provider-dropdown .section-label .address-container .address-label{overflow:hidden;line-break:anywhere;line-height:12px;flex-grow:1;padding-top:3px}  .model-explorer-node-data-provider-dropdown .section-label .address-container .settings-icon-container{display:flex;align-items:center;justify-content:center;margin-right:4px;pointer-events:all;cursor:pointer;opacity:.7}  .model-explorer-node-data-provider-dropdown .section-label .address-container .settings-icon-container:hover{opacity:1}  .model-explorer-node-data-provider-dropdown .section-label .address-container .settings-icon-container mat-icon{font-size:16px;width:16px;height:16px}  .model-explorer-node-data-provider-dropdown .section-label.upload{display:flex;align-items:center;justify-content:space-between;min-width:180px}  .model-explorer-node-data-provider-dropdown .section-label.upload a{font-size:11px;letter-spacing:normal;text-transform:none;pointer-events:all}  .model-explorer-node-data-provider-dropdown .description{font-size:12px;color:#777;line-height:18px;letter-spacing:normal}  .model-explorer-node-data-provider-dropdown .upload-container{display:flex;flex-direction:column;align-items:flex-start;padding:0 16px;margin-top:12px}  .model-explorer-node-data-provider-dropdown .upload-json-file-button{margin:4px 0;width:90px;height:30px;font-size:12px!important;letter-spacing:normal!important}  .model-explorer-node-data-provider-dropdown .upload-json-file-button.upload{margin-top:2px}  .model-explorer-node-data-provider-dropdown .upload-json-file-button   .mat-mdc-button-touch-target{display:none}  .model-explorer-node-data-provider-dropdown .or-divider{height:1px;border-top:1px solid #eee;position:relative;margin-top:12px}  .model-explorer-node-data-provider-dropdown .or-divider .or-label{font-size:10px;top:-12px;color:#aaa;position:absolute;padding:2px;background-color:#fff;display:flex;align-items:center;justify-content:center;width:16px;left:calc(50% - 8px)}  .model-explorer-node-data-provider-dropdown .upload-per-node-data-input{display:none}  .model-explorer-node-data-provider-dropdown .no-extension,   .model-explorer-node-data-provider-dropdown .loading-extension{padding:12px 0 4px 16px;color:#999;font-size:13px;letter-spacing:normal}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function Ife(i59, t) {
  }
  var Hl = class {
    viewContainerRef;
    injector;
    id;
    role = "dialog";
    panelClass = "";
    hasBackdrop = true;
    backdropClass = "";
    disableClose = false;
    width = "";
    height = "";
    minWidth;
    minHeight;
    maxWidth;
    maxHeight;
    positionStrategy;
    data = null;
    direction;
    ariaDescribedBy = null;
    ariaLabelledBy = null;
    ariaLabel = null;
    ariaModal = false;
    autoFocus = "first-tabbable";
    restoreFocus = true;
    scrollStrategy;
    closeOnNavigation = true;
    closeOnDestroy = true;
    closeOnOverlayDetachments = true;
    componentFactoryResolver;
    providers;
    container;
    templateContext;
  };
  var XD = (() => {
    class i59 extends js {
      _elementRef = M(He);
      _focusTrapFactory = M(cL);
      _config;
      _interactivityChecker = M(db);
      _ngZone = M(We);
      _overlayRef = M(lp);
      _focusMonitor = M(so);
      _renderer = M(Pr);
      _platform = M(Nn);
      _document = M(yt, { optional: true });
      _portalOutlet;
      _focusTrap = null;
      _elementFocusedBeforeDialogWasOpened = null;
      _closeInteractionType = null;
      _ariaLabelledByQueue = [];
      _changeDetectorRef = M(Ge);
      _injector = M(mt);
      _isDestroyed = false;
      constructor() {
        super(), this._config = M(Hl, { optional: true }) || new Hl(), this._config.ariaLabelledBy && this._ariaLabelledByQueue.push(this._config.ariaLabelledBy);
      }
      _addAriaLabelledBy(e) {
        this._ariaLabelledByQueue.push(e), this._changeDetectorRef.markForCheck();
      }
      _removeAriaLabelledBy(e) {
        let n = this._ariaLabelledByQueue.indexOf(e);
        n > -1 && (this._ariaLabelledByQueue.splice(n, 1), this._changeDetectorRef.markForCheck());
      }
      _contentAttached() {
        this._initializeFocusTrap(), this._handleBackdropClicks(), this._captureInitialFocus();
      }
      _captureInitialFocus() {
        this._trapFocus();
      }
      ngOnDestroy() {
        this._isDestroyed = true, this._restoreFocus();
      }
      attachComponentPortal(e) {
        this._portalOutlet.hasAttached();
        let n = this._portalOutlet.attachComponentPortal(e);
        return this._contentAttached(), n;
      }
      attachTemplatePortal(e) {
        this._portalOutlet.hasAttached();
        let n = this._portalOutlet.attachTemplatePortal(e);
        return this._contentAttached(), n;
      }
      attachDomPortal = (e) => {
        this._portalOutlet.hasAttached();
        let n = this._portalOutlet.attachDomPortal(e);
        return this._contentAttached(), n;
      };
      _recaptureFocus() {
        this._containsFocus() || this._trapFocus();
      }
      _forceFocus(e, n) {
        this._interactivityChecker.isFocusable(e) || (e.tabIndex = -1, this._ngZone.runOutsideAngular(() => {
          let r = () => {
            o(), s(), e.removeAttribute("tabindex");
          }, o = this._renderer.listen(e, "blur", r), s = this._renderer.listen(e, "mousedown", r);
        })), e.focus(n);
      }
      _focusByCssSelector(e, n) {
        let r = this._elementRef.nativeElement.querySelector(e);
        r && this._forceFocus(r, n);
      }
      _trapFocus() {
        this._isDestroyed || Yi(() => {
          let e = this._elementRef.nativeElement;
          switch (this._config.autoFocus) {
            case false:
            case "dialog":
              this._containsFocus() || e.focus();
              break;
            case true:
            case "first-tabbable":
              this._focusTrap?.focusInitialElement() || this._focusDialogContainer();
              break;
            case "first-heading":
              this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
              break;
            default:
              this._focusByCssSelector(this._config.autoFocus);
              break;
          }
        }, { injector: this._injector });
      }
      _restoreFocus() {
        let e = this._config.restoreFocus, n = null;
        if (typeof e == "string" ? n = this._document.querySelector(e) : typeof e == "boolean" ? n = e ? this._elementFocusedBeforeDialogWasOpened : null : e && (n = e), this._config.restoreFocus && n && typeof n.focus == "function") {
          let r = Bf(), o = this._elementRef.nativeElement;
          (!r || r === this._document.body || r === o || o.contains(r)) && (this._focusMonitor ? (this._focusMonitor.focusVia(n, this._closeInteractionType), this._closeInteractionType = null) : n.focus());
        }
        this._focusTrap && this._focusTrap.destroy();
      }
      _focusDialogContainer() {
        this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus();
      }
      _containsFocus() {
        let e = this._elementRef.nativeElement, n = Bf();
        return e === n || e.contains(n);
      }
      _initializeFocusTrap() {
        this._platform.isBrowser && (this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._document && (this._elementFocusedBeforeDialogWasOpened = Bf()));
      }
      _handleBackdropClicks() {
        this._overlayRef.backdropClick().subscribe(() => {
          this._config.disableClose && this._recaptureFocus();
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["cdk-dialog-container"]], viewQuery: function(n, r) {
        if (n & 1 && Fe(Bo, 7), n & 2) {
          let o;
          Ie(o = De()) && (r._portalOutlet = o.first);
        }
      }, hostAttrs: ["tabindex", "-1", 1, "cdk-dialog-container"], hostVars: 6, hostBindings: function(n, r) {
        n & 2 && Ke("id", r._config.id || null)("role", r._config.role)("aria-modal", r._config.ariaModal)("aria-labelledby", r._config.ariaLabel ? null : r._ariaLabelledByQueue[0])("aria-label", r._config.ariaLabel)("aria-describedby", r._config.ariaDescribedBy || null);
      }, features: [Zt], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function(n, r) {
        n & 1 && X(0, Ife, 0, 0, "ng-template", 0);
      }, dependencies: [Bo], styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"], encapsulation: 2 });
    }
    return i59;
  })();
  var $g = class {
    overlayRef;
    config;
    componentInstance;
    componentRef;
    containerInstance;
    disableClose;
    closed = new we();
    backdropClick;
    keydownEvents;
    outsidePointerEvents;
    id;
    _detachSubscription;
    constructor(t, e) {
      this.overlayRef = t, this.config = e, this.disableClose = e.disableClose, this.backdropClick = t.backdropClick(), this.keydownEvents = t.keydownEvents(), this.outsidePointerEvents = t.outsidePointerEvents(), this.id = e.id, this.keydownEvents.subscribe((n) => {
        n.keyCode === 27 && !this.disableClose && !Ki(n) && (n.preventDefault(), this.close(void 0, { focusOrigin: "keyboard" }));
      }), this.backdropClick.subscribe(() => {
        this.disableClose || this.close(void 0, { focusOrigin: "mouse" });
      }), this._detachSubscription = t.detachments().subscribe(() => {
        e.closeOnOverlayDetachments !== false && this.close();
      });
    }
    close(t, e) {
      if (this.containerInstance) {
        let n = this.closed;
        this.containerInstance._closeInteractionType = e?.focusOrigin || "program", this._detachSubscription.unsubscribe(), this.overlayRef.dispose(), n.next(t), n.complete(), this.componentInstance = this.containerInstance = null;
      }
    }
    updatePosition() {
      return this.overlayRef.updatePosition(), this;
    }
    updateSize(t = "", e = "") {
      return this.overlayRef.updateSize({ width: t, height: e }), this;
    }
    addPanelClass(t) {
      return this.overlayRef.addPanelClass(t), this;
    }
    removePanelClass(t) {
      return this.overlayRef.removePanelClass(t), this;
    }
  };
  var Dfe = new Ee("DialogScrollStrategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.block();
  } });
  var Pfe = new Ee("DialogData");
  var Rfe = new Ee("DefaultDialogConfig");
  var ZD = (() => {
    class i59 {
      _overlay = M(fn);
      _injector = M(mt);
      _defaultOptions = M(Rfe, { optional: true });
      _parentDialog = M(i59, { optional: true, skipSelf: true });
      _overlayContainer = M(qx);
      _idGenerator = M(kn);
      _openDialogsAtThisLevel = [];
      _afterAllClosedAtThisLevel = new we();
      _afterOpenedAtThisLevel = new we();
      _ariaHiddenElements = /* @__PURE__ */ new Map();
      _scrollStrategy = M(Dfe);
      get openDialogs() {
        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
      }
      get afterOpened() {
        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
      }
      afterAllClosed = nc(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(ei(void 0)));
      constructor() {
      }
      open(e, n) {
        let r = this._defaultOptions || new Hl();
        n = le(le({}, r), n), n.id = n.id || this._idGenerator.getId("cdk-dialog-"), n.id && this.getDialogById(n.id);
        let o = this._getOverlayConfig(n), s = this._overlay.create(o), a = new $g(s, n), l = this._attachContainer(s, a, n);
        return a.containerInstance = l, this._attachDialogContent(e, a, l, n), this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(a), a.closed.subscribe(() => this._removeOpenDialog(a, true)), this.afterOpened.next(a), a;
      }
      closeAll() {
        YD(this.openDialogs, (e) => e.close());
      }
      getDialogById(e) {
        return this.openDialogs.find((n) => n.id === e);
      }
      ngOnDestroy() {
        YD(this._openDialogsAtThisLevel, (e) => {
          e.config.closeOnDestroy === false && this._removeOpenDialog(e, false);
        }), YD(this._openDialogsAtThisLevel, (e) => e.close()), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete(), this._openDialogsAtThisLevel = [];
      }
      _getOverlayConfig(e) {
        let n = new Gi({ positionStrategy: e.positionStrategy || this._overlay.position().global().centerHorizontally().centerVertically(), scrollStrategy: e.scrollStrategy || this._scrollStrategy(), panelClass: e.panelClass, hasBackdrop: e.hasBackdrop, direction: e.direction, minWidth: e.minWidth, minHeight: e.minHeight, maxWidth: e.maxWidth, maxHeight: e.maxHeight, width: e.width, height: e.height, disposeOnNavigation: e.closeOnNavigation });
        return e.backdropClass && (n.backdropClass = e.backdropClass), n;
      }
      _attachContainer(e, n, r) {
        let o = r.injector || r.viewContainerRef?.injector, s = [{ provide: Hl, useValue: r }, { provide: $g, useValue: n }, { provide: lp, useValue: e }], a;
        r.container ? typeof r.container == "function" ? a = r.container : (a = r.container.type, s.push(...r.container.providers(r))) : a = XD;
        let l = new Ui(a, r.viewContainerRef, mt.create({ parent: o || this._injector, providers: s }));
        return e.attach(l).instance;
      }
      _attachDialogContent(e, n, r, o) {
        if (e instanceof ni) {
          let s = this._createInjector(o, n, r, void 0), a = { $implicit: o.data, dialogRef: n };
          o.templateContext && (a = le(le({}, a), typeof o.templateContext == "function" ? o.templateContext() : o.templateContext)), r.attachTemplatePortal(new go(e, null, a, s));
        } else {
          let s = this._createInjector(o, n, r, this._injector), a = r.attachComponentPortal(new Ui(e, o.viewContainerRef, s));
          n.componentRef = a, n.componentInstance = a.instance;
        }
      }
      _createInjector(e, n, r, o) {
        let s = e.injector || e.viewContainerRef?.injector, a = [{ provide: Pfe, useValue: e.data }, { provide: $g, useValue: n }];
        return e.providers && (typeof e.providers == "function" ? a.push(...e.providers(n, e, r)) : a.push(...e.providers)), e.direction && (!s || !s.get(_i, null, { optional: true })) && a.push({ provide: _i, useValue: { value: e.direction, change: qt() } }), mt.create({ parent: s || o, providers: a });
      }
      _removeOpenDialog(e, n) {
        let r = this.openDialogs.indexOf(e);
        r > -1 && (this.openDialogs.splice(r, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((o, s) => {
          o ? s.setAttribute("aria-hidden", o) : s.removeAttribute("aria-hidden");
        }), this._ariaHiddenElements.clear(), n && this._getAfterAllClosed().next()));
      }
      _hideNonDialogContentFromAssistiveTechnology() {
        let e = this._overlayContainer.getContainerElement();
        if (e.parentElement) {
          let n = e.parentElement.children;
          for (let r = n.length - 1; r > -1; r--) {
            let o = n[r];
            o !== e && o.nodeName !== "SCRIPT" && o.nodeName !== "STYLE" && !o.hasAttribute("aria-live") && (this._ariaHiddenElements.set(o, o.getAttribute("aria-hidden")), o.setAttribute("aria-hidden", "true"));
          }
        }
      }
      _getAfterAllClosed() {
        let e = this._parentDialog;
        return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  function YD(i59, t) {
    let e = i59.length;
    for (; e--; ) t(i59[e]);
  }
  var DH = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [ZD], imports: [ps, Ws, hb, Ws] });
    }
    return i59;
  })();
  function Ofe(i59, t) {
  }
  var Ow = class {
    viewContainerRef;
    injector;
    id;
    role = "dialog";
    panelClass = "";
    hasBackdrop = true;
    backdropClass = "";
    disableClose = false;
    width = "";
    height = "";
    minWidth;
    minHeight;
    maxWidth;
    maxHeight;
    position;
    data = null;
    direction;
    ariaDescribedBy = null;
    ariaLabelledBy = null;
    ariaLabel = null;
    ariaModal = false;
    autoFocus = "first-tabbable";
    restoreFocus = true;
    delayFocusTrap = true;
    scrollStrategy;
    closeOnNavigation = true;
    componentFactoryResolver;
    enterAnimationDuration;
    exitAnimationDuration;
  };
  var QD = "mdc-dialog--open";
  var PH = "mdc-dialog--opening";
  var RH = "mdc-dialog--closing";
  var Afe = 150;
  var Nfe = 75;
  var kfe = (() => {
    class i59 extends XD {
      _animationMode = M(An, { optional: true });
      _animationStateChanged = new Ue();
      _animationsEnabled = this._animationMode !== "NoopAnimations";
      _actionSectionCount = 0;
      _hostElement = this._elementRef.nativeElement;
      _enterAnimationDuration = this._animationsEnabled ? AH(this._config.enterAnimationDuration) ?? Afe : 0;
      _exitAnimationDuration = this._animationsEnabled ? AH(this._config.exitAnimationDuration) ?? Nfe : 0;
      _animationTimer = null;
      _contentAttached() {
        super._contentAttached(), this._startOpenAnimation();
      }
      _startOpenAnimation() {
        this._animationStateChanged.emit({ state: "opening", totalTime: this._enterAnimationDuration }), this._animationsEnabled ? (this._hostElement.style.setProperty(OH, `${this._enterAnimationDuration}ms`), this._requestAnimationFrame(() => this._hostElement.classList.add(PH, QD)), this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen)) : (this._hostElement.classList.add(QD), Promise.resolve().then(() => this._finishDialogOpen()));
      }
      _startExitAnimation() {
        this._animationStateChanged.emit({ state: "closing", totalTime: this._exitAnimationDuration }), this._hostElement.classList.remove(QD), this._animationsEnabled ? (this._hostElement.style.setProperty(OH, `${this._exitAnimationDuration}ms`), this._requestAnimationFrame(() => this._hostElement.classList.add(RH)), this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose)) : Promise.resolve().then(() => this._finishDialogClose());
      }
      _updateActionSectionCount(e) {
        this._actionSectionCount += e, this._changeDetectorRef.markForCheck();
      }
      _finishDialogOpen = () => {
        this._clearAnimationClasses(), this._openAnimationDone(this._enterAnimationDuration);
      };
      _finishDialogClose = () => {
        this._clearAnimationClasses(), this._animationStateChanged.emit({ state: "closed", totalTime: this._exitAnimationDuration });
      };
      _clearAnimationClasses() {
        this._hostElement.classList.remove(PH, RH);
      }
      _waitForAnimationToComplete(e, n) {
        this._animationTimer !== null && clearTimeout(this._animationTimer), this._animationTimer = setTimeout(n, e);
      }
      _requestAnimationFrame(e) {
        this._ngZone.runOutsideAngular(() => {
          typeof requestAnimationFrame == "function" ? requestAnimationFrame(e) : e();
        });
      }
      _captureInitialFocus() {
        this._config.delayFocusTrap || this._trapFocus();
      }
      _openAnimationDone(e) {
        this._config.delayFocusTrap && this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: e });
      }
      ngOnDestroy() {
        super.ngOnDestroy(), this._animationTimer !== null && clearTimeout(this._animationTimer);
      }
      attachComponentPortal(e) {
        let n = super.attachComponentPortal(e);
        return n.location.nativeElement.classList.add("mat-mdc-dialog-component-host"), n;
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275cmp = xe({ type: i59, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", 1, "mat-mdc-dialog-container", "mdc-dialog"], hostVars: 10, hostBindings: function(n, r) {
        n & 2 && (gr("id", r._config.id), Ke("aria-modal", r._config.ariaModal)("role", r._config.role)("aria-labelledby", r._config.ariaLabel ? null : r._ariaLabelledByQueue[0])("aria-label", r._config.ariaLabel)("aria-describedby", r._config.ariaDescribedBy || null), ye("_mat-animation-noopable", !r._animationsEnabled)("mat-mdc-dialog-container-with-actions", r._actionSectionCount > 0));
      }, features: [Zt], decls: 3, vars: 0, consts: [[1, "mat-mdc-dialog-inner-container", "mdc-dialog__container"], [1, "mat-mdc-dialog-surface", "mdc-dialog__surface"], ["cdkPortalOutlet", ""]], template: function(n, r) {
        n & 1 && (b(0, "div", 0)(1, "div", 1), X(2, Ofe, 0, 0, "ng-template", 2), x()());
      }, dependencies: [Bo], styles: ['.mat-mdc-dialog-container{width:100%;height:100%;display:block;box-sizing:border-box;max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;outline:0}.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-max-width, 560px);min-width:var(--mat-dialog-container-min-width, 280px)}@media(max-width: 599px){.cdk-overlay-pane.mat-mdc-dialog-panel{max-width:var(--mat-dialog-container-small-max-width, calc(100vw - 32px))}}.mat-mdc-dialog-inner-container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;opacity:0;transition:opacity linear var(--mat-dialog-transition-duration, 0ms);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mdc-dialog--closing .mat-mdc-dialog-inner-container{transition:opacity 75ms linear;transform:none}.mdc-dialog--open .mat-mdc-dialog-inner-container{opacity:1}._mat-animation-noopable .mat-mdc-dialog-inner-container{transition:none}.mat-mdc-dialog-surface{display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;width:100%;height:100%;position:relative;overflow-y:auto;outline:0;transform:scale(0.8);transition:transform var(--mat-dialog-transition-duration, 0ms) cubic-bezier(0, 0, 0.2, 1);max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit;box-shadow:var(--mat-dialog-container-elevation-shadow, none);border-radius:var(--mdc-dialog-container-shape, var(--mat-sys-corner-extra-large, 4px));background-color:var(--mdc-dialog-container-color, var(--mat-sys-surface, white))}[dir=rtl] .mat-mdc-dialog-surface{text-align:right}.mdc-dialog--open .mat-mdc-dialog-surface,.mdc-dialog--closing .mat-mdc-dialog-surface{transform:none}._mat-animation-noopable .mat-mdc-dialog-surface{transition:none}.mat-mdc-dialog-surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}.mat-mdc-dialog-title{display:block;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:var(--mat-dialog-headline-padding, 6px 24px 13px)}.mat-mdc-dialog-title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mat-mdc-dialog-title{text-align:right}.mat-mdc-dialog-container .mat-mdc-dialog-title{color:var(--mdc-dialog-subhead-color, var(--mat-sys-on-surface, rgba(0, 0, 0, 0.87)));font-family:var(--mdc-dialog-subhead-font, var(--mat-sys-headline-small-font, inherit));line-height:var(--mdc-dialog-subhead-line-height, var(--mat-sys-headline-small-line-height, 1.5rem));font-size:var(--mdc-dialog-subhead-size, var(--mat-sys-headline-small-size, 1rem));font-weight:var(--mdc-dialog-subhead-weight, var(--mat-sys-headline-small-weight, 400));letter-spacing:var(--mdc-dialog-subhead-tracking, var(--mat-sys-headline-small-tracking, 0.03125em))}.mat-mdc-dialog-content{display:block;flex-grow:1;box-sizing:border-box;margin:0;overflow:auto;max-height:65vh}.mat-mdc-dialog-content>:first-child{margin-top:0}.mat-mdc-dialog-content>:last-child{margin-bottom:0}.mat-mdc-dialog-container .mat-mdc-dialog-content{color:var(--mdc-dialog-supporting-text-color, var(--mat-sys-on-surface-variant, rgba(0, 0, 0, 0.6)));font-family:var(--mdc-dialog-supporting-text-font, var(--mat-sys-body-medium-font, inherit));line-height:var(--mdc-dialog-supporting-text-line-height, var(--mat-sys-body-medium-line-height, 1.5rem));font-size:var(--mdc-dialog-supporting-text-size, var(--mat-sys-body-medium-size, 1rem));font-weight:var(--mdc-dialog-supporting-text-weight, var(--mat-sys-body-medium-weight, 400));letter-spacing:var(--mdc-dialog-supporting-text-tracking, var(--mat-sys-body-medium-tracking, 0.03125em))}.mat-mdc-dialog-container .mat-mdc-dialog-content{padding:var(--mat-dialog-content-padding, 20px 24px)}.mat-mdc-dialog-container-with-actions .mat-mdc-dialog-content{padding:var(--mat-dialog-with-actions-content-padding, 20px 24px 0)}.mat-mdc-dialog-container .mat-mdc-dialog-title+.mat-mdc-dialog-content{padding-top:0}.mat-mdc-dialog-actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0);padding:var(--mat-dialog-actions-padding, 16px 24px);justify-content:var(--mat-dialog-actions-alignment, flex-end)}@media(forced-colors: active){.mat-mdc-dialog-actions{border-top-color:CanvasText}}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-start,.mat-mdc-dialog-actions[align=start]{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}.mat-mdc-dialog-component-host{display:contents}'], encapsulation: 2 });
    }
    return i59;
  })();
  var OH = "--mat-dialog-transition-duration";
  function AH(i59) {
    return i59 == null ? null : typeof i59 == "number" ? i59 : i59.endsWith("ms") ? ya(i59.substring(0, i59.length - 2)) : i59.endsWith("s") ? ya(i59.substring(0, i59.length - 1)) * 1e3 : i59 === "0" ? 0 : null;
  }
  var Rw = function(i59) {
    return i59[i59.OPEN = 0] = "OPEN", i59[i59.CLOSING = 1] = "CLOSING", i59[i59.CLOSED = 2] = "CLOSED", i59;
  }(Rw || {});
  var qg = class {
    _ref;
    _containerInstance;
    componentInstance;
    componentRef;
    disableClose;
    id;
    _afterOpened = new we();
    _beforeClosed = new we();
    _result;
    _closeFallbackTimeout;
    _state = Rw.OPEN;
    _closeInteractionType;
    constructor(t, e, n) {
      this._ref = t, this._containerInstance = n, this.disableClose = e.disableClose, this.id = t.id, t.addPanelClass("mat-mdc-dialog-panel"), n._animationStateChanged.pipe(En((r) => r.state === "opened"), On(1)).subscribe(() => {
        this._afterOpened.next(), this._afterOpened.complete();
      }), n._animationStateChanged.pipe(En((r) => r.state === "closed"), On(1)).subscribe(() => {
        clearTimeout(this._closeFallbackTimeout), this._finishDialogClose();
      }), t.overlayRef.detachments().subscribe(() => {
        this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._finishDialogClose();
      }), Jn(this.backdropClick(), this.keydownEvents().pipe(En((r) => r.keyCode === 27 && !this.disableClose && !Ki(r)))).subscribe((r) => {
        this.disableClose || (r.preventDefault(), NH(this, r.type === "keydown" ? "keyboard" : "mouse"));
      });
    }
    close(t) {
      this._result = t, this._containerInstance._animationStateChanged.pipe(En((e) => e.state === "closing"), On(1)).subscribe((e) => {
        this._beforeClosed.next(t), this._beforeClosed.complete(), this._ref.overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100);
      }), this._state = Rw.CLOSING, this._containerInstance._startExitAnimation();
    }
    afterOpened() {
      return this._afterOpened;
    }
    afterClosed() {
      return this._ref.closed;
    }
    beforeClosed() {
      return this._beforeClosed;
    }
    backdropClick() {
      return this._ref.backdropClick;
    }
    keydownEvents() {
      return this._ref.keydownEvents;
    }
    updatePosition(t) {
      let e = this._ref.config.positionStrategy;
      return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._ref.updatePosition(), this;
    }
    updateSize(t = "", e = "") {
      return this._ref.updateSize(t, e), this;
    }
    addPanelClass(t) {
      return this._ref.addPanelClass(t), this;
    }
    removePanelClass(t) {
      return this._ref.removePanelClass(t), this;
    }
    getState() {
      return this._state;
    }
    _finishDialogClose() {
      this._state = Rw.CLOSED, this._ref.close(this._result, { focusOrigin: this._closeInteractionType }), this.componentInstance = null;
    }
  };
  function NH(i59, t, e) {
    return i59._closeInteractionType = t, i59.close(e);
  }
  var Lfe = new Ee("MatMdcDialogData");
  var Ffe = new Ee("mat-mdc-dialog-default-options");
  var Bfe = new Ee("mat-mdc-dialog-scroll-strategy", { providedIn: "root", factory: () => {
    let i59 = M(fn);
    return () => i59.scrollStrategies.block();
  } });
  var Yg = (() => {
    class i59 {
      _overlay = M(fn);
      _defaultOptions = M(Ffe, { optional: true });
      _scrollStrategy = M(Bfe);
      _parentDialog = M(i59, { optional: true, skipSelf: true });
      _idGenerator = M(kn);
      _dialog = M(ZD);
      _openDialogsAtThisLevel = [];
      _afterAllClosedAtThisLevel = new we();
      _afterOpenedAtThisLevel = new we();
      dialogConfigClass = Ow;
      _dialogRefConstructor;
      _dialogContainerType;
      _dialogDataToken;
      get openDialogs() {
        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;
      }
      get afterOpened() {
        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;
      }
      _getAfterAllClosed() {
        let e = this._parentDialog;
        return e ? e._getAfterAllClosed() : this._afterAllClosedAtThisLevel;
      }
      afterAllClosed = nc(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(ei(void 0)));
      constructor() {
        this._dialogRefConstructor = qg, this._dialogContainerType = kfe, this._dialogDataToken = Lfe;
      }
      open(e, n) {
        let r;
        n = le(le({}, this._defaultOptions || new Ow()), n), n.id = n.id || this._idGenerator.getId("mat-mdc-dialog-"), n.scrollStrategy = n.scrollStrategy || this._scrollStrategy();
        let o = this._dialog.open(e, xt(le({}, n), { positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(), disableClose: true, closeOnDestroy: false, closeOnOverlayDetachments: false, container: { type: this._dialogContainerType, providers: () => [{ provide: this.dialogConfigClass, useValue: n }, { provide: Hl, useValue: n }] }, templateContext: () => ({ dialogRef: r }), providers: (s, a, l) => (r = new this._dialogRefConstructor(s, n, l), r.updatePosition(n?.position), [{ provide: this._dialogContainerType, useValue: l }, { provide: this._dialogDataToken, useValue: a.data }, { provide: this._dialogRefConstructor, useValue: r }]) }));
        return r.componentRef = o.componentRef, r.componentInstance = o.componentInstance, this.openDialogs.push(r), this.afterOpened.next(r), r.afterClosed().subscribe(() => {
          let s = this.openDialogs.indexOf(r);
          s > -1 && (this.openDialogs.splice(s, 1), this.openDialogs.length || this._getAfterAllClosed().next());
        }), r;
      }
      closeAll() {
        this._closeDialogs(this.openDialogs);
      }
      getDialogById(e) {
        return this.openDialogs.find((n) => n.id === e);
      }
      ngOnDestroy() {
        this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete();
      }
      _closeDialogs(e) {
        let n = e.length;
        for (; n--; ) e[n].close();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var kH = (() => {
    class i59 {
      dialogRef = M(qg, { optional: true });
      _elementRef = M(He);
      _dialog = M(Yg);
      ariaLabel;
      type = "button";
      dialogResult;
      _matDialogClose;
      constructor() {
      }
      ngOnInit() {
        this.dialogRef || (this.dialogRef = zH(this._elementRef, this._dialog.openDialogs));
      }
      ngOnChanges(e) {
        let n = e._matDialogClose || e._matDialogCloseResult;
        n && (this.dialogResult = n.currentValue);
      }
      _onButtonClick(e) {
        NH(this.dialogRef, e.screenX === 0 && e.screenY === 0 ? "keyboard" : "mouse", this.dialogResult);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function(n, r) {
        n & 1 && Z("click", function(s) {
          return r._onButtonClick(s);
        }), n & 2 && Ke("aria-label", r.ariaLabel || null)("type", r.type);
      }, inputs: { ariaLabel: [0, "aria-label", "ariaLabel"], type: "type", dialogResult: [0, "mat-dialog-close", "dialogResult"], _matDialogClose: [0, "matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [yn] });
    }
    return i59;
  })();
  var LH = (() => {
    class i59 {
      _dialogRef = M(qg, { optional: true });
      _elementRef = M(He);
      _dialog = M(Yg);
      constructor() {
      }
      ngOnInit() {
        this._dialogRef || (this._dialogRef = zH(this._elementRef, this._dialog.openDialogs)), this._dialogRef && Promise.resolve().then(() => {
          this._onAdd();
        });
      }
      ngOnDestroy() {
        this._dialogRef?._containerInstance && Promise.resolve().then(() => {
          this._onRemove();
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59 });
    }
    return i59;
  })();
  var FH = (() => {
    class i59 extends LH {
      id = M(kn).getId("mat-mdc-dialog-title-");
      _onAdd() {
        this._dialogRef._containerInstance?._addAriaLabelledBy?.(this.id);
      }
      _onRemove() {
        this._dialogRef?._containerInstance?._removeAriaLabelledBy?.(this.id);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]], hostAttrs: [1, "mat-mdc-dialog-title", "mdc-dialog__title"], hostVars: 1, hostBindings: function(n, r) {
        n & 2 && gr("id", r.id);
      }, inputs: { id: "id" }, exportAs: ["matDialogTitle"], features: [Zt] });
    }
    return i59;
  })();
  var BH = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-mdc-dialog-content", "mdc-dialog__content"], features: [xN([pD])] });
    }
    return i59;
  })();
  var VH = (() => {
    class i59 extends LH {
      align;
      _onAdd() {
        this._dialogRef._containerInstance?._updateActionSectionCount?.(1);
      }
      _onRemove() {
        this._dialogRef._containerInstance?._updateActionSectionCount?.(-1);
      }
      static \u0275fac = /* @__PURE__ */ (() => {
        let e;
        return function(r) {
          return (e || (e = ri(i59)))(r || i59);
        };
      })();
      static \u0275dir = qe({ type: i59, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-mdc-dialog-actions", "mdc-dialog__actions"], hostVars: 6, hostBindings: function(n, r) {
        n & 2 && ye("mat-mdc-dialog-actions-align-start", r.align === "start")("mat-mdc-dialog-actions-align-center", r.align === "center")("mat-mdc-dialog-actions-align-end", r.align === "end");
      }, inputs: { align: "align" }, features: [Zt] });
    }
    return i59;
  })();
  function zH(i59, t) {
    let e = i59.nativeElement.parentElement;
    for (; e && !e.classList.contains("mat-mdc-dialog-container"); ) e = e.parentElement;
    return e ? t.find((n) => n.id === e.id) : null;
  }
  var Aw = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [Yg], imports: [DH, ps, Ws, Yt, Yt] });
    }
    return i59;
  })();
  function i410(i59) {
    let t = i59.cloneNode(true), e = t.querySelectorAll("[id]"), n = i59.nodeName.toLowerCase();
    t.removeAttribute("id");
    for (let r = 0; r < e.length; r++) e[r].removeAttribute("id");
    return n === "canvas" ? jH(i59, t) : (n === "input" || n === "select" || n === "textarea") && HH(i59, t), GH("canvas", i59, t, jH), GH("input, textarea, select", i59, t, HH), t;
  }
  function GH(i59, t, e, n) {
    let r = t.querySelectorAll(i59);
    if (r.length) {
      let o = e.querySelectorAll(i59);
      for (let s = 0; s < r.length; s++) n(r[s], o[s]);
    }
  }
  var Vfe = 0;
  function HH(i59, t) {
    t.type !== "file" && (t.value = i59.value), t.type === "radio" && t.name && (t.name = `mat-clone-${t.name}-${Vfe++}`);
  }
  function jH(i59, t) {
    let e = t.getContext("2d");
    if (e) try {
      e.drawImage(i59, 0, 0);
    } catch {
    }
  }
  function oP(i59) {
    let t = i59.getBoundingClientRect();
    return { top: t.top, right: t.right, bottom: t.bottom, left: t.left, width: t.width, height: t.height, x: t.x, y: t.y };
  }
  function JD(i59, t, e) {
    let { top: n, bottom: r, left: o, right: s } = i59;
    return e >= n && e <= r && t >= o && t <= s;
  }
  function Zg(i59, t, e) {
    i59.top += t, i59.bottom = i59.top + i59.height, i59.left += e, i59.right = i59.left + i59.width;
  }
  function WH(i59, t, e, n) {
    let { top: r, right: o, bottom: s, left: a, width: l, height: c } = i59, d = l * t, u = c * t;
    return n > r - u && n < s + u && e > a - d && e < o + d;
  }
  var Lw = class {
    _document;
    positions = /* @__PURE__ */ new Map();
    constructor(t) {
      this._document = t;
    }
    clear() {
      this.positions.clear();
    }
    cache(t) {
      this.clear(), this.positions.set(this._document, { scrollPosition: this.getViewportScrollPosition() }), t.forEach((e) => {
        this.positions.set(e, { scrollPosition: { top: e.scrollTop, left: e.scrollLeft }, clientRect: oP(e) });
      });
    }
    handleScroll(t) {
      let e = Fi(t), n = this.positions.get(e);
      if (!n) return null;
      let r = n.scrollPosition, o, s;
      if (e === this._document) {
        let c = this.getViewportScrollPosition();
        o = c.top, s = c.left;
      } else o = e.scrollTop, s = e.scrollLeft;
      let a = r.top - o, l = r.left - s;
      return this.positions.forEach((c, d) => {
        c.clientRect && e !== d && e.contains(d) && Zg(c.clientRect, a, l);
      }), r.top = o, r.left = s, { top: a, left: l };
    }
    getViewportScrollPosition() {
      return { top: window.scrollY, left: window.scrollX };
    }
  };
  function r4(i59, t) {
    let e = i59.rootNodes;
    if (e.length === 1 && e[0].nodeType === t.ELEMENT_NODE) return e[0];
    let n = t.createElement("div");
    return e.forEach((r) => n.appendChild(r)), n;
  }
  function sP(i59, t, e) {
    for (let n in t) if (t.hasOwnProperty(n)) {
      let r = t[n];
      r ? i59.setProperty(n, r, e?.has(n) ? "important" : "") : i59.removeProperty(n);
    }
    return i59;
  }
  function yp(i59, t) {
    let e = t ? "" : "none";
    sP(i59.style, { "touch-action": t ? "" : "none", "-webkit-user-drag": t ? "" : "none", "-webkit-tap-highlight-color": t ? "" : "transparent", "user-select": e, "-ms-user-select": e, "-webkit-user-select": e, "-moz-user-select": e });
  }
  function $H(i59, t, e) {
    sP(i59.style, { position: t ? "" : "fixed", top: t ? "" : "0", opacity: t ? "" : "0", left: t ? "" : "-999em" }, e);
  }
  function Fw(i59, t) {
    return t && t != "none" ? i59 + " " + t : i59;
  }
  function qH(i59, t) {
    i59.style.width = `${t.width}px`, i59.style.height = `${t.height}px`, i59.style.transform = Bw(t.left, t.top);
  }
  function Bw(i59, t) {
    return `translate3d(${Math.round(i59)}px, ${Math.round(t)}px, 0)`;
  }
  function YH(i59) {
    let t = i59.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
    return parseFloat(i59) * t;
  }
  function zfe(i59) {
    let t = getComputedStyle(i59), e = KD(t, "transition-property"), n = e.find((a) => a === "transform" || a === "all");
    if (!n) return 0;
    let r = e.indexOf(n), o = KD(t, "transition-duration"), s = KD(t, "transition-delay");
    return YH(o[r]) + YH(s[r]);
  }
  function KD(i59, t) {
    return i59.getPropertyValue(t).split(",").map((n) => n.trim());
  }
  var Ufe = /* @__PURE__ */ new Set(["position"]);
  var eP = class {
    _document;
    _rootElement;
    _direction;
    _initialDomRect;
    _previewTemplate;
    _previewClass;
    _pickupPositionOnPage;
    _initialTransform;
    _zIndex;
    _renderer;
    _previewEmbeddedView;
    _preview;
    get element() {
      return this._preview;
    }
    constructor(t, e, n, r, o, s, a, l, c, d) {
      this._document = t, this._rootElement = e, this._direction = n, this._initialDomRect = r, this._previewTemplate = o, this._previewClass = s, this._pickupPositionOnPage = a, this._initialTransform = l, this._zIndex = c, this._renderer = d;
    }
    attach(t) {
      this._preview = this._createPreview(), t.appendChild(this._preview), XH(this._preview) && this._preview.showPopover();
    }
    destroy() {
      this._preview.remove(), this._previewEmbeddedView?.destroy(), this._preview = this._previewEmbeddedView = null;
    }
    setTransform(t) {
      this._preview.style.transform = t;
    }
    getBoundingClientRect() {
      return this._preview.getBoundingClientRect();
    }
    addClass(t) {
      this._preview.classList.add(t);
    }
    getTransitionDuration() {
      return zfe(this._preview);
    }
    addEventListener(t, e) {
      return this._renderer.listen(this._preview, t, e);
    }
    _createPreview() {
      let t = this._previewTemplate, e = this._previewClass, n = t ? t.template : null, r;
      if (n && t) {
        let o = t.matchSize ? this._initialDomRect : null, s = t.viewContainer.createEmbeddedView(n, t.context);
        s.detectChanges(), r = r4(s, this._document), this._previewEmbeddedView = s, t.matchSize ? qH(r, o) : r.style.transform = Bw(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      } else r = i410(this._rootElement), qH(r, this._initialDomRect), this._initialTransform && (r.style.transform = this._initialTransform);
      return sP(r.style, { "pointer-events": "none", margin: XH(r) ? "0 auto 0 0" : "0", position: "fixed", top: "0", left: "0", "z-index": this._zIndex + "" }, Ufe), yp(r, false), r.classList.add("cdk-drag-preview"), r.setAttribute("popover", "manual"), r.setAttribute("dir", this._direction), e && (Array.isArray(e) ? e.forEach((o) => r.classList.add(o)) : r.classList.add(e)), r;
    }
  };
  function XH(i59) {
    return "showPopover" in i59;
  }
  var ZH = Or({ passive: true });
  var Nw = Or({ passive: false });
  var QH = Or({ passive: false, capture: true });
  var Gfe = 800;
  var KH = /* @__PURE__ */ new Set(["position"]);
  var tP = class {
    _config;
    _document;
    _ngZone;
    _viewportRuler;
    _dragDropRegistry;
    _renderer;
    _preview;
    _previewContainer;
    _placeholderRef;
    _placeholder;
    _pickupPositionInElement;
    _pickupPositionOnPage;
    _anchor;
    _passiveTransform = { x: 0, y: 0 };
    _activeTransform = { x: 0, y: 0 };
    _initialTransform;
    _hasStartedDragging = gt(false);
    _hasMoved;
    _initialContainer;
    _initialIndex;
    _parentPositions;
    _moveEvents = new we();
    _pointerDirectionDelta;
    _pointerPositionAtLastDirectionChange;
    _lastKnownPointerPosition;
    _rootElement;
    _ownerSVGElement;
    _rootElementTapHighlight;
    _pointerMoveSubscription = Rt.EMPTY;
    _pointerUpSubscription = Rt.EMPTY;
    _scrollSubscription = Rt.EMPTY;
    _resizeSubscription = Rt.EMPTY;
    _lastTouchEventTime;
    _dragStartTime;
    _boundaryElement = null;
    _nativeInteractionsEnabled = true;
    _initialDomRect;
    _previewRect;
    _boundaryRect;
    _previewTemplate;
    _placeholderTemplate;
    _handles = [];
    _disabledHandles = /* @__PURE__ */ new Set();
    _dropContainer;
    _direction = "ltr";
    _parentDragRef;
    _cachedShadowRoot;
    lockAxis;
    dragStartDelay = 0;
    previewClass;
    scale = 1;
    get disabled() {
      return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
    }
    set disabled(t) {
      t !== this._disabled && (this._disabled = t, this._toggleNativeDragInteractions(), this._handles.forEach((e) => yp(e, t)));
    }
    _disabled = false;
    beforeStarted = new we();
    started = new we();
    released = new we();
    ended = new we();
    entered = new we();
    exited = new we();
    dropped = new we();
    moved = this._moveEvents;
    data;
    constrainPosition;
    constructor(t, e, n, r, o, s, a) {
      this._config = e, this._document = n, this._ngZone = r, this._viewportRuler = o, this._dragDropRegistry = s, this._renderer = a, this.withRootElement(t).withParent(e.parentDragRef || null), this._parentPositions = new Lw(n), s.registerDragItem(this);
    }
    getPlaceholderElement() {
      return this._placeholder;
    }
    getRootElement() {
      return this._rootElement;
    }
    getVisibleElement() {
      return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
    }
    withHandles(t) {
      this._handles = t.map((n) => Ji(n)), this._handles.forEach((n) => yp(n, this.disabled)), this._toggleNativeDragInteractions();
      let e = /* @__PURE__ */ new Set();
      return this._disabledHandles.forEach((n) => {
        this._handles.indexOf(n) > -1 && e.add(n);
      }), this._disabledHandles = e, this;
    }
    withPreviewTemplate(t) {
      return this._previewTemplate = t, this;
    }
    withPlaceholderTemplate(t) {
      return this._placeholderTemplate = t, this;
    }
    withRootElement(t) {
      let e = Ji(t);
      return e !== this._rootElement && (this._rootElement && this._removeRootElementListeners(this._rootElement), this._ngZone.runOutsideAngular(() => {
        e.addEventListener("mousedown", this._pointerDown, Nw), e.addEventListener("touchstart", this._pointerDown, ZH), e.addEventListener("dragstart", this._nativeDragStart, Nw);
      }), this._initialTransform = void 0, this._rootElement = e), typeof SVGElement < "u" && this._rootElement instanceof SVGElement && (this._ownerSVGElement = this._rootElement.ownerSVGElement), this;
    }
    withBoundaryElement(t) {
      return this._boundaryElement = t ? Ji(t) : null, this._resizeSubscription.unsubscribe(), t && (this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize())), this;
    }
    withParent(t) {
      return this._parentDragRef = t, this;
    }
    dispose() {
      this._removeRootElementListeners(this._rootElement), this.isDragging() && this._rootElement?.remove(), this._anchor?.remove(), this._destroyPreview(), this._destroyPlaceholder(), this._dragDropRegistry.removeDragItem(this), this._removeListeners(), this.beforeStarted.complete(), this.started.complete(), this.released.complete(), this.ended.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this._moveEvents.complete(), this._handles = [], this._disabledHandles.clear(), this._dropContainer = void 0, this._resizeSubscription.unsubscribe(), this._parentPositions.clear(), this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
    }
    isDragging() {
      return this._hasStartedDragging() && this._dragDropRegistry.isDragging(this);
    }
    reset() {
      this._rootElement.style.transform = this._initialTransform || "", this._activeTransform = { x: 0, y: 0 }, this._passiveTransform = { x: 0, y: 0 };
    }
    disableHandle(t) {
      !this._disabledHandles.has(t) && this._handles.indexOf(t) > -1 && (this._disabledHandles.add(t), yp(t, true));
    }
    enableHandle(t) {
      this._disabledHandles.has(t) && (this._disabledHandles.delete(t), yp(t, this.disabled));
    }
    withDirection(t) {
      return this._direction = t, this;
    }
    _withDropContainer(t) {
      this._dropContainer = t;
    }
    getFreeDragPosition() {
      let t = this.isDragging() ? this._activeTransform : this._passiveTransform;
      return { x: t.x, y: t.y };
    }
    setFreeDragPosition(t) {
      return this._activeTransform = { x: 0, y: 0 }, this._passiveTransform.x = t.x, this._passiveTransform.y = t.y, this._dropContainer || this._applyRootElementTransform(t.x, t.y), this;
    }
    withPreviewContainer(t) {
      return this._previewContainer = t, this;
    }
    _sortFromLastPointerPosition() {
      let t = this._lastKnownPointerPosition;
      t && this._dropContainer && this._updateActiveDropContainer(this._getConstrainedPointerPosition(t), t);
    }
    _removeListeners() {
      this._pointerMoveSubscription.unsubscribe(), this._pointerUpSubscription.unsubscribe(), this._scrollSubscription.unsubscribe(), this._getShadowRoot()?.removeEventListener("selectstart", e4, QH);
    }
    _destroyPreview() {
      this._preview?.destroy(), this._preview = null;
    }
    _destroyPlaceholder() {
      this._placeholder?.remove(), this._placeholderRef?.destroy(), this._placeholder = this._placeholderRef = null;
    }
    _pointerDown = (t) => {
      if (this.beforeStarted.next(), this._handles.length) {
        let e = this._getTargetHandle(t);
        e && !this._disabledHandles.has(e) && !this.disabled && this._initializeDragSequence(e, t);
      } else this.disabled || this._initializeDragSequence(this._rootElement, t);
    };
    _pointerMove = (t) => {
      let e = this._getPointerPositionOnPage(t);
      if (!this._hasStartedDragging()) {
        let r = Math.abs(e.x - this._pickupPositionOnPage.x), o = Math.abs(e.y - this._pickupPositionOnPage.y);
        if (r + o >= this._config.dragStartThreshold) {
          let a = Date.now() >= this._dragStartTime + this._getDragStartDelay(t), l = this._dropContainer;
          if (!a) {
            this._endDragSequence(t);
            return;
          }
          (!l || !l.isDragging() && !l.isReceiving()) && (t.cancelable && t.preventDefault(), this._hasStartedDragging.set(true), this._ngZone.run(() => this._startDragSequence(t)));
        }
        return;
      }
      t.cancelable && t.preventDefault();
      let n = this._getConstrainedPointerPosition(e);
      if (this._hasMoved = true, this._lastKnownPointerPosition = e, this._updatePointerDirectionDelta(n), this._dropContainer) this._updateActiveDropContainer(n, e);
      else {
        let r = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage, o = this._activeTransform;
        o.x = n.x - r.x + this._passiveTransform.x, o.y = n.y - r.y + this._passiveTransform.y, this._applyRootElementTransform(o.x, o.y);
      }
      this._moveEvents.observers.length && this._ngZone.run(() => {
        this._moveEvents.next({ source: this, pointerPosition: n, event: t, distance: this._getDragDistance(n), delta: this._pointerDirectionDelta });
      });
    };
    _pointerUp = (t) => {
      this._endDragSequence(t);
    };
    _endDragSequence(t) {
      if (this._dragDropRegistry.isDragging(this) && (this._removeListeners(), this._dragDropRegistry.stopDragging(this), this._toggleNativeDragInteractions(), this._handles && (this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight), !!this._hasStartedDragging())) if (this.released.next({ source: this, event: t }), this._dropContainer) this._dropContainer._stopScrolling(), this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(t), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this);
      });
      else {
        this._passiveTransform.x = this._activeTransform.x;
        let e = this._getPointerPositionOnPage(t);
        this._passiveTransform.y = this._activeTransform.y, this._ngZone.run(() => {
          this.ended.next({ source: this, distance: this._getDragDistance(e), dropPoint: e, event: t });
        }), this._cleanupCachedDimensions(), this._dragDropRegistry.stopDragging(this);
      }
    }
    _startDragSequence(t) {
      Xg(t) && (this._lastTouchEventTime = Date.now()), this._toggleNativeDragInteractions();
      let e = this._getShadowRoot(), n = this._dropContainer;
      if (e && this._ngZone.runOutsideAngular(() => {
        e.addEventListener("selectstart", e4, QH);
      }), n) {
        let r = this._rootElement, o = r.parentNode, s = this._placeholder = this._createPlaceholderElement(), a = this._anchor = this._anchor || this._document.createComment("");
        o.insertBefore(a, r), this._initialTransform = r.style.transform || "", this._preview = new eP(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3, this._renderer), this._preview.attach(this._getPreviewInsertionPoint(o, e)), $H(r, false, KH), this._document.body.appendChild(o.replaceChild(s, r)), this.started.next({ source: this, event: t }), n.start(), this._initialContainer = n, this._initialIndex = n.getItemIndex(this);
      } else this.started.next({ source: this, event: t }), this._initialContainer = this._initialIndex = void 0;
      this._parentPositions.cache(n ? n.getScrollableParents() : []);
    }
    _initializeDragSequence(t, e) {
      this._parentDragRef && e.stopPropagation();
      let n = this.isDragging(), r = Xg(e), o = !r && e.button !== 0, s = this._rootElement, a = Fi(e), l = !r && this._lastTouchEventTime && this._lastTouchEventTime + Gfe > Date.now(), c = r ? Hc(e) : Gc(e);
      if (a && a.draggable && e.type === "mousedown" && e.preventDefault(), n || o || l || c) return;
      if (this._handles.length) {
        let h = s.style;
        this._rootElementTapHighlight = h.webkitTapHighlightColor || "", h.webkitTapHighlightColor = "transparent";
      }
      this._hasMoved = false, this._hasStartedDragging.set(this._hasMoved), this._removeListeners(), this._initialDomRect = this._rootElement.getBoundingClientRect(), this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove), this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp), this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((h) => this._updateOnScroll(h)), this._boundaryElement && (this._boundaryRect = oP(this._boundaryElement));
      let d = this._previewTemplate;
      this._pickupPositionInElement = d && d.template && !d.matchSize ? { x: 0, y: 0 } : this._getPointerPositionInElement(this._initialDomRect, t, e);
      let u = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(e);
      this._pointerDirectionDelta = { x: 0, y: 0 }, this._pointerPositionAtLastDirectionChange = { x: u.x, y: u.y }, this._dragStartTime = Date.now(), this._dragDropRegistry.startDragging(this, e);
    }
    _cleanupDragArtifacts(t) {
      $H(this._rootElement, true, KH), this._anchor.parentNode.replaceChild(this._rootElement, this._anchor), this._destroyPreview(), this._destroyPlaceholder(), this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0, this._ngZone.run(() => {
        let e = this._dropContainer, n = e.getItemIndex(this), r = this._getPointerPositionOnPage(t), o = this._getDragDistance(r), s = e._isOverContainer(r.x, r.y);
        this.ended.next({ source: this, distance: o, dropPoint: r, event: t }), this.dropped.next({ item: this, currentIndex: n, previousIndex: this._initialIndex, container: e, previousContainer: this._initialContainer, isPointerOverContainer: s, distance: o, dropPoint: r, event: t }), e.drop(this, n, this._initialIndex, this._initialContainer, s, o, r, t), this._dropContainer = this._initialContainer;
      });
    }
    _updateActiveDropContainer({ x: t, y: e }, { x: n, y: r }) {
      let o = this._initialContainer._getSiblingContainerFromPosition(this, t, e);
      !o && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(t, e) && (o = this._initialContainer), o && o !== this._dropContainer && this._ngZone.run(() => {
        this.exited.next({ item: this, container: this._dropContainer }), this._dropContainer.exit(this), this._dropContainer = o, this._dropContainer.enter(this, t, e, o === this._initialContainer && o.sortingDisabled ? this._initialIndex : void 0), this.entered.next({ item: this, container: o, currentIndex: o.getItemIndex(this) });
      }), this.isDragging() && (this._dropContainer._startScrollingIfNecessary(n, r), this._dropContainer._sortItem(this, t, e, this._pointerDirectionDelta), this.constrainPosition ? this._applyPreviewTransform(t, e) : this._applyPreviewTransform(t - this._pickupPositionInElement.x, e - this._pickupPositionInElement.y));
    }
    _animatePreviewToPlaceholder() {
      if (!this._hasMoved) return Promise.resolve();
      let t = this._placeholder.getBoundingClientRect();
      this._preview.addClass("cdk-drag-animating"), this._applyPreviewTransform(t.left, t.top);
      let e = this._preview.getTransitionDuration();
      return e === 0 ? Promise.resolve() : this._ngZone.runOutsideAngular(() => new Promise((n) => {
        let r = (a) => {
          (!a || this._preview && Fi(a) === this._preview.element && a.propertyName === "transform") && (s(), n(), clearTimeout(o));
        }, o = setTimeout(r, e * 1.5), s = this._preview.addEventListener("transitionend", r);
      }));
    }
    _createPlaceholderElement() {
      let t = this._placeholderTemplate, e = t ? t.template : null, n;
      return e ? (this._placeholderRef = t.viewContainer.createEmbeddedView(e, t.context), this._placeholderRef.detectChanges(), n = r4(this._placeholderRef, this._document)) : n = i410(this._rootElement), n.style.pointerEvents = "none", n.classList.add("cdk-drag-placeholder"), n;
    }
    _getPointerPositionInElement(t, e, n) {
      let r = e === this._rootElement ? null : e, o = r ? r.getBoundingClientRect() : t, s = Xg(n) ? n.targetTouches[0] : n, a = this._getViewportScrollPosition(), l = s.pageX - o.left - a.left, c = s.pageY - o.top - a.top;
      return { x: o.left - t.left + l, y: o.top - t.top + c };
    }
    _getPointerPositionOnPage(t) {
      let e = this._getViewportScrollPosition(), n = Xg(t) ? t.touches[0] || t.changedTouches[0] || { pageX: 0, pageY: 0 } : t, r = n.pageX - e.left, o = n.pageY - e.top;
      if (this._ownerSVGElement) {
        let s = this._ownerSVGElement.getScreenCTM();
        if (s) {
          let a = this._ownerSVGElement.createSVGPoint();
          return a.x = r, a.y = o, a.matrixTransform(s.inverse());
        }
      }
      return { x: r, y: o };
    }
    _getConstrainedPointerPosition(t) {
      let e = this._dropContainer ? this._dropContainer.lockAxis : null, { x: n, y: r } = this.constrainPosition ? this.constrainPosition(t, this, this._initialDomRect, this._pickupPositionInElement) : t;
      if (this.lockAxis === "x" || e === "x" ? r = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0) : (this.lockAxis === "y" || e === "y") && (n = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0)), this._boundaryRect) {
        let { x: o, y: s } = this.constrainPosition ? { x: 0, y: 0 } : this._pickupPositionInElement, a = this._boundaryRect, { width: l, height: c } = this._getPreviewRect(), d = a.top + s, u = a.bottom - (c - s), h = a.left + o, p = a.right - (l - o);
        n = JH(n, h, p), r = JH(r, d, u);
      }
      return { x: n, y: r };
    }
    _updatePointerDirectionDelta(t) {
      let { x: e, y: n } = t, r = this._pointerDirectionDelta, o = this._pointerPositionAtLastDirectionChange, s = Math.abs(e - o.x), a = Math.abs(n - o.y);
      return s > this._config.pointerDirectionChangeThreshold && (r.x = e > o.x ? 1 : -1, o.x = e), a > this._config.pointerDirectionChangeThreshold && (r.y = n > o.y ? 1 : -1, o.y = n), r;
    }
    _toggleNativeDragInteractions() {
      if (!this._rootElement || !this._handles) return;
      let t = this._handles.length > 0 || !this.isDragging();
      t !== this._nativeInteractionsEnabled && (this._nativeInteractionsEnabled = t, yp(this._rootElement, t));
    }
    _removeRootElementListeners(t) {
      t.removeEventListener("mousedown", this._pointerDown, Nw), t.removeEventListener("touchstart", this._pointerDown, ZH), t.removeEventListener("dragstart", this._nativeDragStart, Nw);
    }
    _applyRootElementTransform(t, e) {
      let n = 1 / this.scale, r = Bw(t * n, e * n), o = this._rootElement.style;
      this._initialTransform == null && (this._initialTransform = o.transform && o.transform != "none" ? o.transform : ""), o.transform = Fw(r, this._initialTransform);
    }
    _applyPreviewTransform(t, e) {
      let n = this._previewTemplate?.template ? void 0 : this._initialTransform, r = Bw(t, e);
      this._preview.setTransform(Fw(r, n));
    }
    _getDragDistance(t) {
      let e = this._pickupPositionOnPage;
      return e ? { x: t.x - e.x, y: t.y - e.y } : { x: 0, y: 0 };
    }
    _cleanupCachedDimensions() {
      this._boundaryRect = this._previewRect = void 0, this._parentPositions.clear();
    }
    _containInsideBoundaryOnResize() {
      let { x: t, y: e } = this._passiveTransform;
      if (t === 0 && e === 0 || this.isDragging() || !this._boundaryElement) return;
      let n = this._rootElement.getBoundingClientRect(), r = this._boundaryElement.getBoundingClientRect();
      if (r.width === 0 && r.height === 0 || n.width === 0 && n.height === 0) return;
      let o = r.left - n.left, s = n.right - r.right, a = r.top - n.top, l = n.bottom - r.bottom;
      r.width > n.width ? (o > 0 && (t += o), s > 0 && (t -= s)) : t = 0, r.height > n.height ? (a > 0 && (e += a), l > 0 && (e -= l)) : e = 0, (t !== this._passiveTransform.x || e !== this._passiveTransform.y) && this.setFreeDragPosition({ y: e, x: t });
    }
    _getDragStartDelay(t) {
      let e = this.dragStartDelay;
      return typeof e == "number" ? e : Xg(t) ? e.touch : e ? e.mouse : 0;
    }
    _updateOnScroll(t) {
      let e = this._parentPositions.handleScroll(t);
      if (e) {
        let n = Fi(t);
        this._boundaryRect && n !== this._boundaryElement && n.contains(this._boundaryElement) && Zg(this._boundaryRect, e.top, e.left), this._pickupPositionOnPage.x += e.left, this._pickupPositionOnPage.y += e.top, this._dropContainer || (this._activeTransform.x -= e.left, this._activeTransform.y -= e.top, this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y));
      }
    }
    _getViewportScrollPosition() {
      return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
    }
    _getShadowRoot() {
      return this._cachedShadowRoot === void 0 && (this._cachedShadowRoot = zu(this._rootElement)), this._cachedShadowRoot;
    }
    _getPreviewInsertionPoint(t, e) {
      let n = this._previewContainer || "global";
      if (n === "parent") return t;
      if (n === "global") {
        let r = this._document;
        return e || r.fullscreenElement || r.webkitFullscreenElement || r.mozFullScreenElement || r.msFullscreenElement || r.body;
      }
      return Ji(n);
    }
    _getPreviewRect() {
      return (!this._previewRect || !this._previewRect.width && !this._previewRect.height) && (this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect), this._previewRect;
    }
    _nativeDragStart = (t) => {
      if (this._handles.length) {
        let e = this._getTargetHandle(t);
        e && !this._disabledHandles.has(e) && !this.disabled && t.preventDefault();
      } else this.disabled || t.preventDefault();
    };
    _getTargetHandle(t) {
      return this._handles.find((e) => t.target && (t.target === e || e.contains(t.target)));
    }
  };
  function JH(i59, t, e) {
    return Math.max(t, Math.min(e, i59));
  }
  function Xg(i59) {
    return i59.type[0] === "t";
  }
  function e4(i59) {
    i59.preventDefault();
  }
  function o4(i59, t, e) {
    let n = t4(t, i59.length - 1), r = t4(e, i59.length - 1);
    if (n === r) return;
    let o = i59[n], s = r < n ? -1 : 1;
    for (let a = n; a !== r; a += s) i59[a] = i59[a + s];
    i59[r] = o;
  }
  function t4(i59, t) {
    return Math.max(0, Math.min(t, i59));
  }
  var Vw = class {
    _dragDropRegistry;
    _element;
    _sortPredicate;
    _itemPositions = [];
    _activeDraggables;
    orientation = "vertical";
    direction;
    constructor(t) {
      this._dragDropRegistry = t;
    }
    _previousSwap = { drag: null, delta: 0, overlaps: false };
    start(t) {
      this.withItems(t);
    }
    sort(t, e, n, r) {
      let o = this._itemPositions, s = this._getItemIndexFromPointerPosition(t, e, n, r);
      if (s === -1 && o.length > 0) return null;
      let a = this.orientation === "horizontal", l = o.findIndex((v) => v.drag === t), c = o[s], d = o[l].clientRect, u = c.clientRect, h = l > s ? 1 : -1, p = this._getItemOffsetPx(d, u, h), f = this._getSiblingOffsetPx(l, o, h), m = o.slice();
      return o4(o, l, s), o.forEach((v, _) => {
        if (m[_] === v) return;
        let g = v.drag === t, y = g ? p : f, w = g ? t.getPlaceholderElement() : v.drag.getRootElement();
        v.offset += y;
        let E = Math.round(v.offset * (1 / v.drag.scale));
        a ? (w.style.transform = Fw(`translate3d(${E}px, 0, 0)`, v.initialTransform), Zg(v.clientRect, 0, y)) : (w.style.transform = Fw(`translate3d(0, ${E}px, 0)`, v.initialTransform), Zg(v.clientRect, y, 0));
      }), this._previousSwap.overlaps = JD(u, e, n), this._previousSwap.drag = c.drag, this._previousSwap.delta = a ? r.x : r.y, { previousIndex: l, currentIndex: s };
    }
    enter(t, e, n, r) {
      let o = r == null || r < 0 ? this._getItemIndexFromPointerPosition(t, e, n) : r, s = this._activeDraggables, a = s.indexOf(t), l = t.getPlaceholderElement(), c = s[o];
      if (c === t && (c = s[o + 1]), !c && (o == null || o === -1 || o < s.length - 1) && this._shouldEnterAsFirstChild(e, n) && (c = s[0]), a > -1 && s.splice(a, 1), c && !this._dragDropRegistry.isDragging(c)) {
        let d = c.getRootElement();
        d.parentElement.insertBefore(l, d), s.splice(o, 0, t);
      } else this._element.appendChild(l), s.push(t);
      l.style.transform = "", this._cacheItemPositions();
    }
    withItems(t) {
      this._activeDraggables = t.slice(), this._cacheItemPositions();
    }
    withSortPredicate(t) {
      this._sortPredicate = t;
    }
    reset() {
      this._activeDraggables?.forEach((t) => {
        let e = t.getRootElement();
        if (e) {
          let n = this._itemPositions.find((r) => r.drag === t)?.initialTransform;
          e.style.transform = n || "";
        }
      }), this._itemPositions = [], this._activeDraggables = [], this._previousSwap.drag = null, this._previousSwap.delta = 0, this._previousSwap.overlaps = false;
    }
    getActiveItemsSnapshot() {
      return this._activeDraggables;
    }
    getItemIndex(t) {
      return (this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions).findIndex((n) => n.drag === t);
    }
    updateOnScroll(t, e) {
      this._itemPositions.forEach(({ clientRect: n }) => {
        Zg(n, t, e);
      }), this._itemPositions.forEach(({ drag: n }) => {
        this._dragDropRegistry.isDragging(n) && n._sortFromLastPointerPosition();
      });
    }
    withElementContainer(t) {
      this._element = t;
    }
    _cacheItemPositions() {
      let t = this.orientation === "horizontal";
      this._itemPositions = this._activeDraggables.map((e) => {
        let n = e.getVisibleElement();
        return { drag: e, offset: 0, initialTransform: n.style.transform || "", clientRect: oP(n) };
      }).sort((e, n) => t ? e.clientRect.left - n.clientRect.left : e.clientRect.top - n.clientRect.top);
    }
    _getItemOffsetPx(t, e, n) {
      let r = this.orientation === "horizontal", o = r ? e.left - t.left : e.top - t.top;
      return n === -1 && (o += r ? e.width - t.width : e.height - t.height), o;
    }
    _getSiblingOffsetPx(t, e, n) {
      let r = this.orientation === "horizontal", o = e[t].clientRect, s = e[t + n * -1], a = o[r ? "width" : "height"] * n;
      if (s) {
        let l = r ? "left" : "top", c = r ? "right" : "bottom";
        n === -1 ? a -= s.clientRect[l] - o[c] : a += o[l] - s.clientRect[c];
      }
      return a;
    }
    _shouldEnterAsFirstChild(t, e) {
      if (!this._activeDraggables.length) return false;
      let n = this._itemPositions, r = this.orientation === "horizontal";
      if (n[0].drag !== this._activeDraggables[0]) {
        let s = n[n.length - 1].clientRect;
        return r ? t >= s.right : e >= s.bottom;
      } else {
        let s = n[0].clientRect;
        return r ? t <= s.left : e <= s.top;
      }
    }
    _getItemIndexFromPointerPosition(t, e, n, r) {
      let o = this.orientation === "horizontal", s = this._itemPositions.findIndex(({ drag: a, clientRect: l }) => {
        if (a === t) return false;
        if (r) {
          let c = o ? r.x : r.y;
          if (a === this._previousSwap.drag && this._previousSwap.overlaps && c === this._previousSwap.delta) return false;
        }
        return o ? e >= Math.floor(l.left) && e < Math.floor(l.right) : n >= Math.floor(l.top) && n < Math.floor(l.bottom);
      });
      return s === -1 || !this._sortPredicate(s, t) ? -1 : s;
    }
  };
  var nP = class {
    _document;
    _dragDropRegistry;
    _element;
    _sortPredicate;
    _rootNode;
    _activeItems;
    _previousSwap = { drag: null, deltaX: 0, deltaY: 0, overlaps: false };
    _relatedNodes = [];
    constructor(t, e) {
      this._document = t, this._dragDropRegistry = e;
    }
    start(t) {
      let e = this._element.childNodes;
      this._relatedNodes = [];
      for (let n = 0; n < e.length; n++) {
        let r = e[n];
        this._relatedNodes.push([r, r.nextSibling]);
      }
      this.withItems(t);
    }
    sort(t, e, n, r) {
      let o = this._getItemIndexFromPointerPosition(t, e, n), s = this._previousSwap;
      if (o === -1 || this._activeItems[o] === t) return null;
      let a = this._activeItems[o];
      if (s.drag === a && s.overlaps && s.deltaX === r.x && s.deltaY === r.y) return null;
      let l = this.getItemIndex(t), c = t.getPlaceholderElement(), d = a.getRootElement();
      o > l ? d.after(c) : d.before(c), o4(this._activeItems, l, o);
      let u = this._getRootNode().elementFromPoint(e, n);
      return s.deltaX = r.x, s.deltaY = r.y, s.drag = a, s.overlaps = d === u || d.contains(u), { previousIndex: l, currentIndex: o };
    }
    enter(t, e, n, r) {
      let o = r == null || r < 0 ? this._getItemIndexFromPointerPosition(t, e, n) : r;
      o === -1 && (o = this._getClosestItemIndexToPointer(t, e, n));
      let s = this._activeItems[o], a = this._activeItems.indexOf(t);
      a > -1 && this._activeItems.splice(a, 1), s && !this._dragDropRegistry.isDragging(s) ? (this._activeItems.splice(o, 0, t), s.getRootElement().before(t.getPlaceholderElement())) : (this._activeItems.push(t), this._element.appendChild(t.getPlaceholderElement()));
    }
    withItems(t) {
      this._activeItems = t.slice();
    }
    withSortPredicate(t) {
      this._sortPredicate = t;
    }
    reset() {
      let t = this._element, e = this._previousSwap;
      for (let n = this._relatedNodes.length - 1; n > -1; n--) {
        let [r, o] = this._relatedNodes[n];
        r.parentNode === t && r.nextSibling !== o && (o === null ? t.appendChild(r) : o.parentNode === t && t.insertBefore(r, o));
      }
      this._relatedNodes = [], this._activeItems = [], e.drag = null, e.deltaX = e.deltaY = 0, e.overlaps = false;
    }
    getActiveItemsSnapshot() {
      return this._activeItems;
    }
    getItemIndex(t) {
      return this._activeItems.indexOf(t);
    }
    updateOnScroll() {
      this._activeItems.forEach((t) => {
        this._dragDropRegistry.isDragging(t) && t._sortFromLastPointerPosition();
      });
    }
    withElementContainer(t) {
      t !== this._element && (this._element = t, this._rootNode = void 0);
    }
    _getItemIndexFromPointerPosition(t, e, n) {
      let r = this._getRootNode().elementFromPoint(Math.floor(e), Math.floor(n)), o = r ? this._activeItems.findIndex((s) => {
        let a = s.getRootElement();
        return r === a || a.contains(r);
      }) : -1;
      return o === -1 || !this._sortPredicate(o, t) ? -1 : o;
    }
    _getRootNode() {
      return this._rootNode || (this._rootNode = zu(this._element) || this._document), this._rootNode;
    }
    _getClosestItemIndexToPointer(t, e, n) {
      if (this._activeItems.length === 0) return -1;
      if (this._activeItems.length === 1) return 0;
      let r = 1 / 0, o = -1;
      for (let s = 0; s < this._activeItems.length; s++) {
        let a = this._activeItems[s];
        if (a !== t) {
          let { x: l, y: c } = a.getRootElement().getBoundingClientRect(), d = Math.hypot(e - l, n - c);
          d < r && (r = d, o = s);
        }
      }
      return o;
    }
  };
  var n4 = 0.05;
  var s4 = 0.05;
  var Uo = function(i59) {
    return i59[i59.NONE = 0] = "NONE", i59[i59.UP = 1] = "UP", i59[i59.DOWN = 2] = "DOWN", i59;
  }(Uo || {});
  var Vr = function(i59) {
    return i59[i59.NONE = 0] = "NONE", i59[i59.LEFT = 1] = "LEFT", i59[i59.RIGHT = 2] = "RIGHT", i59;
  }(Vr || {});
  var iP = class {
    _dragDropRegistry;
    _ngZone;
    _viewportRuler;
    element;
    disabled = false;
    sortingDisabled = false;
    lockAxis;
    autoScrollDisabled = false;
    autoScrollStep = 2;
    enterPredicate = () => true;
    sortPredicate = () => true;
    beforeStarted = new we();
    entered = new we();
    exited = new we();
    dropped = new we();
    sorted = new we();
    receivingStarted = new we();
    receivingStopped = new we();
    data;
    _container;
    _isDragging = false;
    _parentPositions;
    _sortStrategy;
    _domRect;
    _draggables = [];
    _siblings = [];
    _activeSiblings = /* @__PURE__ */ new Set();
    _viewportScrollSubscription = Rt.EMPTY;
    _verticalScrollDirection = Uo.NONE;
    _horizontalScrollDirection = Vr.NONE;
    _scrollNode;
    _stopScrollTimers = new we();
    _cachedShadowRoot = null;
    _document;
    _scrollableElements = [];
    _initialScrollSnap;
    _direction = "ltr";
    constructor(t, e, n, r, o) {
      this._dragDropRegistry = e, this._ngZone = r, this._viewportRuler = o;
      let s = this.element = Ji(t);
      this._document = n, this.withOrientation("vertical").withElementContainer(s), e.registerDropContainer(this), this._parentPositions = new Lw(n);
    }
    dispose() {
      this._stopScrolling(), this._stopScrollTimers.complete(), this._viewportScrollSubscription.unsubscribe(), this.beforeStarted.complete(), this.entered.complete(), this.exited.complete(), this.dropped.complete(), this.sorted.complete(), this.receivingStarted.complete(), this.receivingStopped.complete(), this._activeSiblings.clear(), this._scrollNode = null, this._parentPositions.clear(), this._dragDropRegistry.removeDropContainer(this);
    }
    isDragging() {
      return this._isDragging;
    }
    start() {
      this._draggingStarted(), this._notifyReceivingSiblings();
    }
    enter(t, e, n, r) {
      this._draggingStarted(), r == null && this.sortingDisabled && (r = this._draggables.indexOf(t)), this._sortStrategy.enter(t, e, n, r), this._cacheParentPositions(), this._notifyReceivingSiblings(), this.entered.next({ item: t, container: this, currentIndex: this.getItemIndex(t) });
    }
    exit(t) {
      this._reset(), this.exited.next({ item: t, container: this });
    }
    drop(t, e, n, r, o, s, a, l = {}) {
      this._reset(), this.dropped.next({ item: t, currentIndex: e, previousIndex: n, container: this, previousContainer: r, isPointerOverContainer: o, distance: s, dropPoint: a, event: l });
    }
    withItems(t) {
      let e = this._draggables;
      return this._draggables = t, t.forEach((n) => n._withDropContainer(this)), this.isDragging() && (e.filter((r) => r.isDragging()).every((r) => t.indexOf(r) === -1) ? this._reset() : this._sortStrategy.withItems(this._draggables)), this;
    }
    withDirection(t) {
      return this._direction = t, this._sortStrategy instanceof Vw && (this._sortStrategy.direction = t), this;
    }
    connectedTo(t) {
      return this._siblings = t.slice(), this;
    }
    withOrientation(t) {
      if (t === "mixed") this._sortStrategy = new nP(this._document, this._dragDropRegistry);
      else {
        let e = new Vw(this._dragDropRegistry);
        e.direction = this._direction, e.orientation = t, this._sortStrategy = e;
      }
      return this._sortStrategy.withElementContainer(this._container), this._sortStrategy.withSortPredicate((e, n) => this.sortPredicate(e, n, this)), this;
    }
    withScrollableParents(t) {
      let e = this._container;
      return this._scrollableElements = t.indexOf(e) === -1 ? [e, ...t] : t.slice(), this;
    }
    withElementContainer(t) {
      if (t === this._container) return this;
      let e = Ji(this.element), n = this._scrollableElements.indexOf(this._container), r = this._scrollableElements.indexOf(t);
      return n > -1 && this._scrollableElements.splice(n, 1), r > -1 && this._scrollableElements.splice(r, 1), this._sortStrategy && this._sortStrategy.withElementContainer(t), this._cachedShadowRoot = null, this._scrollableElements.unshift(t), this._container = t, this;
    }
    getScrollableParents() {
      return this._scrollableElements;
    }
    getItemIndex(t) {
      return this._isDragging ? this._sortStrategy.getItemIndex(t) : this._draggables.indexOf(t);
    }
    isReceiving() {
      return this._activeSiblings.size > 0;
    }
    _sortItem(t, e, n, r) {
      if (this.sortingDisabled || !this._domRect || !WH(this._domRect, n4, e, n)) return;
      let o = this._sortStrategy.sort(t, e, n, r);
      o && this.sorted.next({ previousIndex: o.previousIndex, currentIndex: o.currentIndex, container: this, item: t });
    }
    _startScrollingIfNecessary(t, e) {
      if (this.autoScrollDisabled) return;
      let n, r = Uo.NONE, o = Vr.NONE;
      if (this._parentPositions.positions.forEach((s, a) => {
        a === this._document || !s.clientRect || n || WH(s.clientRect, n4, t, e) && ([r, o] = Hfe(a, s.clientRect, this._direction, t, e), (r || o) && (n = a));
      }), !r && !o) {
        let { width: s, height: a } = this._viewportRuler.getViewportSize(), l = { width: s, height: a, top: 0, right: s, bottom: a, left: 0 };
        r = a4(l, e), o = l4(l, t), n = window;
      }
      n && (r !== this._verticalScrollDirection || o !== this._horizontalScrollDirection || n !== this._scrollNode) && (this._verticalScrollDirection = r, this._horizontalScrollDirection = o, this._scrollNode = n, (r || o) && n ? this._ngZone.runOutsideAngular(this._startScrollInterval) : this._stopScrolling());
    }
    _stopScrolling() {
      this._stopScrollTimers.next();
    }
    _draggingStarted() {
      let t = this._container.style;
      this.beforeStarted.next(), this._isDragging = true, this._initialScrollSnap = t.msScrollSnapType || t.scrollSnapType || "", t.scrollSnapType = t.msScrollSnapType = "none", this._sortStrategy.start(this._draggables), this._cacheParentPositions(), this._viewportScrollSubscription.unsubscribe(), this._listenToScrollEvents();
    }
    _cacheParentPositions() {
      this._parentPositions.cache(this._scrollableElements), this._domRect = this._parentPositions.positions.get(this._container).clientRect;
    }
    _reset() {
      this._isDragging = false;
      let t = this._container.style;
      t.scrollSnapType = t.msScrollSnapType = this._initialScrollSnap, this._siblings.forEach((e) => e._stopReceiving(this)), this._sortStrategy.reset(), this._stopScrolling(), this._viewportScrollSubscription.unsubscribe(), this._parentPositions.clear();
    }
    _startScrollInterval = () => {
      this._stopScrolling(), oC(0, p_).pipe(Je(this._stopScrollTimers)).subscribe(() => {
        let t = this._scrollNode, e = this.autoScrollStep;
        this._verticalScrollDirection === Uo.UP ? t.scrollBy(0, -e) : this._verticalScrollDirection === Uo.DOWN && t.scrollBy(0, e), this._horizontalScrollDirection === Vr.LEFT ? t.scrollBy(-e, 0) : this._horizontalScrollDirection === Vr.RIGHT && t.scrollBy(e, 0);
      });
    };
    _isOverContainer(t, e) {
      return this._domRect != null && JD(this._domRect, t, e);
    }
    _getSiblingContainerFromPosition(t, e, n) {
      return this._siblings.find((r) => r._canReceive(t, e, n));
    }
    _canReceive(t, e, n) {
      if (!this._domRect || !JD(this._domRect, e, n) || !this.enterPredicate(t, this)) return false;
      let r = this._getShadowRoot().elementFromPoint(e, n);
      return r ? r === this._container || this._container.contains(r) : false;
    }
    _startReceiving(t, e) {
      let n = this._activeSiblings;
      !n.has(t) && e.every((r) => this.enterPredicate(r, this) || this._draggables.indexOf(r) > -1) && (n.add(t), this._cacheParentPositions(), this._listenToScrollEvents(), this.receivingStarted.next({ initiator: t, receiver: this, items: e }));
    }
    _stopReceiving(t) {
      this._activeSiblings.delete(t), this._viewportScrollSubscription.unsubscribe(), this.receivingStopped.next({ initiator: t, receiver: this });
    }
    _listenToScrollEvents() {
      this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((t) => {
        if (this.isDragging()) {
          let e = this._parentPositions.handleScroll(t);
          e && this._sortStrategy.updateOnScroll(e.top, e.left);
        } else this.isReceiving() && this._cacheParentPositions();
      });
    }
    _getShadowRoot() {
      if (!this._cachedShadowRoot) {
        let t = zu(this._container);
        this._cachedShadowRoot = t || this._document;
      }
      return this._cachedShadowRoot;
    }
    _notifyReceivingSiblings() {
      let t = this._sortStrategy.getActiveItemsSnapshot().filter((e) => e.isDragging());
      this._siblings.forEach((e) => e._startReceiving(this, t));
    }
  };
  function a4(i59, t) {
    let { top: e, bottom: n, height: r } = i59, o = r * s4;
    return t >= e - o && t <= e + o ? Uo.UP : t >= n - o && t <= n + o ? Uo.DOWN : Uo.NONE;
  }
  function l4(i59, t) {
    let { left: e, right: n, width: r } = i59, o = r * s4;
    return t >= e - o && t <= e + o ? Vr.LEFT : t >= n - o && t <= n + o ? Vr.RIGHT : Vr.NONE;
  }
  function Hfe(i59, t, e, n, r) {
    let o = a4(t, r), s = l4(t, n), a = Uo.NONE, l = Vr.NONE;
    if (o) {
      let c = i59.scrollTop;
      o === Uo.UP ? c > 0 && (a = Uo.UP) : i59.scrollHeight - c > i59.clientHeight && (a = Uo.DOWN);
    }
    if (s) {
      let c = i59.scrollLeft;
      e === "rtl" ? s === Vr.RIGHT ? c < 0 && (l = Vr.RIGHT) : i59.scrollWidth + c > i59.clientWidth && (l = Vr.LEFT) : s === Vr.LEFT ? c > 0 && (l = Vr.LEFT) : i59.scrollWidth - c > i59.clientWidth && (l = Vr.RIGHT);
    }
    return [a, l];
  }
  var kw = Or({ passive: false, capture: true });
  var jfe = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["ng-component"]], hostAttrs: ["cdk-drag-resets-container", ""], decls: 0, vars: 0, template: function(n, r) {
      }, styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit;inset:auto}}.cdk-drag-placeholder *,.cdk-drag-preview *{pointer-events:none !important}"], encapsulation: 2, changeDetection: 0 });
    }
    return i59;
  })();
  var aP = (() => {
    class i59 {
      _ngZone = M(We);
      _document = M(yt);
      _styleLoader = M(mi);
      _dropInstances = /* @__PURE__ */ new Set();
      _dragInstances = /* @__PURE__ */ new Set();
      _activeDragInstances = gt([]);
      _globalListeners = /* @__PURE__ */ new Map();
      _draggingPredicate = (e) => e.isDragging();
      _domNodesToDirectives = null;
      pointerMove = new we();
      pointerUp = new we();
      scroll = new we();
      constructor() {
      }
      registerDropContainer(e) {
        this._dropInstances.has(e) || this._dropInstances.add(e);
      }
      registerDragItem(e) {
        this._dragInstances.add(e), this._dragInstances.size === 1 && this._ngZone.runOutsideAngular(() => {
          this._document.addEventListener("touchmove", this._persistentTouchmoveListener, kw);
        });
      }
      removeDropContainer(e) {
        this._dropInstances.delete(e);
      }
      removeDragItem(e) {
        this._dragInstances.delete(e), this.stopDragging(e), this._dragInstances.size === 0 && this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, kw);
      }
      startDragging(e, n) {
        if (!(this._activeDragInstances().indexOf(e) > -1) && (this._styleLoader.load(jfe), this._activeDragInstances.update((r) => [...r, e]), this._activeDragInstances().length === 1)) {
          let r = n.type.startsWith("touch"), o = { handler: (s) => this.pointerUp.next(s), options: true };
          r ? (this._globalListeners.set("touchend", o), this._globalListeners.set("touchcancel", o)) : this._globalListeners.set("mouseup", o), this._globalListeners.set("scroll", { handler: (s) => this.scroll.next(s), options: true }).set("selectstart", { handler: this._preventDefaultWhileDragging, options: kw }), r || this._globalListeners.set("mousemove", { handler: (s) => this.pointerMove.next(s), options: kw }), this._ngZone.runOutsideAngular(() => {
            this._globalListeners.forEach((s, a) => {
              this._document.addEventListener(a, s.handler, s.options);
            });
          });
        }
      }
      stopDragging(e) {
        this._activeDragInstances.update((n) => {
          let r = n.indexOf(e);
          return r > -1 ? (n.splice(r, 1), [...n]) : n;
        }), this._activeDragInstances().length === 0 && this._clearGlobalListeners();
      }
      isDragging(e) {
        return this._activeDragInstances().indexOf(e) > -1;
      }
      scrolled(e) {
        let n = [this.scroll];
        return e && e !== this._document && n.push(new Et((r) => this._ngZone.runOutsideAngular(() => {
          let s = (a) => {
            this._activeDragInstances().length && r.next(a);
          };
          return e.addEventListener("scroll", s, true), () => {
            e.removeEventListener("scroll", s, true);
          };
        }))), Jn(...n);
      }
      registerDirectiveNode(e, n) {
        this._domNodesToDirectives ??= /* @__PURE__ */ new WeakMap(), this._domNodesToDirectives.set(e, n);
      }
      removeDirectiveNode(e) {
        this._domNodesToDirectives?.delete(e);
      }
      getDragDirectiveForNode(e) {
        return this._domNodesToDirectives?.get(e) || null;
      }
      ngOnDestroy() {
        this._dragInstances.forEach((e) => this.removeDragItem(e)), this._dropInstances.forEach((e) => this.removeDropContainer(e)), this._domNodesToDirectives = null, this._clearGlobalListeners(), this.pointerMove.complete(), this.pointerUp.complete();
      }
      _preventDefaultWhileDragging = (e) => {
        this._activeDragInstances().length > 0 && e.preventDefault();
      };
      _persistentTouchmoveListener = (e) => {
        this._activeDragInstances().length > 0 && (this._activeDragInstances().some(this._draggingPredicate) && e.preventDefault(), this.pointerMove.next(e));
      };
      _clearGlobalListeners() {
        this._globalListeners.forEach((e, n) => {
          this._document.removeEventListener(n, e.handler, e.options);
        }), this._globalListeners.clear();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var Wfe = { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };
  var c4 = (() => {
    class i59 {
      _document = M(yt);
      _ngZone = M(We);
      _viewportRuler = M(Bl);
      _dragDropRegistry = M(aP);
      _renderer = M(pr).createRenderer(null, null);
      constructor() {
      }
      createDrag(e, n = Wfe) {
        return new tP(e, n, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry, this._renderer);
      }
      createDropList(e) {
        return new iP(e, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275prov = de({ token: i59, factory: i59.\u0275fac, providedIn: "root" });
    }
    return i59;
  })();
  var rP = new Ee("CDK_DRAG_PARENT");
  var d4 = new Ee("CdkDragHandle");
  var u4 = (() => {
    class i59 {
      element = M(He);
      _parentDrag = M(rP, { optional: true, skipSelf: true });
      _dragDropRegistry = M(aP);
      _stateChanges = new we();
      get disabled() {
        return this._disabled;
      }
      set disabled(e) {
        this._disabled = e, this._stateChanges.next(this);
      }
      _disabled = false;
      constructor() {
        this._parentDrag?._addHandle(this);
      }
      ngAfterViewInit() {
        if (!this._parentDrag) {
          let e = this.element.nativeElement.parentElement;
          for (; e; ) {
            let n = this._dragDropRegistry.getDragDirectiveForNode(e);
            if (n) {
              this._parentDrag = n, n._addHandle(this);
              break;
            }
            e = e.parentElement;
          }
        }
      }
      ngOnDestroy() {
        this._parentDrag?._removeHandle(this), this._stateChanges.complete();
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkDragHandle", ""]], hostAttrs: [1, "cdk-drag-handle"], inputs: { disabled: [2, "cdkDragHandleDisabled", "disabled", tt] }, features: [Bt([{ provide: d4, useExisting: i59 }]), on] });
    }
    return i59;
  })();
  var $fe = new Ee("CDK_DRAG_CONFIG");
  var qfe = new Ee("CdkDropList");
  var h4 = (() => {
    class i59 {
      element = M(He);
      dropContainer = M(qfe, { optional: true, skipSelf: true });
      _ngZone = M(We);
      _viewContainerRef = M(un);
      _dir = M(_i, { optional: true });
      _changeDetectorRef = M(Ge);
      _selfHandle = M(d4, { optional: true, self: true });
      _parentDrag = M(rP, { optional: true, skipSelf: true });
      _dragDropRegistry = M(aP);
      _destroyed = new we();
      _handles = new hi([]);
      _previewTemplate;
      _placeholderTemplate;
      _dragRef;
      data;
      lockAxis;
      rootElementSelector;
      boundaryElement;
      dragStartDelay;
      freeDragPosition;
      get disabled() {
        return this._disabled || !!(this.dropContainer && this.dropContainer.disabled);
      }
      set disabled(e) {
        this._disabled = e, this._dragRef.disabled = this._disabled;
      }
      _disabled;
      constrainPosition;
      previewClass;
      previewContainer;
      scale = 1;
      started = new Ue();
      released = new Ue();
      ended = new Ue();
      entered = new Ue();
      exited = new Ue();
      dropped = new Ue();
      moved = new Et((e) => {
        let n = this._dragRef.moved.pipe(kt((r) => ({ source: this, pointerPosition: r.pointerPosition, event: r.event, delta: r.delta, distance: r.distance }))).subscribe(e);
        return () => {
          n.unsubscribe();
        };
      });
      _injector = M(mt);
      constructor() {
        let e = this.dropContainer, n = M($fe, { optional: true }), r = M(c4);
        this._dragRef = r.createDrag(this.element, { dragStartThreshold: n && n.dragStartThreshold != null ? n.dragStartThreshold : 5, pointerDirectionChangeThreshold: n && n.pointerDirectionChangeThreshold != null ? n.pointerDirectionChangeThreshold : 5, zIndex: n?.zIndex }), this._dragRef.data = this, this._dragDropRegistry.registerDirectiveNode(this.element.nativeElement, this), n && this._assignDefaults(n), e && (this._dragRef._withDropContainer(e._dropListRef), e.addItem(this), e._dropListRef.beforeStarted.pipe(Je(this._destroyed)).subscribe(() => {
          this._dragRef.scale = this.scale;
        })), this._syncInputs(this._dragRef), this._handleEvents(this._dragRef);
      }
      getPlaceholderElement() {
        return this._dragRef.getPlaceholderElement();
      }
      getRootElement() {
        return this._dragRef.getRootElement();
      }
      reset() {
        this._dragRef.reset();
      }
      getFreeDragPosition() {
        return this._dragRef.getFreeDragPosition();
      }
      setFreeDragPosition(e) {
        this._dragRef.setFreeDragPosition(e);
      }
      ngAfterViewInit() {
        Yi(() => {
          this._updateRootElement(), this._setupHandlesListener(), this._dragRef.scale = this.scale, this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition);
        }, { injector: this._injector });
      }
      ngOnChanges(e) {
        let n = e.rootElementSelector, r = e.freeDragPosition;
        n && !n.firstChange && this._updateRootElement(), this._dragRef.scale = this.scale, r && !r.firstChange && this.freeDragPosition && this._dragRef.setFreeDragPosition(this.freeDragPosition);
      }
      ngOnDestroy() {
        this.dropContainer && this.dropContainer.removeItem(this), this._dragDropRegistry.removeDirectiveNode(this.element.nativeElement), this._ngZone.runOutsideAngular(() => {
          this._handles.complete(), this._destroyed.next(), this._destroyed.complete(), this._dragRef.dispose();
        });
      }
      _addHandle(e) {
        let n = this._handles.getValue();
        n.push(e), this._handles.next(n);
      }
      _removeHandle(e) {
        let n = this._handles.getValue(), r = n.indexOf(e);
        r > -1 && (n.splice(r, 1), this._handles.next(n));
      }
      _setPreviewTemplate(e) {
        this._previewTemplate = e;
      }
      _resetPreviewTemplate(e) {
        e === this._previewTemplate && (this._previewTemplate = null);
      }
      _setPlaceholderTemplate(e) {
        this._placeholderTemplate = e;
      }
      _resetPlaceholderTemplate(e) {
        e === this._placeholderTemplate && (this._placeholderTemplate = null);
      }
      _updateRootElement() {
        let e = this.element.nativeElement, n = e;
        this.rootElementSelector && (n = e.closest !== void 0 ? e.closest(this.rootElementSelector) : e.parentElement?.closest(this.rootElementSelector)), this._dragRef.withRootElement(n || e);
      }
      _getBoundaryElement() {
        let e = this.boundaryElement;
        return e ? typeof e == "string" ? this.element.nativeElement.closest(e) : Ji(e) : null;
      }
      _syncInputs(e) {
        e.beforeStarted.subscribe(() => {
          if (!e.isDragging()) {
            let n = this._dir, r = this.dragStartDelay, o = this._placeholderTemplate ? { template: this._placeholderTemplate.templateRef, context: this._placeholderTemplate.data, viewContainer: this._viewContainerRef } : null, s = this._previewTemplate ? { template: this._previewTemplate.templateRef, context: this._previewTemplate.data, matchSize: this._previewTemplate.matchSize, viewContainer: this._viewContainerRef } : null;
            e.disabled = this.disabled, e.lockAxis = this.lockAxis, e.scale = this.scale, e.dragStartDelay = typeof r == "object" && r ? r : ya(r), e.constrainPosition = this.constrainPosition, e.previewClass = this.previewClass, e.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(o).withPreviewTemplate(s).withPreviewContainer(this.previewContainer || "global"), n && e.withDirection(n.value);
          }
        }), e.beforeStarted.pipe(On(1)).subscribe(() => {
          if (this._parentDrag) {
            e.withParent(this._parentDrag._dragRef);
            return;
          }
          let n = this.element.nativeElement.parentElement;
          for (; n; ) {
            let r = this._dragDropRegistry.getDragDirectiveForNode(n);
            if (r) {
              e.withParent(r._dragRef);
              break;
            }
            n = n.parentElement;
          }
        });
      }
      _handleEvents(e) {
        e.started.subscribe((n) => {
          this.started.emit({ source: this, event: n.event }), this._changeDetectorRef.markForCheck();
        }), e.released.subscribe((n) => {
          this.released.emit({ source: this, event: n.event });
        }), e.ended.subscribe((n) => {
          this.ended.emit({ source: this, distance: n.distance, dropPoint: n.dropPoint, event: n.event }), this._changeDetectorRef.markForCheck();
        }), e.entered.subscribe((n) => {
          this.entered.emit({ container: n.container.data, item: this, currentIndex: n.currentIndex });
        }), e.exited.subscribe((n) => {
          this.exited.emit({ container: n.container.data, item: this });
        }), e.dropped.subscribe((n) => {
          this.dropped.emit({ previousIndex: n.previousIndex, currentIndex: n.currentIndex, previousContainer: n.previousContainer.data, container: n.container.data, isPointerOverContainer: n.isPointerOverContainer, item: this, distance: n.distance, dropPoint: n.dropPoint, event: n.event });
        });
      }
      _assignDefaults(e) {
        let { lockAxis: n, dragStartDelay: r, constrainPosition: o, previewClass: s, boundaryElement: a, draggingDisabled: l, rootElementSelector: c, previewContainer: d } = e;
        this.disabled = l ?? false, this.dragStartDelay = r || 0, n && (this.lockAxis = n), o && (this.constrainPosition = o), s && (this.previewClass = s), a && (this.boundaryElement = a), c && (this.rootElementSelector = c), d && (this.previewContainer = d);
      }
      _setupHandlesListener() {
        this._handles.pipe(Wi((e) => {
          let n = e.map((r) => r.element);
          this._selfHandle && this.rootElementSelector && n.push(this.element), this._dragRef.withHandles(n);
        }), Ai((e) => Jn(...e.map((n) => n._stateChanges.pipe(ei(n))))), Je(this._destroyed)).subscribe((e) => {
          let n = this._dragRef, r = e.element.nativeElement;
          e.disabled ? n.disableHandle(r) : n.enableHandle(r);
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275dir = qe({ type: i59, selectors: [["", "cdkDrag", ""]], hostAttrs: [1, "cdk-drag"], hostVars: 4, hostBindings: function(n, r) {
        n & 2 && ye("cdk-drag-disabled", r.disabled)("cdk-drag-dragging", r._dragRef.isDragging());
      }, inputs: { data: [0, "cdkDragData", "data"], lockAxis: [0, "cdkDragLockAxis", "lockAxis"], rootElementSelector: [0, "cdkDragRootElement", "rootElementSelector"], boundaryElement: [0, "cdkDragBoundary", "boundaryElement"], dragStartDelay: [0, "cdkDragStartDelay", "dragStartDelay"], freeDragPosition: [0, "cdkDragFreeDragPosition", "freeDragPosition"], disabled: [2, "cdkDragDisabled", "disabled", tt], constrainPosition: [0, "cdkDragConstrainPosition", "constrainPosition"], previewClass: [0, "cdkDragPreviewClass", "previewClass"], previewContainer: [0, "cdkDragPreviewContainer", "previewContainer"], scale: [2, "cdkDragScale", "scale", Gn] }, outputs: { started: "cdkDragStarted", released: "cdkDragReleased", ended: "cdkDragEnded", entered: "cdkDragEntered", exited: "cdkDragExited", dropped: "cdkDragDropped", moved: "cdkDragMoved" }, exportAs: ["cdkDrag"], features: [Bt([{ provide: rP, useExisting: i59 }]), on, yn] });
    }
    return i59;
  })();
  var p4 = (() => {
    class i59 {
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275mod = lt({ type: i59 });
      static \u0275inj = at({ providers: [c4], imports: [Hs] });
    }
    return i59;
  })();
  var lP = (i59, t) => t.type;
  function Xfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 18), Z("click", function() {
        let r = q(e).$implicit, o = T(2).$index, s = T();
        return Y(s.handleToggleMatchType(o, r.type));
      }), b(1, "mat-icon"), D(2), x()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = T(2).$implicit, r = T();
      ye("selected", r.getIsMatchTypeSelected(n, e.type))("disabled", r.getDisableMatchType(n, e.type)), U("matTooltip", e.tooltip), C(2), Qe(e.type);
    }
  }
  function Zfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 12)(1, "div", 13), D(2, "R"), x(), b(3, "div", 14), D(4, "E"), x()(), b(5, "input", 15, 1), Z("change", function() {
        q(e);
        let r = Ce(6), o = T().$index, s = T();
        return Y(s.handleRegexQueryChanged(o, r.value));
      }), x(), b(7, "div", 16), Qt(8, Xfe, 3, 6, "div", 17, lP), x();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T();
      C(5), U("value", e.queryRegex), C(3), Kt(n.allSearchMatchTypeOptions);
    }
  }
  function Qfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 19), D(1, " [\xB7\xB7] "), x(), b(2, "div", 20)(3, "input", 21, 2), Z("change", function() {
        q(e);
        let r = Ce(4), o = Ce(8), s = Ce(12), a = T().$index, l = T();
        return Y(l.handleAttrValueRangeQueryChanged(a, r.value.trim(), o.value.trim(), s.value.trim()));
      }), x(), b(5, "div", 22), D(6, ":"), x(), b(7, "input", 23, 3), Z("change", function() {
        q(e);
        let r = Ce(4), o = Ce(8), s = Ce(12), a = T().$index, l = T();
        return Y(l.handleAttrValueRangeQueryChanged(a, r.value.trim(), o.value.trim(), s.value.trim()));
      }), x(), b(9, "div", 24), D(10, ","), x(), b(11, "input", 25, 4), Z("change", function() {
        q(e);
        let r = Ce(4), o = Ce(8), s = Ce(12), a = T().$index, l = T();
        return Y(l.handleAttrValueRangeQueryChanged(a, r.value.trim(), o.value.trim(), s.value.trim()));
      }), x()();
    }
    if (i59 & 2) {
      let e = T().$implicit, n = T();
      C(3), U("value", e.attrName), C(4), U("value", n.getAttrValueRangeString(e.min)), C(4), U("value", n.getAttrValueRangeString(e.max));
    }
  }
  function Kfe(i59, t) {
    if (i59 & 1 && (b(0, "option", 28), D(1), x()), i59 & 2) {
      let e = t.$implicit, n = T(2).$implicit;
      U("value", e.type)("selected", e.type === n.nodeType), C(), Oe(" ", e.label, " ");
    }
  }
  function Jfe(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 26)(1, "mat-icon"), D(2, "device_hub"), x()(), b(3, "select", 27, 5), Z("change", function() {
        q(e);
        let r = Ce(4), o = T().$index, s = T();
        return Y(s.handleNodeTypeChanged(o, r.value));
      }), Qt(5, Kfe, 2, 3, "option", 28, lP), x();
    }
    if (i59 & 2) {
      let e = T(2);
      C(5), Kt(e.allSearchNodeTypes);
    }
  }
  function eme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 29), Z("click", function() {
        q(e);
        let r = T().$index, o = T();
        return Y(o.handleDeleteQuery(r));
      }), b(1, "mat-icon"), D(2, "delete"), x()();
    }
  }
  function tme(i59, t) {
    if (i59 & 1 && (b(0, "div", 7), X(1, Zfe, 10, 1)(2, Qfe, 13, 3)(3, Jfe, 7, 0)(4, eme, 3, 0, "div", 11), x()), i59 & 2) {
      let e, n = t.$implicit, r = T();
      C(), he((e = n.type) === r.NodeQueryType.REGEX ? 1 : e === r.NodeQueryType.ATTR_VALUE_RANGE ? 2 : e === r.NodeQueryType.NODE_TYPE ? 3 : -1), C(3), he(r.getShowDeleteQueryButton(n) ? 4 : -1);
    }
  }
  function nme(i59, t) {
    i59 & 1 && (b(0, "div", 31)(1, "div", 13), D(2, "R"), x(), b(3, "div", 14), D(4, "E"), x()());
  }
  function ime(i59, t) {
    i59 & 1 && (b(0, "div", 32), D(1, " [\xB7\xB7] "), x());
  }
  function rme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 30), Z("click", function() {
        let r = q(e).$implicit, o = T();
        return Y(o.handleAddQuery(r.type));
      }), X(1, nme, 5, 0, "div", 31)(2, ime, 2, 0, "div", 32), b(3, "div", 33), D(4), x()();
    }
    if (i59 & 2) {
      let e, n = t.$implicit, r = T();
      C(), he((e = n.type) === r.NodeQueryType.REGEX ? 1 : e === r.NodeQueryType.ATTR_VALUE_RANGE ? 2 : -1), C(3), Qe(n.label);
    }
  }
  var f4 = (() => {
    class i59 {
      changeDetectorRef;
      queries = [];
      queriesUpdated = new Ue();
      NodeQueryType = Dn;
      allSearchMatchTypeOptions = [{ type: _t.NODE_LABEL, tooltip: "Match label" }, { type: _t.ATTRIBUTE, tooltip: "Match attributes" }, { type: _t.INPUT_METADATA, tooltip: "Match inputs (op node only)" }, { type: _t.OUTPUT_METADATA, tooltip: "Match outputs (op node only)" }];
      allSearchNodeTypes = [{ type: _r.OP_NODES, label: "Op nodes only" }, { type: _r.LAYER_NODES, label: "Layer nodes only" }, { type: _r.OP_AND_LAYER_NODES, label: "Op and layer nodes" }];
      allQueryTypes = [{ type: Dn.REGEX, label: "Regex" }, { type: Dn.ATTR_VALUE_RANGE, label: "Attribute value range" }];
      curQueries = [];
      curMatchedNodes = {};
      constructor(e) {
        this.changeDetectorRef = e;
      }
      ngOnInit() {
        this.curQueries = JSON.parse(JSON.stringify(this.queries));
      }
      setMatchedNodes(e) {
        this.curMatchedNodes = e, this.changeDetectorRef.markForCheck();
      }
      handleRegexQueryChanged(e, n) {
        let r = this.curQueries[e];
        r.queryRegex = n.trim(), this.queriesUpdated.emit([...this.curQueries]);
      }
      handleAttrValueRangeQueryChanged(e, n, r, o) {
        let s = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY;
        r !== "" && !isNaN(Number(r)) && (s = Number(r)), o !== "" && !isNaN(Number(o)) && (a = Number(o));
        let l = this.curQueries[e];
        l.attrName = n, l.min = s, l.max = a, this.queriesUpdated.emit([...this.curQueries]);
      }
      handleNodeTypeChanged(e, n) {
        let r = this.curQueries[e];
        r.nodeType = n, this.queriesUpdated.emit([...this.curQueries]);
      }
      handleToggleMatchType(e, n) {
        if (this.getDisableMatchType(this.curQueries[e], n)) return;
        let r = this.curQueries[e], o = r.matchTypes.indexOf(n);
        o >= 0 ? r.matchTypes.splice(o, 1) : r.matchTypes.push(n), this.queriesUpdated.emit([...this.curQueries]);
      }
      handleDeleteQuery(e) {
        this.curQueries.splice(e, 1), this.queriesUpdated.emit([...this.curQueries]);
      }
      handleAddQuery(e) {
        switch (e) {
          case Dn.REGEX:
            this.curQueries.push({ type: e, queryRegex: "", matchTypes: [_t.NODE_LABEL] });
            break;
          case Dn.ATTR_VALUE_RANGE:
            this.curQueries.push({ type: e, attrName: "", min: Number.NEGATIVE_INFINITY, max: Number.POSITIVE_INFINITY });
            break;
          case Dn.NODE_TYPE:
            this.curQueries.push({ type: e, nodeType: _r.OP_NODES });
            break;
          default:
            break;
        }
        this.queriesUpdated.emit([...this.curQueries]);
      }
      getIsMatchTypeSelected(e, n) {
        return e.matchTypes.includes(n);
      }
      getDisableMatchType(e, n) {
        return e.matchTypes.length === 1 && e.matchTypes[0] === n;
      }
      getAttrValueRangeString(e) {
        return e == null || e === Number.NEGATIVE_INFINITY || e === Number.POSITIVE_INFINITY ? "" : `${e}`;
      }
      getShowDeleteQueryButton(e) {
        return e.type !== Dn.NODE_TYPE;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Ge));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["complex-queries"]], inputs: { queries: "queries" }, outputs: { queriesUpdated: "queriesUpdated" }, decls: 11, vars: 1, consts: [["menu", "matMenu"], ["queryInput", ""], ["inputAttrName", ""], ["inputMin", ""], ["inputMax", ""], ["select", ""], [1, "container"], [1, "query-container"], [1, "btn-add-query", 3, "matMenuTriggerFor"], [1, "model-explorer-add-query-menu"], [1, "menu-item"], ["matTooltip", "Delete query", "matTooltipPosition", "right", 1, "icon-container", "delete"], ["matTooltip", "Regex", "n", "", "matTooltipPosition", "left", 1, "model-explorer-regex-icon"], [1, "r"], [1, "e"], ["placeholder", "Regex", 1, "regex", "common-input", 3, "change", "value"], [1, "targets-container"], [1, "icon-container", "match-type", 3, "matTooltip", "selected", "disabled"], [1, "icon-container", "match-type", 3, "click", "matTooltip"], ["matTooltip", "Attribute value range", "matTooltipPosition", "left", 1, "model-explorer-attr-value-range-icon"], [1, "attrs-value-range-container"], ["placeholder", "Attr name", 1, "common-input", "attr-name", 3, "change", "value"], [1, "colon"], ["placeholder", "min", 1, "common-input", "min", 3, "change", "value"], [1, "to"], ["placeholder", "max", 1, "common-input", "max", 3, "change", "value"], ["matTooltip", "Node type", "matTooltipPosition", "left", 1, "model-explorer-node-type-icon"], [1, "node-type-selector", 3, "change"], [3, "value", "selected"], ["matTooltip", "Delete query", "matTooltipPosition", "right", 1, "icon-container", "delete", 3, "click"], [1, "menu-item", 3, "click"], [1, "model-explorer-regex-icon"], [1, "model-explorer-attr-value-range-icon"], [1, "label"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 6), Qt(1, tme, 5, 2, "div", 7, mr), b(3, "div", 8)(4, "mat-icon"), D(5, "add"), x(), D(6, " Add query "), x(), b(7, "mat-menu", 9, 0), Qt(9, rme, 5, 2, "div", 10, lP), x()()), n & 2) {
          let o = Ce(8);
          C(), Kt(r.curQueries), C(2), U("matMenuTriggerFor", o), C(6), Kt(r.allQueryTypes);
        }
      }, dependencies: [et, vt, St, Vl, $s, cp, tn, $n], styles: [`.query-container[_ngcontent-%COMP%]{display:flex;align-items:center;gap:6px;margin-bottom:4px;position:relative;padding-right:36px}.query-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{height:22px;border:1px solid #ccc;border-radius:4px;box-sizing:border-box;padding:0 4px;outline:none}.query-container[_ngcontent-%COMP%]   input.regex[_ngcontent-%COMP%]{flex-grow:1}.query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]{display:flex;align-items:center;width:240px}.query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   .colon[_ngcontent-%COMP%], .query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   .to[_ngcontent-%COMP%]{font-weight:700;margin:0 2px;height:22px}.query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{min-width:0}.query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   input.attr-name[_ngcontent-%COMP%]{flex-grow:1}.query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   input.min[_ngcontent-%COMP%], .query-container[_ngcontent-%COMP%]   .attrs-value-range-container[_ngcontent-%COMP%]   input.max[_ngcontent-%COMP%]{width:46px;flex-shrink:0}.query-container[_ngcontent-%COMP%]   .node-type-selector[_ngcontent-%COMP%]{border:1px solid #ccc;border-radius:4px;outline:none;height:23px;cursor:pointer;box-sizing:border-box;width:160px}.query-container[_ngcontent-%COMP%]   .icon-container.delete[_ngcontent-%COMP%]{display:flex;position:absolute;right:0;top:4px;cursor:pointer;opacity:.6}.query-container[_ngcontent-%COMP%]   .icon-container.delete[_ngcontent-%COMP%]:hover{opacity:1}.query-container[_ngcontent-%COMP%]   .icon-container.delete[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px}.targets-container[_ngcontent-%COMP%]{display:flex;align-items:center;gap:2px}.targets-container[_ngcontent-%COMP%]   .icon-container.match-type[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;background-color:#ddd;border-radius:4px;cursor:pointer;padding:4px}.targets-container[_ngcontent-%COMP%]   .icon-container.match-type.selected[_ngcontent-%COMP%]{background-color:#a3c9ff}.targets-container[_ngcontent-%COMP%]   .icon-container.match-type.disabled[_ngcontent-%COMP%]{cursor:default}.targets-container[_ngcontent-%COMP%]   .icon-container.match-type[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:14px;width:14px;height:14px;color:#333}.btn-add-query[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer;width:fit-content;line-height:16px;opacity:.6;white-space:nowrap;margin-top:2px;-webkit-user-select:none;user-select:none;margin-left:19px}.btn-add-query[_ngcontent-%COMP%]:hover{opacity:1}.btn-add-query[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px;margin-right:2px}  .model-explorer-add-query-menu .menu-item{letter-spacing:normal!important;font-family:Google Sans Text,Arial,Helvetica,sans-serif!important;font-size:12px;padding:0 8px;cursor:pointer;display:flex;align-items:center}  .model-explorer-add-query-menu .menu-item .label{margin-left:6px}  .model-explorer-add-query-menu .menu-item:hover{background-color:#eee}  .model-explorer-regex-icon{display:flex;width:16px;height:16px;align-items:center;justify-content:center;font-weight:700;-webkit-user-select:none;user-select:none;color:#aaa}  .model-explorer-regex-icon .r{font-size:12px}  .model-explorer-regex-icon .e{font-size:8px;margin-top:2px}  .model-explorer-attr-value-range-icon{display:flex;width:16px;height:16px;align-items:center;justify-content:center;font-size:10px;font-weight:700;-webkit-user-select:none;user-select:none;color:#aaa}  .model-explorer-node-type-icon{width:16px;height:16px}  .model-explorer-node-type-icon mat-icon{font-size:16px;width:16px;height:16px;color:#aaa}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  function ome(i59, t) {
    if (i59 & 1 && (b(0, "div", 3), ae(1, "io-tree", 4), x()), i59 & 2) {
      let e = T();
      C(), U("data", e.curIoTreeData)("rendererId", e.rendererId)("tooltipPosition", "right");
    }
  }
  var m4 = (() => {
    class i59 {
      nodes = [];
      rendererId = "";
      labelSuffix = "node";
      popupSize = { minWidth: 320, maxWidth: 640, minHeight: 0 };
      curIoTreeData = [];
      ngOnChanges(e) {
        e.nodes && (this.curIoTreeData = Ha(this.nodes, [], "incoming"));
      }
      get label() {
        let e = this.nodes.length;
        return `${e} ${this.labelSuffix}${e === 1 ? "" : "s"}`;
      }
      static \u0275fac = function(n) {
        return new (n || i59)();
      };
      static \u0275cmp = xe({ type: i59, selectors: [["node-list-viewer"]], inputs: { nodes: "nodes", rendererId: "rendererId", labelSuffix: "labelSuffix" }, features: [yn], decls: 5, vars: 5, consts: [["nodeList", ""], [1, "container"], ["panelClass", "model-explorer-node-list-panel", 1, "label-container", 3, "bubbleClick", "overlaySize"], [1, "model-explorer-node-list"], [3, "data", "rendererId", "tooltipPosition"]], template: function(n, r) {
        if (n & 1 && (b(0, "div", 1)(1, "div", 2), D(2), x(), X(3, ome, 2, 3, "ng-template", null, 0, Tt), x()), n & 2) {
          let o = Ce(4);
          C(), ye("disabled", r.nodes.length === 0), U("bubbleClick", o)("overlaySize", r.popupSize), C(), Oe(" ", r.label, " ");
        }
      }, dependencies: [Xr, et, Ul, vt], styles: [`.container[_ngcontent-%COMP%]{display:flex;position:relative}.label-container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;padding:4px 6px;border-radius:4px;background-color:#a3c9ff;line-height:14px;cursor:pointer;-webkit-user-select:none;user-select:none;opacity:.8}.label-container[_ngcontent-%COMP%]:hover{opacity:1}.label-container.disabled[_ngcontent-%COMP%]{pointer-events:none;background-color:#ddd}  .model-explorer-node-list{font-size:12px;background-color:#fff;line-height:normal}  .model-explorer-node-list-panel bubble-container{width:100%}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var sme = (i59, t) => t.id;
  function ame(i59, t) {
    i59 & 1 && (b(0, "div", 24), D(1, " Rules use your defined queries to match nodes for styling. All queries within a rule are connected with "), b(2, "span", 25), D(3, "AND"), x(), D(4, " logic. "), x());
  }
  function lme(i59, t) {
    if (i59 & 1 && (b(0, "div", 28), ae(1, "node-list-viewer", 36), x()), i59 & 2) {
      let e = T().$index, n = T(2);
      C(), U("nodes", n.getMatchedNodes(e, 0))("rendererId", n.leftPaneRendererId);
    }
  }
  function cme(i59, t) {
    if (i59 & 1 && (b(0, "div", 28)(1, "div", 37), D(2, "Left pane"), x(), ae(3, "node-list-viewer", 36), x(), b(4, "div", 28)(5, "div", 37), D(6, "Right pane"), x(), ae(7, "node-list-viewer", 36), x()), i59 & 2) {
      let e = T().$index, n = T(2);
      C(3), U("nodes", n.getMatchedNodes(e, 0))("rendererId", n.leftPaneRendererId), C(4), U("nodes", n.getMatchedNodes(e, 1))("rendererId", n.rightPaneRendererId);
    }
  }
  function dme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 41)(1, "label")(2, "input", 42, 3), Z("change", function() {
        q(e);
        let r = Ce(3), o = T(2).$implicit, s = T().$index, a = T(2);
        return Y(a.handleStyleColorChanged(s, o, r.value));
      }), x()(), b(4, "input", 43, 4), Z("change", function() {
        q(e);
        let r = Ce(5), o = T(2).$implicit, s = T().$index, a = T(2);
        return Y(a.handleStyleColorChanged(s, o, r.value));
      }), x()();
    }
    if (i59 & 2) {
      let e = T(2).$implicit, n = T().$implicit, r = T(2);
      C(), sn("background-color", r.getSerializedStyleValue(n, e)), C(), U("value", r.getSerializedStyleValue(n, e)), C(2), U("value", r.getSerializedStyleValue(n, e));
    }
  }
  function ume(i59, t) {
    if (i59 & 1 && X(0, dme, 6, 4, "div", 41), i59 & 2) {
      let e = T().$implicit, n = T().$implicit, r = T(2);
      he(r.getIsStyleEnabled(n, e) ? 0 : -1);
    }
  }
  function hme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 44)(1, "input", 45, 5), Z("change", function() {
        q(e);
        let r = Ce(2), o = T(2).$implicit, s = T().$index, a = T(2);
        return Y(a.handleStyleColorChanged(s, o, r.value));
      }), x()();
    }
    if (i59 & 2) {
      let e = T(2).$implicit, n = T().$implicit, r = T(2);
      C(), U("value", r.getSerializedStyleValue(n, e));
    }
  }
  function pme(i59, t) {
    if (i59 & 1 && X(0, hme, 3, 1, "div", 44), i59 & 2) {
      let e = T().$implicit, n = T().$implicit, r = T(2);
      he(r.getIsStyleEnabled(n, e) ? 0 : -1);
    }
  }
  function fme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 30)(1, "div", 38)(2, "input", 39, 2), Z("change", function() {
        let r = q(e).$implicit, o = Ce(3), s = T().$index, a = T(2);
        return Y(a.handleToggleStyle(s, r, o.checked));
      }), x(), b(4, "div", 40), Z("click", function() {
        let r = q(e).$implicit, o = T().$index, s = T(2);
        return Y(s.handleToggleStyle(o, r));
      }), D(5), x()(), X(6, ume, 1, 1)(7, pme, 1, 1), x();
    }
    if (i59 & 2) {
      let e, n = t.$implicit, r = T().$implicit, o = T(2);
      C(2), U("checked", o.getIsStyleEnabled(r, n)), C(3), Oe(" ", n.label, " "), C(), he((e = n.type) === o.StyleType.COLOR ? 6 : e === o.StyleType.NUMBER ? 7 : -1);
    }
  }
  function mme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 46), Z("click", function() {
        q(e);
        let r = T().$index, o = T(2);
        return Y(o.handleMoveUpRule(r));
      }), b(1, "mat-icon"), D(2, "arrow_upward_alt"), x()();
    }
  }
  function gme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 47), Z("click", function() {
        q(e);
        let r = T().$index, o = T(2);
        return Y(o.handleMoveDownRule(r));
      }), b(1, "mat-icon"), D(2, "arrow_downward_alt"), x()();
    }
  }
  function _me(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "tr")(1, "td", 19)(2, "complex-queries", 26), Z("queriesUpdated", function(r) {
        let o = q(e).$index, s = T(2);
        return Y(s.handleQueriesUpdated(o, r));
      }), x(), b(3, "div", 27), X(4, lme, 2, 2, "div", 28)(5, cme, 8, 4), x()(), b(6, "td", 22)(7, "div", 29), Qt(8, fme, 8, 3, "div", 30, sme), x()(), b(10, "td", 23)(11, "div", 31), X(12, mme, 3, 0, "div", 32)(13, gme, 3, 0, "div", 33), b(14, "div", 34), Z("click", function() {
        let r = q(e).$index, o = T(2);
        return Y(o.handleDuplicateRule(r));
      }), b(15, "mat-icon"), D(16, "content_copy"), x()(), b(17, "div", 35), Z("click", function() {
        let r = q(e).$index, o = T(2);
        return Y(o.handleDeleteRule(r));
      }), b(18, "mat-icon"), D(19, "delete"), x()()()()();
    }
    if (i59 & 2) {
      let e = t.$implicit, n = t.$index, r = t.$count, o = T(2);
      C(2), U("queries", e.queries), C(2), he(o.panesCount === 1 ? 4 : o.panesCount === 2 ? 5 : -1), C(4), Kt(o.allStyles), C(4), he(n !== 0 ? 12 : -1), C(), he(n !== r - 1 ? 13 : -1);
    }
  }
  function vme(i59, t) {
    if (i59 & 1 && (b(0, "table", 10)(1, "thead")(2, "th", 19)(3, "div", 20), D(4, " Queries to match nodes "), b(5, "div", 21)(6, "mat-icon"), D(7, "help_outline"), x()(), X(8, ame, 5, 0, "ng-template", null, 1, Tt), x()(), b(10, "th", 22), D(11, "Styles to apply"), x(), ae(12, "th", 23), x(), b(13, "tbody"), Qt(14, _me, 20, 4, "tr", null, mr), x()()), i59 & 2) {
      let e = Ce(9), n = T();
      C(5), U("bubble", e)("overlaySize", n.helpPopupSize)("hoverDelayMs", 10), C(9), Kt(n.rules());
    }
  }
  function yme(i59, t) {
    i59 & 1 && (b(0, "div", 11), D(1, ' No rules configured. Click the "Add rule" button below to get started. '), x());
  }
  var g4 = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      nodeStylerService;
      rules;
      hasNonEmptyNodeStylerRules;
      hasRules = It(() => this.rules().length > 0);
      StyleType = hp;
      NodeStylerQueryType = Dn;
      allStyles = wG;
      allSearchMatchTypeOptions = [{ type: _t.NODE_LABEL, tooltip: "Match label" }, { type: _t.ATTRIBUTE, tooltip: "Match attributes" }, { type: _t.INPUT_METADATA, tooltip: "Match inputs (op node only)" }, { type: _t.OUTPUT_METADATA, tooltip: "Match outputs (op node only)" }];
      allSearchNodeTypes = [{ type: _r.OP_NODES, label: "Ops only" }, { type: _r.LAYER_NODES, label: "Layers only" }, { type: _r.OP_AND_LAYER_NODES, label: "Ops & layers" }];
      allQueryTypes = [{ type: Dn.REGEX, label: "Regex" }, { type: Dn.ATTR_VALUE_RANGE, label: "Attribute value range" }];
      helpPopupSize = { minWidth: 0, minHeight: 0, maxWidth: 340 };
      curMatchedNodes = {};
      constructor(e, n, r) {
        this.appService = e, this.changeDetectorRef = n, this.nodeStylerService = r, this.rules = this.nodeStylerService.rules, this.hasNonEmptyNodeStylerRules = this.nodeStylerService.hasNonEmptyNodeStylerRules, ht(() => {
          this.curMatchedNodes = this.nodeStylerService.matchedNodes(), this.changeDetectorRef.markForCheck();
        });
      }
      handleClickAddRule() {
        this.nodeStylerService.addNewRule();
      }
      handleClickExportRules() {
        let e = document.createElement("a");
        e.download = "node_styler_rules.json";
        let n = `data:text/json;charset=utf-8, ${encodeURIComponent(JSON.stringify(this.rules(), null, 2))}`;
        qs(e, n), e.click();
      }
      handleClickImportRules(e) {
        if (!e.files || e.files.length === 0) return;
        let n = new FileReader();
        n.onload = (r) => {
          let o = JSON.parse(r.target?.result);
          this.nodeStylerService.updateRules(o);
        }, n.readAsText(e.files[0]);
      }
      handleQueriesUpdated(e, n) {
        this.nodeStylerService.updateQueries(e, n);
      }
      handleToggleStyle(e, n, r) {
        this.nodeStylerService.toggleStyle(e, n, r);
      }
      handleStyleColorChanged(e, n, r) {
        let o = r;
        r.startsWith("rgb") ? o = this.rgbToHex(r) : r.startsWith("#") || (o = Dy[r] || r), this.nodeStylerService.updateStyleValue(e, n, o);
      }
      handleNumberChanged(e, n, r) {
        let o = Number(r);
        isNaN(o) || (o = Math.min(10, Math.max(1e-3, o)), this.nodeStylerService.updateStyleValue(e, n, `${o}`));
      }
      handleMoveUpRule(e) {
        this.nodeStylerService.moveUpRule(e);
      }
      handleMoveDownRule(e) {
        this.nodeStylerService.moveDownRule(e);
      }
      handleDuplicateRule(e) {
        this.nodeStylerService.duplicateRule(e);
      }
      handleDeleteRule(e) {
        this.nodeStylerService.deleteRule(e);
      }
      getIsStyleEnabled(e, n) {
        return e.styles[n.id] != null;
      }
      getSerializedStyleValue(e, n) {
        return Rc(e, n.id);
      }
      getMatchedNodes(e, n) {
        return (this.curMatchedNodes[e] || {})[n] || [];
      }
      get panesCount() {
        return this.appService.panes().length;
      }
      get leftPaneRendererId() {
        return this.appService.panes()[0].id;
      }
      get rightPaneRendererId() {
        return this.appService.panes()[1].id;
      }
      rgbToHex(e) {
        let n = e.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+\.{0,1}\d*))?\)$/);
        if (n) {
          let r = n.slice(1, 4).map((o) => Number(o).toString(16).padStart(2, "0")).join("");
          return r[0] === r[1] && r[2] === r[3] && r[4] === r[5] ? `#${r[0]}${r[2]}${r[4]}` : `#${r}`;
        }
        return "unknown";
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(Ys));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["node-styler-dialog"]], decls: 26, vars: 1, consts: [["input", ""], ["helpQuery", ""], ["cb", ""], ["colorPicker", ""], ["colorInput", ""], ["numberInput", ""], ["mat-dialog-title", "", "cdkDrag", "", "cdkDragRootElement", ".cdk-overlay-pane", "cdkDragHandle", "", 1, "title-container"], [1, "title"], [1, "description"], ["mat-dialog-content", "", 1, "dialog-content"], ["border", "0", "cellspacing", "0", "cellpadding", "0", 1, "rules-table"], [1, "no-rules-message"], ["mat-dialog-actions", "", 1, "btns-container"], [1, "left-btns"], ["mat-flat-button", "", "color", "primary", 1, "action-button", "add-rule", 3, "click"], ["mat-flat-button", "", "color", "primary", 1, "action-button", "load-rules", 3, "click"], ["mat-flat-button", "", "color", "primary", 1, "action-button", "save-rules", 3, "click"], ["type", "file", "accept", "application/JSON", 1, "import-rules-input", 3, "change"], ["mat-button", "", "mat-dialog-close", "", 1, "close"], [1, "query"], [1, "query-header-container"], [1, "icon-container", 3, "bubble", "overlaySize", "hoverDelayMs"], [1, "styles"], [1, "action-btns"], [1, "model-explorer-help-popup"], [1, "bold"], [3, "queriesUpdated", "queries"], [1, "node-list-viewers-container"], [1, "node-list-viewer-container"], [1, "styles-container"], [1, "color-style-container"], [1, "action-buttons-container"], ["matTooltip", "Move up", 1, "icon-container", "move-up"], ["matTooltip", "Move down", 1, "icon-container", "move-down"], ["matTooltip", "Duplicate rule", 1, "icon-container", "duplicate-rule", 3, "click"], ["matTooltip", "Delete rule", 1, "icon-container", "delete-rule", 3, "click"], ["labelSuffix", "matched node", 3, "nodes", "rendererId"], [1, "label"], [1, "style-name-container"], ["type", "checkbox", 3, "change", "checked"], [3, "click"], [1, "color-picker-container"], ["type", "color", 3, "change", "value"], ["type", "text", 3, "change", "value"], [1, "number-editor-container"], [3, "change", "value"], ["matTooltip", "Move up", 1, "icon-container", "move-up", 3, "click"], ["matTooltip", "Move down", 1, "icon-container", "move-down", 3, "click"]], template: function(n, r) {
        if (n & 1) {
          let o = pe();
          b(0, "div", 6)(1, "div", 7), D(2, "Node styler"), x(), b(3, "div", 8), D(4, " Use the buttons below to apply styling rules to this graph "), x()(), b(5, "div", 9), X(6, vme, 16, 3, "table", 10)(7, yme, 2, 0, "div", 11), x(), b(8, "div", 12)(9, "div", 13)(10, "button", 14), Z("click", function() {
            return q(o), Y(r.handleClickAddRule());
          }), b(11, "mat-icon"), D(12, "add"), x(), D(13, " Add rule "), x(), b(14, "button", 15), Z("click", function() {
            q(o);
            let a = Ce(23);
            return Y(a.click());
          }), b(15, "mat-icon"), D(16, "file_upload"), x(), D(17, " Import rules "), x(), b(18, "button", 16), Z("click", function() {
            return q(o), Y(r.handleClickExportRules());
          }), b(19, "mat-icon"), D(20, "file_download"), x(), D(21, " Export rules "), x(), b(22, "input", 17, 0), Z("change", function() {
            q(o);
            let a = Ce(23);
            return Y(r.handleClickImportRules(a));
          }), x()(), b(24, "button", 18), D(25, "Done"), x()();
        }
        n & 2 && (C(6), he(r.hasRules() ? 6 : 7));
      }, dependencies: [Bn, et, f4, p4, h4, u4, Hn, vr, Aw, kH, FH, VH, BH, vt, St, Vl, tn, $n, m4], styles: [`*[_ngcontent-%COMP%]:not(mat-icon){font-family:Google Sans Text,Arial,Helvetica,sans-serif!important;letter-spacing:normal!important}.title-container[_ngcontent-%COMP%]{position:relative}.title[_ngcontent-%COMP%]{font-size:24px;font-weight:500;margin-top:-30px}.description[_ngcontent-%COMP%]{line-height:14px;font-size:12px;color:#777;margin-top:6px;margin-bottom:4px;font-weight:400}.btns-container[_ngcontent-%COMP%]{width:100%;display:flex;align-items:center;justify-content:space-between;padding:0 24px}.action-button[_ngcontent-%COMP%]{height:30px;padding:0 10px;font-size:13px}.action-button[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{margin-right:2px}.import-rules-input[_ngcontent-%COMP%]{display:none}.dialog-content[_ngcontent-%COMP%]{padding:0;box-sizing:border-box;border-top:1px solid #e6e6e6;border-bottom:1px solid #e6e6e6;background-color:#f9f9f9;overflow:hidden auto}.dialog-content[_ngcontent-%COMP%]   .no-rules-message[_ngcontent-%COMP%]{padding:12px 24px;font-size:12px;color:#777}.common-input[_ngcontent-%COMP%]{padding:0 4px;border:1px solid #ccc;border-radius:4px;height:22px;box-sizing:border-box;outline:none}.common-input[_ngcontent-%COMP%]:focus{border-color:#1a73e8;outline:1px solid #1a73e8}.rules-table[_ngcontent-%COMP%]{width:100%;font-size:12px}.rules-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]:not(.action-btns), .rules-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]:not(.action-btns){border-right:1px solid #e6e6e6}.rules-table[_ngcontent-%COMP%]   tr[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border-bottom:1px solid #e6e6e6}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]{text-align:left;height:32px;position:sticky;top:0;background-color:#f1f1f1;z-index:100}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{font-weight:500;border-bottom:1px solid #e6e6e6}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.query[_ngcontent-%COMP%]{padding-left:24px;width:410px}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.query[_ngcontent-%COMP%]   .query-header-container[_ngcontent-%COMP%]{display:flex;align-items:center}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.query[_ngcontent-%COMP%]   .query-header-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{width:16px;height:16px;opacity:.6;cursor:pointer;margin-left:4px}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.query[_ngcontent-%COMP%]   .query-header-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.query[_ngcontent-%COMP%]   .query-header-container[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.target[_ngcontent-%COMP%]{padding-left:12px}.rules-table[_ngcontent-%COMP%]   thead[_ngcontent-%COMP%]   th.styles[_ngcontent-%COMP%]{padding-left:12px;min-width:254px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{padding-top:8px;padding-bottom:8px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.query[_ngcontent-%COMP%]{padding-left:24px;padding-right:12px;vertical-align:top}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.query[_ngcontent-%COMP%]   .node-list-viewers-container[_ngcontent-%COMP%]{display:flex;gap:12px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.query[_ngcontent-%COMP%]   .node-list-viewer-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;width:fit-content;margin-top:12px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.query[_ngcontent-%COMP%]   .node-list-viewer-container[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{line-height:18px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.target[_ngcontent-%COMP%]{vertical-align:top;padding-left:12px;padding-right:12px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.styles[_ngcontent-%COMP%]{padding-left:12px;padding-right:18px;vertical-align:top}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.styles[_ngcontent-%COMP%]   .styles-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:2px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.action-btns[_ngcontent-%COMP%]{vertical-align:top;padding-right:12px;width:80px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.action-btns[_ngcontent-%COMP%]   .action-buttons-container[_ngcontent-%COMP%]{display:flex;justify-content:flex-end;gap:2px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.action-btns[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]{display:flex;opacity:.6;cursor:pointer;margin-top:2px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.action-btns[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]:hover{opacity:1}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   td.action-btns[_ngcontent-%COMP%]   .icon-container[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:16px;width:16px;height:16px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]{display:flex;align-items:center}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .style-name-container[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer;-webkit-user-select:none;user-select:none;width:100px}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .style-name-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{cursor:pointer}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .color-picker-container[_ngcontent-%COMP%]{display:flex;align-items:center;overflow:hidden;border-radius:4px;border:1px solid #ccc;margin-left:4px;width:fit-content;background-color:#fff;box-sizing:border-box;height:24px;position:relative}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .color-picker-container[_ngcontent-%COMP%]:focus-within{border-color:#1a73e8;outline:1px solid #1a73e8}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .color-picker-container[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]{display:inline-block;width:16px;height:16px;margin:2px;background-color:red;border-radius:4px;cursor:pointer;border:1px solid #ddd}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .color-picker-container[_ngcontent-%COMP%]   label[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{visibility:hidden}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .color-picker-container[_ngcontent-%COMP%]   input[type=text][_ngcontent-%COMP%]{width:100px;border:none;height:100%;background-color:transparent;outline:none}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .number-editor-container[_ngcontent-%COMP%]{display:flex;align-items:center;overflow:hidden;margin-left:4px;width:fit-content}.rules-table[_ngcontent-%COMP%]   tbody[_ngcontent-%COMP%]   .color-style-container[_ngcontent-%COMP%]   .number-editor-container[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:80px;height:28px;border:1px solid #ccc;border-radius:4px;background-color:transparent;box-sizing:border-box;padding:0 4px;outline:none}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var _4 = (() => {
    class i59 {
      dialog;
      nodeStylerService;
      viewContainerRef;
      hasNonEmptyNodeStylerRules;
      dialogOpened = gt(false);
      constructor(e, n, r) {
        this.dialog = e, this.nodeStylerService = n, this.viewContainerRef = r, this.hasNonEmptyNodeStylerRules = this.nodeStylerService.hasNonEmptyNodeStylerRules;
      }
      handleClickOpenDialog() {
        this.dialogOpened.set(true), this.dialog.open(g4, { width: "800px", height: "600px", viewContainerRef: this.viewContainerRef, hasBackdrop: false, autoFocus: false }).afterClosed().subscribe(() => {
          this.dialogOpened.set(false);
        });
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(Yg), K(Ys), K(un));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["node-styler"]], decls: 3, vars: 4, consts: [["mat-icon-button", "", "aria-label", "node-styler", "matTooltip", "Style nodes with custom rules", 3, "click"]], template: function(n, r) {
        n & 1 && (b(0, "button", 0), Z("click", function() {
          return r.handleClickOpenDialog();
        }), b(1, "mat-icon"), D(2, "palette"), x()()), n & 2 && (ye("disabled", r.dialogOpened()), C(), ye("highlight", r.hasNonEmptyNodeStylerRules()));
      }, dependencies: [et, Hn, pl, Aw, vt, St, tn, $n], styles: [`button.disabled[_ngcontent-%COMP%]{pointer-events:none}button[_ngcontent-%COMP%]   mat-icon.highlight[_ngcontent-%COMP%]{background:linear-gradient(45deg,#0089ff 0 30%,#f1af00 70% 100%);background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var bme = ["*"];
  var v4 = (() => {
    class i59 {
      appService;
      titleClicked = new Ue();
      constructor(e) {
        this.appService = e;
      }
      get disableTitleTooltip() {
        return this.appService.testMode;
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["title-bar"]], outputs: { titleClicked: "titleClicked" }, ngContentSelectors: bme, decls: 22, vars: 1, consts: [[1, "container"], ["matTooltip", "Back home", 1, "title", 3, "click", "matTooltipDisabled"], [1, "right-container"], [1, "divider"], [1, "divider", "tighter-right"], [1, "icons-container"], ["href", "https://github.com/google-ai-edge/model-explorer", "target", "_blank"], ["mat-icon-button", "", "aria-label", "doc", "matTooltip", "GitHub"], ["href", "https://github.com/google-ai-edge/model-explorer/issues", "target", "_blank"], ["mat-icon-button", "", "aria-label", "bug", "matTooltip", "File issue or feature request"]], template: function(n, r) {
        n & 1 && (Tn(), b(0, "div", 0)(1, "div", 1), Z("click", function() {
          return r.titleClicked.emit();
        }), ae(2, "me-logo"), D(3, " Model Explorer "), ae(4, "new-version-chip"), x(), b(5, "div", 2), ae(6, "node-data-provider-dropdown")(7, "div", 3)(8, "graph-selector")(9, "div", 4)(10, "node-styler"), b(11, "div", 5)(12, "a", 6)(13, "button", 7)(14, "mat-icon"), D(15, "article"), x()()(), b(16, "a", 8)(17, "button", 9)(18, "mat-icon"), D(19, "bug_report"), x()()()(), ae(20, "open-in-new-tab-button"), zt(21), x()()), n & 2 && (C(), U("matTooltipDisabled", r.disableTitleTooltip));
      }, dependencies: [et, MH, Hx, Hn, pl, vt, St, tn, $n, TH, IH, _4, xH], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;padding:8px 8px 8px 12px;box-sizing:border-box;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid #ddd}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]{font-weight:400;cursor:pointer;color:#444746;font-size:20px;display:flex;align-items:center}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   me-logo[_ngcontent-%COMP%]{margin-right:6px}.container[_ngcontent-%COMP%]   .title[_ngcontent-%COMP%]   new-version-chip[_ngcontent-%COMP%]{margin-left:16px}.container[_ngcontent-%COMP%]   .right-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{width:1px;height:28px;border-left:1px solid #ccc;margin:0 16px}.container[_ngcontent-%COMP%]   .divider.tighter-right[_ngcontent-%COMP%]{margin-right:4px}.container[_ngcontent-%COMP%]   .icons-container[_ngcontent-%COMP%]{display:flex;align-items:center}.container[_ngcontent-%COMP%]   .icons-container[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;color:#000}.container[_ngcontent-%COMP%]   open-in-new-tab-button[_ngcontent-%COMP%]{margin-left:8px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var xme = ["*"];
  function wme(i59, t) {
    i59 & 1 && ae(0, "benchmark-runner");
  }
  function Cme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "title-bar", 4), Z("titleClicked", function() {
        q(e);
        let r = T(3);
        return Y(r.titleClicked.emit());
      }), zt(1), x();
    }
  }
  function Sme(i59, t) {
    i59 & 1 && (b(0, "div", 3), D(1, "No graphs"), x());
  }
  function Mme(i59, t) {
    i59 & 1 && ae(0, "split-panes-container");
  }
  function Eme(i59, t) {
    if (i59 & 1 && (X(0, Cme, 2, 0, "title-bar"), b(1, "div", 2), X(2, Sme, 2, 0, "div", 3)(3, Mme, 1, 0, "split-panes-container"), x()), i59 & 2) {
      let e = T(2);
      he(e.showTitleBar ? 0 : -1), C(2), he(e.hasNoGraphs ? 2 : 3);
    }
  }
  function Tme(i59, t) {
    if (i59 & 1) {
      let e = pe();
      b(0, "div", 1), Z("dragover", function(r) {
        q(e);
        let o = T();
        return Y(o.handleDragOver(r));
      })("drop", function(r) {
        q(e);
        let o = T();
        return Y(o.handleDrop(r));
      }), X(1, wme, 1, 0, "benchmark-runner")(2, Eme, 4, 2), x();
    }
    if (i59 & 2) {
      let e = T();
      C(), he(e.benchmark ? 1 : 2);
    }
  }
  var zw = (() => {
    class i59 {
      appService;
      changeDetectorRef;
      destroyRef;
      el;
      snackBar;
      threejsService;
      uiStateService;
      nodeDataProviderExtensionService;
      nodeStylerService;
      syncNavigationService;
      graphCollections;
      config;
      initialUiState;
      benchmark = false;
      nodeDataSources = [];
      titleClicked = new Ue();
      uiStateChanged = new Ue();
      modelGraphProcessed = new Ue();
      remoteNodeDataPathsChanged = new Ue();
      syncNavigationModeChanged = new Ue();
      selectedNodeChanged = new Ue();
      hoveredNodeChanged = new Ue();
      doubleClickedNodeChanged = new Ue();
      curProcessedModelGraph;
      ready = false;
      mouseDownHandler = (e) => {
        window.parent.postMessage({ cmd: "model-explorer-mousedown" }, "*");
      };
      constructor(e, n, r, o, s, a, l, c, d, u) {
        this.appService = e, this.changeDetectorRef = n, this.destroyRef = r, this.el = o, this.snackBar = s, this.threejsService = a, this.uiStateService = l, this.nodeDataProviderExtensionService = c, this.nodeStylerService = d, this.syncNavigationService = u, ht(() => {
          let h = this.uiStateService.curUiState();
          h && this.uiStateChanged.emit(h);
        }), ht(() => {
          this.remoteNodeDataPathsChanged.emit(this.appService.remoteNodeDataPaths());
        }), ht(() => {
          this.selectedNodeChanged.emit(this.appService.selectedNode());
        }), ht(() => {
          this.hoveredNodeChanged.emit(this.appService.hoveredNode());
        }), ht(() => {
          this.doubleClickedNodeChanged.emit(this.appService.doubleClickedNode());
        }), window.addEventListener("message", (h) => {
          let p = h.data;
          switch (p.cmd) {
            case "model-explorer-load-node-data-file":
              let f = p.path;
              f && this.handleGetNodeDataPathFromPostMessage(f);
              break;
            case "model-explorer-select-node-by-output-tensor-name":
              let m = p.tensorName;
              m && this.handleSelectNodeByOutputTensorNameFromPostMessage(m);
              break;
            case "model-explorer-select-node-by-node-id":
              let v = p.nodeId;
              v && this.handleSelectNodeByNodeIdFromPostMessage(v);
              break;
            default:
              break;
          }
        }), this.appService.modelGraphProcessed$.pipe(wi(this.destroyRef)).subscribe((h) => {
          this.modelGraphProcessed.next(h);
        }), this.syncNavigationService.syncNavigationModeChanged$.pipe(wi(this.destroyRef)).subscribe((h) => {
          this.syncNavigationModeChanged.next(h);
        }), this.initThreejs();
      }
      ngOnInit() {
        if (this.appService.config.set(this.config || {}), this.appService.addGraphCollections(this.graphCollections), this.appService.curInitialUiState.set(this.initialUiState), this.config?.nodeStylerRules && this.nodeStylerService.rules.set(this.config.nodeStylerRules), !this.initialUiState || this.initialUiState.paneStates.length === 0) {
          if (this.graphCollections.length > 0 && this.graphCollections[0].graphs.length > 0) {
            let n = [...this.graphCollections[0].graphs].sort((r, o) => o.nodes.length - r.nodes.length)[0];
            this.appService.selectGraphInCurrentPane(n);
          }
        } else if (this.initialUiState.paneStates.length === 1) {
          let e = this.initialUiState.paneStates[0], n = e.selectedNodeId === "" && e.deepestExpandedGroupNodeIds.length === 0, r = this.findGraphFromCollections(e.selectedCollectionLabel, e.selectedGraphId), o = e.flattenLayers === true;
          if (r) this.appService.selectGraphInCurrentPane(r, o, void 0, n);
          else {
            let s = this.graphCollections[0].graphs[0];
            this.appService.selectGraphInCurrentPane(s, o, void 0, n);
          }
          this.appService.setFlattenLayersInCurrentPane(o);
        } else if (this.initialUiState.paneStates.length === 2) {
          let e = this.initialUiState.paneStates[0], n = this.findGraphFromCollections(e.selectedCollectionLabel, e.selectedGraphId), r = e.flattenLayers === true;
          if (n) this.appService.selectGraphInCurrentPane(n, r);
          else {
            let l = this.graphCollections[0].graphs[0];
            this.appService.selectGraphInCurrentPane(l, r);
          }
          this.appService.setFlattenLayersInCurrentPane(r);
          let o = this.initialUiState.paneStates[1], s = o.flattenLayers === true, a = this.findGraphFromCollections(o.selectedCollectionLabel, o.selectedGraphId);
          if (a) this.appService.openGraphInSplitPane(a, s);
          else {
            let l = this.graphCollections[0].graphs[0];
            this.appService.openGraphInSplitPane(l, s);
          }
          e.selected ? this.appService.selectPaneByIndex(0) : o.selected && this.appService.selectPaneByIndex(1), this.appService.setPaneWidthFraction(e.widthFraction);
        }
        this.el.nativeElement.addEventListener("mousedown", this.mouseDownHandler, true);
      }
      ngOnChanges(e) {
        e.graphCollections && (e.graphCollections.isFirstChange() || (this.appService.reset(), this.uiStateService.reset(), this.cleanUp(), this.ngOnInit()));
      }
      ngOnDestroy() {
        this.cleanUp();
      }
      handleKeyboardEvent(e) {
        e.key === " " ? Oy() || this.appService.spaceKeyToZoomFitClicked.next({}) : e.key === "f" && (e.ctrlKey || e.metaKey) && (this.config?.hideTitleBar || e.preventDefault(), this.appService.searchKeyClicked.next({}));
      }
      handleDragOver(e) {
        e.preventDefault();
      }
      handleDrop(e) {
        return $t(this, null, function* () {
          if (!e.dataTransfer) return;
          e.stopPropagation(), e.preventDefault();
          let n = [];
          e.dataTransfer?.items ? Array.from(e.dataTransfer.items).forEach((o, s) => {
            if (o.kind === "file") {
              let a = o.getAsFile();
              a && n.push(a);
            }
          }) : n.push(...Array.from(e.dataTransfer?.files || []));
          let r = false;
          if (n.length !== 0) for (let o of n) {
            if (!o.name.endsWith(".json")) continue;
            let s = new FileReader(), a = yield new Promise((l) => {
              s.onload = (c) => {
                let d = JSON.parse(c.target?.result);
                l(d);
              }, s.readAsText(o);
            });
            a.results != null && a.results.results == null ? (this.addNodeDataProviderData(o.name, a), r = true) : Object.values(a).some((l) => l.results != null) && (this.addNodeDataProviderDataWithGraphIndex(o.name, a), r = true);
          }
          r || this.snackBar.open("File(s) not supported", "Dismiss");
        });
      }
      selectNode(e, n, r, o = 0) {
        let s = this.graphCollections;
        if (r) {
          let c = this.appService.curGraphCollections().find((d) => d.label.toLowerCase() === r.toLowerCase());
          if (!c) {
            console.warn(`Failed to locate collection with label "${r}"`);
            return;
          }
          s = [c];
        }
        let a;
        for (let c of s) {
          let d = c.graphs.find((u) => u.id === n);
          if (d) {
            a = d;
            break;
          }
        }
        if (!a) {
          console.warn(`Failed to locate graph with id "${n}"`);
          return;
        }
        this.appService.selectGraphInPane(a, o);
        let l = this.appService.panes()[o].id;
        this.appService.curInitialUiState.set(void 0), this.appService.selectNode(l, void 0), this.appService.curToLocateNodeInfo.set(void 0), this.appService.setNodeToReveal(l, e);
      }
      addNodeDataProviderData(e, n, r = 0, o = false) {
        let s = this.appService.getModelGraphFromPaneIndex(r);
        if (!s) {
          console.warn(`Model graph in pane with index ${r} doesn't exist`);
          return;
        }
        this.nodeDataProviderExtensionService.addRun(Li(), e, "", s, { [s.id]: n }, o);
      }
      addNodeDataProviderDataWithGraphIndex(e, n, r = 0, o = false) {
        let s = this.appService.getModelGraphFromPaneIndex(r);
        if (!s) {
          console.warn(`Model graph in pane with index ${r} doesn't exist`);
          return;
        }
        this.nodeDataProviderExtensionService.addRun(Li(), e, "", s, n, o);
      }
      loadRemoteNodeDataPaths(e, n) {
        return $t(this, null, function* () {
          yield Promise.all(e.map((r) => this.nodeDataProviderExtensionService.addRunFromRemoteSource(r, n)));
        });
      }
      get hasNoGraphs() {
        return this.graphCollections.reduce((e, n) => e + n.graphs.length, 0) === 0;
      }
      get showTitleBar() {
        return !this.config?.hideTitleBar;
      }
      findGraphFromCollections(e, n) {
        for (let r of this.graphCollections) for (let o of r.graphs) if (o.id === n && (e === "" || o.collectionLabel === e)) return o;
      }
      handleGetNodeDataPathFromPostMessage(e) {
        let n = this.appService.getModelGraphFromPaneIndex(0);
        if (!n) {
          console.warn("Model graph in pane with index 0 doesn't exist");
          return;
        }
        this.loadRemoteNodeDataPaths([e], n);
      }
      handleSelectNodeByOutputTensorNameFromPostMessage(e) {
        let n = this.appService.getModelGraphFromSelectedPane();
        if (!n) return;
        let r;
        for (let o of n.nodes) if (dt(o)) {
          let s = o.outputsMetadata || {};
          for (let a of Object.keys(s)) {
            let l = s[a];
            if (e === l.tensor_name) {
              r = o;
              break;
            }
          }
          if (r) break;
        }
        r && this.selectNode(r.id, n.id);
      }
      handleSelectNodeByNodeIdFromPostMessage(e) {
        let n = this.appService.getModelGraphFromSelectedPane();
        if (!n) return;
        let r = n.nodesById[e];
        r && this.selectNode(r.id, n.id);
      }
      initThreejs() {
        return $t(this, null, function* () {
          yield this.threejsService.depsLoadedPromise, this.ready = true, this.changeDetectorRef.markForCheck();
        });
      }
      cleanUp() {
        this.el.nativeElement.removeEventListener("mousedown", this.mouseDownHandler, true);
      }
      static \u0275fac = function(n) {
        return new (n || i59)(K(nt), K(Ge), K(pi), K(He), K(Gl), K(Hi), K(al), K(Cr), K(Ys), K(Xs));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["model-graph-visualizer"]], hostBindings: function(n, r) {
        n & 1 && Z("keydown", function(s) {
          return r.handleKeyboardEvent(s);
        }, false, Bv);
      }, inputs: { graphCollections: "graphCollections", config: "config", initialUiState: "initialUiState", benchmark: "benchmark", nodeDataSources: "nodeDataSources" }, outputs: { titleClicked: "titleClicked", uiStateChanged: "uiStateChanged", modelGraphProcessed: "modelGraphProcessed", remoteNodeDataPathsChanged: "remoteNodeDataPathsChanged", syncNavigationModeChanged: "syncNavigationModeChanged", selectedNodeChanged: "selectedNodeChanged", hoveredNodeChanged: "hoveredNodeChanged", doubleClickedNodeChanged: "doubleClickedNodeChanged" }, features: [Bt([nt, PG, Cr, Ys, Xs, al, ll]), yn], ngContentSelectors: xme, decls: 1, vars: 1, consts: [["class", "container", 3, "dragover", "drop", 4, "ngIf"], [1, "container", 3, "dragover", "drop"], [1, "main"], [1, "no-graphs-message"], [3, "titleClicked"]], template: function(n, r) {
        n & 1 && (Tn(), X(0, Tme, 3, 1, "div", 0)), n & 2 && U("ngIf", r.ready);
      }, dependencies: [DG, et, In, v4, bH], styles: [`.container[_ngcontent-%COMP%]{width:100%;height:100%;display:flex;flex-direction:column;position:relative}.container[_ngcontent-%COMP%]   benchmark-runner[_ngcontent-%COMP%]{flex-grow:1}.container[_ngcontent-%COMP%]   title-bar[_ngcontent-%COMP%]{height:48px;min-height:48px}.container[_ngcontent-%COMP%]   .main[_ngcontent-%COMP%]{flex-grow:1;display:flex;position:relative;overflow:hidden}.container[_ngcontent-%COMP%]   .main[_ngcontent-%COMP%]   .no-graphs-message[_ngcontent-%COMP%]{position:absolute;top:0;left:0;width:100%;height:100%;z-index:200;display:flex;align-items:center;justify-content:center;color:#999}.container[_ngcontent-%COMP%]   .main[_ngcontent-%COMP%]   split-panes-container[_ngcontent-%COMP%]{flex-grow:1}.container[_ngcontent-%COMP%]   .main[_ngcontent-%COMP%]   graph-selector[_ngcontent-%COMP%]{position:absolute;top:12px;left:12px;z-index:100}  .model-explorer-help-popup{font-size:12px;padding:8px;background-color:#fff;line-height:normal}  .model-explorer-help-popup .bold{font-weight:700}  .model-explorer-help-popup .shortcut{display:flex;align-items:center;color:#777;margin-top:8px}  .model-explorer-help-popup .shortcut mat-icon{font-size:20px;width:20px;height:20px;margin-right:2px;color:#777}  .model-explorer-help-popup .description{color:#777;margin-top:8px}

















`], changeDetection: 0 });
    }
    return i59;
  })();
  var y4 = "https://fonts.googleapis.com/icon?family=Material+Icons";
  var b4 = (() => {
    class i59 {
      el;
      ngZone;
      graphCollections = Kp([]);
      config = Kp();
      initialUiState = Kp();
      benchmark = Kp(false);
      titleClicked = _c();
      uiStateChanged = _c();
      modelGraphProcessed = _c();
      selectedNodeChanged = _c();
      hoveredNodeChanged = _c();
      doubleClickedNodeChanged = _c();
      visualizer = gN(zw);
      constructor(e, n) {
        this.el = e, this.ngZone = n;
        let r = window.modelExplorer.assetFilesBaseUrl ?? "static_files";
        this.el.nativeElement.shadowRoot.appendChild(Uw(y4)), document.head.appendChild(Uw(y4));
        let o = `${r}/styles.css`;
        this.el.nativeElement.shadowRoot.appendChild(Uw(o)), document.head.appendChild(Uw(o));
      }
      selectNode = (e, n, r, o = 0) => {
        this.ngZone.run(() => {
          this.visualizer()?.selectNode(e, n, r, o);
        });
      };
      addNodeDataProviderData = (e, n, r = 0, o = false) => {
        this.ngZone.run(() => {
          this.visualizer()?.addNodeDataProviderData(e, n, r, o);
        });
      };
      addNodeDataProviderDataWithGraphIndex = (e, n, r = 0, o = false) => {
        this.ngZone.run(() => {
          this.visualizer()?.addNodeDataProviderDataWithGraphIndex(e, n, r, o);
        });
      };
      static \u0275fac = function(n) {
        return new (n || i59)(K(He), K(We));
      };
      static \u0275cmp = xe({ type: i59, selectors: [["custom-element-wrapper"]], viewQuery: function(n, r) {
        n & 1 && Hv(r.visualizer, zw, 5), n & 2 && wu();
      }, inputs: { graphCollections: [1, "graphCollections"], config: [1, "config"], initialUiState: [1, "initialUiState"], benchmark: [1, "benchmark"], selectNode: "selectNode", addNodeDataProviderData: "addNodeDataProviderData", addNodeDataProviderDataWithGraphIndex: "addNodeDataProviderDataWithGraphIndex" }, outputs: { titleClicked: "titleClicked", uiStateChanged: "uiStateChanged", modelGraphProcessed: "modelGraphProcessed", selectedNodeChanged: "selectedNodeChanged", hoveredNodeChanged: "hoveredNodeChanged", doubleClickedNodeChanged: "doubleClickedNodeChanged" }, decls: 2, vars: 4, consts: [[1, "me-custom-element-container"], [3, "titleClicked", "uiStateChanged", "modelGraphProcessed", "selectedNodeChanged", "hoveredNodeChanged", "doubleClickedNodeChanged", "graphCollections", "config", "initialUiState", "benchmark"]], template: function(n, r) {
        n & 1 && (b(0, "div", 0)(1, "model-graph-visualizer", 1), Z("titleClicked", function() {
          return r.titleClicked.emit();
        })("uiStateChanged", function(s) {
          return r.uiStateChanged.emit(s);
        })("modelGraphProcessed", function(s) {
          return r.modelGraphProcessed.emit(s);
        })("selectedNodeChanged", function(s) {
          return r.selectedNodeChanged.emit(s);
        })("hoveredNodeChanged", function(s) {
          return r.hoveredNodeChanged.emit(s);
        })("doubleClickedNodeChanged", function(s) {
          return r.doubleClickedNodeChanged.emit(s);
        }), x()()), n & 2 && (C(), U("graphCollections", r.graphCollections())("config", r.config())("initialUiState", r.initialUiState())("benchmark", r.benchmark()));
      }, dependencies: [et, zw], styles: [`.me-custom-element-container{width:100%;height:100%;overflow:hidden;font-family:Arial,Helvetica,sans-serif;line-height:normal;letter-spacing:normal;background-color:#fff}.me-custom-element-container ::ng-deep input,.me-custom-element-container ::ng-deep textarea{font-family:Arial,Helvetica,sans-serif}
/**
 * @license
 * Copyright 2025 The Model Explorer Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ==============================================================================
 */
`], encapsulation: 3 });
    }
    return i59;
  })();
  function Uw(i59) {
    let t = document.createElement("link");
    return t.href = i59, t.rel = "stylesheet", t.type = "text/css", t;
  }
  var cP = "model-explorer-visualizer";
  xk({ providers: [g2()] }).then((i59) => {
    if (customElements.get(cP)) console.log(`Custom element '${cP}' already registered`);
    else {
      let t = qN(b4, { injector: i59.injector });
      customElements.define(cP, t);
    }
  });
  window.modelExplorer = {};
})();
